library dart_bindings;

import 'dart:convert';
import 'dart:core';
import 'dart:core' as core show Map;
import 'dart:typed_data';
import 'dart:async';
import 'dart:ffi' as ffi;
import 'dart:io';
import 'package:ffi/ffi.dart' as ffi_package;
import 'package:async/async.dart';
import 'package:meta/meta.dart';
import 'buffered_channel.dart';
import 'channel.dart';
import 'enum_set.dart';
import 'native_exception.dart';
import 'optional.dart';
import 'stateful_channel.dart';

part 'library_loading.dart';
ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) get _lookup =>
  <T extends ffi.NativeType>(String symbolName) {
    return libraryProvider.sdkLibrary.lookup<T>(symbolName);
  };
// MARK: - BuildingId

/** Идентификатор здания. */
class BuildingId {
  final int value;

  const BuildingId([this.value = 0]);

  BuildingId copyWith({
    int? value
  }) {
    return BuildingId(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BuildingId &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CBuildingId extends ffi.Struct {
  @ffi.Uint64()
  external int value;

}
// MARK: - BuildingId <-> _CBuildingId

extension _CBuildingIdToDart on _CBuildingId {
  BuildingId _toDart() {
    return BuildingId(
      this.value
    );
  }
}

extension _DartTo_CBuildingId on BuildingId {
  _CBuildingId _copyFromDartTo_CBuildingId() {
    final res = _CBuildingIdMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CBuildingIdRelease on _CBuildingId {
  void _releaseIntermediate() {
  }
}

// MARK: - DayTime

/** Момент времени внутри дня. */
class DayTime {
  /** Часы, 0-23. */
  final int hours;
  /** Минуты, 0-59. */
  final int minutes;

  const DayTime({
    required this.hours,
    required this.minutes
  });

  DayTime copyWith({
    int? hours,
    int? minutes
  }) {
    return DayTime(
      hours: hours ?? this.hours,
      minutes: minutes ?? this.minutes
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DayTime &&
    other.runtimeType == runtimeType &&
    other.hours == hours &&
    other.minutes == minutes;

  @override
  int get hashCode {
    return Object.hash(hours, minutes);
  }

}
final class _CDayTime extends ffi.Struct {
  @ffi.Uint8()
  external int hours;

  @ffi.Uint8()
  external int minutes;

}
// MARK: - DayTime <-> _CDayTime

extension _CDayTimeToDart on _CDayTime {
  DayTime _toDart() {
    return DayTime(
      hours: this.hours,
      minutes: this.minutes
    );
  }
}

extension _DartTo_CDayTime on DayTime {
  _CDayTime _copyFromDartTo_CDayTime() {
    final res = _CDayTimeMakeDefault();
    res.hours = this.hours;
    res.minutes = this.minutes;
    return res;
  }
}
extension _CDayTimeRelease on _CDayTime {
  void _releaseIntermediate() {
  }
}

// MARK: - DgisObjectId

class DgisObjectId {
  /**
   Стабильный числовой идентификатор объекта.
  
   - Note: Нулевой идентификатор не соответствует ни одному объекту.
  */
  final int objectId;
  /**
   Стабильный числовой идентификатор входа/подъезда для объекта object_id.
  
   - Note: Нулевой идентификатор означает что вход/подъезд не задан.
  */
  final int entranceId;

  const DgisObjectId({
    this.objectId = 0,
    this.entranceId = 0
  });

  DgisObjectId copyWith({
    int? objectId,
    int? entranceId
  }) {
    return DgisObjectId(
      objectId: objectId ?? this.objectId,
      entranceId: entranceId ?? this.entranceId
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DgisObjectId &&
    other.runtimeType == runtimeType &&
    other.objectId == objectId &&
    other.entranceId == entranceId;

  @override
  int get hashCode {
    return Object.hash(objectId, entranceId);
  }

}
final class _CDgisObjectId extends ffi.Struct {
  @ffi.Uint64()
  external int objectId;

  @ffi.Uint64()
  external int entranceId;

}
// MARK: - DgisObjectId <-> _CDgisObjectId

extension _CDgisObjectIdToDart on _CDgisObjectId {
  DgisObjectId _toDart() {
    return DgisObjectId(
      objectId: this.objectId,
      entranceId: this.entranceId
    );
  }
}

extension _DartTo_CDgisObjectId on DgisObjectId {
  _CDgisObjectId _copyFromDartTo_CDgisObjectId() {
    final res = _CDgisObjectIdMakeDefault();
    res.objectId = this.objectId;
    res.entranceId = this.entranceId;
    return res;
  }
}
extension _CDgisObjectIdRelease on _CDgisObjectId {
  void _releaseIntermediate() {
  }
}

// MARK: - Context

/** Контекст - окружение, необходимое для работы SDK. */
class Context implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CContext_releasePtr);

  Context._raw(this._self);
  factory Context._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Context._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Context &&
    other.runtimeType == runtimeType &&
    _CContext_cg_objectIdentifier(this._self) == _CContext_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CContext_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Context <-> CContext

final class _CContext extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CContextBasicFunctions on _CContext {
  void _releaseIntermediate() {
    _CContext_release(_impl);
  }

  _CContext _retain() {
    return _CContext_retain(_impl);
  }
}

extension _CContextToDart on _CContext {
  Context _toDart() {
    return Context._create(_retain()._impl);
  }
}


extension _DartToCContext on Context {
  _CContext _copyFromDartTo_CContext() {
    return (_CContextMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - SystemMemoryManager

/** Интерфейс управления использованием системной памяти. */
class SystemMemoryManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CSystemMemoryManager_releasePtr);

  SystemMemoryManager._raw(this._self);
  factory SystemMemoryManager._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SystemMemoryManager._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SystemMemoryManager &&
    other.runtimeType == runtimeType &&
    _CSystemMemoryManager_cg_objectIdentifier(this._self) == _CSystemMemoryManager_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSystemMemoryManager_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: SystemMemoryManager: Methods

  /** Уменьшение использования памяти путём очистки всевозможных кешей и буферов. */
  void reduceMemoryUsage()  {
    void res = _CSystemMemoryManager_reduceMemoryUsage(_CSystemMemoryManagerMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - SystemMemoryManager <-> CSystemMemoryManager

final class _CSystemMemoryManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSystemMemoryManagerBasicFunctions on _CSystemMemoryManager {
  void _releaseIntermediate() {
    _CSystemMemoryManager_release(_impl);
  }

  _CSystemMemoryManager _retain() {
    return _CSystemMemoryManager_retain(_impl);
  }
}

extension _CSystemMemoryManagerToDart on _CSystemMemoryManager {
  SystemMemoryManager _toDart() {
    return SystemMemoryManager._create(_retain()._impl);
  }
}


extension _DartToCSystemMemoryManager on SystemMemoryManager {
  _CSystemMemoryManager _copyFromDartTo_CSystemMemoryManager() {
    return (_CSystemMemoryManagerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - LevelId

/** Идентификатор этажного плана. */
class LevelId {
  final int value;

  const LevelId([this.value = 0]);

  LevelId copyWith({
    int? value
  }) {
    return LevelId(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LevelId &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CLevelId extends ffi.Struct {
  @ffi.Uint64()
  external int value;

}
// MARK: - LevelId <-> _CLevelId

extension _CLevelIdToDart on _CLevelId {
  LevelId _toDart() {
    return LevelId(
      this.value
    );
  }
}

extension _DartTo_CLevelId on LevelId {
  _CLevelId _copyFromDartTo_CLevelId() {
    final res = _CLevelIdMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CLevelIdRelease on _CLevelId {
  void _releaseIntermediate() {
  }
}

// MARK: - String <-> _CString

final class _CString extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

_CString _CStringCreateWithData(
  int size,
  ffi.Pointer<ffi_package.Utf8> utf8Data
) {
  return _CStringCreateWithDataPrivate(size, utf8Data);
}

extension _CStringBasicFunctions on _CString {
  int _getSize() {
    return _GetSizeWith_CString(this);
  }

  ffi.Pointer<ffi_package.Utf8> _getData() {
    return _GetDataWith_CString(this);
  }

  void _releaseIntermediate() {
    _CString_release(this);
  }
}

extension _CStringToDart on _CString {
  String _toDart() {
    return _getData().toDartString(length: _getSize());
  }
}

extension _DartTo_CString on String {
  _CString _copyFromDartTo_CString() {
    // Adapted from https://pub.dev/documentation/ffi/latest/ffi/StringUtf8Pointer/toNativeUtf8.html
    final units = utf8.encode(this);
    final result = ffi_package.malloc<ffi.Uint8>(units.length);
    final nativeString = result.asTypedList(units.length);
    nativeString.setAll(0, units);
    return _CStringCreateWithData(units.length, result.cast());
  }
}


// MARK: - LevelInfo

/** Информация об этаже здания. */
class LevelInfo {
  /** Идентификатор этажного плана. */
  final LevelId id;
  /** Название этажа. */
  final String name;

  const LevelInfo({
    required this.id,
    required this.name
  });

  LevelInfo copyWith({
    LevelId? id,
    String? name
  }) {
    return LevelInfo(
      id: id ?? this.id,
      name: name ?? this.name
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LevelInfo &&
    other.runtimeType == runtimeType &&
    other.id == id &&
    other.name == name;

  @override
  int get hashCode {
    return Object.hash(id, name);
  }

}
final class _CLevelInfo extends ffi.Struct {
  external _CLevelId id;

  external _CString name;

}
// MARK: - LevelInfo <-> _CLevelInfo

extension _CLevelInfoToDart on _CLevelInfo {
  LevelInfo _toDart() {
    return LevelInfo(
      id: this.id._toDart(),
      name: this.name._toDart()
    );
  }
}

extension _DartTo_CLevelInfo on LevelInfo {
  _CLevelInfo _copyFromDartTo_CLevelInfo() {
    final res = _CLevelInfoMakeDefault();
    res.id = this.id._copyFromDartTo_CLevelId();
    res.name = this.name._copyFromDartTo_CString();
    return res;
  }
}
extension _CLevelInfoRelease on _CLevelInfo {
  void _releaseIntermediate() {
    name._releaseIntermediate();
  }
}

// MARK: - Meter

/** Длина/расстояние в метрах. */
class Meter {
  final double value;

  const Meter([this.value = 0]);

  Meter copyWith({
    double? value
  }) {
    return Meter(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Meter &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CMeter extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - Meter <-> _CMeter

extension _CMeterToDart on _CMeter {
  Meter _toDart() {
    return Meter(
      this.value
    );
  }
}

extension _DartTo_CMeter on Meter {
  _CMeter _copyFromDartTo_CMeter() {
    final res = _CMeterMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CMeterRelease on _CMeter {
  void _releaseIntermediate() {
  }
}

// MARK: - PersonalDataCollectionConsent

/** Статус согласия пользователя на сбор и отправку персональных данных. */
enum PersonalDataCollectionConsent {
  /** Пользователь согласен. */
  granted(0),
  /** Пользователь не согласен. */
  denied(1),
  ;

  const PersonalDataCollectionConsent(this.rawValue);
  final int rawValue;

  static PersonalDataCollectionConsent getByValue(int value) {
    return PersonalDataCollectionConsent.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CPersonalDataCollectionConsent extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CPersonalDataCollectionConsentBasicFunctions on _CPersonalDataCollectionConsent {
  void _releaseIntermediate() {
  }
}

extension _CPersonalDataCollectionConsentToDart on _CPersonalDataCollectionConsent {
  PersonalDataCollectionConsent _toDart() {
    return PersonalDataCollectionConsent.getByValue(this.rawValue);
  }
}

extension _DartTo_CPersonalDataCollectionConsent on PersonalDataCollectionConsent {
  _CPersonalDataCollectionConsent _copyFromDartTo_CPersonalDataCollectionConsent() {
    return _CPersonalDataCollectionConsentMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ScreenSize

/** Размер в пикселях. */
class ScreenSize {
  final int width;
  final int height;

  const ScreenSize({
    this.width = 0,
    this.height = 0
  });

  ScreenSize copyWith({
    int? width,
    int? height
  }) {
    return ScreenSize(
      width: width ?? this.width,
      height: height ?? this.height
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ScreenSize &&
    other.runtimeType == runtimeType &&
    other.width == width &&
    other.height == height;

  @override
  int get hashCode {
    return Object.hash(width, height);
  }

}
final class _CScreenSize extends ffi.Struct {
  @ffi.Uint32()
  external int width;

  @ffi.Uint32()
  external int height;

}
// MARK: - ScreenSize <-> _CScreenSize

extension _CScreenSizeToDart on _CScreenSize {
  ScreenSize _toDart() {
    return ScreenSize(
      width: this.width,
      height: this.height
    );
  }
}

extension _DartTo_CScreenSize on ScreenSize {
  _CScreenSize _copyFromDartTo_CScreenSize() {
    final res = _CScreenSizeMakeDefault();
    res.width = this.width;
    res.height = this.height;
    return res;
  }
}
extension _CScreenSizeRelease on _CScreenSize {
  void _releaseIntermediate() {
  }
}

// MARK: - WeekDay

/** День недели. */
enum WeekDay {
  sunday(0),
  monday(1),
  tuesday(2),
  wednesday(3),
  thursday(4),
  friday(5),
  saturday(6),
  ;

  const WeekDay(this.rawValue);
  final int rawValue;

  static WeekDay getByValue(int value) {
    return WeekDay.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CWeekDay extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CWeekDayBasicFunctions on _CWeekDay {
  void _releaseIntermediate() {
  }
}

extension _CWeekDayToDart on _CWeekDay {
  WeekDay _toDart() {
    return WeekDay.getByValue(this.rawValue);
  }
}

extension _DartTo_CWeekDay on WeekDay {
  _CWeekDay _copyFromDartTo_CWeekDay() {
    return _CWeekDayMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - WeekTime

/** Момент времени внутри недели. */
class WeekTime {
  /** День недели. */
  final WeekDay weekDay;
  /** Время. */
  final DayTime time;

  const WeekTime({
    required this.weekDay,
    required this.time
  });

  WeekTime copyWith({
    WeekDay? weekDay,
    DayTime? time
  }) {
    return WeekTime(
      weekDay: weekDay ?? this.weekDay,
      time: time ?? this.time
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is WeekTime &&
    other.runtimeType == runtimeType &&
    other.weekDay == weekDay &&
    other.time == time;

  @override
  int get hashCode {
    return Object.hash(weekDay, time);
  }

}
final class _CWeekTime extends ffi.Struct {
  external _CWeekDay weekDay;

  external _CDayTime time;

}
// MARK: - WeekTime <-> _CWeekTime

extension _CWeekTimeToDart on _CWeekTime {
  WeekTime _toDart() {
    return WeekTime(
      weekDay: this.weekDay._toDart(),
      time: this.time._toDart()
    );
  }
}

extension _DartTo_CWeekTime on WeekTime {
  _CWeekTime _copyFromDartTo_CWeekTime() {
    final res = _CWeekTimeMakeDefault();
    res.weekDay = this.weekDay._copyFromDartTo_CWeekDay();
    res.time = this.time._copyFromDartTo_CDayTime();
    return res;
  }
}
extension _CWeekTimeRelease on _CWeekTime {
  void _releaseIntermediate() {
  }
}

// MARK: - WeekTimeInterval

/** Интервал времени в течение недели. */
class WeekTimeInterval {
  /** Время начала. */
  final WeekTime startTime;
  /** Время окончания. */
  final WeekTime finishTime;

  const WeekTimeInterval({
    required this.startTime,
    required this.finishTime
  });

  WeekTimeInterval copyWith({
    WeekTime? startTime,
    WeekTime? finishTime
  }) {
    return WeekTimeInterval(
      startTime: startTime ?? this.startTime,
      finishTime: finishTime ?? this.finishTime
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is WeekTimeInterval &&
    other.runtimeType == runtimeType &&
    other.startTime == startTime &&
    other.finishTime == finishTime;

  @override
  int get hashCode {
    return Object.hash(startTime, finishTime);
  }

}
final class _CWeekTimeInterval extends ffi.Struct {
  external _CWeekTime startTime;

  external _CWeekTime finishTime;

}
// MARK: - WeekTimeInterval <-> _CWeekTimeInterval

extension _CWeekTimeIntervalToDart on _CWeekTimeInterval {
  WeekTimeInterval _toDart() {
    return WeekTimeInterval(
      startTime: this.startTime._toDart(),
      finishTime: this.finishTime._toDart()
    );
  }
}

extension _DartTo_CWeekTimeInterval on WeekTimeInterval {
  _CWeekTimeInterval _copyFromDartTo_CWeekTimeInterval() {
    final res = _CWeekTimeIntervalMakeDefault();
    res.startTime = this.startTime._copyFromDartTo_CWeekTime();
    res.finishTime = this.finishTime._copyFromDartTo_CWeekTime();
    return res;
  }
}
extension _CWeekTimeIntervalRelease on _CWeekTimeInterval {
  void _releaseIntermediate() {
  }
}

// MARK: - getSystemMemoryManager

/** Получение объекта для управления использованием системной памяти. */
SystemMemoryManager getSystemMemoryManager(
  Context context
){
  var _a0 = context._copyFromDartTo_CContext();
  _CSystemMemoryManager res = _CFunction_G_getSystemMemoryManager_With_CContext(_a0);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - makeSystemContext

/**
 Метод для создания SDK контекста.

 - Parameter keySource: Источник ключа SDK.
 - Parameter httpOptions: Настройки http клиента.
 - Parameter logOptions: Настройки логирования.
 - Parameter dataCollectConsent: Статус согласия пользователя на сбор и отправку персональных данных.
 - Parameter vendorConfig: Переопределение конфигурации SDK.
 - Parameter locationProvider: Интерфейс источника геопозиции, который реализуется пользователем на платформе.
 Если null, то используется источник по умолчанию.
 - Parameter headingProvider: Интерфейс, предоставляющий направление устройства относительно направления на север.
 Если null на iOS, то используется источник по умолчанию.
 Если null на Android, то cлежение за направлением будет реализовано на основе GPS.
*/
@internal
Context makeSystemContext(
  KeySource keySource,
  HttpOptions httpOptions,
  LogOptions logOptions,
  PersonalDataCollectionConsent dataCollectConsent,
  VendorConfig vendorConfig,
  [LocationProvider? locationProvider = null,
  HeadingProvider? headingProvider = null
  ]){
  var _a0 = keySource._copyFromDartTo_CKeySource();
  var _a1 = httpOptions._copyFromDartTo_CHttpOptions();
  var _a2 = logOptions._copyFromDartTo_CLogOptions();
  var _a3 = dataCollectConsent._copyFromDartTo_CPersonalDataCollectionConsent();
  var _a4 = vendorConfig._copyFromDartTo_CVendorConfig();
  var _a5 = locationProvider._copyFromDartTo_COptional_CLocationProvider();
  var _a6 = headingProvider._copyFromDartTo_COptional_CHeadingProvider();
  _CContext res = _CFunction_G_makeSystemContext_With_CKeySource_CHttpOptions_CLogOptions_CPersonalDataCollectionConsent_CVendorConfig_COptional_CLocationProvider_COptional_CHeadingProvider(_a0, _a1, _a2, _a3, _a4, _a5, _a6);
  _a6._releaseIntermediate();
  _a5._releaseIntermediate();
  _a4._releaseIntermediate();
  _a2._releaseIntermediate();
  _a1._releaseIntermediate();
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - KeyFromAsset

/**
 Ключ из asset-а.
 Для Android это директория assets.
 Для iOS это директория Bundle.main.
*/
class KeyFromAsset {
  /** Путь относительно корневой директории asset-ов. */
  final String path;

  const KeyFromAsset(this.path);

  KeyFromAsset copyWith({
    String? path
  }) {
    return KeyFromAsset(
      path ?? this.path
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is KeyFromAsset &&
    other.runtimeType == runtimeType &&
    other.path == path;

  @override
  int get hashCode {
    return path.hashCode;
  }

}
final class _CKeyFromAsset extends ffi.Struct {
  external _CString path;

}
// MARK: - KeyFromAsset <-> _CKeyFromAsset

extension _CKeyFromAssetToDart on _CKeyFromAsset {
  KeyFromAsset _toDart() {
    return KeyFromAsset(
      this.path._toDart()
    );
  }
}

extension _DartTo_CKeyFromAsset on KeyFromAsset {
  _CKeyFromAsset _copyFromDartTo_CKeyFromAsset() {
    final res = _CKeyFromAssetMakeDefault();
    res.path = this.path._copyFromDartTo_CString();
    return res;
  }
}
extension _CKeyFromAssetRelease on _CKeyFromAsset {
  void _releaseIntermediate() {
    path._releaseIntermediate();
  }
}

// MARK: - KeyFromFile

/** Ключ из файла. */
class KeyFromFile {
  /** Путь к файлу. */
  final String path;

  const KeyFromFile(this.path);

  KeyFromFile copyWith({
    String? path
  }) {
    return KeyFromFile(
      path ?? this.path
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is KeyFromFile &&
    other.runtimeType == runtimeType &&
    other.path == path;

  @override
  int get hashCode {
    return path.hashCode;
  }

}
final class _CKeyFromFile extends ffi.Struct {
  external _CString path;

}
// MARK: - KeyFromFile <-> _CKeyFromFile

extension _CKeyFromFileToDart on _CKeyFromFile {
  KeyFromFile _toDart() {
    return KeyFromFile(
      this.path._toDart()
    );
  }
}

extension _DartTo_CKeyFromFile on KeyFromFile {
  _CKeyFromFile _copyFromDartTo_CKeyFromFile() {
    final res = _CKeyFromFileMakeDefault();
    res.path = this.path._copyFromDartTo_CString();
    return res;
  }
}
extension _CKeyFromFileRelease on _CKeyFromFile {
  void _releaseIntermediate() {
    path._releaseIntermediate();
  }
}

// MARK: - KeyFromString

/** Ключ из строки. */
class KeyFromString {
  /** Содержимое. */
  final String contents;

  const KeyFromString(this.contents);

  KeyFromString copyWith({
    String? contents
  }) {
    return KeyFromString(
      contents ?? this.contents
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is KeyFromString &&
    other.runtimeType == runtimeType &&
    other.contents == contents;

  @override
  int get hashCode {
    return contents.hashCode;
  }

}
final class _CKeyFromString extends ffi.Struct {
  external _CString contents;

}
// MARK: - KeyFromString <-> _CKeyFromString

extension _CKeyFromStringToDart on _CKeyFromString {
  KeyFromString _toDart() {
    return KeyFromString(
      this.contents._toDart()
    );
  }
}

extension _DartTo_CKeyFromString on KeyFromString {
  _CKeyFromString _copyFromDartTo_CKeyFromString() {
    final res = _CKeyFromStringMakeDefault();
    res.contents = this.contents._copyFromDartTo_CString();
    return res;
  }
}
extension _CKeyFromStringRelease on _CKeyFromString {
  void _releaseIntermediate() {
    contents._releaseIntermediate();
  }
}

// MARK: - KeySource

/** Источник ключа. */
final class KeySource {
  final Object? _value;
  final int _index;

  KeySource._raw(this._value, this._index);

  KeySource.fromAsset(KeyFromAsset value) : this._raw(value, 0);
  KeySource.fromFile(KeyFromFile value) : this._raw(value, 1);
  KeySource.fromString(KeyFromString value) : this._raw(value, 2);

  bool get isFromAsset => this._index == 0;
  KeyFromAsset? get asFromAsset => this.isFromAsset ? this._value as KeyFromAsset : null;

  bool get isFromFile => this._index == 1;
  KeyFromFile? get asFromFile => this.isFromFile ? this._value as KeyFromFile : null;

  bool get isFromString => this._index == 2;
  KeyFromString? get asFromString => this.isFromString ? this._value as KeyFromString : null;

  T match<T>({
    required T Function(KeyFromAsset value) fromAsset,
    required T Function(KeyFromFile value) fromFile,
    required T Function(KeyFromString value) fromString,
  }) {
    return switch (this._index) {
      0 => fromAsset(this._value as KeyFromAsset),
      1 => fromFile(this._value as KeyFromFile),
      2 => fromString(this._value as KeyFromString),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "KeySource(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is KeySource &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CKeySourceImpl extends ffi.Union {
  external _CKeyFromAsset _fromAsset;
  external _CKeyFromFile _fromFile;
  external _CKeyFromString _fromString;
}

final class _CKeySource extends ffi.Struct {
  external _CKeySourceImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CKeySourceBasicFunctions on _CKeySource {
  void _releaseIntermediate() {
    _CKeySource_release(this);
  }
}
	
// MARK: - KeySource <-> CKeySource

extension _CKeySourceToDart on _CKeySource {
  KeySource _toDart() {
    return switch (this._index) {
      0 => KeySource.fromAsset(this._impl._fromAsset._toDart()),
      1 => KeySource.fromFile(this._impl._fromFile._toDart()),
      2 => KeySource.fromString(this._impl._fromString._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CKeySource on KeySource {
  _CKeySource _copyFromDartTo_CKeySource() {
    var res = _CKeySourceMakeDefault();
    this.match<void>(
      fromAsset: (KeyFromAsset value) {
        res._impl._fromAsset = value._copyFromDartTo_CKeyFromAsset();
        res._index = 0;
      },
      fromFile: (KeyFromFile value) {
        res._impl._fromFile = value._copyFromDartTo_CKeyFromFile();
        res._index = 1;
      },
      fromString: (KeyFromString value) {
        res._impl._fromString = value._copyFromDartTo_CKeyFromString();
        res._index = 2;
      },
    );
    return res;
  }
}

// MARK: - Duration <-> _CTimeInterval

final class _CTimeInterval extends ffi.Struct {
  @ffi.Double()
  external double timeInterval;
}

extension _CTimeIntervalBasicFunctions on _CTimeInterval {
  void _releaseIntermediate() {
  }
}

extension _CTimeIntervalToDart on _CTimeInterval {
  Duration _toDart() {
    return Duration(milliseconds: (timeInterval * 1000).ceil());
  }
}

extension _DartTo_CTimeInterval on Duration {
  _CTimeInterval _copyFromDartTo_CTimeInterval() {
    return _CTimeIntervalMakeDefault()..timeInterval = inMilliseconds.toDouble() / 1000;
  }
}
	
// MARK: - String? <-> _COptional_CString

final class _COptional_CString extends ffi.Struct {
  
  external _CString value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CStringBasicFunctions on _COptional_CString {
  void _releaseIntermediate() {
    _COptional_CString_release(this);
  }
}

extension _COptional_CStringToDart on _COptional_CString {
  String? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CString on String? {
  _COptional_CString _copyFromDartTo_COptional_CString() {
    final cOptional = _COptional_CStringMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CString();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - int? <-> _COptional_uint64_t

final class _COptional_uint64_t extends ffi.Struct {
  @ffi.Uint64()
  external int value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_uint64_tBasicFunctions on _COptional_uint64_t {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_uint64_tToDart on _COptional_uint64_t {
  int? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value;
  }
}

extension _DartTo_COptional_uint64_t on int? {
  _COptional_uint64_t _copyFromDartTo_COptional_uint64_t() {
    final cOptional = _COptional_uint64_tMakeDefault();
    if (this != null) {
      cOptional.value = this!;
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - HttpOptions

/** Опции Http-клиента. */
class HttpOptions {
  /** Таймаут для HTTP-запросов. */
  final Duration timeout;
  /** Использовать HTTP кэш. */
  final bool useCache;
  /**
   Путь к каталогу верхнего уровня для основного файлового хранилища HTTP кэша.
   Файловое хранилище будет находиться в подкаталоге http_cache в данном каталоге.
   Если путь не указан, будет использоваться директория по умолчанию.
  */
  final String? cacheStoragePath;
  /**
   Максимальный размер HTTP-кеша в байтах.
   Если не указан, по умолчанию максимальный размер HTTP кэша составляет 300 Мб.
  */
  final int? cacheMaxSize;

  const HttpOptions({
    this.timeout = const Duration(milliseconds: 15000),
    this.useCache = true,
    this.cacheStoragePath = null,
    this.cacheMaxSize = null
  });

  HttpOptions copyWith({
    Duration? timeout,
    bool? useCache,
    Optional<String?>? cacheStoragePath,
    Optional<int?>? cacheMaxSize
  }) {
    return HttpOptions(
      timeout: timeout ?? this.timeout,
      useCache: useCache ?? this.useCache,
      cacheStoragePath: cacheStoragePath != null ? cacheStoragePath.value : this.cacheStoragePath,
      cacheMaxSize: cacheMaxSize != null ? cacheMaxSize.value : this.cacheMaxSize
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is HttpOptions &&
    other.runtimeType == runtimeType &&
    other.timeout == timeout &&
    other.useCache == useCache &&
    other.cacheStoragePath == cacheStoragePath &&
    other.cacheMaxSize == cacheMaxSize;

  @override
  int get hashCode {
    return Object.hash(timeout, useCache, cacheStoragePath, cacheMaxSize);
  }

}
final class _CHttpOptions extends ffi.Struct {
  external _CTimeInterval timeout;

  @ffi.Bool()
  external bool useCache;

  external _COptional_CString cacheStoragePath;

  external _COptional_uint64_t cacheMaxSize;

}
// MARK: - HttpOptions <-> _CHttpOptions

extension _CHttpOptionsToDart on _CHttpOptions {
  HttpOptions _toDart() {
    return HttpOptions(
      timeout: this.timeout._toDart(),
      useCache: this.useCache,
      cacheStoragePath: this.cacheStoragePath._toDart(),
      cacheMaxSize: this.cacheMaxSize._toDart()
    );
  }
}

extension _DartTo_CHttpOptions on HttpOptions {
  _CHttpOptions _copyFromDartTo_CHttpOptions() {
    final res = _CHttpOptionsMakeDefault();
    res.timeout = this.timeout._copyFromDartTo_CTimeInterval();
    res.useCache = this.useCache;
    res.cacheStoragePath = this.cacheStoragePath._copyFromDartTo_COptional_CString();
    res.cacheMaxSize = this.cacheMaxSize._copyFromDartTo_COptional_uint64_t();
    return res;
  }
}
extension _CHttpOptionsRelease on _CHttpOptions {
  void _releaseIntermediate() {
    cacheStoragePath._releaseIntermediate();
  }
}

// MARK: - LogLevel

/** Уровень логирования. */
enum LogLevel {
  verbose(0),
  info(1),
  warning(2),
  error(3),
  fatal(4),
  off(5),
  ;

  const LogLevel(this.rawValue);
  final int rawValue;

  static LogLevel getByValue(int value) {
    return LogLevel.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CLogLevel extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CLogLevelBasicFunctions on _CLogLevel {
  void _releaseIntermediate() {
  }
}

extension _CLogLevelToDart on _CLogLevel {
  LogLevel _toDart() {
    return LogLevel.getByValue(this.rawValue);
  }
}

extension _DartTo_CLogLevel on LogLevel {
  _CLogLevel _copyFromDartTo_CLogLevel() {
    return _CLogLevelMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - LogSink

/** Приемник логирования. */
abstract class LogSink {
  void write(
    LogMessage message
  );
}

class _LogSink {
  final LogSink object;
  int refCounter = 1;

  _LogSink(this.object);
}

final class _CLogSink extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.Void> _cppValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _CLogMessage)>> _write_CLogMessage;
}

extension _CLogSinkBasicFunctions on _CLogSink {
  void _releaseIntermediate() {
    _CLogSink_release(this);
  }
}

int _CLogSinkInstanceCounter = 1;
final _CLogSinkInstanceMap = <int, _LogSink>{};

extension _CLogSinkToDart on _CLogSink {
  LogSink _toDart() {
    late LogSink? result;
    final platformValue = this._value.cast<ffi.Int64>();
    if (platformValue.address != 0) {
      result = _CLogSinkInstanceMap[platformValue.address]?.object;
    } else if (this._cppValue.address != 0) {
      final cppValue = _CLogSinkCppMakeDefault().._impl = this._cppValue;
      result = cppValue._toDart();
    }
    if (result == null) {
      throw Exception("Invalid intermediate object of type _CLogSink");
    }
    return result;
  }
}

extension _DartTo_CLogSink on LogSink {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    _CLogSinkInstanceMap[platformValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    final platformObject = _CLogSinkInstanceMap[platformValue.address];
    if (platformObject == null) {
      return;
    }
    platformObject.refCounter -= 1;
    if (platformObject.refCounter > 0) {
      return;
    }
    _CLogSinkInstanceMap.remove(platformValue.address);
  }

  _CLogSink _copyFromDartTo_CLogSink() {
    var res = _CLogSinkMakeDefault();
    if (this is _LogSinkCpp) {
      final cppValue = this as _LogSinkCpp;
      res._cppValue = cppValue._copyFromDartTo_CLogSinkCpp()._impl;
      return res;
    }
    final instanceId = _CLogSinkInstanceCounter;
    _CLogSinkInstanceCounter += 1;
    _CLogSinkInstanceMap[instanceId] = _LogSink(this);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;

    final write_CLogMessageFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _CLogMessage)>.listener(write_CLogMessageFunction);
    res._write_CLogMessage = write_CLogMessageFunctionCallable.nativeFunction;
    return res;
  }

  static void write_CLogMessageFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> resultValueCallback, _CLogMessage message) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CLogSink");
    }
    final platformObject = _CLogSinkInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CLogSink");
    }

    final messageDart = message._toDart();
    platformObject.object.write(messageDart);
    message._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
    callbackFunction(context);
  }


}

// MARK: - LogSink? <-> _COptional_CLogSink

final class _COptional_CLogSink extends ffi.Struct {
  
  external _CLogSink value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CLogSinkBasicFunctions on _COptional_CLogSink {
  void _releaseIntermediate() {
    _COptional_CLogSink_release(this);
  }
}

extension _COptional_CLogSinkToDart on _COptional_CLogSink {
  LogSink? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CLogSink on LogSink? {
  _COptional_CLogSink _copyFromDartTo_COptional_CLogSink() {
    final cOptional = _COptional_CLogSinkMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CLogSink();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - LogOptions

/** Настройки логирования. */
class LogOptions {
  /** Уровень логирования в системный лог. */
  final LogLevel systemLevel;
  /** Уровень логирования в пользовательский приемник. */
  final LogLevel customLevel;
  /** Пользовательский приемник логирования. */
  final LogSink? customSink;

  const LogOptions({
    this.systemLevel = LogLevel.warning,
    this.customLevel = LogLevel.warning,
    this.customSink = null
  });

  LogOptions copyWith({
    LogLevel? systemLevel,
    LogLevel? customLevel,
    Optional<LogSink?>? customSink
  }) {
    return LogOptions(
      systemLevel: systemLevel ?? this.systemLevel,
      customLevel: customLevel ?? this.customLevel,
      customSink: customSink != null ? customSink.value : this.customSink
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LogOptions &&
    other.runtimeType == runtimeType &&
    other.systemLevel == systemLevel &&
    other.customLevel == customLevel &&
    other.customSink == customSink;

  @override
  int get hashCode {
    return Object.hash(systemLevel, customLevel, customSink);
  }

}
final class _CLogOptions extends ffi.Struct {
  external _CLogLevel systemLevel;

  external _CLogLevel customLevel;

  external _COptional_CLogSink customSink;

}
// MARK: - LogOptions <-> _CLogOptions

extension _CLogOptionsToDart on _CLogOptions {
  LogOptions _toDart() {
    return LogOptions(
      systemLevel: this.systemLevel._toDart(),
      customLevel: this.customLevel._toDart(),
      customSink: this.customSink._toDart()
    );
  }
}

extension _DartTo_CLogOptions on LogOptions {
  _CLogOptions _copyFromDartTo_CLogOptions() {
    final res = _CLogOptionsMakeDefault();
    res.systemLevel = this.systemLevel._copyFromDartTo_CLogLevel();
    res.customLevel = this.customLevel._copyFromDartTo_CLogLevel();
    res.customSink = this.customSink._copyFromDartTo_COptional_CLogSink();
    return res;
  }
}
extension _CLogOptionsRelease on _CLogOptions {
  void _releaseIntermediate() {
    customSink._releaseIntermediate();
  }
}

// MARK: - _LogSinkCpp

/** Приемник логирования. */
class _LogSinkCpp extends LogSink implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CLogSinkCpp_releasePtr);

  _LogSinkCpp._raw(this._self);
  factory _LogSinkCpp._create(ffi.Pointer<ffi.Void> self) {
    final classObject = _LogSinkCpp._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is _LogSinkCpp &&
    other.runtimeType == runtimeType &&
    _CLogSinkCpp_cg_objectIdentifier(this._self) == _CLogSinkCpp_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CLogSinkCpp_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: _LogSinkCpp: Methods

  /**
   Запись в лог.
   Метод может вызываться на произвольном потоке.
  */
  void write(
    LogMessage message
  )  {
    var _a1 = message._copyFromDartTo_CLogMessage();
    void res = _CLogSinkCpp_write_CLogMessage(_CLogSinkCppMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - _LogSinkCpp <-> CLogSinkCpp

final class _CLogSinkCpp extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CLogSinkCppBasicFunctions on _CLogSinkCpp {
  void _releaseIntermediate() {
    _CLogSinkCpp_release(_impl);
  }

  _CLogSinkCpp _retain() {
    return _CLogSinkCpp_retain(_impl);
  }
}

extension _CLogSinkCppToDart on _CLogSinkCpp {
  _LogSinkCpp _toDart() {
    return _LogSinkCpp._create(_retain()._impl);
  }
}


extension _DartToCLogSinkCpp on _LogSinkCpp {
  _CLogSinkCpp _copyFromDartTo_CLogSinkCpp() {
    return (_CLogSinkCppMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - LogMessage

/** Сообщение, записываемое в лог. */
class LogMessage {
  /** Уровень логирования. */
  final LogLevel level;
  /** Содержимое сообщения. */
  final String text;
  /** Имя файла, в котором было записано сообщение. */
  final String file;
  /** Номер строки, в которой было записано сообщение. */
  final int line;

  const LogMessage({
    required this.level,
    required this.text,
    required this.file,
    required this.line
  });

  LogMessage copyWith({
    LogLevel? level,
    String? text,
    String? file,
    int? line
  }) {
    return LogMessage(
      level: level ?? this.level,
      text: text ?? this.text,
      file: file ?? this.file,
      line: line ?? this.line
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LogMessage &&
    other.runtimeType == runtimeType &&
    other.level == level &&
    other.text == text &&
    other.file == file &&
    other.line == line;

  @override
  int get hashCode {
    return Object.hash(level, text, file, line);
  }

}
final class _CLogMessage extends ffi.Struct {
  external _CLogLevel level;

  external _CString text;

  external _CString file;

  @ffi.Uint32()
  external int line;

}
// MARK: - LogMessage <-> _CLogMessage

extension _CLogMessageToDart on _CLogMessage {
  LogMessage _toDart() {
    return LogMessage(
      level: this.level._toDart(),
      text: this.text._toDart(),
      file: this.file._toDart(),
      line: this.line
    );
  }
}

extension _DartTo_CLogMessage on LogMessage {
  _CLogMessage _copyFromDartTo_CLogMessage() {
    final res = _CLogMessageMakeDefault();
    res.level = this.level._copyFromDartTo_CLogLevel();
    res.text = this.text._copyFromDartTo_CString();
    res.file = this.file._copyFromDartTo_CString();
    res.line = this.line;
    return res;
  }
}
extension _CLogMessageRelease on _CLogMessage {
  void _releaseIntermediate() {
    text._releaseIntermediate();
    file._releaseIntermediate();
  }
}

// MARK: - CEmpty <-> _CEmpty

final class _CEmpty extends ffi.Struct {
  @ffi.Int8()
  external int _dummy;
}
	
// MARK: - VendorConfigFromAsset

/**
 Переопределение настроек SDK через указание пути к asset-у приложения.
 Для Android это директория assets.
 Для iOS это директория Bundle.main.
*/
class VendorConfigFromAsset {
  /** Путь относительно корневой директории asset-ов. */
  final String path;

  const VendorConfigFromAsset(this.path);

  VendorConfigFromAsset copyWith({
    String? path
  }) {
    return VendorConfigFromAsset(
      path ?? this.path
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is VendorConfigFromAsset &&
    other.runtimeType == runtimeType &&
    other.path == path;

  @override
  int get hashCode {
    return path.hashCode;
  }

}
final class _CVendorConfigFromAsset extends ffi.Struct {
  external _CString path;

}
// MARK: - VendorConfigFromAsset <-> _CVendorConfigFromAsset

extension _CVendorConfigFromAssetToDart on _CVendorConfigFromAsset {
  VendorConfigFromAsset _toDart() {
    return VendorConfigFromAsset(
      this.path._toDart()
    );
  }
}

extension _DartTo_CVendorConfigFromAsset on VendorConfigFromAsset {
  _CVendorConfigFromAsset _copyFromDartTo_CVendorConfigFromAsset() {
    final res = _CVendorConfigFromAssetMakeDefault();
    res.path = this.path._copyFromDartTo_CString();
    return res;
  }
}
extension _CVendorConfigFromAssetRelease on _CVendorConfigFromAsset {
  void _releaseIntermediate() {
    path._releaseIntermediate();
  }
}

// MARK: - VendorConfigFromFile

/** Переопределение настроек SDK через указание пути к файлу в файловой системе устройства. */
class VendorConfigFromFile {
  /** Путь к файлу. */
  final String path;

  const VendorConfigFromFile(this.path);

  VendorConfigFromFile copyWith({
    String? path
  }) {
    return VendorConfigFromFile(
      path ?? this.path
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is VendorConfigFromFile &&
    other.runtimeType == runtimeType &&
    other.path == path;

  @override
  int get hashCode {
    return path.hashCode;
  }

}
final class _CVendorConfigFromFile extends ffi.Struct {
  external _CString path;

}
// MARK: - VendorConfigFromFile <-> _CVendorConfigFromFile

extension _CVendorConfigFromFileToDart on _CVendorConfigFromFile {
  VendorConfigFromFile _toDart() {
    return VendorConfigFromFile(
      this.path._toDart()
    );
  }
}

extension _DartTo_CVendorConfigFromFile on VendorConfigFromFile {
  _CVendorConfigFromFile _copyFromDartTo_CVendorConfigFromFile() {
    final res = _CVendorConfigFromFileMakeDefault();
    res.path = this.path._copyFromDartTo_CString();
    return res;
  }
}
extension _CVendorConfigFromFileRelease on _CVendorConfigFromFile {
  void _releaseIntermediate() {
    path._releaseIntermediate();
  }
}

// MARK: - VendorConfigFromString

/** Переопределение настроек SDK через указание содержимого файла. */
class VendorConfigFromString {
  /** Содержимое файла переопределения настроек. */
  final String contents;

  const VendorConfigFromString(this.contents);

  VendorConfigFromString copyWith({
    String? contents
  }) {
    return VendorConfigFromString(
      contents ?? this.contents
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is VendorConfigFromString &&
    other.runtimeType == runtimeType &&
    other.contents == contents;

  @override
  int get hashCode {
    return contents.hashCode;
  }

}
final class _CVendorConfigFromString extends ffi.Struct {
  external _CString contents;

}
// MARK: - VendorConfigFromString <-> _CVendorConfigFromString

extension _CVendorConfigFromStringToDart on _CVendorConfigFromString {
  VendorConfigFromString _toDart() {
    return VendorConfigFromString(
      this.contents._toDart()
    );
  }
}

extension _DartTo_CVendorConfigFromString on VendorConfigFromString {
  _CVendorConfigFromString _copyFromDartTo_CVendorConfigFromString() {
    final res = _CVendorConfigFromStringMakeDefault();
    res.contents = this.contents._copyFromDartTo_CString();
    return res;
  }
}
extension _CVendorConfigFromStringRelease on _CVendorConfigFromString {
  void _releaseIntermediate() {
    contents._releaseIntermediate();
  }
}

// MARK: - VendorConfig

/** Переопределение конфигурации SDK. */
final class VendorConfig {
  final Object? _value;
  final int _index;

  VendorConfig._raw(this._value, this._index);

  VendorConfig.none() : this._raw(null, 0);
  VendorConfig.fromAsset(VendorConfigFromAsset value) : this._raw(value, 1);
  VendorConfig.fromFile(VendorConfigFromFile value) : this._raw(value, 2);
  VendorConfig.fromString(VendorConfigFromString value) : this._raw(value, 3);

  bool get isNone => this._index == 0;
  Object? get asNone => this.isNone ? this._value as Object : null;

  bool get isFromAsset => this._index == 1;
  VendorConfigFromAsset? get asFromAsset => this.isFromAsset ? this._value as VendorConfigFromAsset : null;

  bool get isFromFile => this._index == 2;
  VendorConfigFromFile? get asFromFile => this.isFromFile ? this._value as VendorConfigFromFile : null;

  bool get isFromString => this._index == 3;
  VendorConfigFromString? get asFromString => this.isFromString ? this._value as VendorConfigFromString : null;

  T match<T>({
    required T Function() none,
    required T Function(VendorConfigFromAsset value) fromAsset,
    required T Function(VendorConfigFromFile value) fromFile,
    required T Function(VendorConfigFromString value) fromString,
  }) {
    return switch (this._index) {
      0 => none(),
      1 => fromAsset(this._value as VendorConfigFromAsset),
      2 => fromFile(this._value as VendorConfigFromFile),
      3 => fromString(this._value as VendorConfigFromString),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "VendorConfig(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is VendorConfig &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CVendorConfigImpl extends ffi.Union {
  external _CEmpty _none;
  external _CVendorConfigFromAsset _fromAsset;
  external _CVendorConfigFromFile _fromFile;
  external _CVendorConfigFromString _fromString;
}

final class _CVendorConfig extends ffi.Struct {
  external _CVendorConfigImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CVendorConfigBasicFunctions on _CVendorConfig {
  void _releaseIntermediate() {
    _CVendorConfig_release(this);
  }
}
	
// MARK: - VendorConfig <-> CVendorConfig

extension _CVendorConfigToDart on _CVendorConfig {
  VendorConfig _toDart() {
    return switch (this._index) {
      0 => VendorConfig.none(),
      1 => VendorConfig.fromAsset(this._impl._fromAsset._toDart()),
      2 => VendorConfig.fromFile(this._impl._fromFile._toDart()),
      3 => VendorConfig.fromString(this._impl._fromString._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CVendorConfig on VendorConfig {
  _CVendorConfig _copyFromDartTo_CVendorConfig() {
    var res = _CVendorConfigMakeDefault();
    this.match<void>(
      none: () {
        res._index = 0;
      },
      fromAsset: (VendorConfigFromAsset value) {
        res._impl._fromAsset = value._copyFromDartTo_CVendorConfigFromAsset();
        res._index = 1;
      },
      fromFile: (VendorConfigFromFile value) {
        res._impl._fromFile = value._copyFromDartTo_CVendorConfigFromFile();
        res._index = 2;
      },
      fromString: (VendorConfigFromString value) {
        res._impl._fromString = value._copyFromDartTo_CVendorConfigFromString();
        res._index = 3;
      },
    );
    return res;
  }
}

// MARK: - DesiredAccuracy

/** Ожидаемая точность определения местоположения. */
enum DesiredAccuracy {
  /**
   Низкая точность определения геопозиции.
   Наиболее подходящий для определения текущего города/района режим.
   Этот режим отличается низким энергопотреблением.
   В данном режиме устройство может как полагаться исключительно на сети (Wi-Fi, 3GPP, IP),
   так и использовать GNSS-приемник в режиме пониженного энергопотребления
   (с кешированием геопозиции на длительное время).
  */
  low(0),
  /**
   Точность определения геопозиции, предоставляемая стандартным GNSS-приёмником.
   Наиболее подходящий для отображения текущего местоположения на карте режим.
   Если на устройстве установлен GNSS-приемник и спутники находятся в зоне видимости, то для
   определения местоположения используются данные со спутников. В противном случае
   используются альтернативные источники геопозиции.
  */
  medium(1),
  /**
   Точность определения геопозиции, предоставляемая стандартным GNSS-приёмником и, возможно,
   улучшенная дополнительными средствами.
   Наиболее подходящий для ведения по маршруту режим.
   Аналогичен режиму Medium, но приемник GNSS может быть переведен в режим повышенной точности либо
   для уточнения геопозиции могут использоваться дополнительные датчики.
   Может потреблять много энергии (устройство в таком режиме, как правило, подключено к источнику питания).
  */
  high(2),
  ;

  const DesiredAccuracy(this.rawValue);
  final int rawValue;

  static DesiredAccuracy getByValue(int value) {
    return DesiredAccuracy.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CDesiredAccuracy extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CDesiredAccuracyBasicFunctions on _CDesiredAccuracy {
  void _releaseIntermediate() {
  }
}

extension _CDesiredAccuracyToDart on _CDesiredAccuracy {
  DesiredAccuracy _toDart() {
    return DesiredAccuracy.getByValue(this.rawValue);
  }
}

extension _DartTo_CDesiredAccuracy on DesiredAccuracy {
  _CDesiredAccuracy _copyFromDartTo_CDesiredAccuracy() {
    return _CDesiredAccuracyMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - LocationProvider

/**
 Интерфейс источника геопозиции, который реализуется пользователем на платформе.

 - Note: Все методы данного интерфейса должны вызываться из одного потока.
*/
abstract class LocationProvider {
  Location? lastLocation();
  void setNotifiers(
    LocationNotifier? locationNotifier,
    LocationAvailableNotifier? availableNotifier
  );
  void setDesiredAccuracy(
    DesiredAccuracy desiredAccuracy
  );
}

class _LocationProvider {
  final LocationProvider object;
  int refCounter = 1;

  _LocationProvider(this.object);
}

final class _CLocationProvider extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.Void> _cppValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CLocation)>>)>> _lastLocation;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _COptional_CLocationNotifier, _COptional_CLocationAvailableNotifier)>> _setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifier;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _CDesiredAccuracy)>> _setDesiredAccuracy_CDesiredAccuracy;
}

extension _CLocationProviderBasicFunctions on _CLocationProvider {
  void _releaseIntermediate() {
    _CLocationProvider_release(this);
  }
}

int _CLocationProviderInstanceCounter = 1;
final _CLocationProviderInstanceMap = <int, _LocationProvider>{};

extension _CLocationProviderToDart on _CLocationProvider {
  LocationProvider _toDart() {
    late LocationProvider? result;
    final platformValue = this._value.cast<ffi.Int64>();
    if (platformValue.address != 0) {
      result = _CLocationProviderInstanceMap[platformValue.address]?.object;
    } else if (this._cppValue.address != 0) {
      final cppValue = _CLocationProviderCppMakeDefault().._impl = this._cppValue;
      result = cppValue._toDart();
    }
    if (result == null) {
      throw Exception("Invalid intermediate object of type _CLocationProvider");
    }
    return result;
  }
}

extension _DartTo_CLocationProvider on LocationProvider {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    _CLocationProviderInstanceMap[platformValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    final platformObject = _CLocationProviderInstanceMap[platformValue.address];
    if (platformObject == null) {
      return;
    }
    platformObject.refCounter -= 1;
    if (platformObject.refCounter > 0) {
      return;
    }
    _CLocationProviderInstanceMap.remove(platformValue.address);
  }

  _CLocationProvider _copyFromDartTo_CLocationProvider() {
    var res = _CLocationProviderMakeDefault();
    if (this is _LocationProviderCpp) {
      final cppValue = this as _LocationProviderCpp;
      res._cppValue = cppValue._copyFromDartTo_CLocationProviderCpp()._impl;
      return res;
    }
    final instanceId = _CLocationProviderInstanceCounter;
    _CLocationProviderInstanceCounter += 1;
    _CLocationProviderInstanceMap[instanceId] = _LocationProvider(this);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;

    final lastLocationFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CLocation)>>)>.listener(lastLocationFunction);
    res._lastLocation = lastLocationFunctionCallable.nativeFunction;
    final setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifierFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _COptional_CLocationNotifier, _COptional_CLocationAvailableNotifier)>.listener(setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifierFunction);
    res._setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifier = setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifierFunctionCallable.nativeFunction;
    final setDesiredAccuracy_CDesiredAccuracyFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _CDesiredAccuracy)>.listener(setDesiredAccuracy_CDesiredAccuracyFunction);
    res._setDesiredAccuracy_CDesiredAccuracy = setDesiredAccuracy_CDesiredAccuracyFunctionCallable.nativeFunction;
    return res;
  }

  static void lastLocationFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CLocation)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CLocationProvider");
    }
    final platformObject = _CLocationProviderInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CLocationProvider");
    }

    final res = platformObject.object.lastLocation();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _COptional_CLocation)>();
    callbackFunction(context, res._copyFromDartTo_COptional_CLocation());
  }

  static void setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifierFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> resultValueCallback, _COptional_CLocationNotifier locationNotifier, _COptional_CLocationAvailableNotifier availableNotifier) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CLocationProvider");
    }
    final platformObject = _CLocationProviderInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CLocationProvider");
    }

    final locationNotifierDart = locationNotifier._toDart();
    final availableNotifierDart = availableNotifier._toDart();
    platformObject.object.setNotifiers(locationNotifierDart, availableNotifierDart);
    locationNotifier._releaseIntermediate();
    availableNotifier._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
    callbackFunction(context);
  }

  static void setDesiredAccuracy_CDesiredAccuracyFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> resultValueCallback, _CDesiredAccuracy desiredAccuracy) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CLocationProvider");
    }
    final platformObject = _CLocationProviderInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CLocationProvider");
    }

    final desiredAccuracyDart = desiredAccuracy._toDart();
    platformObject.object.setDesiredAccuracy(desiredAccuracyDart);
    desiredAccuracy._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
    callbackFunction(context);
  }


}

// MARK: - LocationProvider? <-> _COptional_CLocationProvider

final class _COptional_CLocationProvider extends ffi.Struct {
  
  external _CLocationProvider value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CLocationProviderBasicFunctions on _COptional_CLocationProvider {
  void _releaseIntermediate() {
    _COptional_CLocationProvider_release(this);
  }
}

extension _COptional_CLocationProviderToDart on _COptional_CLocationProvider {
  LocationProvider? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CLocationProvider on LocationProvider? {
  _COptional_CLocationProvider _copyFromDartTo_COptional_CLocationProvider() {
    final cOptional = _COptional_CLocationProviderMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CLocationProvider();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - _LocationProviderCpp

/**
 Интерфейс источника геопозиции, который реализуется пользователем на платформе.

 - Note: Все методы данного интерфейса должны вызываться из одного потока.
*/
class _LocationProviderCpp extends LocationProvider implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CLocationProviderCpp_releasePtr);

  _LocationProviderCpp._raw(this._self);
  factory _LocationProviderCpp._create(ffi.Pointer<ffi.Void> self) {
    final classObject = _LocationProviderCpp._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is _LocationProviderCpp &&
    other.runtimeType == runtimeType &&
    _CLocationProviderCpp_cg_objectIdentifier(this._self) == _CLocationProviderCpp_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CLocationProviderCpp_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: _LocationProviderCpp: Methods

  /**
   Наилучшая известная на текущий момент геопозиция.
   Если известная на текущий момент геопозиция отсутствует или не предоставляется API платформы - метод вернет
   null.
  
   - Note: Возвращаемая данным методом геопозиция может быть недостоверной (см. set_callbacks()).
   - Note: Этот метод должен запросить у системы наилучшую известную на текущий момент геопозицию
   и вернуть её даже если она является устаревшей и/или не соответствует требуемой точности.
   - Note: Если API платформы не предоставляет аналогичный по функциональности метод,
   то данный метод всегда должен возвращать null.
  */
  Location? lastLocation()  {
    _COptional_CLocation res = _CLocationProviderCpp_lastLocation(_CLocationProviderCppMakeDefault().._impl=_self);
    return res._toDart();
  }

  /**
   Устанавливает интерфейсы для оповещения об обновлении текущей гепозиции и изменении доступности источника
   геопозиции.
  
   - Note: Повторный вызов данного метода перезаписывает предыдущие интерфейсы.
   - Note: Если оба параметра равны null, то слежение за обновлением геопозиции нужно отключить.
   - Parameter locationNotifier: Интерфейс для оповещения об обновлении текущей гепозиции.
   - Note: Если провайдер доступен (был вызван available_callback со значением true),
   то метод LocationNotifier.send всегда возвращает достоверную геопозицию.
   Достоверная геопозиция - это геопозиция, в которой все поля имеют актуальное значение на момент ее
   отправки в этот канал (т.е. если accuracy геопозиции >= половине длины экватора Земли,
   то геопозиция является достоверной для любых от указанных в ней корректных координат).
   - Note: Если location.coordinates.accuracy
   <
   = 0, то позиция считается недостоверной даже если available == true.
   - Parameter availableNotifier: Интерфейс для оповещения об изменении доступности источника геопозиции.
   - Note: Если вызван метод AvailableNotifier.send true, то все последующие вызовы
   location_callback будут содержать достоверную (актуальную) геопозицию.
   - Note: Даже если слежение за изменением геопозиции недоступно, LocationProvider может присылать новую геопозицию,
   но она будет считаться недостоверной.
  */
  void setNotifiers(
    LocationNotifier? locationNotifier,
    LocationAvailableNotifier? availableNotifier
  )  {
    var _a1 = locationNotifier._copyFromDartTo_COptional_CLocationNotifier();
    var _a2 = availableNotifier._copyFromDartTo_COptional_CLocationAvailableNotifier();
    void res = _CLocationProviderCpp_setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifier(_CLocationProviderCppMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Задает желаемую точность определения местоположения.
  
   - Note: Если устройство не может вернуть местоположение с желаемой точностью,
   то оно может вернуть местоположение с меньшей точностью.
   - Note: Если API платформы не предоставляет аналогичный по функциональности метод,
   то данный метод должен иметь пустую реализацию.
  */
  void setDesiredAccuracy(
    DesiredAccuracy desiredAccuracy
  )  {
    var _a1 = desiredAccuracy._copyFromDartTo_CDesiredAccuracy();
    void res = _CLocationProviderCpp_setDesiredAccuracy_CDesiredAccuracy(_CLocationProviderCppMakeDefault().._impl=_self, _a1);
    return res;
  }

}

// MARK: - _LocationProviderCpp <-> CLocationProviderCpp

final class _CLocationProviderCpp extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CLocationProviderCppBasicFunctions on _CLocationProviderCpp {
  void _releaseIntermediate() {
    _CLocationProviderCpp_release(_impl);
  }

  _CLocationProviderCpp _retain() {
    return _CLocationProviderCpp_retain(_impl);
  }
}

extension _CLocationProviderCppToDart on _CLocationProviderCpp {
  _LocationProviderCpp _toDart() {
    return _LocationProviderCpp._create(_retain()._impl);
  }
}


extension _DartToCLocationProviderCpp on _LocationProviderCpp {
  _CLocationProviderCpp _copyFromDartTo_CLocationProviderCpp() {
    return (_CLocationProviderCppMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Latitude

/** Географическая широта. */
class Latitude {
  final double value;

  const Latitude([this.value = 0]);

  Latitude copyWith({
    double? value
  }) {
    return Latitude(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Latitude &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CLatitude extends ffi.Struct {
  @ffi.Double()
  external double value;

}
// MARK: - Latitude <-> _CLatitude

extension _CLatitudeToDart on _CLatitude {
  Latitude _toDart() {
    return Latitude(
      this.value
    );
  }
}

extension _DartTo_CLatitude on Latitude {
  _CLatitude _copyFromDartTo_CLatitude() {
    final res = _CLatitudeMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CLatitudeRelease on _CLatitude {
  void _releaseIntermediate() {
  }
}

// MARK: - Longitude

/** Географическая долгота. */
class Longitude {
  final double value;

  const Longitude([this.value = 0]);

  Longitude copyWith({
    double? value
  }) {
    return Longitude(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Longitude &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CLongitude extends ffi.Struct {
  @ffi.Double()
  external double value;

}
// MARK: - Longitude <-> _CLongitude

extension _CLongitudeToDart on _CLongitude {
  Longitude _toDart() {
    return Longitude(
      this.value
    );
  }
}

extension _DartTo_CLongitude on Longitude {
  _CLongitude _copyFromDartTo_CLongitude() {
    final res = _CLongitudeMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CLongitudeRelease on _CLongitude {
  void _releaseIntermediate() {
  }
}

// MARK: - GeoPoint

/**
 Точка в сферической системе координат, которая совместно с геодезической системой координат (например, WGS84)
 указывает на точку на поверхности Земли.
 Данная структура не привязана к конкретной геодезической системе координат.
 Но данный модуль содержит свободные функции, которые оперируют данной структурой уже
 в конкретной в системе координат (в какой именно см. в документации к функциям).
*/
class GeoPoint {
  final Latitude latitude;
  final Longitude longitude;

  const GeoPoint({
    required this.latitude,
    required this.longitude
  });

  GeoPoint copyWith({
    Latitude? latitude,
    Longitude? longitude
  }) {
    return GeoPoint(
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GeoPoint &&
    other.runtimeType == runtimeType &&
    other.latitude == latitude &&
    other.longitude == longitude;

  @override
  int get hashCode {
    return Object.hash(latitude, longitude);
  }

}
final class _CGeoPoint extends ffi.Struct {
  external _CLatitude latitude;

  external _CLongitude longitude;

}
// MARK: - GeoPoint <-> _CGeoPoint

extension _CGeoPointToDart on _CGeoPoint {
  GeoPoint _toDart() {
    return GeoPoint(
      latitude: this.latitude._toDart(),
      longitude: this.longitude._toDart()
    );
  }
}

extension _DartTo_CGeoPoint on GeoPoint {
  _CGeoPoint _copyFromDartTo_CGeoPoint() {
    final res = _CGeoPointMakeDefault();
    res.latitude = this.latitude._copyFromDartTo_CLatitude();
    res.longitude = this.longitude._copyFromDartTo_CLongitude();
    return res;
  }
}
extension _CGeoPointRelease on _CGeoPoint {
  void _releaseIntermediate() {
  }
}

// MARK: - LocationCoordinates

class LocationCoordinates {
  final GeoPoint value;
  final double accuracy;

  const LocationCoordinates({
    required this.value,
    required this.accuracy
  });

  LocationCoordinates copyWith({
    GeoPoint? value,
    double? accuracy
  }) {
    return LocationCoordinates(
      value: value ?? this.value,
      accuracy: accuracy ?? this.accuracy
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LocationCoordinates &&
    other.runtimeType == runtimeType &&
    other.value == value &&
    other.accuracy == accuracy;

  @override
  int get hashCode {
    return Object.hash(value, accuracy);
  }

}
final class _CLocationCoordinates extends ffi.Struct {
  external _CGeoPoint value;

  @ffi.Double()
  external double accuracy;

}
// MARK: - LocationCoordinates <-> _CLocationCoordinates

extension _CLocationCoordinatesToDart on _CLocationCoordinates {
  LocationCoordinates _toDart() {
    return LocationCoordinates(
      value: this.value._toDart(),
      accuracy: this.accuracy
    );
  }
}

extension _DartTo_CLocationCoordinates on LocationCoordinates {
  _CLocationCoordinates _copyFromDartTo_CLocationCoordinates() {
    final res = _CLocationCoordinatesMakeDefault();
    res.value = this.value._copyFromDartTo_CGeoPoint();
    res.accuracy = this.accuracy;
    return res;
  }
}
extension _CLocationCoordinatesRelease on _CLocationCoordinates {
  void _releaseIntermediate() {
  }
}

// MARK: - double? <-> _COptional_double

final class _COptional_double extends ffi.Struct {
  @ffi.Double()
  external double value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_doubleBasicFunctions on _COptional_double {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_doubleToDart on _COptional_double {
  double? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value;
  }
}

extension _DartTo_COptional_double on double? {
  _COptional_double _copyFromDartTo_COptional_double() {
    final cOptional = _COptional_doubleMakeDefault();
    if (this != null) {
      cOptional.value = this!;
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - LocationFuzzyDouble

class LocationFuzzyDouble {
  final double value;
  final double? accuracy;

  const LocationFuzzyDouble({
    required this.value,
    required this.accuracy
  });

  LocationFuzzyDouble copyWith({
    double? value,
    Optional<double?>? accuracy
  }) {
    return LocationFuzzyDouble(
      value: value ?? this.value,
      accuracy: accuracy != null ? accuracy.value : this.accuracy
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LocationFuzzyDouble &&
    other.runtimeType == runtimeType &&
    other.value == value &&
    other.accuracy == accuracy;

  @override
  int get hashCode {
    return Object.hash(value, accuracy);
  }

}
final class _CLocationFuzzyDouble extends ffi.Struct {
  @ffi.Double()
  external double value;

  external _COptional_double accuracy;

}
// MARK: - LocationFuzzyDouble <-> _CLocationFuzzyDouble

extension _CLocationFuzzyDoubleToDart on _CLocationFuzzyDouble {
  LocationFuzzyDouble _toDart() {
    return LocationFuzzyDouble(
      value: this.value,
      accuracy: this.accuracy._toDart()
    );
  }
}

extension _DartTo_CLocationFuzzyDouble on LocationFuzzyDouble {
  _CLocationFuzzyDouble _copyFromDartTo_CLocationFuzzyDouble() {
    final res = _CLocationFuzzyDoubleMakeDefault();
    res.value = this.value;
    res.accuracy = this.accuracy._copyFromDartTo_COptional_double();
    return res;
  }
}
extension _CLocationFuzzyDoubleRelease on _CLocationFuzzyDouble {
  void _releaseIntermediate() {
  }
}

// MARK: - LocationFuzzyDouble? <-> _COptional_CLocationFuzzyDouble

final class _COptional_CLocationFuzzyDouble extends ffi.Struct {
  
  external _CLocationFuzzyDouble value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CLocationFuzzyDoubleBasicFunctions on _COptional_CLocationFuzzyDouble {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CLocationFuzzyDoubleToDart on _COptional_CLocationFuzzyDouble {
  LocationFuzzyDouble? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CLocationFuzzyDouble on LocationFuzzyDouble? {
  _COptional_CLocationFuzzyDouble _copyFromDartTo_COptional_CLocationFuzzyDouble() {
    final cOptional = _COptional_CLocationFuzzyDoubleMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CLocationFuzzyDouble();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Bearing

/**
 Угол между направлением на один объект и на другой объект, либо между направлением на объект и север.
 Угол отсчитывается по часовой стрелке. Диапазон значений [0°, 360°].
*/
class Bearing {
  final double value;

  const Bearing([this.value = 0]);

  Bearing copyWith({
    double? value
  }) {
    return Bearing(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Bearing &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CBearing extends ffi.Struct {
  @ffi.Double()
  external double value;

}
// MARK: - Bearing <-> _CBearing

extension _CBearingToDart on _CBearing {
  Bearing _toDart() {
    return Bearing(
      this.value
    );
  }
}

extension _DartTo_CBearing on Bearing {
  _CBearing _copyFromDartTo_CBearing() {
    final res = _CBearingMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CBearingRelease on _CBearing {
  void _releaseIntermediate() {
  }
}

// MARK: - Bearing? <-> _COptional_CBearing

final class _COptional_CBearing extends ffi.Struct {
  
  external _CBearing value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CBearingBasicFunctions on _COptional_CBearing {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CBearingToDart on _COptional_CBearing {
  Bearing? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CBearing on Bearing? {
  _COptional_CBearing _copyFromDartTo_COptional_CBearing() {
    final cOptional = _COptional_CBearingMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CBearing();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - LocationCourse

class LocationCourse {
  final Bearing value;
  final Bearing? accuracy;

  const LocationCourse({
    required this.value,
    required this.accuracy
  });

  LocationCourse copyWith({
    Bearing? value,
    Optional<Bearing?>? accuracy
  }) {
    return LocationCourse(
      value: value ?? this.value,
      accuracy: accuracy != null ? accuracy.value : this.accuracy
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LocationCourse &&
    other.runtimeType == runtimeType &&
    other.value == value &&
    other.accuracy == accuracy;

  @override
  int get hashCode {
    return Object.hash(value, accuracy);
  }

}
final class _CLocationCourse extends ffi.Struct {
  external _CBearing value;

  external _COptional_CBearing accuracy;

}
// MARK: - LocationCourse <-> _CLocationCourse

extension _CLocationCourseToDart on _CLocationCourse {
  LocationCourse _toDart() {
    return LocationCourse(
      value: this.value._toDart(),
      accuracy: this.accuracy._toDart()
    );
  }
}

extension _DartTo_CLocationCourse on LocationCourse {
  _CLocationCourse _copyFromDartTo_CLocationCourse() {
    final res = _CLocationCourseMakeDefault();
    res.value = this.value._copyFromDartTo_CBearing();
    res.accuracy = this.accuracy._copyFromDartTo_COptional_CBearing();
    return res;
  }
}
extension _CLocationCourseRelease on _CLocationCourse {
  void _releaseIntermediate() {
  }
}

// MARK: - LocationCourse? <-> _COptional_CLocationCourse

final class _COptional_CLocationCourse extends ffi.Struct {
  
  external _CLocationCourse value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CLocationCourseBasicFunctions on _COptional_CLocationCourse {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CLocationCourseToDart on _COptional_CLocationCourse {
  LocationCourse? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CLocationCourse on LocationCourse? {
  _COptional_CLocationCourse _copyFromDartTo_COptional_CLocationCourse() {
    final cOptional = _COptional_CLocationCourseMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CLocationCourse();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Location

/** Геопозиция. */
class Location {
  /**
   coordinates::value - координаты геопозиции в системе координат WGS 84.
   coordinates::accuracy - горизонтальная точность определения координат геопозиции (DRMS), м.
   https://en.wikipedia.org/wiki/Circular_error_probable
   Область значений: >= 0.
  */
  final LocationCoordinates coordinates;
  /**
   altitude::value - высота над опорным эллипсоидом WGS 84, м.
   altitude::accuracy - стандартное отклонение ошибки измерения высоты, м.
   null означает, что платформа не предоставляет данное поле.
   https://en.wikipedia.org/wiki/Standard_deviation
   Область значений: (null, > 0).
  */
  final LocationFuzzyDouble? altitude;
  /**
   course::value - путевой угол (направление движения вдоль поверхности Земли).
   Угол измеряется относительно географического севера).
   course::accuracy - стандартное отклонение ошибки измерения путевого угла.
   null означает, что платформа не предоставляет данное поле.
   https://en.wikipedia.org/wiki/Standard_deviation
   Область значений: (null, > 0).
  */
  final LocationCourse? course;
  /**
   ground_speed - скорость движения вдоль поверхности Земли, м/с.
   Область значений: >= 0.
   ground_speed::accuracy - среднеквадратичное отклонение ошибки измерения скорости, м/с.
   null означает, что платформа не предоставляет данное поле.
   https://en.wikipedia.org/wiki/Standard_deviation
   Область значений: (null, > 0).
  */
  final LocationFuzzyDouble? groundSpeed;
  /**
   Временная точка, в которой была определена геопозиция.
   Эта точка не привязана ни к какой конкретной дате и используется исключительно для того,
   чтобы вычислить время между двумя измерениями геопозиции,
   полученными от одного источника геопозиции в одной сессии.
   Это поле должно монотонно возрастать (даже когда система находится в спящем режиме).
  */
  final Duration timestamp;

  const Location({
    required this.coordinates,
    required this.altitude,
    required this.course,
    required this.groundSpeed,
    required this.timestamp
  });

  Location copyWith({
    LocationCoordinates? coordinates,
    Optional<LocationFuzzyDouble?>? altitude,
    Optional<LocationCourse?>? course,
    Optional<LocationFuzzyDouble?>? groundSpeed,
    Duration? timestamp
  }) {
    return Location(
      coordinates: coordinates ?? this.coordinates,
      altitude: altitude != null ? altitude.value : this.altitude,
      course: course != null ? course.value : this.course,
      groundSpeed: groundSpeed != null ? groundSpeed.value : this.groundSpeed,
      timestamp: timestamp ?? this.timestamp
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Location &&
    other.runtimeType == runtimeType &&
    other.coordinates == coordinates &&
    other.altitude == altitude &&
    other.course == course &&
    other.groundSpeed == groundSpeed &&
    other.timestamp == timestamp;

  @override
  int get hashCode {
    return Object.hash(coordinates, altitude, course, groundSpeed, timestamp);
  }

}
final class _CLocation extends ffi.Struct {
  external _CLocationCoordinates coordinates;

  external _COptional_CLocationFuzzyDouble altitude;

  external _COptional_CLocationCourse course;

  external _COptional_CLocationFuzzyDouble groundSpeed;

  external _CTimeInterval timestamp;

}
// MARK: - Location <-> _CLocation

extension _CLocationToDart on _CLocation {
  Location _toDart() {
    return Location(
      coordinates: this.coordinates._toDart(),
      altitude: this.altitude._toDart(),
      course: this.course._toDart(),
      groundSpeed: this.groundSpeed._toDart(),
      timestamp: this.timestamp._toDart()
    );
  }
}

extension _DartTo_CLocation on Location {
  _CLocation _copyFromDartTo_CLocation() {
    final res = _CLocationMakeDefault();
    res.coordinates = this.coordinates._copyFromDartTo_CLocationCoordinates();
    res.altitude = this.altitude._copyFromDartTo_COptional_CLocationFuzzyDouble();
    res.course = this.course._copyFromDartTo_COptional_CLocationCourse();
    res.groundSpeed = this.groundSpeed._copyFromDartTo_COptional_CLocationFuzzyDouble();
    res.timestamp = this.timestamp._copyFromDartTo_CTimeInterval();
    return res;
  }
}
extension _CLocationRelease on _CLocation {
  void _releaseIntermediate() {
  }
}

// MARK: - Location? <-> _COptional_CLocation

final class _COptional_CLocation extends ffi.Struct {
  
  external _CLocation value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CLocationBasicFunctions on _COptional_CLocation {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CLocationToDart on _COptional_CLocation {
  Location? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CLocation on Location? {
  _COptional_CLocation _copyFromDartTo_COptional_CLocation() {
    final cOptional = _COptional_CLocationMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CLocation();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - LocationNotifier

/** Интерфейс объекта, который сообщает об обновлении геопозиции. */
class LocationNotifier implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CLocationNotifier_releasePtr);

  LocationNotifier._raw(this._self);
  factory LocationNotifier._create(ffi.Pointer<ffi.Void> self) {
    final classObject = LocationNotifier._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LocationNotifier &&
    other.runtimeType == runtimeType &&
    _CLocationNotifier_cg_objectIdentifier(this._self) == _CLocationNotifier_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CLocationNotifier_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: LocationNotifier: Methods

  /** Необходимо вызывать, чтобы сообщить об обновлении геопозиции. */
  void send(
    List<Location> locations
  )  {
    var _a1 = locations._copyFromDartTo_CArray_CLocation();
    void res = _CLocationNotifier_send_CArray_CLocation(_CLocationNotifierMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - LocationNotifier <-> CLocationNotifier

final class _CLocationNotifier extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CLocationNotifierBasicFunctions on _CLocationNotifier {
  void _releaseIntermediate() {
    _CLocationNotifier_release(_impl);
  }

  _CLocationNotifier _retain() {
    return _CLocationNotifier_retain(_impl);
  }
}

extension _CLocationNotifierToDart on _CLocationNotifier {
  LocationNotifier _toDart() {
    return LocationNotifier._create(_retain()._impl);
  }
}


extension _DartToCLocationNotifier on LocationNotifier {
  _CLocationNotifier _copyFromDartTo_CLocationNotifier() {
    return (_CLocationNotifierMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - LocationNotifier? <-> _COptional_CLocationNotifier

final class _COptional_CLocationNotifier extends ffi.Struct {
  
  external _CLocationNotifier value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CLocationNotifierBasicFunctions on _COptional_CLocationNotifier {
  void _releaseIntermediate() {
    _COptional_CLocationNotifier_release(this);
  }
}

extension _COptional_CLocationNotifierToDart on _COptional_CLocationNotifier {
  LocationNotifier? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CLocationNotifier on LocationNotifier? {
  _COptional_CLocationNotifier _copyFromDartTo_COptional_CLocationNotifier() {
    final cOptional = _COptional_CLocationNotifierMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CLocationNotifier();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<Location> <-> _CArray_CLocation

final class _CArray_CLocation extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CLocationToDart on _CArray_CLocation {
  List<Location> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CLocation on List<Location> {
  _CArray_CLocation _copyFromDartTo_CArray_CLocation() {
    final cArray = _CArray_CLocationmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CLocation();
        _CArray_CLocationaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CLocationBasicFunctions on _CArray_CLocation {
  void _releaseIntermediate() {
    _CArray_CLocation_release(this);
  }

  static final _listToFill = <Location>[];

  static void _iterate(_CLocation item) {
    _listToFill.add(item._toDart());
  }

  List<Location> _fillFromC() {
    _forEach_CArray_CLocation(this, ffi.Pointer.fromFunction<ffi.Void Function(_CLocation)>(_iterate));
    final result = List<Location>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - LocationAvailableNotifier

/** Интерфейс объекта, который сообщает об изменении доступности источника геопозиции. */
class LocationAvailableNotifier implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CLocationAvailableNotifier_releasePtr);

  LocationAvailableNotifier._raw(this._self);
  factory LocationAvailableNotifier._create(ffi.Pointer<ffi.Void> self) {
    final classObject = LocationAvailableNotifier._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LocationAvailableNotifier &&
    other.runtimeType == runtimeType &&
    _CLocationAvailableNotifier_cg_objectIdentifier(this._self) == _CLocationAvailableNotifier_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CLocationAvailableNotifier_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: LocationAvailableNotifier: Methods

  /** Необходимо вызывать, чтобы сообщить об изменении. */
  void send(
    bool available
  )  {
    void res = _CLocationAvailableNotifier_send_bool(_CLocationAvailableNotifierMakeDefault().._impl=_self, available);
    return res;
  }

}

// MARK: - LocationAvailableNotifier <-> CLocationAvailableNotifier

final class _CLocationAvailableNotifier extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CLocationAvailableNotifierBasicFunctions on _CLocationAvailableNotifier {
  void _releaseIntermediate() {
    _CLocationAvailableNotifier_release(_impl);
  }

  _CLocationAvailableNotifier _retain() {
    return _CLocationAvailableNotifier_retain(_impl);
  }
}

extension _CLocationAvailableNotifierToDart on _CLocationAvailableNotifier {
  LocationAvailableNotifier _toDart() {
    return LocationAvailableNotifier._create(_retain()._impl);
  }
}


extension _DartToCLocationAvailableNotifier on LocationAvailableNotifier {
  _CLocationAvailableNotifier _copyFromDartTo_CLocationAvailableNotifier() {
    return (_CLocationAvailableNotifierMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - LocationAvailableNotifier? <-> _COptional_CLocationAvailableNotifier

final class _COptional_CLocationAvailableNotifier extends ffi.Struct {
  
  external _CLocationAvailableNotifier value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CLocationAvailableNotifierBasicFunctions on _COptional_CLocationAvailableNotifier {
  void _releaseIntermediate() {
    _COptional_CLocationAvailableNotifier_release(this);
  }
}

extension _COptional_CLocationAvailableNotifierToDart on _COptional_CLocationAvailableNotifier {
  LocationAvailableNotifier? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CLocationAvailableNotifier on LocationAvailableNotifier? {
  _COptional_CLocationAvailableNotifier _copyFromDartTo_COptional_CLocationAvailableNotifier() {
    final cOptional = _COptional_CLocationAvailableNotifierMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CLocationAvailableNotifier();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - HeadingProvider

/**
 Интерфейс, предоставляющий направление устройства относительно направления на север,
 который реализуется на платформе.

 - Note: Все методы данного интерфейса должны вызываться из одного потока.
*/
abstract class HeadingProvider {
  void setNotifiers(
    HeadingNotifier? headingNotifier,
    HeadingAvailableNotifier? availableNotifier
  );
}

class _HeadingProvider {
  final HeadingProvider object;
  int refCounter = 1;

  _HeadingProvider(this.object);
}

final class _CHeadingProvider extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.Void> _cppValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _COptional_CHeadingNotifier, _COptional_CHeadingAvailableNotifier)>> _setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifier;
}

extension _CHeadingProviderBasicFunctions on _CHeadingProvider {
  void _releaseIntermediate() {
    _CHeadingProvider_release(this);
  }
}

int _CHeadingProviderInstanceCounter = 1;
final _CHeadingProviderInstanceMap = <int, _HeadingProvider>{};

extension _CHeadingProviderToDart on _CHeadingProvider {
  HeadingProvider _toDart() {
    late HeadingProvider? result;
    final platformValue = this._value.cast<ffi.Int64>();
    if (platformValue.address != 0) {
      result = _CHeadingProviderInstanceMap[platformValue.address]?.object;
    } else if (this._cppValue.address != 0) {
      final cppValue = _CHeadingProviderCppMakeDefault().._impl = this._cppValue;
      result = cppValue._toDart();
    }
    if (result == null) {
      throw Exception("Invalid intermediate object of type _CHeadingProvider");
    }
    return result;
  }
}

extension _DartTo_CHeadingProvider on HeadingProvider {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    _CHeadingProviderInstanceMap[platformValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    final platformObject = _CHeadingProviderInstanceMap[platformValue.address];
    if (platformObject == null) {
      return;
    }
    platformObject.refCounter -= 1;
    if (platformObject.refCounter > 0) {
      return;
    }
    _CHeadingProviderInstanceMap.remove(platformValue.address);
  }

  _CHeadingProvider _copyFromDartTo_CHeadingProvider() {
    var res = _CHeadingProviderMakeDefault();
    if (this is _HeadingProviderCpp) {
      final cppValue = this as _HeadingProviderCpp;
      res._cppValue = cppValue._copyFromDartTo_CHeadingProviderCpp()._impl;
      return res;
    }
    final instanceId = _CHeadingProviderInstanceCounter;
    _CHeadingProviderInstanceCounter += 1;
    _CHeadingProviderInstanceMap[instanceId] = _HeadingProvider(this);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;

    final setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifierFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _COptional_CHeadingNotifier, _COptional_CHeadingAvailableNotifier)>.listener(setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifierFunction);
    res._setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifier = setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifierFunctionCallable.nativeFunction;
    return res;
  }

  static void setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifierFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> resultValueCallback, _COptional_CHeadingNotifier headingNotifier, _COptional_CHeadingAvailableNotifier availableNotifier) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CHeadingProvider");
    }
    final platformObject = _CHeadingProviderInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CHeadingProvider");
    }

    final headingNotifierDart = headingNotifier._toDart();
    final availableNotifierDart = availableNotifier._toDart();
    platformObject.object.setNotifiers(headingNotifierDart, availableNotifierDart);
    headingNotifier._releaseIntermediate();
    availableNotifier._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
    callbackFunction(context);
  }


}

// MARK: - HeadingProvider? <-> _COptional_CHeadingProvider

final class _COptional_CHeadingProvider extends ffi.Struct {
  
  external _CHeadingProvider value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CHeadingProviderBasicFunctions on _COptional_CHeadingProvider {
  void _releaseIntermediate() {
    _COptional_CHeadingProvider_release(this);
  }
}

extension _COptional_CHeadingProviderToDart on _COptional_CHeadingProvider {
  HeadingProvider? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CHeadingProvider on HeadingProvider? {
  _COptional_CHeadingProvider _copyFromDartTo_COptional_CHeadingProvider() {
    final cOptional = _COptional_CHeadingProviderMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CHeadingProvider();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - _HeadingProviderCpp

/**
 Интерфейс, предоставляющий направление устройства относительно направления на север,
 который реализуется на платформе.

 - Note: Все методы данного интерфейса должны вызываться из одного потока.
*/
class _HeadingProviderCpp extends HeadingProvider implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CHeadingProviderCpp_releasePtr);

  _HeadingProviderCpp._raw(this._self);
  factory _HeadingProviderCpp._create(ffi.Pointer<ffi.Void> self) {
    final classObject = _HeadingProviderCpp._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is _HeadingProviderCpp &&
    other.runtimeType == runtimeType &&
    _CHeadingProviderCpp_cg_objectIdentifier(this._self) == _CHeadingProviderCpp_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CHeadingProviderCpp_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: _HeadingProviderCpp: Methods

  /**
   Устанавливает интерфейсы для оповещения об обновлении текущего направления и изменении доступности источника
   направления.
  
   - Note: Повторный вызов данного метода перезаписывает предыдущие функции обратного вызова.
   - Note: Если оба параметра равны null, то слежение за обновлением направления нужно отключить.
   - Parameter headingNotifier: Интерфейс для оповещения об обновлении текущего направления.
   - Parameter availableNotifier: Интерфейс для оповещения об изменении доступности источника направления.
   - Note: Даже если слежение за изменением направления недоступно, provider может присылать новое направление,
   но оно будет считаться недостоверным.
  */
  void setNotifiers(
    HeadingNotifier? headingNotifier,
    HeadingAvailableNotifier? availableNotifier
  )  {
    var _a1 = headingNotifier._copyFromDartTo_COptional_CHeadingNotifier();
    var _a2 = availableNotifier._copyFromDartTo_COptional_CHeadingAvailableNotifier();
    void res = _CHeadingProviderCpp_setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifier(_CHeadingProviderCppMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - _HeadingProviderCpp <-> CHeadingProviderCpp

final class _CHeadingProviderCpp extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CHeadingProviderCppBasicFunctions on _CHeadingProviderCpp {
  void _releaseIntermediate() {
    _CHeadingProviderCpp_release(_impl);
  }

  _CHeadingProviderCpp _retain() {
    return _CHeadingProviderCpp_retain(_impl);
  }
}

extension _CHeadingProviderCppToDart on _CHeadingProviderCpp {
  _HeadingProviderCpp _toDart() {
    return _HeadingProviderCpp._create(_retain()._impl);
  }
}


extension _DartToCHeadingProviderCpp on _HeadingProviderCpp {
  _CHeadingProviderCpp _copyFromDartTo_CHeadingProviderCpp() {
    return (_CHeadingProviderCppMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - HeadingNotifier

/** Интерфейс объекта на обновление текущего направления. */
class HeadingNotifier implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CHeadingNotifier_releasePtr);

  HeadingNotifier._raw(this._self);
  factory HeadingNotifier._create(ffi.Pointer<ffi.Void> self) {
    final classObject = HeadingNotifier._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is HeadingNotifier &&
    other.runtimeType == runtimeType &&
    _CHeadingNotifier_cg_objectIdentifier(this._self) == _CHeadingNotifier_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CHeadingNotifier_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: HeadingNotifier: Methods

  /** Необходимо вызывать, чтобы сообщить об обновлении направления. */
  void send(
    PlatformHeading platformHeading
  )  {
    var _a1 = platformHeading._copyFromDartTo_CPlatformHeading();
    void res = _CHeadingNotifier_send_CPlatformHeading(_CHeadingNotifierMakeDefault().._impl=_self, _a1);
    return res;
  }

}

// MARK: - HeadingNotifier <-> CHeadingNotifier

final class _CHeadingNotifier extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CHeadingNotifierBasicFunctions on _CHeadingNotifier {
  void _releaseIntermediate() {
    _CHeadingNotifier_release(_impl);
  }

  _CHeadingNotifier _retain() {
    return _CHeadingNotifier_retain(_impl);
  }
}

extension _CHeadingNotifierToDart on _CHeadingNotifier {
  HeadingNotifier _toDart() {
    return HeadingNotifier._create(_retain()._impl);
  }
}


extension _DartToCHeadingNotifier on HeadingNotifier {
  _CHeadingNotifier _copyFromDartTo_CHeadingNotifier() {
    return (_CHeadingNotifierMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - HeadingNotifier? <-> _COptional_CHeadingNotifier

final class _COptional_CHeadingNotifier extends ffi.Struct {
  
  external _CHeadingNotifier value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CHeadingNotifierBasicFunctions on _COptional_CHeadingNotifier {
  void _releaseIntermediate() {
    _COptional_CHeadingNotifier_release(this);
  }
}

extension _COptional_CHeadingNotifierToDart on _COptional_CHeadingNotifier {
  HeadingNotifier? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CHeadingNotifier on HeadingNotifier? {
  _COptional_CHeadingNotifier _copyFromDartTo_COptional_CHeadingNotifier() {
    final cOptional = _COptional_CHeadingNotifierMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CHeadingNotifier();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - PlatformHeading

/** Информация о направлении устройста, которую отдает платформа. */
class PlatformHeading {
  /** Направление. */
  final LocationCourse heading;
  /**
   Временная точка, в которой было определено направление.
   Эта точка не привязана ни к какой конкретной дате и используется исключительно для того,
   чтобы вычислить время между двумя измерениями направления,
   полученными от одного источника направления в одной сессии.
   Это поле должно монотонно возрастать.
  */
  final Duration timestamp;

  const PlatformHeading({
    required this.heading,
    required this.timestamp
  });

  PlatformHeading copyWith({
    LocationCourse? heading,
    Duration? timestamp
  }) {
    return PlatformHeading(
      heading: heading ?? this.heading,
      timestamp: timestamp ?? this.timestamp
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PlatformHeading &&
    other.runtimeType == runtimeType &&
    other.heading == heading &&
    other.timestamp == timestamp;

  @override
  int get hashCode {
    return Object.hash(heading, timestamp);
  }

}
final class _CPlatformHeading extends ffi.Struct {
  external _CLocationCourse heading;

  external _CTimeInterval timestamp;

}
// MARK: - PlatformHeading <-> _CPlatformHeading

extension _CPlatformHeadingToDart on _CPlatformHeading {
  PlatformHeading _toDart() {
    return PlatformHeading(
      heading: this.heading._toDart(),
      timestamp: this.timestamp._toDart()
    );
  }
}

extension _DartTo_CPlatformHeading on PlatformHeading {
  _CPlatformHeading _copyFromDartTo_CPlatformHeading() {
    final res = _CPlatformHeadingMakeDefault();
    res.heading = this.heading._copyFromDartTo_CLocationCourse();
    res.timestamp = this.timestamp._copyFromDartTo_CTimeInterval();
    return res;
  }
}
extension _CPlatformHeadingRelease on _CPlatformHeading {
  void _releaseIntermediate() {
  }
}

// MARK: - HeadingAvailableNotifier

/** Интерфейс объекта, который сообщает об изменении доступности источника направления. */
class HeadingAvailableNotifier implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CHeadingAvailableNotifier_releasePtr);

  HeadingAvailableNotifier._raw(this._self);
  factory HeadingAvailableNotifier._create(ffi.Pointer<ffi.Void> self) {
    final classObject = HeadingAvailableNotifier._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is HeadingAvailableNotifier &&
    other.runtimeType == runtimeType &&
    _CHeadingAvailableNotifier_cg_objectIdentifier(this._self) == _CHeadingAvailableNotifier_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CHeadingAvailableNotifier_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: HeadingAvailableNotifier: Methods

  /** Необходимо вызывать, чтобы сообщить об изменении. */
  void send(
    bool available
  )  {
    void res = _CHeadingAvailableNotifier_send_bool(_CHeadingAvailableNotifierMakeDefault().._impl=_self, available);
    return res;
  }

}

// MARK: - HeadingAvailableNotifier <-> CHeadingAvailableNotifier

final class _CHeadingAvailableNotifier extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CHeadingAvailableNotifierBasicFunctions on _CHeadingAvailableNotifier {
  void _releaseIntermediate() {
    _CHeadingAvailableNotifier_release(_impl);
  }

  _CHeadingAvailableNotifier _retain() {
    return _CHeadingAvailableNotifier_retain(_impl);
  }
}

extension _CHeadingAvailableNotifierToDart on _CHeadingAvailableNotifier {
  HeadingAvailableNotifier _toDart() {
    return HeadingAvailableNotifier._create(_retain()._impl);
  }
}


extension _DartToCHeadingAvailableNotifier on HeadingAvailableNotifier {
  _CHeadingAvailableNotifier _copyFromDartTo_CHeadingAvailableNotifier() {
    return (_CHeadingAvailableNotifierMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - HeadingAvailableNotifier? <-> _COptional_CHeadingAvailableNotifier

final class _COptional_CHeadingAvailableNotifier extends ffi.Struct {
  
  external _CHeadingAvailableNotifier value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CHeadingAvailableNotifierBasicFunctions on _COptional_CHeadingAvailableNotifier {
  void _releaseIntermediate() {
    _COptional_CHeadingAvailableNotifier_release(this);
  }
}

extension _COptional_CHeadingAvailableNotifierToDart on _COptional_CHeadingAvailableNotifier {
  HeadingAvailableNotifier? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CHeadingAvailableNotifier on HeadingAvailableNotifier? {
  _COptional_CHeadingAvailableNotifier _copyFromDartTo_COptional_CHeadingAvailableNotifier() {
    final cOptional = _COptional_CHeadingAvailableNotifierMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CHeadingAvailableNotifier();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - File

/**
 Идентификатор файла.

 Может являться не только файлом на файловой системе, но и произвольным источником данных.
*/
class File implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CFile_releasePtr);

  File._raw(this._self);
  factory File._create(ffi.Pointer<ffi.Void> self) {
    final classObject = File._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Файл в файловой системе.
  
   - Parameter path: Путь к файлу.
  */
  factory File(
    String path
  ) {
    var _a0 = path._copyFromDartTo_CString();
    _CFile res = _CFile_C_createWith_CString(_a0);
    _a0._releaseIntermediate();
    return File._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is File &&
    other.runtimeType == runtimeType &&
    _CFile_cg_objectIdentifier(this._self) == _CFile_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CFile_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CFile: Static Methods

  /**
   Файл с содержимым из заданной строки.
  
   - Parameter contents: Содержимое файла.
  */
  static File fromString(
    String contents
  )  {
    var _a0 = contents._copyFromDartTo_CString();
    _CFile res = _CFile_S_fromString_CString(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Файл из asset-ов.
  
   - Parameter path: Путь относительно корневой директории asset-ов.
  */
  static File fromAsset(
    Context context,
    String path
  )  {
    var _a0 = context._copyFromDartTo_CContext();
    var _a1 = path._copyFromDartTo_CString();
    _CFile res = _CFile_S_fromAsset_CContext_CString(_a0, _a1);
    _a1._releaseIntermediate();
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - File <-> CFile

final class _CFile extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CFileBasicFunctions on _CFile {
  void _releaseIntermediate() {
    _CFile_release(_impl);
  }

  _CFile _retain() {
    return _CFile_retain(_impl);
  }
}

extension _CFileToDart on _CFile {
  File _toDart() {
    return File._create(_retain()._impl);
  }
}


extension _DartToCFile on File {
  _CFile _copyFromDartTo_CFile() {
    return (_CFileMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - GeoRect

/**
 Прямоугольная область в сферической системе координат (например, WGS84).
 Данная структура не привязана к конкретной геодезической системе координат.
*/
class GeoRect {
  /** Юго-западная точка, левая нижняя граница прямоугольника. */
  final GeoPoint southWestPoint;
  /** Северо-восточная точка, правая верхняя граница прямоугольника. */
  final GeoPoint northEastPoint;

  const GeoRect({
    required this.southWestPoint,
    required this.northEastPoint
  });

  GeoRect copyWith({
    GeoPoint? southWestPoint,
    GeoPoint? northEastPoint
  }) {
    return GeoRect(
      southWestPoint: southWestPoint ?? this.southWestPoint,
      northEastPoint: northEastPoint ?? this.northEastPoint
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GeoRect &&
    other.runtimeType == runtimeType &&
    other.southWestPoint == southWestPoint &&
    other.northEastPoint == northEastPoint;

  @override
  int get hashCode {
    return Object.hash(southWestPoint, northEastPoint);
  }

}
final class _CGeoRect extends ffi.Struct {
  external _CGeoPoint southWestPoint;

  external _CGeoPoint northEastPoint;

}
// MARK: - GeoRect <-> _CGeoRect

extension _CGeoRectToDart on _CGeoRect {
  GeoRect _toDart() {
    return GeoRect(
      southWestPoint: this.southWestPoint._toDart(),
      northEastPoint: this.northEastPoint._toDart()
    );
  }
}

extension _DartTo_CGeoRect on GeoRect {
  _CGeoRect _copyFromDartTo_CGeoRect() {
    final res = _CGeoRectMakeDefault();
    res.southWestPoint = this.southWestPoint._copyFromDartTo_CGeoPoint();
    res.northEastPoint = this.northEastPoint._copyFromDartTo_CGeoPoint();
    return res;
  }
}
extension _CGeoRectRelease on _CGeoRect {
  void _releaseIntermediate() {
  }
}

// MARK: - calculateBearing

/**
 Вычисляет направление (путевой угол, т.е. угол между направлением на географический север и направлением движения,
 отсчитываемый по часовой стрелке) между двумя точками
 (решает первую часть обратной геодезической задачи https://en.wikipedia.org/wiki/Geodesy#Geodetic_problems).

 - Parameter from: ссылка на исходную точку.
 - Parameter to: ссылка на конечную точку.
 - Returns: направление в диапазоне [0, 360) градусов.
*/
@internal
Bearing calculateBearing(
  GeoPoint from,
  GeoPoint to
){
  var _a0 = from._copyFromDartTo_CGeoPoint();
  var _a1 = to._copyFromDartTo_CGeoPoint();
  _CBearing res = _CFunction_G_calculateBearing_With_CGeoPoint_CGeoPoint(_a0, _a1);
  return res._toDart();
}

// MARK: - calculateDistance

/**
 Вычисляет минимальное (по ортодромии) расстояние между двумя точками
 (решает вторую часть обратной геодезической задачи https://en.wikipedia.org/wiki/Geodesy#Geodetic_problems).

 - Parameter from: ссылка на исходную точку.
 - Parameter to: ссылка на конечную точку.
 - Returns: расстояние в метрах.
*/
@internal
double calculateDistance(
  GeoPoint from,
  GeoPoint to
){
  var _a0 = from._copyFromDartTo_CGeoPoint();
  var _a1 = to._copyFromDartTo_CGeoPoint();
  double res = _CFunction_G_calculateDistance_With_CGeoPoint_CGeoPoint(_a0, _a1);
  return res;
}

// MARK: - move

/**
 Вычисляет точку, полученную перемещением исходной точки в указанном направлении на указанное расстояние
 (решает прямую геодезическую задачу https://en.wikipedia.org/wiki/Geodesy#Geodetic_problems).

 - Parameter point: ссылка на исходную точку.
 - Parameter bearing: направление перемещения в градусах.
 - Parameter distance: расстояние перемещения в метрах.
*/
@internal
GeoPoint move(
  GeoPoint point,
  Bearing bearing,
  double distance
){
  var _a0 = point._copyFromDartTo_CGeoPoint();
  var _a1 = bearing._copyFromDartTo_CBearing();
  _CGeoPoint res = _CFunction_G_move_With_CGeoPoint_CBearing_double(_a0, _a1, distance);
  return res._toDart();
}

// MARK: - isGeoPointValid

bool isGeoPointValid(
  GeoPoint geoPoint
){
  var _a0 = geoPoint._copyFromDartTo_CGeoPoint();
  bool res = _CFunction_G_isGeoPointValid_With_CGeoPoint(_a0);
  return res;
}

// MARK: - isGeoRectValid

bool isGeoRectValid(
  GeoRect geoRect
){
  var _a0 = geoRect._copyFromDartTo_CGeoRect();
  bool res = _CFunction_G_isGeoRectValid_With_CGeoRect(_a0);
  return res;
}

// MARK: - containsPoint

bool containsPoint(
  GeoRect rect,
  GeoPoint point
){
  var _a0 = rect._copyFromDartTo_CGeoRect();
  var _a1 = point._copyFromDartTo_CGeoPoint();
  bool res = _CFunction_G_containsPoint_With_CGeoRect_CGeoPoint(_a0, _a1);
  return res;
}

// MARK: - containsRect

bool containsRect(
  GeoRect rect1,
  GeoRect rect2
){
  var _a0 = rect1._copyFromDartTo_CGeoRect();
  var _a1 = rect2._copyFromDartTo_CGeoRect();
  bool res = _CFunction_G_containsRect_With_CGeoRect_CGeoRect(_a0, _a1);
  return res;
}

// MARK: - expandPoint

GeoRect expandPoint(
  GeoRect rect,
  GeoPoint point
){
  var _a0 = rect._copyFromDartTo_CGeoRect();
  var _a1 = point._copyFromDartTo_CGeoPoint();
  _CGeoRect res = _CFunction_G_expandPoint_With_CGeoRect_CGeoPoint(_a0, _a1);
  return res._toDart();
}

// MARK: - expandRect

GeoRect expandRect(
  GeoRect rect1,
  GeoRect rect2
){
  var _a0 = rect1._copyFromDartTo_CGeoRect();
  var _a1 = rect2._copyFromDartTo_CGeoRect();
  _CGeoRect res = _CFunction_G_expandRect_With_CGeoRect_CGeoRect(_a0, _a1);
  return res._toDart();
}

// MARK: - GeoRect

extension GeoRectIsDegenerate on GeoRect {
  /**
   Проверяет прямоугольник на вырожденность.
   Если точки в прямоугольнике равны, то он вырождается в точку.
   Вырожденный прямоугольник является корректным прямоугольником. Некорректный прямоугольник не является вырожденным.
  */
  bool get isDegenerate {
    var _a0 = this._copyFromDartTo_CGeoRect();
    bool res = _CFunction_G_isDegenerate_With_CGeoRect(_a0);
    return res;
  }
}
// MARK: - GeoRect

extension GeoRectIntersects on GeoRect {
  /**
   Пересекаются ли прямоугольники, т.е. имеют общие точки.
   Прямогольники, с общими точками лишь на границе, так же считаются пересекающимися.
  */
  bool intersects(
    GeoRect rect2
  )  {
    var _a0 = this._copyFromDartTo_CGeoRect();
    var _a1 = rect2._copyFromDartTo_CGeoRect();
    bool res = _CFunction_G_intersects_With_CGeoRect_CGeoRect(_a0, _a1);
    return res;
  }

}
// MARK: - ApartmentRange

/** Диапазон квартир. */
class ApartmentRange {
  /**
   Начало диапазона/хранимое значение.
   На текущий момент возможны только числовые значения, а квартиры с суффиксами в данных пока отсутствуют.
  */
  final String start;
  /**
   Окончание диапазона. Если отсутствует, то диапазон состоит из одного значения start. Иначе это арифметическая
   прогрессия от start до end с шагом 1.
  */
  final String? end;

  const ApartmentRange({
    required this.start,
    this.end = null
  });

  ApartmentRange copyWith({
    String? start,
    Optional<String?>? end
  }) {
    return ApartmentRange(
      start: start ?? this.start,
      end: end != null ? end.value : this.end
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ApartmentRange &&
    other.runtimeType == runtimeType &&
    other.start == start &&
    other.end == end;

  @override
  int get hashCode {
    return Object.hash(start, end);
  }

}
final class _CApartmentRange extends ffi.Struct {
  external _CString start;

  external _COptional_CString end;

}
// MARK: - ApartmentRange <-> _CApartmentRange

extension _CApartmentRangeToDart on _CApartmentRange {
  ApartmentRange _toDart() {
    return ApartmentRange(
      start: this.start._toDart(),
      end: this.end._toDart()
    );
  }
}

extension _DartTo_CApartmentRange on ApartmentRange {
  _CApartmentRange _copyFromDartTo_CApartmentRange() {
    final res = _CApartmentRangeMakeDefault();
    res.start = this.start._copyFromDartTo_CString();
    res.end = this.end._copyFromDartTo_COptional_CString();
    return res;
  }
}
extension _CApartmentRangeRelease on _CApartmentRange {
  void _releaseIntermediate() {
    start._releaseIntermediate();
    end._releaseIntermediate();
  }
}

// MARK: - Attribute

/**
 Дополнительный атрибут.
 Пример:
 {
 tag: "hotel_room_internet",
 name: "Бесплатный интернет в номерах"
 }
*/
class Attribute {
  /** Тег. */
  final String tag;
  /** Значение. */
  final String value;

  const Attribute({
    required this.tag,
    required this.value
  });

  Attribute copyWith({
    String? tag,
    String? value
  }) {
    return Attribute(
      tag: tag ?? this.tag,
      value: value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Attribute &&
    other.runtimeType == runtimeType &&
    other.tag == tag &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(tag, value);
  }

}
final class _CAttribute extends ffi.Struct {
  external _CString tag;

  external _CString value;

}
// MARK: - Attribute <-> _CAttribute

extension _CAttributeToDart on _CAttribute {
  Attribute _toDart() {
    return Attribute(
      tag: this.tag._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CAttribute on Attribute {
  _CAttribute _copyFromDartTo_CAttribute() {
    final res = _CAttributeMakeDefault();
    res.tag = this.tag._copyFromDartTo_CString();
    res.value = this.value._copyFromDartTo_CString();
    return res;
  }
}
extension _CAttributeRelease on _CAttribute {
  void _releaseIntermediate() {
    tag._releaseIntermediate();
    value._releaseIntermediate();
  }
}

// MARK: - PurposeCode

/** Код назначения здания. */
class PurposeCode {
  final int value;

  const PurposeCode([this.value = 0]);

  PurposeCode copyWith({
    int? value
  }) {
    return PurposeCode(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PurposeCode &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CPurposeCode extends ffi.Struct {
  @ffi.Uint64()
  external int value;

}
// MARK: - PurposeCode <-> _CPurposeCode

extension _CPurposeCodeToDart on _CPurposeCode {
  PurposeCode _toDart() {
    return PurposeCode(
      this.value
    );
  }
}

extension _DartTo_CPurposeCode on PurposeCode {
  _CPurposeCode _copyFromDartTo_CPurposeCode() {
    final res = _CPurposeCodeMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CPurposeCodeRelease on _CPurposeCode {
  void _releaseIntermediate() {
  }
}

// MARK: - List<LevelInfo> <-> _CArray_CLevelInfo

final class _CArray_CLevelInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CLevelInfoToDart on _CArray_CLevelInfo {
  List<LevelInfo> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CLevelInfo on List<LevelInfo> {
  _CArray_CLevelInfo _copyFromDartTo_CArray_CLevelInfo() {
    final cArray = _CArray_CLevelInfomakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CLevelInfo();
        _CArray_CLevelInfoaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CLevelInfoBasicFunctions on _CArray_CLevelInfo {
  void _releaseIntermediate() {
    _CArray_CLevelInfo_release(this);
  }

  static final _listToFill = <LevelInfo>[];

  static void _iterate(_CLevelInfo item) {
    _listToFill.add(item._toDart());
  }

  List<LevelInfo> _fillFromC() {
    _forEach_CArray_CLevelInfo(this, ffi.Pointer.fromFunction<ffi.Void Function(_CLevelInfo)>(_iterate));
    final result = List<LevelInfo>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - BuildingLevels

/** Информация об этажных планах здания. */
class BuildingLevels {
  /** Идентификатор этажного плана по умолчанию. */
  final LevelId defaultLevelId;
  /** Все этажные планы здания. */
  final List<LevelInfo> levels;

  const BuildingLevels({
    required this.defaultLevelId,
    required this.levels
  });

  BuildingLevels copyWith({
    LevelId? defaultLevelId,
    List<LevelInfo>? levels
  }) {
    return BuildingLevels(
      defaultLevelId: defaultLevelId ?? this.defaultLevelId,
      levels: levels ?? this.levels
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BuildingLevels &&
    other.runtimeType == runtimeType &&
    other.defaultLevelId == defaultLevelId &&
    other.levels == levels;

  @override
  int get hashCode {
    return Object.hash(defaultLevelId, levels);
  }

}
final class _CBuildingLevels extends ffi.Struct {
  external _CLevelId defaultLevelId;

  external _CArray_CLevelInfo levels;

}
// MARK: - BuildingLevels <-> _CBuildingLevels

extension _CBuildingLevelsToDart on _CBuildingLevels {
  BuildingLevels _toDart() {
    return BuildingLevels(
      defaultLevelId: this.defaultLevelId._toDart(),
      levels: this.levels._toDart()
    );
  }
}

extension _DartTo_CBuildingLevels on BuildingLevels {
  _CBuildingLevels _copyFromDartTo_CBuildingLevels() {
    final res = _CBuildingLevelsMakeDefault();
    res.defaultLevelId = this.defaultLevelId._copyFromDartTo_CLevelId();
    res.levels = this.levels._copyFromDartTo_CArray_CLevelInfo();
    return res;
  }
}
extension _CBuildingLevelsRelease on _CBuildingLevels {
  void _releaseIntermediate() {
    levels._releaseIntermediate();
  }
}

// MARK: - PurposeCode? <-> _COptional_CPurposeCode

final class _COptional_CPurposeCode extends ffi.Struct {
  
  external _CPurposeCode value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CPurposeCodeBasicFunctions on _COptional_CPurposeCode {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CPurposeCodeToDart on _COptional_CPurposeCode {
  PurposeCode? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CPurposeCode on PurposeCode? {
  _COptional_CPurposeCode _copyFromDartTo_COptional_CPurposeCode() {
    final cOptional = _COptional_CPurposeCodeMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CPurposeCode();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - BuildingLevels? <-> _COptional_CBuildingLevels

final class _COptional_CBuildingLevels extends ffi.Struct {
  
  external _CBuildingLevels value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CBuildingLevelsBasicFunctions on _COptional_CBuildingLevels {
  void _releaseIntermediate() {
    _COptional_CBuildingLevels_release(this);
  }
}

extension _COptional_CBuildingLevelsToDart on _COptional_CBuildingLevels {
  BuildingLevels? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CBuildingLevels on BuildingLevels? {
  _COptional_CBuildingLevels _copyFromDartTo_COptional_CBuildingLevels() {
    final cOptional = _COptional_CBuildingLevelsMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CBuildingLevels();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - BuildingId? <-> _COptional_CBuildingId

final class _COptional_CBuildingId extends ffi.Struct {
  
  external _CBuildingId value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CBuildingIdBasicFunctions on _COptional_CBuildingId {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CBuildingIdToDart on _COptional_CBuildingId {
  BuildingId? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CBuildingId on BuildingId? {
  _COptional_CBuildingId _copyFromDartTo_COptional_CBuildingId() {
    final cOptional = _COptional_CBuildingIdMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CBuildingId();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - BuildingInfo

/** Информация о здании. */
class BuildingInfo {
  /** Собственное имя здания. */
  final String? buildingName;
  /** Описание назначения здания. */
  final String? purposeName;
  /** Код назначения здания. */
  final PurposeCode? purposeCode;
  /** Информация об этажных планах здания. */
  final BuildingLevels? buildingLevels;
  /** Уникальный идентификатор здания. */
  final BuildingId? buildingId;

  const BuildingInfo({
    this.buildingName = null,
    this.purposeName = null,
    this.purposeCode = null,
    this.buildingLevels = null,
    required this.buildingId
  });

  BuildingInfo copyWith({
    Optional<String?>? buildingName,
    Optional<String?>? purposeName,
    Optional<PurposeCode?>? purposeCode,
    Optional<BuildingLevels?>? buildingLevels,
    Optional<BuildingId?>? buildingId
  }) {
    return BuildingInfo(
      buildingName: buildingName != null ? buildingName.value : this.buildingName,
      purposeName: purposeName != null ? purposeName.value : this.purposeName,
      purposeCode: purposeCode != null ? purposeCode.value : this.purposeCode,
      buildingLevels: buildingLevels != null ? buildingLevels.value : this.buildingLevels,
      buildingId: buildingId != null ? buildingId.value : this.buildingId
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BuildingInfo &&
    other.runtimeType == runtimeType &&
    other.buildingName == buildingName &&
    other.purposeName == purposeName &&
    other.purposeCode == purposeCode &&
    other.buildingLevels == buildingLevels &&
    other.buildingId == buildingId;

  @override
  int get hashCode {
    return Object.hash(buildingName, purposeName, purposeCode, buildingLevels, buildingId);
  }

}
final class _CBuildingInfo extends ffi.Struct {
  external _COptional_CString buildingName;

  external _COptional_CString purposeName;

  external _COptional_CPurposeCode purposeCode;

  external _COptional_CBuildingLevels buildingLevels;

  external _COptional_CBuildingId buildingId;

}
// MARK: - BuildingInfo <-> _CBuildingInfo

extension _CBuildingInfoToDart on _CBuildingInfo {
  BuildingInfo _toDart() {
    return BuildingInfo(
      buildingName: this.buildingName._toDart(),
      purposeName: this.purposeName._toDart(),
      purposeCode: this.purposeCode._toDart(),
      buildingLevels: this.buildingLevels._toDart(),
      buildingId: this.buildingId._toDart()
    );
  }
}

extension _DartTo_CBuildingInfo on BuildingInfo {
  _CBuildingInfo _copyFromDartTo_CBuildingInfo() {
    final res = _CBuildingInfoMakeDefault();
    res.buildingName = this.buildingName._copyFromDartTo_COptional_CString();
    res.purposeName = this.purposeName._copyFromDartTo_COptional_CString();
    res.purposeCode = this.purposeCode._copyFromDartTo_COptional_CPurposeCode();
    res.buildingLevels = this.buildingLevels._copyFromDartTo_COptional_CBuildingLevels();
    res.buildingId = this.buildingId._copyFromDartTo_COptional_CBuildingId();
    return res;
  }
}
extension _CBuildingInfoRelease on _CBuildingInfo {
  void _releaseIntermediate() {
    buildingName._releaseIntermediate();
    purposeName._releaseIntermediate();
    buildingLevels._releaseIntermediate();
  }
}

// MARK: - ContactInfo

/** Способ связаться с организацией. */
class ContactInfo {
  /**
   Тип контакта. Один из следующих:
   * email — электронная почта
   * website — сайт
   * phone — телефон
   * fax — факс
   * pobox — абонентский ящик
   * icq
   * jabber
   * skype
   * vkontakte
   * twitter
   * odnoklassniki
   * youtube
   * linkedin
   * googleplus
   * pinterest
   * whatsapp
   * viber
   * telegram
  */
  final String type;
  /** Значение контакта для вывода на экран. */
  final String displayText;
  /**
   Техническое значение контакта. В зависимости от типа контакта имеет следующую семантику:
   * email — адрес почты
   * website — полный url
   * phone — номер телефона в международном формате, например: "+73831234567"
   * fax — номер телефона в международном формате, например: "+73831234567"
   * pobox — адрес почтового ящика
   * icq — идентификатор пользователя
   * jabber — идентификатор пользователя
   * skype — идентификатор пользователя
   * vkontakte — полный url
   * twitter — полный url
   * odnoklassniki — полный url
   * youtube — полный url
   * linkedin — полный url
   * googleplus — полный url
   * pinterest — полный url
   * whatsapp — полный url
   * viber — полный url
   * telegram — полный url
  */
  final String value;
  /** Уточняющая информация о контакте. */
  final String? comment;

  const ContactInfo({
    required this.type,
    required this.displayText,
    required this.value,
    required this.comment
  });

  ContactInfo copyWith({
    String? type,
    String? displayText,
    String? value,
    Optional<String?>? comment
  }) {
    return ContactInfo(
      type: type ?? this.type,
      displayText: displayText ?? this.displayText,
      value: value ?? this.value,
      comment: comment != null ? comment.value : this.comment
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ContactInfo &&
    other.runtimeType == runtimeType &&
    other.type == type &&
    other.displayText == displayText &&
    other.value == value &&
    other.comment == comment;

  @override
  int get hashCode {
    return Object.hash(type, displayText, value, comment);
  }

}
final class _CContactInfo extends ffi.Struct {
  external _CString type;

  external _CString displayText;

  external _CString value;

  external _COptional_CString comment;

}
// MARK: - ContactInfo <-> _CContactInfo

extension _CContactInfoToDart on _CContactInfo {
  ContactInfo _toDart() {
    return ContactInfo(
      type: this.type._toDart(),
      displayText: this.displayText._toDart(),
      value: this.value._toDart(),
      comment: this.comment._toDart()
    );
  }
}

extension _DartTo_CContactInfo on ContactInfo {
  _CContactInfo _copyFromDartTo_CContactInfo() {
    final res = _CContactInfoMakeDefault();
    res.type = this.type._copyFromDartTo_CString();
    res.displayText = this.displayText._copyFromDartTo_CString();
    res.value = this.value._copyFromDartTo_CString();
    res.comment = this.comment._copyFromDartTo_COptional_CString();
    return res;
  }
}
extension _CContactInfoRelease on _CContactInfo {
  void _releaseIntermediate() {
    type._releaseIntermediate();
    displayText._releaseIntermediate();
    value._releaseIntermediate();
    comment._releaseIntermediate();
  }
}

// MARK: - IsOpenNow

/** Открыто сейчас. */
class IsOpenNow {

  const IsOpenNow();

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is IsOpenNow &&
    other.runtimeType == runtimeType;

  @override
  int get hashCode {
    return 0;
  }

}
final class _CIsOpenNow extends ffi.Struct {
  @ffi.Int8()
  external int _dummy;
}
// MARK: - IsOpenNow <-> _CIsOpenNow

extension _CIsOpenNowToDart on _CIsOpenNow {
  IsOpenNow _toDart() {
    return IsOpenNow(
    );
  }
}

extension _DartTo_CIsOpenNow on IsOpenNow {
  _CIsOpenNow _copyFromDartTo_CIsOpenNow() {
    final res = _CIsOpenNowMakeDefault();
    return res;
  }
}
extension _CIsOpenNowRelease on _CIsOpenNow {
  void _releaseIntermediate() {
  }
}

// MARK: - WorkTimeFilter

/**
 Фильтр по времени работы объекта.
 Либо открыт сейчас, либо открыт на конкретные дата и время.
*/
final class WorkTimeFilter {
  final Object? _value;
  final int _index;

  WorkTimeFilter._raw(this._value, this._index);

  WorkTimeFilter.workTime(WeekTime value) : this._raw(value, 0);
  WorkTimeFilter.isOpenNow(IsOpenNow value) : this._raw(value, 1);

  bool get isWorkTime => this._index == 0;
  WeekTime? get asWorkTime => this.isWorkTime ? this._value as WeekTime : null;

  bool get isIsOpenNow => this._index == 1;
  IsOpenNow? get asIsOpenNow => this.isIsOpenNow ? this._value as IsOpenNow : null;

  T match<T>({
    required T Function(WeekTime value) workTime,
    required T Function(IsOpenNow value) isOpenNow,
  }) {
    return switch (this._index) {
      0 => workTime(this._value as WeekTime),
      1 => isOpenNow(this._value as IsOpenNow),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "WorkTimeFilter(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is WorkTimeFilter &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CWorkTimeFilterImpl extends ffi.Union {
  external _CWeekTime _workTime;
  external _CIsOpenNow _isOpenNow;
}

final class _CWorkTimeFilter extends ffi.Struct {
  external _CWorkTimeFilterImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CWorkTimeFilterBasicFunctions on _CWorkTimeFilter {
  void _releaseIntermediate() {
    _CWorkTimeFilter_release(this);
  }
}
	
// MARK: - WorkTimeFilter <-> CWorkTimeFilter

extension _CWorkTimeFilterToDart on _CWorkTimeFilter {
  WorkTimeFilter _toDart() {
    return switch (this._index) {
      0 => WorkTimeFilter.workTime(this._impl._workTime._toDart()),
      1 => WorkTimeFilter.isOpenNow(this._impl._isOpenNow._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CWorkTimeFilter on WorkTimeFilter {
  _CWorkTimeFilter _copyFromDartTo_CWorkTimeFilter() {
    var res = _CWorkTimeFilterMakeDefault();
    this.match<void>(
      workTime: (WeekTime value) {
        res._impl._workTime = value._copyFromDartTo_CWeekTime();
        res._index = 0;
      },
      isOpenNow: (IsOpenNow value) {
        res._impl._isOpenNow = value._copyFromDartTo_CIsOpenNow();
        res._index = 1;
      },
    );
    return res;
  }
}

// MARK: - bool? <-> _COptional_bool

final class _COptional_bool extends ffi.Struct {
  @ffi.Bool()
  external bool value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_boolBasicFunctions on _COptional_bool {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_boolToDart on _COptional_bool {
  bool? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value;
  }
}

extension _DartTo_COptional_bool on bool? {
  _COptional_bool _copyFromDartTo_COptional_bool() {
    final cOptional = _COptional_boolMakeDefault();
    if (this != null) {
      cOptional.value = this!;
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - FlagFilter

/** Фильтр - флаг. */
class FlagFilter {
  /** Тэг фильтра. */
  final String tagName;
  /**
   Название фильтра для отображения.
  
   - Note: Зависит от языка выдачи. Не все названия могут быть переведены.
  */
  final String displayName;
  /** Значение флага. */
  final bool? flagValue;

  const FlagFilter({
    required this.tagName,
    required this.displayName,
    required this.flagValue
  });

  FlagFilter copyWith({
    String? tagName,
    String? displayName,
    Optional<bool?>? flagValue
  }) {
    return FlagFilter(
      tagName: tagName ?? this.tagName,
      displayName: displayName ?? this.displayName,
      flagValue: flagValue != null ? flagValue.value : this.flagValue
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is FlagFilter &&
    other.runtimeType == runtimeType &&
    other.tagName == tagName &&
    other.displayName == displayName &&
    other.flagValue == flagValue;

  @override
  int get hashCode {
    return Object.hash(tagName, displayName, flagValue);
  }

}
final class _CFlagFilter extends ffi.Struct {
  external _CString tagName;

  external _CString displayName;

  external _COptional_bool flagValue;

}
// MARK: - FlagFilter <-> _CFlagFilter

extension _CFlagFilterToDart on _CFlagFilter {
  FlagFilter _toDart() {
    return FlagFilter(
      tagName: this.tagName._toDart(),
      displayName: this.displayName._toDart(),
      flagValue: this.flagValue._toDart()
    );
  }
}

extension _DartTo_CFlagFilter on FlagFilter {
  _CFlagFilter _copyFromDartTo_CFlagFilter() {
    final res = _CFlagFilterMakeDefault();
    res.tagName = this.tagName._copyFromDartTo_CString();
    res.displayName = this.displayName._copyFromDartTo_CString();
    res.flagValue = this.flagValue._copyFromDartTo_COptional_bool();
    return res;
  }
}
extension _CFlagFilterRelease on _CFlagFilter {
  void _releaseIntermediate() {
    tagName._releaseIntermediate();
    displayName._releaseIntermediate();
  }
}

// MARK: - RangeFilter

/** Фильтр диапазонов значений. */
class RangeFilter {
  /** Тэг фильтра. */
  final String tagName;
  /**
   Название фильтра для отображения.
  
   - Note: Зависит от языка выдачи. Не все названия могут быть переведены.
  */
  final String displayName;
  /** Минимальное значение диапазона. */
  final double minValue;
  /** Максимальное значение диапазона. */
  final double maxValue;

  const RangeFilter({
    required this.tagName,
    required this.displayName,
    required this.minValue,
    required this.maxValue
  });

  RangeFilter copyWith({
    String? tagName,
    String? displayName,
    double? minValue,
    double? maxValue
  }) {
    return RangeFilter(
      tagName: tagName ?? this.tagName,
      displayName: displayName ?? this.displayName,
      minValue: minValue ?? this.minValue,
      maxValue: maxValue ?? this.maxValue
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RangeFilter &&
    other.runtimeType == runtimeType &&
    other.tagName == tagName &&
    other.displayName == displayName &&
    other.minValue == minValue &&
    other.maxValue == maxValue;

  @override
  int get hashCode {
    return Object.hash(tagName, displayName, minValue, maxValue);
  }

}
final class _CRangeFilter extends ffi.Struct {
  external _CString tagName;

  external _CString displayName;

  @ffi.Double()
  external double minValue;

  @ffi.Double()
  external double maxValue;

}
// MARK: - RangeFilter <-> _CRangeFilter

extension _CRangeFilterToDart on _CRangeFilter {
  RangeFilter _toDart() {
    return RangeFilter(
      tagName: this.tagName._toDart(),
      displayName: this.displayName._toDart(),
      minValue: this.minValue,
      maxValue: this.maxValue
    );
  }
}

extension _DartTo_CRangeFilter on RangeFilter {
  _CRangeFilter _copyFromDartTo_CRangeFilter() {
    final res = _CRangeFilterMakeDefault();
    res.tagName = this.tagName._copyFromDartTo_CString();
    res.displayName = this.displayName._copyFromDartTo_CString();
    res.minValue = this.minValue;
    res.maxValue = this.maxValue;
    return res;
  }
}
extension _CRangeFilterRelease on _CRangeFilter {
  void _releaseIntermediate() {
    tagName._releaseIntermediate();
    displayName._releaseIntermediate();
  }
}

// MARK: - SortingFilter

/** Фильтр сортировки. */
class SortingFilter {
  /** Тэг фильтра. */
  final String tagName;
  /**
   Название фильтра для отображения.
  
   - Note: Зависит от языка выдачи. Не все названия могут быть переведены.
  */
  final String displayName;

  const SortingFilter({
    required this.tagName,
    required this.displayName
  });

  SortingFilter copyWith({
    String? tagName,
    String? displayName
  }) {
    return SortingFilter(
      tagName: tagName ?? this.tagName,
      displayName: displayName ?? this.displayName
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SortingFilter &&
    other.runtimeType == runtimeType &&
    other.tagName == tagName &&
    other.displayName == displayName;

  @override
  int get hashCode {
    return Object.hash(tagName, displayName);
  }

}
final class _CSortingFilter extends ffi.Struct {
  external _CString tagName;

  external _CString displayName;

}
// MARK: - SortingFilter <-> _CSortingFilter

extension _CSortingFilterToDart on _CSortingFilter {
  SortingFilter _toDart() {
    return SortingFilter(
      tagName: this.tagName._toDart(),
      displayName: this.displayName._toDart()
    );
  }
}

extension _DartTo_CSortingFilter on SortingFilter {
  _CSortingFilter _copyFromDartTo_CSortingFilter() {
    final res = _CSortingFilterMakeDefault();
    res.tagName = this.tagName._copyFromDartTo_CString();
    res.displayName = this.displayName._copyFromDartTo_CString();
    return res;
  }
}
extension _CSortingFilterRelease on _CSortingFilter {
  void _releaseIntermediate() {
    tagName._releaseIntermediate();
    displayName._releaseIntermediate();
  }
}

// MARK: - DynamicFilter

/** Динамические фильтры поисковой выдачи. */
final class DynamicFilter {
  final Object? _value;
  final int _index;

  DynamicFilter._raw(this._value, this._index);

  DynamicFilter.flagFilter(FlagFilter value) : this._raw(value, 0);
  DynamicFilter.rangeFilter(RangeFilter value) : this._raw(value, 1);
  DynamicFilter.sortingFilter(SortingFilter value) : this._raw(value, 2);

  bool get isFlagFilter => this._index == 0;
  FlagFilter? get asFlagFilter => this.isFlagFilter ? this._value as FlagFilter : null;

  bool get isRangeFilter => this._index == 1;
  RangeFilter? get asRangeFilter => this.isRangeFilter ? this._value as RangeFilter : null;

  bool get isSortingFilter => this._index == 2;
  SortingFilter? get asSortingFilter => this.isSortingFilter ? this._value as SortingFilter : null;

  T match<T>({
    required T Function(FlagFilter value) flagFilter,
    required T Function(RangeFilter value) rangeFilter,
    required T Function(SortingFilter value) sortingFilter,
  }) {
    return switch (this._index) {
      0 => flagFilter(this._value as FlagFilter),
      1 => rangeFilter(this._value as RangeFilter),
      2 => sortingFilter(this._value as SortingFilter),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "DynamicFilter(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DynamicFilter &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CDynamicFilterImpl extends ffi.Union {
  external _CFlagFilter _flagFilter;
  external _CRangeFilter _rangeFilter;
  external _CSortingFilter _sortingFilter;
}

final class _CDynamicFilter extends ffi.Struct {
  external _CDynamicFilterImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CDynamicFilterBasicFunctions on _CDynamicFilter {
  void _releaseIntermediate() {
    _CDynamicFilter_release(this);
  }
}
	
// MARK: - DynamicFilter <-> CDynamicFilter

extension _CDynamicFilterToDart on _CDynamicFilter {
  DynamicFilter _toDart() {
    return switch (this._index) {
      0 => DynamicFilter.flagFilter(this._impl._flagFilter._toDart()),
      1 => DynamicFilter.rangeFilter(this._impl._rangeFilter._toDart()),
      2 => DynamicFilter.sortingFilter(this._impl._sortingFilter._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CDynamicFilter on DynamicFilter {
  _CDynamicFilter _copyFromDartTo_CDynamicFilter() {
    var res = _CDynamicFilterMakeDefault();
    this.match<void>(
      flagFilter: (FlagFilter value) {
        res._impl._flagFilter = value._copyFromDartTo_CFlagFilter();
        res._index = 0;
      },
      rangeFilter: (RangeFilter value) {
        res._impl._rangeFilter = value._copyFromDartTo_CRangeFilter();
        res._index = 1;
      },
      sortingFilter: (SortingFilter value) {
        res._impl._sortingFilter = value._copyFromDartTo_CSortingFilter();
        res._index = 2;
      },
    );
    return res;
  }
}

// MARK: - WorkTimeFilter? <-> _COptional_CWorkTimeFilter

final class _COptional_CWorkTimeFilter extends ffi.Struct {
  
  external _CWorkTimeFilter value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CWorkTimeFilterBasicFunctions on _COptional_CWorkTimeFilter {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CWorkTimeFilterToDart on _COptional_CWorkTimeFilter {
  WorkTimeFilter? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CWorkTimeFilter on WorkTimeFilter? {
  _COptional_CWorkTimeFilter _copyFromDartTo_COptional_CWorkTimeFilter() {
    final cOptional = _COptional_CWorkTimeFilterMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CWorkTimeFilter();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<DynamicFilter> <-> _CArray_CDynamicFilter

final class _CArray_CDynamicFilter extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CDynamicFilterToDart on _CArray_CDynamicFilter {
  List<DynamicFilter> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CDynamicFilter on List<DynamicFilter> {
  _CArray_CDynamicFilter _copyFromDartTo_CArray_CDynamicFilter() {
    final cArray = _CArray_CDynamicFiltermakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CDynamicFilter();
        _CArray_CDynamicFilteraddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CDynamicFilterBasicFunctions on _CArray_CDynamicFilter {
  void _releaseIntermediate() {
    _CArray_CDynamicFilter_release(this);
  }

  static final _listToFill = <DynamicFilter>[];

  static void _iterate(_CDynamicFilter item) {
    _listToFill.add(item._toDart());
  }

  List<DynamicFilter> _fillFromC() {
    _forEach_CArray_CDynamicFilter(this, ffi.Pointer.fromFunction<ffi.Void Function(_CDynamicFilter)>(_iterate));
    final result = List<DynamicFilter>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - DirectoryFilter

/** Фильтры для справочника. */
class DirectoryFilter {
  /** Фильтр по времени работы. */
  final WorkTimeFilter? workTime;
  /** Динамические фильтры. */
  final List<DynamicFilter> dynamic_;

  const DirectoryFilter({
    required this.workTime,
    required this.dynamic_
  });

  DirectoryFilter copyWith({
    Optional<WorkTimeFilter?>? workTime,
    List<DynamicFilter>? dynamic_
  }) {
    return DirectoryFilter(
      workTime: workTime != null ? workTime.value : this.workTime,
      dynamic_: dynamic_ ?? this.dynamic_
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DirectoryFilter &&
    other.runtimeType == runtimeType &&
    other.workTime == workTime &&
    other.dynamic_ == dynamic_;

  @override
  int get hashCode {
    return Object.hash(workTime, dynamic_);
  }

}
final class _CDirectoryFilter extends ffi.Struct {
  external _COptional_CWorkTimeFilter workTime;

  external _CArray_CDynamicFilter dynamic_;

}
// MARK: - DirectoryFilter <-> _CDirectoryFilter

extension _CDirectoryFilterToDart on _CDirectoryFilter {
  DirectoryFilter _toDart() {
    return DirectoryFilter(
      workTime: this.workTime._toDart(),
      dynamic_: this.dynamic_._toDart()
    );
  }
}

extension _DartTo_CDirectoryFilter on DirectoryFilter {
  _CDirectoryFilter _copyFromDartTo_CDirectoryFilter() {
    final res = _CDirectoryFilterMakeDefault();
    res.workTime = this.workTime._copyFromDartTo_COptional_CWorkTimeFilter();
    res.dynamic_ = this.dynamic_._copyFromDartTo_CArray_CDynamicFilter();
    return res;
  }
}
extension _CDirectoryFilterRelease on _CDirectoryFilter {
  void _releaseIntermediate() {
    dynamic_._releaseIntermediate();
  }
}

// MARK: - List<GeoPoint> <-> _CArray_CGeoPoint

final class _CArray_CGeoPoint extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CGeoPointToDart on _CArray_CGeoPoint {
  List<GeoPoint> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CGeoPoint on List<GeoPoint> {
  _CArray_CGeoPoint _copyFromDartTo_CArray_CGeoPoint() {
    final cArray = _CArray_CGeoPointmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CGeoPoint();
        _CArray_CGeoPointaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CGeoPointBasicFunctions on _CArray_CGeoPoint {
  void _releaseIntermediate() {
    _CArray_CGeoPoint_release(this);
  }

  static final _listToFill = <GeoPoint>[];

  static void _iterate(_CGeoPoint item) {
    _listToFill.add(item._toDart());
  }

  List<GeoPoint> _fillFromC() {
    _forEach_CArray_CGeoPoint(this, ffi.Pointer.fromFunction<ffi.Void Function(_CGeoPoint)>(_iterate));
    final result = List<GeoPoint>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - List<List<GeoPoint>> <-> _CArray_CArray_CGeoPoint

final class _CArray_CArray_CGeoPoint extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CArray_CGeoPointToDart on _CArray_CArray_CGeoPoint {
  List<List<GeoPoint>> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CArray_CGeoPoint on List<List<GeoPoint>> {
  _CArray_CArray_CGeoPoint _copyFromDartTo_CArray_CArray_CGeoPoint() {
    final cArray = _CArray_CArray_CGeoPointmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CArray_CGeoPoint();
        _CArray_CArray_CGeoPointaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CArray_CGeoPointBasicFunctions on _CArray_CArray_CGeoPoint {
  void _releaseIntermediate() {
    _CArray_CArray_CGeoPoint_release(this);
  }

  static final _listToFill = <List<GeoPoint>>[];

  static void _iterate(_CArray_CGeoPoint item) {
    _listToFill.add(item._toDart());
  }

  List<List<GeoPoint>> _fillFromC() {
    _forEach_CArray_CArray_CGeoPoint(this, ffi.Pointer.fromFunction<ffi.Void Function(_CArray_CGeoPoint)>(_iterate));
    final result = List<List<GeoPoint>>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - EntranceGeometry

/** Геометрии для отображения входа на карте. */
class EntranceGeometry {
  /** Местоположение входа. */
  final List<GeoPoint> entrancePoints;
  /** Геометрии стрелок, указывающих на вход. */
  final List<List<GeoPoint>> entrancePolylines;

  const EntranceGeometry({
    required this.entrancePoints,
    required this.entrancePolylines
  });

  EntranceGeometry copyWith({
    List<GeoPoint>? entrancePoints,
    List<List<GeoPoint>>? entrancePolylines
  }) {
    return EntranceGeometry(
      entrancePoints: entrancePoints ?? this.entrancePoints,
      entrancePolylines: entrancePolylines ?? this.entrancePolylines
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is EntranceGeometry &&
    other.runtimeType == runtimeType &&
    other.entrancePoints == entrancePoints &&
    other.entrancePolylines == entrancePolylines;

  @override
  int get hashCode {
    return Object.hash(entrancePoints, entrancePolylines);
  }

}
final class _CEntranceGeometry extends ffi.Struct {
  external _CArray_CGeoPoint entrancePoints;

  external _CArray_CArray_CGeoPoint entrancePolylines;

}
// MARK: - EntranceGeometry <-> _CEntranceGeometry

extension _CEntranceGeometryToDart on _CEntranceGeometry {
  EntranceGeometry _toDart() {
    return EntranceGeometry(
      entrancePoints: this.entrancePoints._toDart(),
      entrancePolylines: this.entrancePolylines._toDart()
    );
  }
}

extension _DartTo_CEntranceGeometry on EntranceGeometry {
  _CEntranceGeometry _copyFromDartTo_CEntranceGeometry() {
    final res = _CEntranceGeometryMakeDefault();
    res.entrancePoints = this.entrancePoints._copyFromDartTo_CArray_CGeoPoint();
    res.entrancePolylines = this.entrancePolylines._copyFromDartTo_CArray_CArray_CGeoPoint();
    return res;
  }
}
extension _CEntranceGeometryRelease on _CEntranceGeometry {
  void _releaseIntermediate() {
    entrancePoints._releaseIntermediate();
    entrancePolylines._releaseIntermediate();
  }
}

// MARK: - List<ApartmentRange> <-> _CArray_CApartmentRange

final class _CArray_CApartmentRange extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CApartmentRangeToDart on _CArray_CApartmentRange {
  List<ApartmentRange> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CApartmentRange on List<ApartmentRange> {
  _CArray_CApartmentRange _copyFromDartTo_CArray_CApartmentRange() {
    final cArray = _CArray_CApartmentRangemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CApartmentRange();
        _CArray_CApartmentRangeaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CApartmentRangeBasicFunctions on _CArray_CApartmentRange {
  void _releaseIntermediate() {
    _CArray_CApartmentRange_release(this);
  }

  static final _listToFill = <ApartmentRange>[];

  static void _iterate(_CApartmentRange item) {
    _listToFill.add(item._toDart());
  }

  List<ApartmentRange> _fillFromC() {
    _forEach_CArray_CApartmentRange(this, ffi.Pointer.fromFunction<ffi.Void Function(_CApartmentRange)>(_iterate));
    final result = List<ApartmentRange>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - EntranceGeometry? <-> _COptional_CEntranceGeometry

final class _COptional_CEntranceGeometry extends ffi.Struct {
  
  external _CEntranceGeometry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CEntranceGeometryBasicFunctions on _COptional_CEntranceGeometry {
  void _releaseIntermediate() {
    _COptional_CEntranceGeometry_release(this);
  }
}

extension _COptional_CEntranceGeometryToDart on _COptional_CEntranceGeometry {
  EntranceGeometry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CEntranceGeometry on EntranceGeometry? {
  _COptional_CEntranceGeometry _copyFromDartTo_COptional_CEntranceGeometry() {
    final cOptional = _COptional_CEntranceGeometryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CEntranceGeometry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - EntranceInfo

/** Информация о входе в здание. */
class EntranceInfo {
  /** Идентификатор объекта входа. */
  final DgisObjectId id;
  /** Номер дома, к которому относится вход. */
  final String? buildingNumber;
  /**
   Непустое имя подъезда. Заполняется только для подъездов.
   Может принимать значения имени подъезда (например "Подъезд 1") или
   номера здания, если подъезд имеет собственный адрес.
  */
  final String? porchName;
  /**
   Непустой номер подъезда. Заполняется только для подъездов.
   Может принимать значения номера подъезда (например "1") или
   номера здания, если подъезд имеет собственный адрес.
  */
  final String? porchNumber;
  /** Номера квартир, относящихся к подъезду. */
  final List<ApartmentRange> apartmentRanges;
  /** Геометрии для отображения входа на карте. */
  final EntranceGeometry? geometry;

  const EntranceInfo({
    required this.id,
    required this.buildingNumber,
    required this.porchName,
    required this.porchNumber,
    required this.apartmentRanges,
    required this.geometry
  });

  EntranceInfo copyWith({
    DgisObjectId? id,
    Optional<String?>? buildingNumber,
    Optional<String?>? porchName,
    Optional<String?>? porchNumber,
    List<ApartmentRange>? apartmentRanges,
    Optional<EntranceGeometry?>? geometry
  }) {
    return EntranceInfo(
      id: id ?? this.id,
      buildingNumber: buildingNumber != null ? buildingNumber.value : this.buildingNumber,
      porchName: porchName != null ? porchName.value : this.porchName,
      porchNumber: porchNumber != null ? porchNumber.value : this.porchNumber,
      apartmentRanges: apartmentRanges ?? this.apartmentRanges,
      geometry: geometry != null ? geometry.value : this.geometry
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is EntranceInfo &&
    other.runtimeType == runtimeType &&
    other.id == id &&
    other.buildingNumber == buildingNumber &&
    other.porchName == porchName &&
    other.porchNumber == porchNumber &&
    other.apartmentRanges == apartmentRanges &&
    other.geometry == geometry;

  @override
  int get hashCode {
    return Object.hash(id, buildingNumber, porchName, porchNumber, apartmentRanges, geometry);
  }

}
final class _CEntranceInfo extends ffi.Struct {
  external _CDgisObjectId id;

  external _COptional_CString buildingNumber;

  external _COptional_CString porchName;

  external _COptional_CString porchNumber;

  external _CArray_CApartmentRange apartmentRanges;

  external _COptional_CEntranceGeometry geometry;

}
// MARK: - EntranceInfo <-> _CEntranceInfo

extension _CEntranceInfoToDart on _CEntranceInfo {
  EntranceInfo _toDart() {
    return EntranceInfo(
      id: this.id._toDart(),
      buildingNumber: this.buildingNumber._toDart(),
      porchName: this.porchName._toDart(),
      porchNumber: this.porchNumber._toDart(),
      apartmentRanges: this.apartmentRanges._toDart(),
      geometry: this.geometry._toDart()
    );
  }
}

extension _DartTo_CEntranceInfo on EntranceInfo {
  _CEntranceInfo _copyFromDartTo_CEntranceInfo() {
    final res = _CEntranceInfoMakeDefault();
    res.id = this.id._copyFromDartTo_CDgisObjectId();
    res.buildingNumber = this.buildingNumber._copyFromDartTo_COptional_CString();
    res.porchName = this.porchName._copyFromDartTo_COptional_CString();
    res.porchNumber = this.porchNumber._copyFromDartTo_COptional_CString();
    res.apartmentRanges = this.apartmentRanges._copyFromDartTo_CArray_CApartmentRange();
    res.geometry = this.geometry._copyFromDartTo_COptional_CEntranceGeometry();
    return res;
  }
}
extension _CEntranceInfoRelease on _CEntranceInfo {
  void _releaseIntermediate() {
    buildingNumber._releaseIntermediate();
    porchName._releaseIntermediate();
    porchNumber._releaseIntermediate();
    apartmentRanges._releaseIntermediate();
    geometry._releaseIntermediate();
  }
}

// MARK: - FilterType

/** Тип фильтра */
enum FilterType {
  /** Фильтр задаёт порядок сортировки результата поиска. */
  sort(0),
  /** Фильтр указывает на наличие определенного признака у объекта в результатах поиска. */
  filter(1),
  ;

  const FilterType(this.rawValue);
  final int rawValue;

  static FilterType getByValue(int value) {
    return FilterType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CFilterType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CFilterTypeBasicFunctions on _CFilterType {
  void _releaseIntermediate() {
  }
}

extension _CFilterTypeToDart on _CFilterType {
  FilterType _toDart() {
    return FilterType.getByValue(this.rawValue);
  }
}

extension _DartTo_CFilterType on FilterType {
  _CFilterType _copyFromDartTo_CFilterType() {
    return _CFilterTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - FloorInfo

/** Информация об этажном плане для маркера - элемента поисковой выдачи. */
class FloorInfo {
  /** Идентификатор этажного плана. */
  final LevelId levelId;
  /** Идентификатор здания. */
  final BuildingId buildingId;

  const FloorInfo({
    required this.levelId,
    required this.buildingId
  });

  FloorInfo copyWith({
    LevelId? levelId,
    BuildingId? buildingId
  }) {
    return FloorInfo(
      levelId: levelId ?? this.levelId,
      buildingId: buildingId ?? this.buildingId
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is FloorInfo &&
    other.runtimeType == runtimeType &&
    other.levelId == levelId &&
    other.buildingId == buildingId;

  @override
  int get hashCode {
    return Object.hash(levelId, buildingId);
  }

}
final class _CFloorInfo extends ffi.Struct {
  external _CLevelId levelId;

  external _CBuildingId buildingId;

}
// MARK: - FloorInfo <-> _CFloorInfo

extension _CFloorInfoToDart on _CFloorInfo {
  FloorInfo _toDart() {
    return FloorInfo(
      levelId: this.levelId._toDart(),
      buildingId: this.buildingId._toDart()
    );
  }
}

extension _DartTo_CFloorInfo on FloorInfo {
  _CFloorInfo _copyFromDartTo_CFloorInfo() {
    final res = _CFloorInfoMakeDefault();
    res.levelId = this.levelId._copyFromDartTo_CLevelId();
    res.buildingId = this.buildingId._copyFromDartTo_CBuildingId();
    return res;
  }
}
extension _CFloorInfoRelease on _CFloorInfo {
  void _releaseIntermediate() {
  }
}

// MARK: - FormattedAddress

/** Человекочитаемое представление адреса. */
class FormattedAddress {
  /**
   Адрес из дриллдауна.
   Пример: "Новосибирск, Кировский район".
  */
  final String? drilldownAddress;
  /**
   Адрес внутри населённого пункта.
   Пример: "Николаева, 11".
  */
  final String? streetAddress;
  /**
   Комментарий к адресу.
   Пример: "301 офис; 9 этаж".
  */
  final String? addressComment;
  /**
   Почтовый индекс объекта с кодом здания, если есть.
   Пример: "630088", "630007/XBVJF8".
  */
  final String? postCode;

  const FormattedAddress({
    required this.drilldownAddress,
    required this.streetAddress,
    required this.addressComment,
    required this.postCode
  });

  FormattedAddress copyWith({
    Optional<String?>? drilldownAddress,
    Optional<String?>? streetAddress,
    Optional<String?>? addressComment,
    Optional<String?>? postCode
  }) {
    return FormattedAddress(
      drilldownAddress: drilldownAddress != null ? drilldownAddress.value : this.drilldownAddress,
      streetAddress: streetAddress != null ? streetAddress.value : this.streetAddress,
      addressComment: addressComment != null ? addressComment.value : this.addressComment,
      postCode: postCode != null ? postCode.value : this.postCode
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is FormattedAddress &&
    other.runtimeType == runtimeType &&
    other.drilldownAddress == drilldownAddress &&
    other.streetAddress == streetAddress &&
    other.addressComment == addressComment &&
    other.postCode == postCode;

  @override
  int get hashCode {
    return Object.hash(drilldownAddress, streetAddress, addressComment, postCode);
  }

}
final class _CFormattedAddress extends ffi.Struct {
  external _COptional_CString drilldownAddress;

  external _COptional_CString streetAddress;

  external _COptional_CString addressComment;

  external _COptional_CString postCode;

}
// MARK: - FormattedAddress <-> _CFormattedAddress

extension _CFormattedAddressToDart on _CFormattedAddress {
  FormattedAddress _toDart() {
    return FormattedAddress(
      drilldownAddress: this.drilldownAddress._toDart(),
      streetAddress: this.streetAddress._toDart(),
      addressComment: this.addressComment._toDart(),
      postCode: this.postCode._toDart()
    );
  }
}

extension _DartTo_CFormattedAddress on FormattedAddress {
  _CFormattedAddress _copyFromDartTo_CFormattedAddress() {
    final res = _CFormattedAddressMakeDefault();
    res.drilldownAddress = this.drilldownAddress._copyFromDartTo_COptional_CString();
    res.streetAddress = this.streetAddress._copyFromDartTo_COptional_CString();
    res.addressComment = this.addressComment._copyFromDartTo_COptional_CString();
    res.postCode = this.postCode._copyFromDartTo_COptional_CString();
    return res;
  }
}
extension _CFormattedAddressRelease on _CFormattedAddress {
  void _releaseIntermediate() {
    drilldownAddress._releaseIntermediate();
    streetAddress._releaseIntermediate();
    addressComment._releaseIntermediate();
    postCode._releaseIntermediate();
  }
}

// MARK: - FormattingType

/** Требование к длине строкового представления адреса. */
enum FormattingType {
  /** Короткая форма адреса. Для многокомпонентных адресов некоторые компоненты могут быть опущены. */
  short(0),
  /** Полная форма адреса. Все компоненты будут представлены. */
  full(1),
  ;

  const FormattingType(this.rawValue);
  final int rawValue;

  static FormattingType getByValue(int value) {
    return FormattingType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CFormattingType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CFormattingTypeBasicFunctions on _CFormattingType {
  void _releaseIntermediate() {
  }
}

extension _CFormattingTypeToDart on _CFormattingType {
  FormattingType _toDart() {
    return FormattingType.getByValue(this.rawValue);
  }
}

extension _DartTo_CFormattingType on FormattingType {
  _CFormattingType _copyFromDartTo_CFormattingType() {
    return _CFormattingTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ObjectType

/** Тип объекта справочника. */
enum ObjectType {
  /** Административная единица. */
  admDiv(0),
  /** Город. */
  admDivCity(1),
  /** Страна. */
  admDivCountry(2),
  /** Район. */
  admDivDistrict(3),
  /** Район области. */
  admDivDistrictArea(4),
  /** Округ. */
  admDivDivision(5),
  /** Жилмассив, микрорайон. */
  admDivLivingArea(6),
  /** Разные площадные объекты: парки, пляжи, территории баз отдыха, озёра и прочие места. */
  admDivPlace(7),
  /** Регион (область/край/республика и т.п.). */
  admDivRegion(8),
  /** Населённый пункт (деревня, посёлок и т.п.). */
  admDivSettlement(9),
  /** Достопримечательность. */
  attraction(10),
  /** Компания. */
  branch(11),
  /** Здание. */
  building(12),
  /** Глобальная координата в системе координат WGS84 в формате lon, lat. */
  coordinates(13),
  /** Перекрёсток. */
  crossroad(14),
  /** Проход/проезд. */
  gate(15),
  /** Знак километра. */
  kilometerRoadSign(16),
  /** Парковка. */
  parking(17),
  /** Дорога. */
  road(18),
  /** Маршрут. */
  route(19),
  /** Остановки или станция общественного транспорта. */
  station(20),
  /** Вход на станцию. */
  stationEntrance(21),
  /** Станция метро. */
  stationMetro(22),
  /** Остановочная платформа. */
  stationPlatform(23),
  /** Улица. */
  street(24),
  /** На случай получения неожиданного типа. */
  unknown(25),
  ;

  const ObjectType(this.rawValue);
  final int rawValue;

  static ObjectType getByValue(int value) {
    return ObjectType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CObjectType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CObjectTypeBasicFunctions on _CObjectType {
  void _releaseIntermediate() {
  }
}

extension _CObjectTypeToDart on _CObjectType {
  ObjectType _toDart() {
    return ObjectType.getByValue(this.rawValue);
  }
}

extension _DartTo_CObjectType on ObjectType {
  _CObjectType _copyFromDartTo_CObjectType() {
    return _CObjectTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - GroupItem

/** Элемент объединенной карточки, содержащий информацию об объекте. */
class GroupItem {
  /** Идентификатор объекта. */
  final DgisObjectId id;
  /** Тип объекта. */
  final ObjectType type;

  const GroupItem({
    required this.id,
    required this.type
  });

  GroupItem copyWith({
    DgisObjectId? id,
    ObjectType? type
  }) {
    return GroupItem(
      id: id ?? this.id,
      type: type ?? this.type
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GroupItem &&
    other.runtimeType == runtimeType &&
    other.id == id &&
    other.type == type;

  @override
  int get hashCode {
    return Object.hash(id, type);
  }

}
final class _CGroupItem extends ffi.Struct {
  external _CDgisObjectId id;

  external _CObjectType type;

}
// MARK: - GroupItem <-> _CGroupItem

extension _CGroupItemToDart on _CGroupItem {
  GroupItem _toDart() {
    return GroupItem(
      id: this.id._toDart(),
      type: this.type._toDart()
    );
  }
}

extension _DartTo_CGroupItem on GroupItem {
  _CGroupItem _copyFromDartTo_CGroupItem() {
    final res = _CGroupItemMakeDefault();
    res.id = this.id._copyFromDartTo_CDgisObjectId();
    res.type = this.type._copyFromDartTo_CObjectType();
    return res;
  }
}
extension _CGroupItemRelease on _CGroupItem {
  void _releaseIntermediate() {
  }
}

// MARK: - Aggregate

/** Обобщенное описание станции зарядки автомобилей. */
class Aggregate {
  /** Количество доступных коннекторов. */
  final int connectorsFree;
  /** Общее количество коннекторов (кроме недоступных). */
  final int connectorsTotal;
  /** Статус активности. true, если есть хотя бы один доступный, зарезервированный или на зарядке коннектор. */
  final bool isActive;
  /** Статус занятости. true, если половина или более коннекторов заняты. */
  final bool isBusy;
  /** Максимальная мощность из всех коннекторов. */
  final int power;

  const Aggregate({
    required this.connectorsFree,
    required this.connectorsTotal,
    required this.isActive,
    required this.isBusy,
    required this.power
  });

  Aggregate copyWith({
    int? connectorsFree,
    int? connectorsTotal,
    bool? isActive,
    bool? isBusy,
    int? power
  }) {
    return Aggregate(
      connectorsFree: connectorsFree ?? this.connectorsFree,
      connectorsTotal: connectorsTotal ?? this.connectorsTotal,
      isActive: isActive ?? this.isActive,
      isBusy: isBusy ?? this.isBusy,
      power: power ?? this.power
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Aggregate &&
    other.runtimeType == runtimeType &&
    other.connectorsFree == connectorsFree &&
    other.connectorsTotal == connectorsTotal &&
    other.isActive == isActive &&
    other.isBusy == isBusy &&
    other.power == power;

  @override
  int get hashCode {
    return Object.hash(connectorsFree, connectorsTotal, isActive, isBusy, power);
  }

}
final class _CAggregate extends ffi.Struct {
  @ffi.Uint16()
  external int connectorsFree;

  @ffi.Uint16()
  external int connectorsTotal;

  @ffi.Bool()
  external bool isActive;

  @ffi.Bool()
  external bool isBusy;

  @ffi.Uint16()
  external int power;

}
// MARK: - Aggregate <-> _CAggregate

extension _CAggregateToDart on _CAggregate {
  Aggregate _toDart() {
    return Aggregate(
      connectorsFree: this.connectorsFree,
      connectorsTotal: this.connectorsTotal,
      isActive: this.isActive,
      isBusy: this.isBusy,
      power: this.power
    );
  }
}

extension _DartTo_CAggregate on Aggregate {
  _CAggregate _copyFromDartTo_CAggregate() {
    final res = _CAggregateMakeDefault();
    res.connectorsFree = this.connectorsFree;
    res.connectorsTotal = this.connectorsTotal;
    res.isActive = this.isActive;
    res.isBusy = this.isBusy;
    res.power = this.power;
    return res;
  }
}
extension _CAggregateRelease on _CAggregate {
  void _releaseIntermediate() {
  }
}

// MARK: - StatusType

/** Статус коннектора. */
enum StatusType {
  /** Доступно. */
  available(0),
  /** Зарядка. */
  charging(1),
  /** Зарезервировано. */
  reserved(2),
  /** Недоступно. */
  unavailable(3),
  /** Неизвестно. */
  unknown(4),
  ;

  const StatusType(this.rawValue);
  final int rawValue;

  static StatusType getByValue(int value) {
    return StatusType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CStatusType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CStatusTypeBasicFunctions on _CStatusType {
  void _releaseIntermediate() {
  }
}

extension _CStatusTypeToDart on _CStatusType {
  StatusType _toDart() {
    return StatusType.getByValue(this.rawValue);
  }
}

extension _DartTo_CStatusType on StatusType {
  _CStatusType _copyFromDartTo_CStatusType() {
    return _CStatusTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - Connector

class Connector {
  /** Мощность зарядки в кВт. */
  final int power;
  /** Стоимость за один кВт·ч. */
  final int price;
  /** Статус. */
  final StatusType status;
  /** Тип коннектора. */
  final String type;

  const Connector({
    required this.power,
    required this.price,
    required this.status,
    required this.type
  });

  Connector copyWith({
    int? power,
    int? price,
    StatusType? status,
    String? type
  }) {
    return Connector(
      power: power ?? this.power,
      price: price ?? this.price,
      status: status ?? this.status,
      type: type ?? this.type
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Connector &&
    other.runtimeType == runtimeType &&
    other.power == power &&
    other.price == price &&
    other.status == status &&
    other.type == type;

  @override
  int get hashCode {
    return Object.hash(power, price, status, type);
  }

}
final class _CConnector extends ffi.Struct {
  @ffi.Uint16()
  external int power;

  @ffi.Uint16()
  external int price;

  external _CStatusType status;

  external _CString type;

}
// MARK: - Connector <-> _CConnector

extension _CConnectorToDart on _CConnector {
  Connector _toDart() {
    return Connector(
      power: this.power,
      price: this.price,
      status: this.status._toDart(),
      type: this.type._toDart()
    );
  }
}

extension _DartTo_CConnector on Connector {
  _CConnector _copyFromDartTo_CConnector() {
    final res = _CConnectorMakeDefault();
    res.power = this.power;
    res.price = this.price;
    res.status = this.status._copyFromDartTo_CStatusType();
    res.type = this.type._copyFromDartTo_CString();
    return res;
  }
}
extension _CConnectorRelease on _CConnector {
  void _releaseIntermediate() {
    type._releaseIntermediate();
  }
}

// MARK: - List<Connector> <-> _CArray_CConnector

final class _CArray_CConnector extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CConnectorToDart on _CArray_CConnector {
  List<Connector> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CConnector on List<Connector> {
  _CArray_CConnector _copyFromDartTo_CArray_CConnector() {
    final cArray = _CArray_CConnectormakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CConnector();
        _CArray_CConnectoraddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CConnectorBasicFunctions on _CArray_CConnector {
  void _releaseIntermediate() {
    _CArray_CConnector_release(this);
  }

  static final _listToFill = <Connector>[];

  static void _iterate(_CConnector item) {
    _listToFill.add(item._toDart());
  }

  List<Connector> _fillFromC() {
    _forEach_CArray_CConnector(this, ffi.Pointer.fromFunction<ffi.Void Function(_CConnector)>(_iterate));
    final result = List<Connector>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - ChargingStation

/** Атрибуты для электрозаправок. */
class ChargingStation {
  final Aggregate aggregate;
  final List<Connector> connectors;

  const ChargingStation({
    required this.aggregate,
    required this.connectors
  });

  ChargingStation copyWith({
    Aggregate? aggregate,
    List<Connector>? connectors
  }) {
    return ChargingStation(
      aggregate: aggregate ?? this.aggregate,
      connectors: connectors ?? this.connectors
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ChargingStation &&
    other.runtimeType == runtimeType &&
    other.aggregate == aggregate &&
    other.connectors == connectors;

  @override
  int get hashCode {
    return Object.hash(aggregate, connectors);
  }

}
final class _CChargingStation extends ffi.Struct {
  external _CAggregate aggregate;

  external _CArray_CConnector connectors;

}
// MARK: - ChargingStation <-> _CChargingStation

extension _CChargingStationToDart on _CChargingStation {
  ChargingStation _toDart() {
    return ChargingStation(
      aggregate: this.aggregate._toDart(),
      connectors: this.connectors._toDart()
    );
  }
}

extension _DartTo_CChargingStation on ChargingStation {
  _CChargingStation _copyFromDartTo_CChargingStation() {
    final res = _CChargingStationMakeDefault();
    res.aggregate = this.aggregate._copyFromDartTo_CAggregate();
    res.connectors = this.connectors._copyFromDartTo_CArray_CConnector();
    return res;
  }
}
extension _CChargingStationRelease on _CChargingStation {
  void _releaseIntermediate() {
    connectors._releaseIntermediate();
  }
}

// MARK: - RubricId

/** Идентификатор рубрики. */
class RubricId {
  final int value;

  const RubricId([this.value = 0]);

  RubricId copyWith({
    int? value
  }) {
    return RubricId(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RubricId &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CRubricId extends ffi.Struct {
  @ffi.Uint64()
  external int value;

}
// MARK: - RubricId <-> _CRubricId

extension _CRubricIdToDart on _CRubricId {
  RubricId _toDart() {
    return RubricId(
      this.value
    );
  }
}

extension _DartTo_CRubricId on RubricId {
  _CRubricId _copyFromDartTo_CRubricId() {
    final res = _CRubricIdMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CRubricIdRelease on _CRubricId {
  void _releaseIntermediate() {
  }
}

// MARK: - ItemMarkerInfo

/** Идентификатор объекта и его координаты. */
class ItemMarkerInfo implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  DgisObjectId? get objectId {
    _COptional_CDgisObjectId res = _CItemMarkerInfo_objectId(_CItemMarkerInfoMakeDefault().._impl=_self);
    return res._toDart();
  }
  GeoPointWithElevation get geoPoint {
    _CGeoPointWithElevation res = _CItemMarkerInfo_geoPoint(_CItemMarkerInfoMakeDefault().._impl=_self);
    return res._toDart();
  }
  FloorInfo? get floorInfo {
    _COptional_CFloorInfo res = _CItemMarkerInfo_floorInfo(_CItemMarkerInfoMakeDefault().._impl=_self);
    return res._toDart();
  }
  String? get title {
    _COptional_CString res = _CItemMarkerInfo_title(_CItemMarkerInfoMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  List<RubricId> get rubricIds {
    _CArray_CRubricId res = _CItemMarkerInfo_rubricIds(_CItemMarkerInfoMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CItemMarkerInfo_releasePtr);

  ItemMarkerInfo._raw(this._self);
  factory ItemMarkerInfo._create(ffi.Pointer<ffi.Void> self) {
    final classObject = ItemMarkerInfo._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ItemMarkerInfo &&
    other.runtimeType == runtimeType &&
    _CItemMarkerInfo_cg_objectIdentifier(this._self) == _CItemMarkerInfo_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CItemMarkerInfo_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - ItemMarkerInfo <-> CItemMarkerInfo

final class _CItemMarkerInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CItemMarkerInfoBasicFunctions on _CItemMarkerInfo {
  void _releaseIntermediate() {
    _CItemMarkerInfo_release(_impl);
  }

  _CItemMarkerInfo _retain() {
    return _CItemMarkerInfo_retain(_impl);
  }
}

extension _CItemMarkerInfoToDart on _CItemMarkerInfo {
  ItemMarkerInfo _toDart() {
    return ItemMarkerInfo._create(_retain()._impl);
  }
}


extension _DartToCItemMarkerInfo on ItemMarkerInfo {
  _CItemMarkerInfo _copyFromDartTo_CItemMarkerInfo() {
    return (_CItemMarkerInfoMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - DgisObjectId? <-> _COptional_CDgisObjectId

final class _COptional_CDgisObjectId extends ffi.Struct {
  
  external _CDgisObjectId value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CDgisObjectIdBasicFunctions on _COptional_CDgisObjectId {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CDgisObjectIdToDart on _COptional_CDgisObjectId {
  DgisObjectId? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CDgisObjectId on DgisObjectId? {
  _COptional_CDgisObjectId _copyFromDartTo_COptional_CDgisObjectId() {
    final cOptional = _COptional_CDgisObjectIdMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CDgisObjectId();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Elevation

/** Неотрицательная высота точки над поверхностью в метрах. */
class Elevation {
  final double value;

  const Elevation([this.value = 0]);

  Elevation copyWith({
    double? value
  }) {
    return Elevation(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Elevation &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CElevation extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - Elevation <-> _CElevation

extension _CElevationToDart on _CElevation {
  Elevation _toDart() {
    return Elevation(
      this.value
    );
  }
}

extension _DartTo_CElevation on Elevation {
  _CElevation _copyFromDartTo_CElevation() {
    final res = _CElevationMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CElevationRelease on _CElevation {
  void _releaseIntermediate() {
  }
}

// MARK: - GeoPointWithElevation

/**
 Точка в географической системе координат (широта, долгота, возвышение).

 - Note: возвышение (Elevation) в метрах над поверхностью, а не над уровнем моря.
*/
class GeoPointWithElevation {
  final Latitude latitude;
  final Longitude longitude;
  final Elevation elevation;

  const GeoPointWithElevation({
    required this.latitude,
    required this.longitude,
    this.elevation = const Elevation(0)
  });

  GeoPointWithElevation copyWith({
    Latitude? latitude,
    Longitude? longitude,
    Elevation? elevation
  }) {
    return GeoPointWithElevation(
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      elevation: elevation ?? this.elevation
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GeoPointWithElevation &&
    other.runtimeType == runtimeType &&
    other.latitude == latitude &&
    other.longitude == longitude &&
    other.elevation == elevation;

  @override
  int get hashCode {
    return Object.hash(latitude, longitude, elevation);
  }

}
final class _CGeoPointWithElevation extends ffi.Struct {
  external _CLatitude latitude;

  external _CLongitude longitude;

  external _CElevation elevation;

}
// MARK: - GeoPointWithElevation <-> _CGeoPointWithElevation

extension _CGeoPointWithElevationToDart on _CGeoPointWithElevation {
  GeoPointWithElevation _toDart() {
    return GeoPointWithElevation(
      latitude: this.latitude._toDart(),
      longitude: this.longitude._toDart(),
      elevation: this.elevation._toDart()
    );
  }
}

extension _DartTo_CGeoPointWithElevation on GeoPointWithElevation {
  _CGeoPointWithElevation _copyFromDartTo_CGeoPointWithElevation() {
    final res = _CGeoPointWithElevationMakeDefault();
    res.latitude = this.latitude._copyFromDartTo_CLatitude();
    res.longitude = this.longitude._copyFromDartTo_CLongitude();
    res.elevation = this.elevation._copyFromDartTo_CElevation();
    return res;
  }
}
extension _CGeoPointWithElevationRelease on _CGeoPointWithElevation {
  void _releaseIntermediate() {
  }
}

// MARK: - FloorInfo? <-> _COptional_CFloorInfo

final class _COptional_CFloorInfo extends ffi.Struct {
  
  external _CFloorInfo value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CFloorInfoBasicFunctions on _COptional_CFloorInfo {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CFloorInfoToDart on _COptional_CFloorInfo {
  FloorInfo? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CFloorInfo on FloorInfo? {
  _COptional_CFloorInfo _copyFromDartTo_COptional_CFloorInfo() {
    final cOptional = _COptional_CFloorInfoMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CFloorInfo();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<RubricId> <-> _CArray_CRubricId

final class _CArray_CRubricId extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CRubricIdToDart on _CArray_CRubricId {
  List<RubricId> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CRubricId on List<RubricId> {
  _CArray_CRubricId _copyFromDartTo_CArray_CRubricId() {
    final cArray = _CArray_CRubricIdmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CRubricId();
        _CArray_CRubricIdaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CRubricIdBasicFunctions on _CArray_CRubricId {
  void _releaseIntermediate() {
    _CArray_CRubricId_release(this);
  }

  static final _listToFill = <RubricId>[];

  static void _iterate(_CRubricId item) {
    _listToFill.add(item._toDart());
  }

  List<RubricId> _fillFromC() {
    _forEach_CArray_CRubricId(this, ffi.Pointer.fromFunction<ffi.Void Function(_CRubricId)>(_iterate));
    final result = List<RubricId>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - List<List<WeekTimeInterval>> <-> _CArray_CArray_CWeekTimeInterval

final class _CArray_CArray_CWeekTimeInterval extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CArray_CWeekTimeIntervalToDart on _CArray_CArray_CWeekTimeInterval {
  List<List<WeekTimeInterval>> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CArray_CWeekTimeInterval on List<List<WeekTimeInterval>> {
  _CArray_CArray_CWeekTimeInterval _copyFromDartTo_CArray_CArray_CWeekTimeInterval() {
    final cArray = _CArray_CArray_CWeekTimeIntervalmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CArray_CWeekTimeInterval();
        _CArray_CArray_CWeekTimeIntervaladdElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CArray_CWeekTimeIntervalBasicFunctions on _CArray_CArray_CWeekTimeInterval {
  void _releaseIntermediate() {
    _CArray_CArray_CWeekTimeInterval_release(this);
  }

  static final _listToFill = <List<WeekTimeInterval>>[];

  static void _iterate(_CArray_CWeekTimeInterval item) {
    _listToFill.add(item._toDart());
  }

  List<List<WeekTimeInterval>> _fillFromC() {
    _forEach_CArray_CArray_CWeekTimeInterval(this, ffi.Pointer.fromFunction<ffi.Void Function(_CArray_CWeekTimeInterval)>(_iterate));
    final result = List<List<WeekTimeInterval>>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - OpeningHours

/** Часы работы организации. */
class OpeningHours {
  /** Часы работы для каждого дня недели, начиная с понедельника. */
  final List<List<WeekTimeInterval>> weekOpeningHours;
  final bool isOpen24x7;

  const OpeningHours({
    required this.weekOpeningHours,
    required this.isOpen24x7
  });

  OpeningHours copyWith({
    List<List<WeekTimeInterval>>? weekOpeningHours,
    bool? isOpen24x7
  }) {
    return OpeningHours(
      weekOpeningHours: weekOpeningHours ?? this.weekOpeningHours,
      isOpen24x7: isOpen24x7 ?? this.isOpen24x7
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is OpeningHours &&
    other.runtimeType == runtimeType &&
    other.weekOpeningHours == weekOpeningHours &&
    other.isOpen24x7 == isOpen24x7;

  @override
  int get hashCode {
    return Object.hash(weekOpeningHours, isOpen24x7);
  }

}
final class _COpeningHours extends ffi.Struct {
  external _CArray_CArray_CWeekTimeInterval weekOpeningHours;

  @ffi.Bool()
  external bool isOpen24x7;

}
// MARK: - OpeningHours <-> _COpeningHours

extension _COpeningHoursToDart on _COpeningHours {
  OpeningHours _toDart() {
    return OpeningHours(
      weekOpeningHours: this.weekOpeningHours._toDart(),
      isOpen24x7: this.isOpen24x7
    );
  }
}

extension _DartTo_COpeningHours on OpeningHours {
  _COpeningHours _copyFromDartTo_COpeningHours() {
    final res = _COpeningHoursMakeDefault();
    res.weekOpeningHours = this.weekOpeningHours._copyFromDartTo_CArray_CArray_CWeekTimeInterval();
    res.isOpen24x7 = this.isOpen24x7;
    return res;
  }
}
extension _COpeningHoursRelease on _COpeningHours {
  void _releaseIntermediate() {
    weekOpeningHours._releaseIntermediate();
  }
}

// MARK: - List<WeekTimeInterval> <-> _CArray_CWeekTimeInterval

final class _CArray_CWeekTimeInterval extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CWeekTimeIntervalToDart on _CArray_CWeekTimeInterval {
  List<WeekTimeInterval> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CWeekTimeInterval on List<WeekTimeInterval> {
  _CArray_CWeekTimeInterval _copyFromDartTo_CArray_CWeekTimeInterval() {
    final cArray = _CArray_CWeekTimeIntervalmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CWeekTimeInterval();
        _CArray_CWeekTimeIntervaladdElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CWeekTimeIntervalBasicFunctions on _CArray_CWeekTimeInterval {
  void _releaseIntermediate() {
    _CArray_CWeekTimeInterval_release(this);
  }

  static final _listToFill = <WeekTimeInterval>[];

  static void _iterate(_CWeekTimeInterval item) {
    _listToFill.add(item._toDart());
  }

  List<WeekTimeInterval> _fillFromC() {
    _forEach_CArray_CWeekTimeInterval(this, ffi.Pointer.fromFunction<ffi.Void Function(_CWeekTimeInterval)>(_iterate));
    final result = List<WeekTimeInterval>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - OrgId

/** Идентификатор организации. */
class OrgId {
  final int value;

  const OrgId([this.value = 0]);

  OrgId copyWith({
    int? value
  }) {
    return OrgId(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is OrgId &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _COrgId extends ffi.Struct {
  @ffi.Uint64()
  external int value;

}
// MARK: - OrgId <-> _COrgId

extension _COrgIdToDart on _COrgId {
  OrgId _toDart() {
    return OrgId(
      this.value
    );
  }
}

extension _DartTo_COrgId on OrgId {
  _COrgId _copyFromDartTo_COrgId() {
    final res = _COrgIdMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _COrgIdRelease on _COrgId {
  void _releaseIntermediate() {
  }
}

// MARK: - OrgInfo

/** Информация об организации. */
class OrgInfo {
  /** Количество филиалов организации. */
  final int branchCount;
  /** Уникальный идентификатор организации. */
  final OrgId id;
  /** Название организации. */
  final String? name;

  const OrgInfo({
    required this.branchCount,
    required this.id,
    required this.name
  });

  OrgInfo copyWith({
    int? branchCount,
    OrgId? id,
    Optional<String?>? name
  }) {
    return OrgInfo(
      branchCount: branchCount ?? this.branchCount,
      id: id ?? this.id,
      name: name != null ? name.value : this.name
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is OrgInfo &&
    other.runtimeType == runtimeType &&
    other.branchCount == branchCount &&
    other.id == id &&
    other.name == name;

  @override
  int get hashCode {
    return Object.hash(branchCount, id, name);
  }

}
final class _COrgInfo extends ffi.Struct {
  @ffi.Uint32()
  external int branchCount;

  external _COrgId id;

  external _COptional_CString name;

}
// MARK: - OrgInfo <-> _COrgInfo

extension _COrgInfoToDart on _COrgInfo {
  OrgInfo _toDart() {
    return OrgInfo(
      branchCount: this.branchCount,
      id: this.id._toDart(),
      name: this.name._toDart()
    );
  }
}

extension _DartTo_COrgInfo on OrgInfo {
  _COrgInfo _copyFromDartTo_COrgInfo() {
    final res = _COrgInfoMakeDefault();
    res.branchCount = this.branchCount;
    res.id = this.id._copyFromDartTo_COrgId();
    res.name = this.name._copyFromDartTo_COptional_CString();
    return res;
  }
}
extension _COrgInfoRelease on _COrgInfo {
  void _releaseIntermediate() {
    name._releaseIntermediate();
  }
}

// MARK: - ParkingAccess

/** Тип доступа для парковки. */
enum ParkingAccess {
  /** Общедоступная. */
  public(0),
  /** Только для инвалидов. */
  handicappedOnly(1),
  /** Только для клиентов. */
  customersOnly(2),
  /** Только для резидентов. */
  residentsOnly(3),
  /** Место стоянки для такси. */
  taxiOnly(4),
  ;

  const ParkingAccess(this.rawValue);
  final int rawValue;

  static ParkingAccess getByValue(int value) {
    return ParkingAccess.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CParkingAccess extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CParkingAccessBasicFunctions on _CParkingAccess {
  void _releaseIntermediate() {
  }
}

extension _CParkingAccessToDart on _CParkingAccess {
  ParkingAccess _toDart() {
    return ParkingAccess.getByValue(this.rawValue);
  }
}

extension _DartTo_CParkingAccess on ParkingAccess {
  _CParkingAccess _copyFromDartTo_CParkingAccess() {
    return _CParkingAccessMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - SpecialSpaceType

/** Тип особого места. */
enum SpecialSpaceType {
  /** Для велосипедов. */
  bicycle(0),
  /** Для мотоциклов. */
  motorbike(1),
  /** Для семей. */
  family(2),
  /** Для инвалидов. */
  handicapped(3),
  /** Для колясок. */
  babyCarriage(4),
  /** Для грузовиков. */
  truck(5),
  /** Для самокатов. */
  scooter(6),
  ;

  const SpecialSpaceType(this.rawValue);
  final int rawValue;

  static SpecialSpaceType getByValue(int value) {
    return SpecialSpaceType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CSpecialSpaceType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CSpecialSpaceTypeBasicFunctions on _CSpecialSpaceType {
  void _releaseIntermediate() {
  }
}

extension _CSpecialSpaceTypeToDart on _CSpecialSpaceType {
  SpecialSpaceType _toDart() {
    return SpecialSpaceType.getByValue(this.rawValue);
  }
}

extension _DartTo_CSpecialSpaceType on SpecialSpaceType {
  _CSpecialSpaceType _copyFromDartTo_CSpecialSpaceType() {
    return _CSpecialSpaceTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - SpecialSpace

/** Особое место для парковки. */
class SpecialSpace {
  /** Тип. */
  final SpecialSpaceType type;
  /** Локализованное название особого места. */
  final String name;
  /** Количество мест такого типа на парковке. */
  final String? count;

  const SpecialSpace({
    required this.type,
    required this.name,
    required this.count
  });

  SpecialSpace copyWith({
    SpecialSpaceType? type,
    String? name,
    Optional<String?>? count
  }) {
    return SpecialSpace(
      type: type ?? this.type,
      name: name ?? this.name,
      count: count != null ? count.value : this.count
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SpecialSpace &&
    other.runtimeType == runtimeType &&
    other.type == type &&
    other.name == name &&
    other.count == count;

  @override
  int get hashCode {
    return Object.hash(type, name, count);
  }

}
final class _CSpecialSpace extends ffi.Struct {
  external _CSpecialSpaceType type;

  external _CString name;

  external _COptional_CString count;

}
// MARK: - SpecialSpace <-> _CSpecialSpace

extension _CSpecialSpaceToDart on _CSpecialSpace {
  SpecialSpace _toDart() {
    return SpecialSpace(
      type: this.type._toDart(),
      name: this.name._toDart(),
      count: this.count._toDart()
    );
  }
}

extension _DartTo_CSpecialSpace on SpecialSpace {
  _CSpecialSpace _copyFromDartTo_CSpecialSpace() {
    final res = _CSpecialSpaceMakeDefault();
    res.type = this.type._copyFromDartTo_CSpecialSpaceType();
    res.name = this.name._copyFromDartTo_CString();
    res.count = this.count._copyFromDartTo_COptional_CString();
    return res;
  }
}
extension _CSpecialSpaceRelease on _CSpecialSpace {
  void _releaseIntermediate() {
    name._releaseIntermediate();
    count._releaseIntermediate();
  }
}

// MARK: - List<SpecialSpace> <-> _CArray_CSpecialSpace

final class _CArray_CSpecialSpace extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CSpecialSpaceToDart on _CArray_CSpecialSpace {
  List<SpecialSpace> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CSpecialSpace on List<SpecialSpace> {
  _CArray_CSpecialSpace _copyFromDartTo_CArray_CSpecialSpace() {
    final cArray = _CArray_CSpecialSpacemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CSpecialSpace();
        _CArray_CSpecialSpaceaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CSpecialSpaceBasicFunctions on _CArray_CSpecialSpace {
  void _releaseIntermediate() {
    _CArray_CSpecialSpace_release(this);
  }

  static final _listToFill = <SpecialSpace>[];

  static void _iterate(_CSpecialSpace item) {
    _listToFill.add(item._toDart());
  }

  List<SpecialSpace> _fillFromC() {
    _forEach_CArray_CSpecialSpace(this, ffi.Pointer.fromFunction<ffi.Void Function(_CSpecialSpace)>(_iterate));
    final result = List<SpecialSpace>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - ParkingCapacity

/** Вместимость парковки. */
class ParkingCapacity {
  /** Общая вместимость парковки, машиномест. */
  final String? total;
  /** Описание особых мест для парковки. */
  final List<SpecialSpace> specialSpaces;

  const ParkingCapacity({
    required this.total,
    required this.specialSpaces
  });

  ParkingCapacity copyWith({
    Optional<String?>? total,
    List<SpecialSpace>? specialSpaces
  }) {
    return ParkingCapacity(
      total: total != null ? total.value : this.total,
      specialSpaces: specialSpaces ?? this.specialSpaces
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ParkingCapacity &&
    other.runtimeType == runtimeType &&
    other.total == total &&
    other.specialSpaces == specialSpaces;

  @override
  int get hashCode {
    return Object.hash(total, specialSpaces);
  }

}
final class _CParkingCapacity extends ffi.Struct {
  external _COptional_CString total;

  external _CArray_CSpecialSpace specialSpaces;

}
// MARK: - ParkingCapacity <-> _CParkingCapacity

extension _CParkingCapacityToDart on _CParkingCapacity {
  ParkingCapacity _toDart() {
    return ParkingCapacity(
      total: this.total._toDart(),
      specialSpaces: this.specialSpaces._toDart()
    );
  }
}

extension _DartTo_CParkingCapacity on ParkingCapacity {
  _CParkingCapacity _copyFromDartTo_CParkingCapacity() {
    final res = _CParkingCapacityMakeDefault();
    res.total = this.total._copyFromDartTo_COptional_CString();
    res.specialSpaces = this.specialSpaces._copyFromDartTo_CArray_CSpecialSpace();
    return res;
  }
}
extension _CParkingCapacityRelease on _CParkingCapacity {
  void _releaseIntermediate() {
    total._releaseIntermediate();
    specialSpaces._releaseIntermediate();
  }
}

// MARK: - ParkingType

/** Тип парковки. */
enum ParkingType {
  /** Наземная парковка. */
  ground(0),
  /** Подземная парковка. */
  underground(1),
  /** Многоуровневая парковка. */
  multilevel(2),
  ;

  const ParkingType(this.rawValue);
  final int rawValue;

  static ParkingType getByValue(int value) {
    return ParkingType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CParkingType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CParkingTypeBasicFunctions on _CParkingType {
  void _releaseIntermediate() {
  }
}

extension _CParkingTypeToDart on _CParkingType {
  ParkingType _toDart() {
    return ParkingType.getByValue(this.rawValue);
  }
}

extension _DartTo_CParkingType on ParkingType {
  _CParkingType _copyFromDartTo_CParkingType() {
    return _CParkingTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ParkingPurpose

/** Назначение парковки. */
enum ParkingPurpose {
  /** Для автомобилей. */
  car(0),
  /** Для велосипедов. */
  bike(1),
  /** Для мотоциклов/мопедов. */
  motorbike(2),
  /** Для колясок. */
  babyCarriage(3),
  /** Для самокатов. */
  scooter(4),
  ;

  const ParkingPurpose(this.rawValue);
  final int rawValue;

  static ParkingPurpose getByValue(int value) {
    return ParkingPurpose.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CParkingPurpose extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CParkingPurposeBasicFunctions on _CParkingPurpose {
  void _releaseIntermediate() {
  }
}

extension _CParkingPurposeToDart on _CParkingPurpose {
  ParkingPurpose _toDart() {
    return ParkingPurpose.getByValue(this.rawValue);
  }
}

extension _DartTo_CParkingPurpose on ParkingPurpose {
  _CParkingPurpose _copyFromDartTo_CParkingPurpose() {
    return _CParkingPurposeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ParkingPavingType

/** Тип покрытия парковки. */
enum ParkingPavingType {
  /** Асфальтированное покрытие. */
  asphalt(0),
  /** Бетонное покрытие. */
  concrete(1),
  /** Гравийное покрытие. */
  gravel(2),
  /** Без покрытия. */
  unpaved(3),
  ;

  const ParkingPavingType(this.rawValue);
  final int rawValue;

  static ParkingPavingType getByValue(int value) {
    return ParkingPavingType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CParkingPavingType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CParkingPavingTypeBasicFunctions on _CParkingPavingType {
  void _releaseIntermediate() {
  }
}

extension _CParkingPavingTypeToDart on _CParkingPavingType {
  ParkingPavingType _toDart() {
    return ParkingPavingType.getByValue(this.rawValue);
  }
}

extension _DartTo_CParkingPavingType on ParkingPavingType {
  _CParkingPavingType _copyFromDartTo_CParkingPavingType() {
    return _CParkingPavingTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ParkingType? <-> _COptional_CParkingType

final class _COptional_CParkingType extends ffi.Struct {
  
  external _CParkingType value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CParkingTypeBasicFunctions on _COptional_CParkingType {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CParkingTypeToDart on _COptional_CParkingType {
  ParkingType? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CParkingType on ParkingType? {
  _COptional_CParkingType _copyFromDartTo_COptional_CParkingType() {
    final cOptional = _COptional_CParkingTypeMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CParkingType();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - ParkingPavingType? <-> _COptional_CParkingPavingType

final class _COptional_CParkingPavingType extends ffi.Struct {
  
  external _CParkingPavingType value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CParkingPavingTypeBasicFunctions on _COptional_CParkingPavingType {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CParkingPavingTypeToDart on _COptional_CParkingPavingType {
  ParkingPavingType? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CParkingPavingType on ParkingPavingType? {
  _COptional_CParkingPavingType _copyFromDartTo_COptional_CParkingPavingType() {
    final cOptional = _COptional_CParkingPavingTypeMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CParkingPavingType();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - int? <-> _COptional_uint16_t

final class _COptional_uint16_t extends ffi.Struct {
  @ffi.Uint16()
  external int value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_uint16_tBasicFunctions on _COptional_uint16_t {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_uint16_tToDart on _COptional_uint16_t {
  int? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value;
  }
}

extension _DartTo_COptional_uint16_t on int? {
  _COptional_uint16_t _copyFromDartTo_COptional_uint16_t() {
    final cOptional = _COptional_uint16_tMakeDefault();
    if (this != null) {
      cOptional.value = this!;
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - ParkingCapacity? <-> _COptional_CParkingCapacity

final class _COptional_CParkingCapacity extends ffi.Struct {
  
  external _CParkingCapacity value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CParkingCapacityBasicFunctions on _COptional_CParkingCapacity {
  void _releaseIntermediate() {
    _COptional_CParkingCapacity_release(this);
  }
}

extension _COptional_CParkingCapacityToDart on _COptional_CParkingCapacity {
  ParkingCapacity? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CParkingCapacity on ParkingCapacity? {
  _COptional_CParkingCapacity _copyFromDartTo_COptional_CParkingCapacity() {
    final cOptional = _COptional_CParkingCapacityMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CParkingCapacity();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - ParkingInfo

/** Общая информация о парковке. */
class ParkingInfo {
  /** Тип. */
  final ParkingType? type;
  /** Назначение. */
  final ParkingPurpose purpose;
  /** Тип доступа. */
  final ParkingAccess access;
  /** Тип покрытия. */
  final ParkingPavingType? pavingType;
  /** Является ли парковка платной. */
  final bool isPaid;
  /** Является ли парковка перехватывающей. */
  final bool isIncentive;
  /** Есть места для грузовиков. */
  final bool forTrucks;
  /** Количество уровней. */
  final int? levelCount;
  /** Вместимость. */
  final ParkingCapacity? capacity;

  const ParkingInfo({
    required this.type,
    required this.purpose,
    required this.access,
    required this.pavingType,
    required this.isPaid,
    required this.isIncentive,
    required this.forTrucks,
    required this.levelCount,
    required this.capacity
  });

  ParkingInfo copyWith({
    Optional<ParkingType?>? type,
    ParkingPurpose? purpose,
    ParkingAccess? access,
    Optional<ParkingPavingType?>? pavingType,
    bool? isPaid,
    bool? isIncentive,
    bool? forTrucks,
    Optional<int?>? levelCount,
    Optional<ParkingCapacity?>? capacity
  }) {
    return ParkingInfo(
      type: type != null ? type.value : this.type,
      purpose: purpose ?? this.purpose,
      access: access ?? this.access,
      pavingType: pavingType != null ? pavingType.value : this.pavingType,
      isPaid: isPaid ?? this.isPaid,
      isIncentive: isIncentive ?? this.isIncentive,
      forTrucks: forTrucks ?? this.forTrucks,
      levelCount: levelCount != null ? levelCount.value : this.levelCount,
      capacity: capacity != null ? capacity.value : this.capacity
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ParkingInfo &&
    other.runtimeType == runtimeType &&
    other.type == type &&
    other.purpose == purpose &&
    other.access == access &&
    other.pavingType == pavingType &&
    other.isPaid == isPaid &&
    other.isIncentive == isIncentive &&
    other.forTrucks == forTrucks &&
    other.levelCount == levelCount &&
    other.capacity == capacity;

  @override
  int get hashCode {
    return Object.hash(type, purpose, access, pavingType, isPaid, isIncentive, forTrucks, levelCount, capacity);
  }

}
final class _CParkingInfo extends ffi.Struct {
  external _COptional_CParkingType type;

  external _CParkingPurpose purpose;

  external _CParkingAccess access;

  external _COptional_CParkingPavingType pavingType;

  @ffi.Bool()
  external bool isPaid;

  @ffi.Bool()
  external bool isIncentive;

  @ffi.Bool()
  external bool forTrucks;

  external _COptional_uint16_t levelCount;

  external _COptional_CParkingCapacity capacity;

}
// MARK: - ParkingInfo <-> _CParkingInfo

extension _CParkingInfoToDart on _CParkingInfo {
  ParkingInfo _toDart() {
    return ParkingInfo(
      type: this.type._toDart(),
      purpose: this.purpose._toDart(),
      access: this.access._toDart(),
      pavingType: this.pavingType._toDart(),
      isPaid: this.isPaid,
      isIncentive: this.isIncentive,
      forTrucks: this.forTrucks,
      levelCount: this.levelCount._toDart(),
      capacity: this.capacity._toDart()
    );
  }
}

extension _DartTo_CParkingInfo on ParkingInfo {
  _CParkingInfo _copyFromDartTo_CParkingInfo() {
    final res = _CParkingInfoMakeDefault();
    res.type = this.type._copyFromDartTo_COptional_CParkingType();
    res.purpose = this.purpose._copyFromDartTo_CParkingPurpose();
    res.access = this.access._copyFromDartTo_CParkingAccess();
    res.pavingType = this.pavingType._copyFromDartTo_COptional_CParkingPavingType();
    res.isPaid = this.isPaid;
    res.isIncentive = this.isIncentive;
    res.forTrucks = this.forTrucks;
    res.levelCount = this.levelCount._copyFromDartTo_COptional_uint16_t();
    res.capacity = this.capacity._copyFromDartTo_COptional_CParkingCapacity();
    return res;
  }
}
extension _CParkingInfoRelease on _CParkingInfo {
  void _releaseIntermediate() {
    capacity._releaseIntermediate();
  }
}

// MARK: - Reviews

/** Отзывы. */
class Reviews {
  /** Рейтинг в диапазоне от 0 до 5. */
  final double rating;
  /** Количество отзывов. */
  final int count;

  const Reviews({
    required this.rating,
    required this.count
  });

  Reviews copyWith({
    double? rating,
    int? count
  }) {
    return Reviews(
      rating: rating ?? this.rating,
      count: count ?? this.count
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Reviews &&
    other.runtimeType == runtimeType &&
    other.rating == rating &&
    other.count == count;

  @override
  int get hashCode {
    return Object.hash(rating, count);
  }

}
final class _CReviews extends ffi.Struct {
  @ffi.Float()
  external double rating;

  @ffi.Uint32()
  external int count;

}
// MARK: - Reviews <-> _CReviews

extension _CReviewsToDart on _CReviews {
  Reviews _toDart() {
    return Reviews(
      rating: this.rating,
      count: this.count
    );
  }
}

extension _DartTo_CReviews on Reviews {
  _CReviews _copyFromDartTo_CReviews() {
    final res = _CReviewsMakeDefault();
    res.rating = this.rating;
    res.count = this.count;
    return res;
  }
}
extension _CReviewsRelease on _CReviews {
  void _releaseIntermediate() {
  }
}

// MARK: - SearchResultType

/** Тип результата (не поискового запроса!). */
enum SearchResultType {
  /** По запросу найден конкретный объект. */
  recovery(0),
  /** По запросу найдена рубрика, в результатах - список объектов из этой рубрики. */
  discovery(1),
  ;

  const SearchResultType(this.rawValue);
  final int rawValue;

  static SearchResultType getByValue(int value) {
    return SearchResultType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CSearchResultType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CSearchResultTypeBasicFunctions on _CSearchResultType {
  void _releaseIntermediate() {
  }
}

extension _CSearchResultTypeToDart on _CSearchResultType {
  SearchResultType _toDart() {
    return SearchResultType.getByValue(this.rawValue);
  }
}

extension _DartTo_CSearchResultType on SearchResultType {
  _CSearchResultType _copyFromDartTo_CSearchResultType() {
    return _CSearchResultTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - SortingType

/** Тип сортировки. */
enum SortingType {
  /** По релевантности. Используется по умолчанию. */
  byRelevance(0),
  /** По расстоянию от текущего положения пользователя. */
  byDistance(1),
  /** По рейтингу. */
  byRating(2),
  ;

  const SortingType(this.rawValue);
  final int rawValue;

  static SortingType getByValue(int value) {
    return SortingType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CSortingType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CSortingTypeBasicFunctions on _CSortingType {
  void _releaseIntermediate() {
  }
}

extension _CSortingTypeToDart on _CSortingType {
  SortingType _toDart() {
    return SortingType.getByValue(this.rawValue);
  }
}

extension _DartTo_CSortingType on SortingType {
  _CSortingType _copyFromDartTo_CSortingType() {
    return _CSortingTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - TradeLicense

/** Лицензия организации. */
class TradeLicense {
  /** Тип. */
  final String type;
  /** Номер. */
  final String license;
  /** Форма собственности компании. */
  final String legalForm;
  /** Дата, до которой действует лицензия. */
  final String endDate;

  const TradeLicense({
    required this.type,
    required this.license,
    required this.legalForm,
    required this.endDate
  });

  TradeLicense copyWith({
    String? type,
    String? license,
    String? legalForm,
    String? endDate
  }) {
    return TradeLicense(
      type: type ?? this.type,
      license: license ?? this.license,
      legalForm: legalForm ?? this.legalForm,
      endDate: endDate ?? this.endDate
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TradeLicense &&
    other.runtimeType == runtimeType &&
    other.type == type &&
    other.license == license &&
    other.legalForm == legalForm &&
    other.endDate == endDate;

  @override
  int get hashCode {
    return Object.hash(type, license, legalForm, endDate);
  }

}
final class _CTradeLicense extends ffi.Struct {
  external _CString type;

  external _CString license;

  external _CString legalForm;

  external _CString endDate;

}
// MARK: - TradeLicense <-> _CTradeLicense

extension _CTradeLicenseToDart on _CTradeLicense {
  TradeLicense _toDart() {
    return TradeLicense(
      type: this.type._toDart(),
      license: this.license._toDart(),
      legalForm: this.legalForm._toDart(),
      endDate: this.endDate._toDart()
    );
  }
}

extension _DartTo_CTradeLicense on TradeLicense {
  _CTradeLicense _copyFromDartTo_CTradeLicense() {
    final res = _CTradeLicenseMakeDefault();
    res.type = this.type._copyFromDartTo_CString();
    res.license = this.license._copyFromDartTo_CString();
    res.legalForm = this.legalForm._copyFromDartTo_CString();
    res.endDate = this.endDate._copyFromDartTo_CString();
    return res;
  }
}
extension _CTradeLicenseRelease on _CTradeLicense {
  void _releaseIntermediate() {
    type._releaseIntermediate();
    license._releaseIntermediate();
    legalForm._releaseIntermediate();
    endDate._releaseIntermediate();
  }
}

// MARK: - UIMarkerInfo

/** Идентификатор объекта с подписью. */
class UIMarkerInfo {
  final DgisObjectId objectId;
  final String? label;

  const UIMarkerInfo({
    required this.objectId,
    required this.label
  });

  UIMarkerInfo copyWith({
    DgisObjectId? objectId,
    Optional<String?>? label
  }) {
    return UIMarkerInfo(
      objectId: objectId ?? this.objectId,
      label: label != null ? label.value : this.label
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is UIMarkerInfo &&
    other.runtimeType == runtimeType &&
    other.objectId == objectId &&
    other.label == label;

  @override
  int get hashCode {
    return Object.hash(objectId, label);
  }

}
final class _CUIMarkerInfo extends ffi.Struct {
  external _CDgisObjectId objectId;

  external _COptional_CString label;

}
// MARK: - UIMarkerInfo <-> _CUIMarkerInfo

extension _CUIMarkerInfoToDart on _CUIMarkerInfo {
  UIMarkerInfo _toDart() {
    return UIMarkerInfo(
      objectId: this.objectId._toDart(),
      label: this.label._toDart()
    );
  }
}

extension _DartTo_CUIMarkerInfo on UIMarkerInfo {
  _CUIMarkerInfo _copyFromDartTo_CUIMarkerInfo() {
    final res = _CUIMarkerInfoMakeDefault();
    res.objectId = this.objectId._copyFromDartTo_CDgisObjectId();
    res.label = this.label._copyFromDartTo_COptional_CString();
    return res;
  }
}
extension _CUIMarkerInfoRelease on _CUIMarkerInfo {
  void _releaseIntermediate() {
    label._releaseIntermediate();
  }
}

// MARK: - WorkStatus

/** Статус работы. */
class WorkStatus {
  /** Открыто ли сейчас. */
  final bool isOpen;
  /**
   Текстовое описание.
   Например, "Открыто до 21:00", "Круглосуточно", "Закроется через 5 минут".
  */
  final String description;

  const WorkStatus({
    required this.isOpen,
    required this.description
  });

  WorkStatus copyWith({
    bool? isOpen,
    String? description
  }) {
    return WorkStatus(
      isOpen: isOpen ?? this.isOpen,
      description: description ?? this.description
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is WorkStatus &&
    other.runtimeType == runtimeType &&
    other.isOpen == isOpen &&
    other.description == description;

  @override
  int get hashCode {
    return Object.hash(isOpen, description);
  }

}
final class _CWorkStatus extends ffi.Struct {
  @ffi.Bool()
  external bool isOpen;

  external _CString description;

}
// MARK: - WorkStatus <-> _CWorkStatus

extension _CWorkStatusToDart on _CWorkStatus {
  WorkStatus _toDart() {
    return WorkStatus(
      isOpen: this.isOpen,
      description: this.description._toDart()
    );
  }
}

extension _DartTo_CWorkStatus on WorkStatus {
  _CWorkStatus _copyFromDartTo_CWorkStatus() {
    final res = _CWorkStatusMakeDefault();
    res.isOpen = this.isOpen;
    res.description = this.description._copyFromDartTo_CString();
    return res;
  }
}
extension _CWorkStatusRelease on _CWorkStatus {
  void _releaseIntermediate() {
    description._releaseIntermediate();
  }
}

// MARK: - AddressAdmDiv

/** Объект административного деления. */
class AddressAdmDiv {
  /**
   Тип административной единицы. Один из следующих:
   * country — страна
   * region — регион (область/край/республика и т.п.)
   * district_area — район области
   * city — город
   * settlement — населённый пункт
   * division — округ
   * district — район
   * living_area — жилмассив, микрорайон
   * place — место
  */
  final String type;
  final String name;

  const AddressAdmDiv({
    required this.type,
    required this.name
  });

  AddressAdmDiv copyWith({
    String? type,
    String? name
  }) {
    return AddressAdmDiv(
      type: type ?? this.type,
      name: name ?? this.name
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is AddressAdmDiv &&
    other.runtimeType == runtimeType &&
    other.type == type &&
    other.name == name;

  @override
  int get hashCode {
    return Object.hash(type, name);
  }

}
final class _CAddressAdmDiv extends ffi.Struct {
  external _CString type;

  external _CString name;

}
// MARK: - AddressAdmDiv <-> _CAddressAdmDiv

extension _CAddressAdmDivToDart on _CAddressAdmDiv {
  AddressAdmDiv _toDart() {
    return AddressAdmDiv(
      type: this.type._toDart(),
      name: this.name._toDart()
    );
  }
}

extension _DartTo_CAddressAdmDiv on AddressAdmDiv {
  _CAddressAdmDiv _copyFromDartTo_CAddressAdmDiv() {
    final res = _CAddressAdmDivMakeDefault();
    res.type = this.type._copyFromDartTo_CString();
    res.name = this.name._copyFromDartTo_CString();
    return res;
  }
}
extension _CAddressAdmDivRelease on _CAddressAdmDiv {
  void _releaseIntermediate() {
    type._releaseIntermediate();
    name._releaseIntermediate();
  }
}

// MARK: - AddressStreet

/** Обычный адрес, есть улица и номер дома. */
class AddressStreet {
  /** Название улицы. */
  final String street;
  /** Номер дома, включая дроби, корпусы и буквенные обозначения. */
  final String number;
  /** Код ФИАС улицы. */
  final String? fiasCode;

  const AddressStreet({
    required this.street,
    required this.number,
    required this.fiasCode
  });

  AddressStreet copyWith({
    String? street,
    String? number,
    Optional<String?>? fiasCode
  }) {
    return AddressStreet(
      street: street ?? this.street,
      number: number ?? this.number,
      fiasCode: fiasCode != null ? fiasCode.value : this.fiasCode
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is AddressStreet &&
    other.runtimeType == runtimeType &&
    other.street == street &&
    other.number == number &&
    other.fiasCode == fiasCode;

  @override
  int get hashCode {
    return Object.hash(street, number, fiasCode);
  }

}
final class _CAddressStreet extends ffi.Struct {
  external _CString street;

  external _CString number;

  external _COptional_CString fiasCode;

}
// MARK: - AddressStreet <-> _CAddressStreet

extension _CAddressStreetToDart on _CAddressStreet {
  AddressStreet _toDart() {
    return AddressStreet(
      street: this.street._toDart(),
      number: this.number._toDart(),
      fiasCode: this.fiasCode._toDart()
    );
  }
}

extension _DartTo_CAddressStreet on AddressStreet {
  _CAddressStreet _copyFromDartTo_CAddressStreet() {
    final res = _CAddressStreetMakeDefault();
    res.street = this.street._copyFromDartTo_CString();
    res.number = this.number._copyFromDartTo_CString();
    res.fiasCode = this.fiasCode._copyFromDartTo_COptional_CString();
    return res;
  }
}
extension _CAddressStreetRelease on _CAddressStreet {
  void _releaseIntermediate() {
    street._releaseIntermediate();
    number._releaseIntermediate();
    fiasCode._releaseIntermediate();
  }
}

// MARK: - AddressNumber

/** В некоторых населённых пунктах обозначается только номер дома, без улицы (например, Краснообск). */
class AddressNumber {
  /** Номер дома, включая дроби и буквенные обозначения. Возможно, имя собственное, если так принято. */
  final String number;
  /** Код ФИАС улицы. */
  final String? fiasCode;

  const AddressNumber({
    required this.number,
    required this.fiasCode
  });

  AddressNumber copyWith({
    String? number,
    Optional<String?>? fiasCode
  }) {
    return AddressNumber(
      number: number ?? this.number,
      fiasCode: fiasCode != null ? fiasCode.value : this.fiasCode
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is AddressNumber &&
    other.runtimeType == runtimeType &&
    other.number == number &&
    other.fiasCode == fiasCode;

  @override
  int get hashCode {
    return Object.hash(number, fiasCode);
  }

}
final class _CAddressNumber extends ffi.Struct {
  external _CString number;

  external _COptional_CString fiasCode;

}
// MARK: - AddressNumber <-> _CAddressNumber

extension _CAddressNumberToDart on _CAddressNumber {
  AddressNumber _toDart() {
    return AddressNumber(
      number: this.number._toDart(),
      fiasCode: this.fiasCode._toDart()
    );
  }
}

extension _DartTo_CAddressNumber on AddressNumber {
  _CAddressNumber _copyFromDartTo_CAddressNumber() {
    final res = _CAddressNumberMakeDefault();
    res.number = this.number._copyFromDartTo_CString();
    res.fiasCode = this.fiasCode._copyFromDartTo_COptional_CString();
    return res;
  }
}
extension _CAddressNumberRelease on _CAddressNumber {
  void _releaseIntermediate() {
    number._releaseIntermediate();
    fiasCode._releaseIntermediate();
  }
}

// MARK: - AddressLocation

/** Применяется для компонентов, которые тяжело описать конкретным адресом. */
class AddressLocation {
  /** Словесное описание местоположения строения. */
  final String comment;

  const AddressLocation(this.comment);

  AddressLocation copyWith({
    String? comment
  }) {
    return AddressLocation(
      comment ?? this.comment
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is AddressLocation &&
    other.runtimeType == runtimeType &&
    other.comment == comment;

  @override
  int get hashCode {
    return comment.hashCode;
  }

}
final class _CAddressLocation extends ffi.Struct {
  external _CString comment;

}
// MARK: - AddressLocation <-> _CAddressLocation

extension _CAddressLocationToDart on _CAddressLocation {
  AddressLocation _toDart() {
    return AddressLocation(
      this.comment._toDart()
    );
  }
}

extension _DartTo_CAddressLocation on AddressLocation {
  _CAddressLocation _copyFromDartTo_CAddressLocation() {
    final res = _CAddressLocationMakeDefault();
    res.comment = this.comment._copyFromDartTo_CString();
    return res;
  }
}
extension _CAddressLocationRelease on _CAddressLocation {
  void _releaseIntermediate() {
    comment._releaseIntermediate();
  }
}

// MARK: - AddressComponent

/** Компонент адреса: улица, номер дома или словесное описание местоположения. */
final class AddressComponent {
  final Object? _value;
  final int _index;

  AddressComponent._raw(this._value, this._index);

  AddressComponent.streetAddress(AddressStreet value) : this._raw(value, 0);
  AddressComponent.number(AddressNumber value) : this._raw(value, 1);
  AddressComponent.location(AddressLocation value) : this._raw(value, 2);

  bool get isStreetAddress => this._index == 0;
  AddressStreet? get asStreetAddress => this.isStreetAddress ? this._value as AddressStreet : null;

  bool get isNumber => this._index == 1;
  AddressNumber? get asNumber => this.isNumber ? this._value as AddressNumber : null;

  bool get isLocation => this._index == 2;
  AddressLocation? get asLocation => this.isLocation ? this._value as AddressLocation : null;

  T match<T>({
    required T Function(AddressStreet value) streetAddress,
    required T Function(AddressNumber value) number,
    required T Function(AddressLocation value) location,
  }) {
    return switch (this._index) {
      0 => streetAddress(this._value as AddressStreet),
      1 => number(this._value as AddressNumber),
      2 => location(this._value as AddressLocation),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "AddressComponent(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is AddressComponent &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CAddressComponentImpl extends ffi.Union {
  external _CAddressStreet _streetAddress;
  external _CAddressNumber _number;
  external _CAddressLocation _location;
}

final class _CAddressComponent extends ffi.Struct {
  external _CAddressComponentImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CAddressComponentBasicFunctions on _CAddressComponent {
  void _releaseIntermediate() {
    _CAddressComponent_release(this);
  }
}
	
// MARK: - AddressComponent <-> CAddressComponent

extension _CAddressComponentToDart on _CAddressComponent {
  AddressComponent _toDart() {
    return switch (this._index) {
      0 => AddressComponent.streetAddress(this._impl._streetAddress._toDart()),
      1 => AddressComponent.number(this._impl._number._toDart()),
      2 => AddressComponent.location(this._impl._location._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CAddressComponent on AddressComponent {
  _CAddressComponent _copyFromDartTo_CAddressComponent() {
    var res = _CAddressComponentMakeDefault();
    this.match<void>(
      streetAddress: (AddressStreet value) {
        res._impl._streetAddress = value._copyFromDartTo_CAddressStreet();
        res._index = 0;
      },
      number: (AddressNumber value) {
        res._impl._number = value._copyFromDartTo_CAddressNumber();
        res._index = 1;
      },
      location: (AddressLocation value) {
        res._impl._location = value._copyFromDartTo_CAddressLocation();
        res._index = 2;
      },
    );
    return res;
  }
}

// MARK: - List<AddressAdmDiv> <-> _CArray_CAddressAdmDiv

final class _CArray_CAddressAdmDiv extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CAddressAdmDivToDart on _CArray_CAddressAdmDiv {
  List<AddressAdmDiv> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CAddressAdmDiv on List<AddressAdmDiv> {
  _CArray_CAddressAdmDiv _copyFromDartTo_CArray_CAddressAdmDiv() {
    final cArray = _CArray_CAddressAdmDivmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CAddressAdmDiv();
        _CArray_CAddressAdmDivaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CAddressAdmDivBasicFunctions on _CArray_CAddressAdmDiv {
  void _releaseIntermediate() {
    _CArray_CAddressAdmDiv_release(this);
  }

  static final _listToFill = <AddressAdmDiv>[];

  static void _iterate(_CAddressAdmDiv item) {
    _listToFill.add(item._toDart());
  }

  List<AddressAdmDiv> _fillFromC() {
    _forEach_CArray_CAddressAdmDiv(this, ffi.Pointer.fromFunction<ffi.Void Function(_CAddressAdmDiv)>(_iterate));
    final result = List<AddressAdmDiv>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - List<AddressComponent> <-> _CArray_CAddressComponent

final class _CArray_CAddressComponent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CAddressComponentToDart on _CArray_CAddressComponent {
  List<AddressComponent> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CAddressComponent on List<AddressComponent> {
  _CArray_CAddressComponent _copyFromDartTo_CArray_CAddressComponent() {
    final cArray = _CArray_CAddressComponentmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CAddressComponent();
        _CArray_CAddressComponentaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CAddressComponentBasicFunctions on _CArray_CAddressComponent {
  void _releaseIntermediate() {
    _CArray_CAddressComponent_release(this);
  }

  static final _listToFill = <AddressComponent>[];

  static void _iterate(_CAddressComponent item) {
    _listToFill.add(item._toDart());
  }

  List<AddressComponent> _fillFromC() {
    _forEach_CArray_CAddressComponent(this, ffi.Pointer.fromFunction<ffi.Void Function(_CAddressComponent)>(_iterate));
    final result = List<AddressComponent>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - Address

/** Адрес в виде набора отдельных компонентов. */
class Address {
  /** Набор объектов административного деления, в которых находится описываемый объект. */
  final List<AddressAdmDiv> drillDown;
  /** Полный адрес объекта может содержать несколько отдельных адресных компонент. */
  final List<AddressComponent> components;
  /** Название здания. */
  final String? buildingName;
  /** Уникальный идентификатор здания. */
  final BuildingId? buildingId;
  /** Почтовый индекс. */
  final String? postCode;
  /** Уникальный почтовый код здания. */
  final String? buildingCode;
  /** Код ФИАС объекта. */
  final String? fiasCode;
  /**
   Комментарий к адресу.
   Пример: "301 офис; 9 этаж"
  */
  final String? addressComment;

  const Address({
    required this.drillDown,
    required this.components,
    required this.buildingName,
    required this.buildingId,
    required this.postCode,
    required this.buildingCode,
    required this.fiasCode,
    required this.addressComment
  });

  Address copyWith({
    List<AddressAdmDiv>? drillDown,
    List<AddressComponent>? components,
    Optional<String?>? buildingName,
    Optional<BuildingId?>? buildingId,
    Optional<String?>? postCode,
    Optional<String?>? buildingCode,
    Optional<String?>? fiasCode,
    Optional<String?>? addressComment
  }) {
    return Address(
      drillDown: drillDown ?? this.drillDown,
      components: components ?? this.components,
      buildingName: buildingName != null ? buildingName.value : this.buildingName,
      buildingId: buildingId != null ? buildingId.value : this.buildingId,
      postCode: postCode != null ? postCode.value : this.postCode,
      buildingCode: buildingCode != null ? buildingCode.value : this.buildingCode,
      fiasCode: fiasCode != null ? fiasCode.value : this.fiasCode,
      addressComment: addressComment != null ? addressComment.value : this.addressComment
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Address &&
    other.runtimeType == runtimeType &&
    other.drillDown == drillDown &&
    other.components == components &&
    other.buildingName == buildingName &&
    other.buildingId == buildingId &&
    other.postCode == postCode &&
    other.buildingCode == buildingCode &&
    other.fiasCode == fiasCode &&
    other.addressComment == addressComment;

  @override
  int get hashCode {
    return Object.hash(drillDown, components, buildingName, buildingId, postCode, buildingCode, fiasCode, addressComment);
  }

}
final class _CAddress extends ffi.Struct {
  external _CArray_CAddressAdmDiv drillDown;

  external _CArray_CAddressComponent components;

  external _COptional_CString buildingName;

  external _COptional_CBuildingId buildingId;

  external _COptional_CString postCode;

  external _COptional_CString buildingCode;

  external _COptional_CString fiasCode;

  external _COptional_CString addressComment;

}
// MARK: - Address <-> _CAddress

extension _CAddressToDart on _CAddress {
  Address _toDart() {
    return Address(
      drillDown: this.drillDown._toDart(),
      components: this.components._toDart(),
      buildingName: this.buildingName._toDart(),
      buildingId: this.buildingId._toDart(),
      postCode: this.postCode._toDart(),
      buildingCode: this.buildingCode._toDart(),
      fiasCode: this.fiasCode._toDart(),
      addressComment: this.addressComment._toDart()
    );
  }
}

extension _DartTo_CAddress on Address {
  _CAddress _copyFromDartTo_CAddress() {
    final res = _CAddressMakeDefault();
    res.drillDown = this.drillDown._copyFromDartTo_CArray_CAddressAdmDiv();
    res.components = this.components._copyFromDartTo_CArray_CAddressComponent();
    res.buildingName = this.buildingName._copyFromDartTo_COptional_CString();
    res.buildingId = this.buildingId._copyFromDartTo_COptional_CBuildingId();
    res.postCode = this.postCode._copyFromDartTo_COptional_CString();
    res.buildingCode = this.buildingCode._copyFromDartTo_COptional_CString();
    res.fiasCode = this.fiasCode._copyFromDartTo_COptional_CString();
    res.addressComment = this.addressComment._copyFromDartTo_COptional_CString();
    return res;
  }
}
extension _CAddressRelease on _CAddress {
  void _releaseIntermediate() {
    drillDown._releaseIntermediate();
    components._releaseIntermediate();
    buildingName._releaseIntermediate();
    postCode._releaseIntermediate();
    buildingCode._releaseIntermediate();
    fiasCode._releaseIntermediate();
    addressComment._releaseIntermediate();
  }
}

// MARK: - DirectoryObject

/** Объект справочника. */
class DirectoryObject implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Тип объекта.
   Может быть несколько, например, ТЦ Сан Сити - филиал организации и здание одновременно.
   Первый тип в этом списке - основной.
  */
  List<ObjectType> get types {
    _CArray_CObjectType res = _CDirectoryObject_types(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Заголовок объекта. */
  String get title {
    _CString res = _CDirectoryObject_title(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Дополнительная информация заголовка
   Пример: "(кв. 1-12)"
  */
  String get titleAddition {
    _CString res = _CDirectoryObject_titleAddition(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Подзаголовок объекта.
  
   - Note: при отсутствии может быть пустой строкой
  */
  String get subtitle {
    _CString res = _CDirectoryObject_subtitle(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Описание объекта. */
  String get description {
    _CString res = _CDirectoryObject_description(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Стабильный числовой идентификатор объекта. */
  DgisObjectId? get id {
    _COptional_CDgisObjectId res = _CDirectoryObject_id(_CDirectoryObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Точка объекта, где следует разместить маркер. */
  GeoPointWithElevation? get markerPosition {
    _COptional_CGeoPointWithElevation res = _CDirectoryObject_markerPosition(_CDirectoryObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Адрес объекта в виде набора компонент. */
  Address? get address {
    _COptional_CAddress res = _CDirectoryObject_address(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Дополнительные атрибуты объекта. */
  List<Attribute> get attributes {
    _CArray_CAttribute res = _CDirectoryObject_attributes(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Контекстные дополнительные атрибуты объекта. */
  List<Attribute> get contextAttributes {
    _CArray_CAttribute res = _CDirectoryObject_contextAttributes(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Сдвиг локального времени объекта относительно UTC в секундах в текущий момент. */
  Duration? get timeZoneOffset {
    _COptional_CTimeInterval res = _CDirectoryObject_timeZoneOffset(_CDirectoryObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Время работы объекта. */
  OpeningHours? get openingHours {
    _COptional_COpeningHours res = _CDirectoryObject_openingHours(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Контакты объекта. */
  List<ContactInfo> get contactInfos {
    _CArray_CContactInfo res = _CDirectoryObject_contactInfos(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Отзывы. */
  Reviews? get reviews {
    _COptional_CReviews res = _CDirectoryObject_reviews(_CDirectoryObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Дополнительная информация о парковке. */
  ParkingInfo? get parkingInfo {
    _COptional_CParkingInfo res = _CDirectoryObject_parkingInfo(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Статус работы. */
  WorkStatus? get workStatus {
    _COptional_CWorkStatus res = _CDirectoryObject_workStatus(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Идентификатор этажа, на котором расположен объект. */
  LevelId? get levelId {
    _COptional_CLevelId res = _CDirectoryObject_levelId(_CDirectoryObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Информация об этажных планах здания. */
  BuildingLevels? get buildingLevels {
    _COptional_CBuildingLevels res = _CDirectoryObject_buildingLevels(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Информация о входах. */
  List<EntranceInfo> get entrances {
    _CArray_CEntranceInfo res = _CDirectoryObject_entrances(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Данные о лицензии организации. */
  TradeLicense? get tradeLicense {
    _COptional_CTradeLicense res = _CDirectoryObject_tradeLicense(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Информация о здании. */
  BuildingInfo get buildingInfo {
    _CBuildingInfo res = _CDirectoryObject_buildingInfo(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Атрибуты для электрозаправки. */
  ChargingStation? get chargingStation {
    _COptional_CChargingStation res = _CDirectoryObject_chargingStation(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Идентификаторы рубрик. */
  List<RubricId> get rubricIds {
    _CArray_CRubricId res = _CDirectoryObject_rubricIds(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Информация об организации. */
  OrgInfo? get orgInfo {
    _COptional_COrgInfo res = _CDirectoryObject_orgInfo(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Связанные в объединённую карточку объекты. */
  List<GroupItem> get group {
    _CArray_CGroupItem res = _CDirectoryObject_group(_CDirectoryObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CDirectoryObject_releasePtr);

  DirectoryObject._raw(this._self);
  factory DirectoryObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = DirectoryObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DirectoryObject &&
    other.runtimeType == runtimeType &&
    _CDirectoryObject_cg_objectIdentifier(this._self) == _CDirectoryObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CDirectoryObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: DirectoryObject: Methods

  /** Cтроковое представление адреса, отформатированное в соответствии с указанным требованием к длине. */
  FormattedAddress? formattedAddress(
    FormattingType type
  )  {
    var _a1 = type._copyFromDartTo_CFormattingType();
    _COptional_CFormattedAddress res = _CDirectoryObject_formattedAddress_CFormattingType(_CDirectoryObjectMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - DirectoryObject <-> CDirectoryObject

final class _CDirectoryObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDirectoryObjectBasicFunctions on _CDirectoryObject {
  void _releaseIntermediate() {
    _CDirectoryObject_release(_impl);
  }

  _CDirectoryObject _retain() {
    return _CDirectoryObject_retain(_impl);
  }
}

extension _CDirectoryObjectToDart on _CDirectoryObject {
  DirectoryObject _toDart() {
    return DirectoryObject._create(_retain()._impl);
  }
}


extension _DartToCDirectoryObject on DirectoryObject {
  _CDirectoryObject _copyFromDartTo_CDirectoryObject() {
    return (_CDirectoryObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<ObjectType> <-> _CArray_CObjectType

final class _CArray_CObjectType extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CObjectTypeToDart on _CArray_CObjectType {
  List<ObjectType> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CObjectType on List<ObjectType> {
  _CArray_CObjectType _copyFromDartTo_CArray_CObjectType() {
    final cArray = _CArray_CObjectTypemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CObjectType();
        _CArray_CObjectTypeaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CObjectTypeBasicFunctions on _CArray_CObjectType {
  void _releaseIntermediate() {
    _CArray_CObjectType_release(this);
  }

  static final _listToFill = <ObjectType>[];

  static void _iterate(_CObjectType item) {
    _listToFill.add(item._toDart());
  }

  List<ObjectType> _fillFromC() {
    _forEach_CArray_CObjectType(this, ffi.Pointer.fromFunction<ffi.Void Function(_CObjectType)>(_iterate));
    final result = List<ObjectType>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - GeoPointWithElevation? <-> _COptional_CGeoPointWithElevation

final class _COptional_CGeoPointWithElevation extends ffi.Struct {
  
  external _CGeoPointWithElevation value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CGeoPointWithElevationBasicFunctions on _COptional_CGeoPointWithElevation {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CGeoPointWithElevationToDart on _COptional_CGeoPointWithElevation {
  GeoPointWithElevation? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CGeoPointWithElevation on GeoPointWithElevation? {
  _COptional_CGeoPointWithElevation _copyFromDartTo_COptional_CGeoPointWithElevation() {
    final cOptional = _COptional_CGeoPointWithElevationMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CGeoPointWithElevation();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Address? <-> _COptional_CAddress

final class _COptional_CAddress extends ffi.Struct {
  
  external _CAddress value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CAddressBasicFunctions on _COptional_CAddress {
  void _releaseIntermediate() {
    _COptional_CAddress_release(this);
  }
}

extension _COptional_CAddressToDart on _COptional_CAddress {
  Address? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CAddress on Address? {
  _COptional_CAddress _copyFromDartTo_COptional_CAddress() {
    final cOptional = _COptional_CAddressMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CAddress();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<Attribute> <-> _CArray_CAttribute

final class _CArray_CAttribute extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CAttributeToDart on _CArray_CAttribute {
  List<Attribute> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CAttribute on List<Attribute> {
  _CArray_CAttribute _copyFromDartTo_CArray_CAttribute() {
    final cArray = _CArray_CAttributemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CAttribute();
        _CArray_CAttributeaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CAttributeBasicFunctions on _CArray_CAttribute {
  void _releaseIntermediate() {
    _CArray_CAttribute_release(this);
  }

  static final _listToFill = <Attribute>[];

  static void _iterate(_CAttribute item) {
    _listToFill.add(item._toDart());
  }

  List<Attribute> _fillFromC() {
    _forEach_CArray_CAttribute(this, ffi.Pointer.fromFunction<ffi.Void Function(_CAttribute)>(_iterate));
    final result = List<Attribute>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - FormattedAddress? <-> _COptional_CFormattedAddress

final class _COptional_CFormattedAddress extends ffi.Struct {
  
  external _CFormattedAddress value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CFormattedAddressBasicFunctions on _COptional_CFormattedAddress {
  void _releaseIntermediate() {
    _COptional_CFormattedAddress_release(this);
  }
}

extension _COptional_CFormattedAddressToDart on _COptional_CFormattedAddress {
  FormattedAddress? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CFormattedAddress on FormattedAddress? {
  _COptional_CFormattedAddress _copyFromDartTo_COptional_CFormattedAddress() {
    final cOptional = _COptional_CFormattedAddressMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CFormattedAddress();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Duration? <-> _COptional_CTimeInterval

final class _COptional_CTimeInterval extends ffi.Struct {
  
  external _CTimeInterval value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CTimeIntervalBasicFunctions on _COptional_CTimeInterval {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CTimeIntervalToDart on _COptional_CTimeInterval {
  Duration? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CTimeInterval on Duration? {
  _COptional_CTimeInterval _copyFromDartTo_COptional_CTimeInterval() {
    final cOptional = _COptional_CTimeIntervalMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CTimeInterval();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - OpeningHours? <-> _COptional_COpeningHours

final class _COptional_COpeningHours extends ffi.Struct {
  
  external _COpeningHours value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_COpeningHoursBasicFunctions on _COptional_COpeningHours {
  void _releaseIntermediate() {
    _COptional_COpeningHours_release(this);
  }
}

extension _COptional_COpeningHoursToDart on _COptional_COpeningHours {
  OpeningHours? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_COpeningHours on OpeningHours? {
  _COptional_COpeningHours _copyFromDartTo_COptional_COpeningHours() {
    final cOptional = _COptional_COpeningHoursMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_COpeningHours();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<ContactInfo> <-> _CArray_CContactInfo

final class _CArray_CContactInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CContactInfoToDart on _CArray_CContactInfo {
  List<ContactInfo> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CContactInfo on List<ContactInfo> {
  _CArray_CContactInfo _copyFromDartTo_CArray_CContactInfo() {
    final cArray = _CArray_CContactInfomakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CContactInfo();
        _CArray_CContactInfoaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CContactInfoBasicFunctions on _CArray_CContactInfo {
  void _releaseIntermediate() {
    _CArray_CContactInfo_release(this);
  }

  static final _listToFill = <ContactInfo>[];

  static void _iterate(_CContactInfo item) {
    _listToFill.add(item._toDart());
  }

  List<ContactInfo> _fillFromC() {
    _forEach_CArray_CContactInfo(this, ffi.Pointer.fromFunction<ffi.Void Function(_CContactInfo)>(_iterate));
    final result = List<ContactInfo>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - Reviews? <-> _COptional_CReviews

final class _COptional_CReviews extends ffi.Struct {
  
  external _CReviews value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CReviewsBasicFunctions on _COptional_CReviews {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CReviewsToDart on _COptional_CReviews {
  Reviews? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CReviews on Reviews? {
  _COptional_CReviews _copyFromDartTo_COptional_CReviews() {
    final cOptional = _COptional_CReviewsMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CReviews();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - ParkingInfo? <-> _COptional_CParkingInfo

final class _COptional_CParkingInfo extends ffi.Struct {
  
  external _CParkingInfo value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CParkingInfoBasicFunctions on _COptional_CParkingInfo {
  void _releaseIntermediate() {
    _COptional_CParkingInfo_release(this);
  }
}

extension _COptional_CParkingInfoToDart on _COptional_CParkingInfo {
  ParkingInfo? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CParkingInfo on ParkingInfo? {
  _COptional_CParkingInfo _copyFromDartTo_COptional_CParkingInfo() {
    final cOptional = _COptional_CParkingInfoMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CParkingInfo();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - WorkStatus? <-> _COptional_CWorkStatus

final class _COptional_CWorkStatus extends ffi.Struct {
  
  external _CWorkStatus value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CWorkStatusBasicFunctions on _COptional_CWorkStatus {
  void _releaseIntermediate() {
    _COptional_CWorkStatus_release(this);
  }
}

extension _COptional_CWorkStatusToDart on _COptional_CWorkStatus {
  WorkStatus? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CWorkStatus on WorkStatus? {
  _COptional_CWorkStatus _copyFromDartTo_COptional_CWorkStatus() {
    final cOptional = _COptional_CWorkStatusMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CWorkStatus();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - LevelId? <-> _COptional_CLevelId

final class _COptional_CLevelId extends ffi.Struct {
  
  external _CLevelId value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CLevelIdBasicFunctions on _COptional_CLevelId {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CLevelIdToDart on _COptional_CLevelId {
  LevelId? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CLevelId on LevelId? {
  _COptional_CLevelId _copyFromDartTo_COptional_CLevelId() {
    final cOptional = _COptional_CLevelIdMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CLevelId();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<EntranceInfo> <-> _CArray_CEntranceInfo

final class _CArray_CEntranceInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CEntranceInfoToDart on _CArray_CEntranceInfo {
  List<EntranceInfo> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CEntranceInfo on List<EntranceInfo> {
  _CArray_CEntranceInfo _copyFromDartTo_CArray_CEntranceInfo() {
    final cArray = _CArray_CEntranceInfomakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CEntranceInfo();
        _CArray_CEntranceInfoaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CEntranceInfoBasicFunctions on _CArray_CEntranceInfo {
  void _releaseIntermediate() {
    _CArray_CEntranceInfo_release(this);
  }

  static final _listToFill = <EntranceInfo>[];

  static void _iterate(_CEntranceInfo item) {
    _listToFill.add(item._toDart());
  }

  List<EntranceInfo> _fillFromC() {
    _forEach_CArray_CEntranceInfo(this, ffi.Pointer.fromFunction<ffi.Void Function(_CEntranceInfo)>(_iterate));
    final result = List<EntranceInfo>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - TradeLicense? <-> _COptional_CTradeLicense

final class _COptional_CTradeLicense extends ffi.Struct {
  
  external _CTradeLicense value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CTradeLicenseBasicFunctions on _COptional_CTradeLicense {
  void _releaseIntermediate() {
    _COptional_CTradeLicense_release(this);
  }
}

extension _COptional_CTradeLicenseToDart on _COptional_CTradeLicense {
  TradeLicense? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CTradeLicense on TradeLicense? {
  _COptional_CTradeLicense _copyFromDartTo_COptional_CTradeLicense() {
    final cOptional = _COptional_CTradeLicenseMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CTradeLicense();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - ChargingStation? <-> _COptional_CChargingStation

final class _COptional_CChargingStation extends ffi.Struct {
  
  external _CChargingStation value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CChargingStationBasicFunctions on _COptional_CChargingStation {
  void _releaseIntermediate() {
    _COptional_CChargingStation_release(this);
  }
}

extension _COptional_CChargingStationToDart on _COptional_CChargingStation {
  ChargingStation? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CChargingStation on ChargingStation? {
  _COptional_CChargingStation _copyFromDartTo_COptional_CChargingStation() {
    final cOptional = _COptional_CChargingStationMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CChargingStation();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - OrgInfo? <-> _COptional_COrgInfo

final class _COptional_COrgInfo extends ffi.Struct {
  
  external _COrgInfo value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_COrgInfoBasicFunctions on _COptional_COrgInfo {
  void _releaseIntermediate() {
    _COptional_COrgInfo_release(this);
  }
}

extension _COptional_COrgInfoToDart on _COptional_COrgInfo {
  OrgInfo? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_COrgInfo on OrgInfo? {
  _COptional_COrgInfo _copyFromDartTo_COptional_COrgInfo() {
    final cOptional = _COptional_COrgInfoMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_COrgInfo();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<GroupItem> <-> _CArray_CGroupItem

final class _CArray_CGroupItem extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CGroupItemToDart on _CArray_CGroupItem {
  List<GroupItem> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CGroupItem on List<GroupItem> {
  _CArray_CGroupItem _copyFromDartTo_CArray_CGroupItem() {
    final cArray = _CArray_CGroupItemmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CGroupItem();
        _CArray_CGroupItemaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CGroupItemBasicFunctions on _CArray_CGroupItem {
  void _releaseIntermediate() {
    _CArray_CGroupItem_release(this);
  }

  static final _listToFill = <GroupItem>[];

  static void _iterate(_CGroupItem item) {
    _listToFill.add(item._toDart());
  }

  List<GroupItem> _fillFromC() {
    _forEach_CArray_CGroupItem(this, ffi.Pointer.fromFunction<ffi.Void Function(_CGroupItem)>(_iterate));
    final result = List<GroupItem>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - Page

/** Страница результатов поиска. */
class Page implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Непустой набор объектов справочника этой страницы. */
  List<DirectoryObject> get items {
    _CArray_CDirectoryObject res = _CPage_items(_CPageMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CPage_releasePtr);

  Page._raw(this._self);
  factory Page._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Page._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Page &&
    other.runtimeType == runtimeType &&
    _CPage_cg_objectIdentifier(this._self) == _CPage_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPage_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: Page: Methods

  /**
   Получить предыдущую страницу результатов.
  
   - Returns: future, резолвящаяся в ненулевой указатель на предыдущую страницу, если страница успешно получена
   future, резолвящаяся в нулевой указатель, если предыдущая страница отсутствует
   exceptional future, если произошла ошибка при получении страницы
  */
  CancelableOperation<Page?> fetchPrevPage()  {
    _CFuture_COptional_CPage res = _CPage_fetchPrevPage(_CPageMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Получить следующую страницу результатов.
  
   - Returns: future, резолвящаяся в ненулевой указатель на следующую страницу, если страница успешно получена
   future, резолвящаяся в нулевой указатель, если следующая страница отсутствует
   exceptional future, если произошла ошибка при получении страницы
  */
  CancelableOperation<Page?> fetchNextPage()  {
    _CFuture_COptional_CPage res = _CPage_fetchNextPage(_CPageMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - Page <-> CPage

final class _CPage extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPageBasicFunctions on _CPage {
  void _releaseIntermediate() {
    _CPage_release(_impl);
  }

  _CPage _retain() {
    return _CPage_retain(_impl);
  }
}

extension _CPageToDart on _CPage {
  Page _toDart() {
    return Page._create(_retain()._impl);
  }
}


extension _DartToCPage on Page {
  _CPage _copyFromDartTo_CPage() {
    return (_CPageMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<DirectoryObject> <-> _CArray_CDirectoryObject

final class _CArray_CDirectoryObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CDirectoryObjectToDart on _CArray_CDirectoryObject {
  List<DirectoryObject> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CDirectoryObject on List<DirectoryObject> {
  _CArray_CDirectoryObject _copyFromDartTo_CArray_CDirectoryObject() {
    final cArray = _CArray_CDirectoryObjectmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CDirectoryObject();
        _CArray_CDirectoryObjectaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CDirectoryObjectBasicFunctions on _CArray_CDirectoryObject {
  void _releaseIntermediate() {
    _CArray_CDirectoryObject_release(this);
  }

  static final _listToFill = <DirectoryObject>[];

  static void _iterate(_CDirectoryObject item) {
    _listToFill.add(item._toDart());
  }

  List<DirectoryObject> _fillFromC() {
    _forEach_CArray_CDirectoryObject(this, ffi.Pointer.fromFunction<ffi.Void Function(_CDirectoryObject)>(_iterate));
    final result = List<DirectoryObject>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - CancelableOperation<Page?> <-> _CFuture_COptional_CPage

final class _CFuture_COptional_CPage extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_COptional_CPage_Cancellable {
  final Completer<Page?> completer;
  final _CFuture_COptional_CPage _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_COptional_CPage, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_COptional_CPage_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_COptional_CPageBasicFunctions on _CFuture_COptional_CPage {
  void _releaseIntermediate() {
    _CFuture_COptional_CPage_release(this);
  }

  _CFuture_COptional_CPage _retain() {
    return _CFuture_COptional_CPage_retain(this);
  }
}

extension _CFuture_COptional_CPageToDart on _CFuture_COptional_CPage {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_COptional_CPage_Cancellable>{};

  static void valueFunction(_COptional_CPage cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<Page?> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<Page?>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CPage, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_COptional_CPageReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_COptional_CPage_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_COptional_CPage on CancelableOperation<Page?> {
  _CFuture_COptional_CPage _copyFromDartTo_CFuture_COptional_CPage() {
    return _CFuture_COptional_CPageMakeDefault();
  }
}
	
// MARK: - Page? <-> _COptional_CPage

final class _COptional_CPage extends ffi.Struct {
  
  external _CPage value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CPageBasicFunctions on _COptional_CPage {
  void _releaseIntermediate() {
    _COptional_CPage_release(this);
  }
}

extension _COptional_CPageToDart on _COptional_CPage {
  Page? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CPage on Page? {
  _COptional_CPage _copyFromDartTo_COptional_CPage() {
    final cOptional = _COptional_CPageMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CPage();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - CCancellable <-> _CCancellable

final class _CCancellable extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCancellableBasicFunctions on _CCancellable {
  void _releaseIntermediate() {
    _CCancellable_release(this);
  }

  _CCancellable _retain() {
    return _CCancellable_retain(this);
  }

  void _cancel() {
    _CCancellableCancel(this);
    this._releaseIntermediate();
  }
}
	
// MARK: - CError <-> _CError

final class _CError extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CErrorBasicFunctions on _CError {
  void _releaseIntermediate() {
    _CError_release(this);
  }
}

extension _CErrorToDart on _CError {
  NativeException _toDart() {
    final res = _CErrorGetDescription(_CErrorMakeDefault().._impl = _impl);
    return NativeException(res.toDartString());
  }
}

extension _DartTo_CError on NativeException {
  _CError _copyFromDartTo_CError() {
    _CString description = this.toString()._copyFromDartTo_CString();
    final res = _CErrorCreateWithDescription(description._getData());
    description._releaseIntermediate();
    return res;
  }
}
	
// MARK: - WidgetType

/** Тип виджета. */
enum WidgetType {
  /** Одиночный чекбокс. */
  checkbox(0),
  /** Группа элементов, каждый из которых может быть отмечен независимо или сгруппирован в */
  checkableItemGroup(1),
  /** Представление непрерывного или дискретного набора упорядоченных значений. */
  range(2),
  ;

  const WidgetType(this.rawValue);
  final int rawValue;

  static WidgetType getByValue(int value) {
    return WidgetType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CWidgetType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CWidgetTypeBasicFunctions on _CWidgetType {
  void _releaseIntermediate() {
  }
}

extension _CWidgetTypeToDart on _CWidgetType {
  WidgetType _toDart() {
    return WidgetType.getByValue(this.rawValue);
  }
}

extension _DartTo_CWidgetType on WidgetType {
  _CWidgetType _copyFromDartTo_CWidgetType() {
    return _CWidgetTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - Widget

/**
 Базовый класс, представляющий виджет для фильтрации поисковой выдачи.

 Виджеты возвращаются в результате поиска и предназначены для фильтрации или сортировки результата по определенным
 параметрам. Виджеты генерируются динамически для каждого результата поиска и могут отсутствовать для некоторых
 запросов. Виджет представляет один конкретный фильтр или их группу, объединённую общим признаком. Например, тип
 кухни в результатах поиска по запросу "Поесть".
*/
class Widget implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Получение типа виджета.
  
   - Returns: тип виджета.
  */
  WidgetType get type {
    _CWidgetType res = _CWidget_type(_CWidgetMakeDefault().._impl=_self);
    return res._toDart();
  }
  /**
   Получение заголовка виджета. Может отсутствовать.
  
   - Returns: заголовок виджета.
  */
  String? get caption {
    _COptional_CString res = _CWidget_caption(_CWidgetMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение списка фильтров, описывающих текущее состояние виджета. Может быть использован при
   формировании поискового запроса.
  
   - Returns: список фильтров.
  */
  List<DynamicFilter> get filters {
    _CArray_CDynamicFilter res = _CWidget_filters(_CWidgetMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CWidget_releasePtr);

  Widget._raw(this._self);
  factory Widget._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Widget._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Widget &&
    other.runtimeType == runtimeType &&
    _CWidget_cg_objectIdentifier(this._self) == _CWidget_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CWidget_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Widget <-> CWidget

final class _CWidget extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CWidgetBasicFunctions on _CWidget {
  void _releaseIntermediate() {
    _CWidget_release(_impl);
  }

  _CWidget _retain() {
    return _CWidget_retain(_impl);
  }
}

extension _CWidgetToDart on _CWidget {
  Widget _toDart() {
    final selector = _CWidget_cg_getSelector(this);
    switch (selector) {
      case 0:
        final res = Widget._create(_retain()._impl);
        return res;
      case 1:
        final res = Checkbox._create(_retain()._impl);
        return res;
      case 2:
        final res = CheckableItemsGroup._create(_retain()._impl);
        return res;
      case 3:
        final res = RangeWidget._create(_retain()._impl);
        return res;
      default: throw Exception("Unrecognized case index $selector");
    }
  }
}

extension _DartToCWidget on Widget {
  _CWidget _copyFromDartTo_CWidget() {
    return (_CWidgetMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Checkbox

/** Виджет-чекбокс. */
class Checkbox extends Widget implements ffi.Finalizable {
  /**
   Получение типа фильтра, который представляет виджет.
  
   - Returns: тип фильтра.
  */
  FilterType get filterType {
    _CFilterType res = _CCheckbox_filterType(_CCheckboxMakeDefault().._impl=_self);
    return res._toDart();
  }
  /**
   Получение текста подписи для "отмеченного" чекбокса.
  
   - Returns: текст подписи.
  */
  String? get checkedText {
    _COptional_CString res = _CCheckbox_checkedText(_CCheckboxMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение текста подписи для "неотмеченного" чекбокса.
  
   - Returns: текст подписи.
  */
  String? get uncheckedText {
    _COptional_CString res = _CCheckbox_uncheckedText(_CCheckboxMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение списка значений, по которым происходит фильтрация.
   Обычно одно значение.
  
   - Returns: список значений фильтров.
  */
  List<String> get values {
    _CArray_CString res = _CCheckbox_values(_CCheckboxMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение состояния виджета.
  
   - Returns: состояние виджета. True - элемент отмечен.
  */
  bool get isChecked {
    bool res = _CCheckbox_isChecked(_CCheckboxMakeDefault().._impl=_self);
    return res;
  }
  set isChecked(bool checked) {
    void res = _CCheckbox_setChecked_bool(_CCheckboxMakeDefault().._impl=_self, checked);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CCheckbox_releasePtr);

  Checkbox._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory Checkbox._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Checkbox._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Checkbox &&
    other.runtimeType == runtimeType &&
    _CCheckbox_cg_objectIdentifier(this._self) == _CCheckbox_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCheckbox_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Checkbox <-> CCheckbox

final class _CCheckbox extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCheckboxBasicFunctions on _CCheckbox {
  void _releaseIntermediate() {
    _CCheckbox_release(_impl);
  }

  _CCheckbox _retain() {
    return _CCheckbox_retain(_impl);
  }
}

extension _CCheckboxToDart on _CCheckbox {
  Checkbox _toDart() {
    return Checkbox._create(_retain()._impl);
  }
}


extension _DartToCCheckbox on Checkbox {
  _CCheckbox _copyFromDartTo_CCheckbox() {
    return (_CCheckboxMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<String> <-> _CArray_CString

final class _CArray_CString extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CStringToDart on _CArray_CString {
  List<String> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CString on List<String> {
  _CArray_CString _copyFromDartTo_CArray_CString() {
    final cArray = _CArray_CStringmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CString();
        _CArray_CStringaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CStringBasicFunctions on _CArray_CString {
  void _releaseIntermediate() {
    _CArray_CString_release(this);
  }

  static final _listToFill = <String>[];

  static void _iterate(_CString item) {
    _listToFill.add(item._toDart());
  }

  List<String> _fillFromC() {
    _forEach_CArray_CString(this, ffi.Pointer.fromFunction<ffi.Void Function(_CString)>(_iterate));
    final result = List<String>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - CheckableItemType

/** Тип отмечаемого элемента. */
enum CheckableItemType {
  /** Простой элемент. */
  simple(0),
  /** Набор элементов, работающих как радио-группа. */
  group(1),
  ;

  const CheckableItemType(this.rawValue);
  final int rawValue;

  static CheckableItemType getByValue(int value) {
    return CheckableItemType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CCheckableItemType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CCheckableItemTypeBasicFunctions on _CCheckableItemType {
  void _releaseIntermediate() {
  }
}

extension _CCheckableItemTypeToDart on _CCheckableItemType {
  CheckableItemType _toDart() {
    return CheckableItemType.getByValue(this.rawValue);
  }
}

extension _DartTo_CCheckableItemType on CheckableItemType {
  _CCheckableItemType _copyFromDartTo_CCheckableItemType() {
    return _CCheckableItemTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CheckableItem

/** Базовое представление отмечаемого элемента из CheckableItemsGroup. */
class CheckableItem implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Получение типа отмечаемого элемента.
  
   - Returns: тип получаемого элемента.
  */
  CheckableItemType get type {
    _CCheckableItemType res = _CCheckableItem_type(_CCheckableItemMakeDefault().._impl=_self);
    return res._toDart();
  }
  /**
   Получение списка фильтров, описывающих текущее состояние виджета. Может быть использован при
   формировании поискового запроса.
  
   - Returns: список фильтров.
  */
  FilterType get filterType {
    _CFilterType res = _CCheckableItem_filterType(_CCheckableItemMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CCheckableItem_releasePtr);

  CheckableItem._raw(this._self);
  factory CheckableItem._create(ffi.Pointer<ffi.Void> self) {
    final classObject = CheckableItem._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CheckableItem &&
    other.runtimeType == runtimeType &&
    _CCheckableItem_cg_objectIdentifier(this._self) == _CCheckableItem_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCheckableItem_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - CheckableItem <-> CCheckableItem

final class _CCheckableItem extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCheckableItemBasicFunctions on _CCheckableItem {
  void _releaseIntermediate() {
    _CCheckableItem_release(_impl);
  }

  _CCheckableItem _retain() {
    return _CCheckableItem_retain(_impl);
  }
}

extension _CCheckableItemToDart on _CCheckableItem {
  CheckableItem _toDart() {
    final selector = _CCheckableItem_cg_getSelector(this);
    switch (selector) {
      case 0:
        final res = CheckableItem._create(_retain()._impl);
        return res;
      case 1:
        final res = SimpleCheckableItem._create(_retain()._impl);
        return res;
      case 2:
        final res = GroupCheckableItem._create(_retain()._impl);
        return res;
      default: throw Exception("Unrecognized case index $selector");
    }
  }
}

extension _DartToCCheckableItem on CheckableItem {
  _CCheckableItem _copyFromDartTo_CCheckableItem() {
    return (_CCheckableItemMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CheckableGroupedItem

/** Единичный элемент из GroupCheckableItem. */
class CheckableGroupedItem implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Получение текстового описания элемента.
  
   - Returns: текстовое описание элемента.
  */
  String get text {
    _CString res = _CCheckableGroupedItem_text(_CCheckableGroupedItemMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение списка значений, по которым происходит фильтрация.
   Обычно одно значение.
  
   - Returns: список значений фильтров.
  */
  List<String> get values {
    _CArray_CString res = _CCheckableGroupedItem_values(_CCheckableGroupedItemMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение состояния элемента.
  
   - Returns: состояние элемента. True - элемент отмечен.
  */
  bool get isChecked {
    bool res = _CCheckableGroupedItem_isChecked(_CCheckableGroupedItemMakeDefault().._impl=_self);
    return res;
  }
  set isChecked(bool checked) {
    void res = _CCheckableGroupedItem_setChecked_bool(_CCheckableGroupedItemMakeDefault().._impl=_self, checked);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CCheckableGroupedItem_releasePtr);

  CheckableGroupedItem._raw(this._self);
  factory CheckableGroupedItem._create(ffi.Pointer<ffi.Void> self) {
    final classObject = CheckableGroupedItem._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CheckableGroupedItem &&
    other.runtimeType == runtimeType &&
    _CCheckableGroupedItem_cg_objectIdentifier(this._self) == _CCheckableGroupedItem_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCheckableGroupedItem_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - CheckableGroupedItem <-> CCheckableGroupedItem

final class _CCheckableGroupedItem extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCheckableGroupedItemBasicFunctions on _CCheckableGroupedItem {
  void _releaseIntermediate() {
    _CCheckableGroupedItem_release(_impl);
  }

  _CCheckableGroupedItem _retain() {
    return _CCheckableGroupedItem_retain(_impl);
  }
}

extension _CCheckableGroupedItemToDart on _CCheckableGroupedItem {
  CheckableGroupedItem _toDart() {
    return CheckableGroupedItem._create(_retain()._impl);
  }
}


extension _DartToCCheckableGroupedItem on CheckableGroupedItem {
  _CCheckableGroupedItem _copyFromDartTo_CCheckableGroupedItem() {
    return (_CCheckableGroupedItemMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CheckableItemsGroup

/** Виджет для представления группы отмечаемых элементов. */
class CheckableItemsGroup extends Widget implements ffi.Finalizable {
  /**
   Получение группы элементов виджета.
  
   - Returns: группа элементов.
  */
  List<CheckableItem> get items {
    _CArray_CCheckableItem res = _CCheckableItemsGroup_items(_CCheckableItemsGroupMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CCheckableItemsGroup_releasePtr);

  CheckableItemsGroup._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory CheckableItemsGroup._create(ffi.Pointer<ffi.Void> self) {
    final classObject = CheckableItemsGroup._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CheckableItemsGroup &&
    other.runtimeType == runtimeType &&
    _CCheckableItemsGroup_cg_objectIdentifier(this._self) == _CCheckableItemsGroup_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCheckableItemsGroup_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - CheckableItemsGroup <-> CCheckableItemsGroup

final class _CCheckableItemsGroup extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCheckableItemsGroupBasicFunctions on _CCheckableItemsGroup {
  void _releaseIntermediate() {
    _CCheckableItemsGroup_release(_impl);
  }

  _CCheckableItemsGroup _retain() {
    return _CCheckableItemsGroup_retain(_impl);
  }
}

extension _CCheckableItemsGroupToDart on _CCheckableItemsGroup {
  CheckableItemsGroup _toDart() {
    return CheckableItemsGroup._create(_retain()._impl);
  }
}


extension _DartToCCheckableItemsGroup on CheckableItemsGroup {
  _CCheckableItemsGroup _copyFromDartTo_CCheckableItemsGroup() {
    return (_CCheckableItemsGroupMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<CheckableItem> <-> _CArray_CCheckableItem

final class _CArray_CCheckableItem extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CCheckableItemToDart on _CArray_CCheckableItem {
  List<CheckableItem> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CCheckableItem on List<CheckableItem> {
  _CArray_CCheckableItem _copyFromDartTo_CArray_CCheckableItem() {
    final cArray = _CArray_CCheckableItemmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CCheckableItem();
        _CArray_CCheckableItemaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CCheckableItemBasicFunctions on _CArray_CCheckableItem {
  void _releaseIntermediate() {
    _CArray_CCheckableItem_release(this);
  }

  static final _listToFill = <CheckableItem>[];

  static void _iterate(_CCheckableItem item) {
    _listToFill.add(item._toDart());
  }

  List<CheckableItem> _fillFromC() {
    _forEach_CArray_CCheckableItem(this, ffi.Pointer.fromFunction<ffi.Void Function(_CCheckableItem)>(_iterate));
    final result = List<CheckableItem>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - SimpleCheckableItem

/** Простой отмечаемый элемент из CheckableItemsGroup. */
class SimpleCheckableItem extends CheckableItem implements ffi.Finalizable {
  /**
   Получение текстового описания элемента.
  
   - Returns: текстовое описание элемента.
  */
  String get text {
    _CString res = _CSimpleCheckableItem_text(_CSimpleCheckableItemMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение списка значений, по которым происходит фильтрация.
   Обычно одно значение.
  
   - Returns: список значений фильтров.
  */
  List<String> get values {
    _CArray_CString res = _CSimpleCheckableItem_values(_CSimpleCheckableItemMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение состояния элемента.
  
   - Returns: состояние элемента. True - элемент отмечен.
  */
  bool get isChecked {
    bool res = _CSimpleCheckableItem_isChecked(_CSimpleCheckableItemMakeDefault().._impl=_self);
    return res;
  }
  set isChecked(bool checked) {
    void res = _CSimpleCheckableItem_setChecked_bool(_CSimpleCheckableItemMakeDefault().._impl=_self, checked);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CSimpleCheckableItem_releasePtr);

  SimpleCheckableItem._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory SimpleCheckableItem._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SimpleCheckableItem._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SimpleCheckableItem &&
    other.runtimeType == runtimeType &&
    _CSimpleCheckableItem_cg_objectIdentifier(this._self) == _CSimpleCheckableItem_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSimpleCheckableItem_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - SimpleCheckableItem <-> CSimpleCheckableItem

final class _CSimpleCheckableItem extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSimpleCheckableItemBasicFunctions on _CSimpleCheckableItem {
  void _releaseIntermediate() {
    _CSimpleCheckableItem_release(_impl);
  }

  _CSimpleCheckableItem _retain() {
    return _CSimpleCheckableItem_retain(_impl);
  }
}

extension _CSimpleCheckableItemToDart on _CSimpleCheckableItem {
  SimpleCheckableItem _toDart() {
    return SimpleCheckableItem._create(_retain()._impl);
  }
}


extension _DartToCSimpleCheckableItem on SimpleCheckableItem {
  _CSimpleCheckableItem _copyFromDartTo_CSimpleCheckableItem() {
    return (_CSimpleCheckableItemMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - GroupCheckableItem

/** Набор отмечаемых элементов, работающих как радио-группа. */
class GroupCheckableItem extends CheckableItem implements ffi.Finalizable {
  /**
   Получение набора элементов группы.
  
   - Returns: набор элементов.
  */
  List<CheckableGroupedItem> get items {
    _CArray_CCheckableGroupedItem res = _CGroupCheckableItem_items(_CGroupCheckableItemMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CGroupCheckableItem_releasePtr);

  GroupCheckableItem._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory GroupCheckableItem._create(ffi.Pointer<ffi.Void> self) {
    final classObject = GroupCheckableItem._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GroupCheckableItem &&
    other.runtimeType == runtimeType &&
    _CGroupCheckableItem_cg_objectIdentifier(this._self) == _CGroupCheckableItem_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CGroupCheckableItem_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - GroupCheckableItem <-> CGroupCheckableItem

final class _CGroupCheckableItem extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CGroupCheckableItemBasicFunctions on _CGroupCheckableItem {
  void _releaseIntermediate() {
    _CGroupCheckableItem_release(_impl);
  }

  _CGroupCheckableItem _retain() {
    return _CGroupCheckableItem_retain(_impl);
  }
}

extension _CGroupCheckableItemToDart on _CGroupCheckableItem {
  GroupCheckableItem _toDart() {
    return GroupCheckableItem._create(_retain()._impl);
  }
}


extension _DartToCGroupCheckableItem on GroupCheckableItem {
  _CGroupCheckableItem _copyFromDartTo_CGroupCheckableItem() {
    return (_CGroupCheckableItemMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<CheckableGroupedItem> <-> _CArray_CCheckableGroupedItem

final class _CArray_CCheckableGroupedItem extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CCheckableGroupedItemToDart on _CArray_CCheckableGroupedItem {
  List<CheckableGroupedItem> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CCheckableGroupedItem on List<CheckableGroupedItem> {
  _CArray_CCheckableGroupedItem _copyFromDartTo_CArray_CCheckableGroupedItem() {
    final cArray = _CArray_CCheckableGroupedItemmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CCheckableGroupedItem();
        _CArray_CCheckableGroupedItemaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CCheckableGroupedItemBasicFunctions on _CArray_CCheckableGroupedItem {
  void _releaseIntermediate() {
    _CArray_CCheckableGroupedItem_release(this);
  }

  static final _listToFill = <CheckableGroupedItem>[];

  static void _iterate(_CCheckableGroupedItem item) {
    _listToFill.add(item._toDart());
  }

  List<CheckableGroupedItem> _fillFromC() {
    _forEach_CArray_CCheckableGroupedItem(this, ffi.Pointer.fromFunction<ffi.Void Function(_CCheckableGroupedItem)>(_iterate));
    final result = List<CheckableGroupedItem>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - Borders

/** Описывает набор непрерывного упорядоченных значений. */
class Borders {
  /** Задаёт притяжку до значения, кратного этому числу. */
  final double? snapping;
  /** Признак использования логарифмической шкалы. */
  final bool isLg;
  /** Значение, по которым происходит фильтрация. */
  final String value;
  /** Нижняя граница набора значений. */
  final double min;
  /** Верхняя граница набора значений. */
  final double max;
  /** Текущее установленное минимальное значение. */
  final double? currentMin;
  /** Текущее установленное максимальное значение. */
  final double? currentMax;

  const Borders({
    required this.snapping,
    required this.isLg,
    required this.value,
    required this.min,
    required this.max,
    this.currentMin = null,
    this.currentMax = null
  });

  Borders copyWith({
    Optional<double?>? snapping,
    bool? isLg,
    String? value,
    double? min,
    double? max,
    Optional<double?>? currentMin,
    Optional<double?>? currentMax
  }) {
    return Borders(
      snapping: snapping != null ? snapping.value : this.snapping,
      isLg: isLg ?? this.isLg,
      value: value ?? this.value,
      min: min ?? this.min,
      max: max ?? this.max,
      currentMin: currentMin != null ? currentMin.value : this.currentMin,
      currentMax: currentMax != null ? currentMax.value : this.currentMax
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Borders &&
    other.runtimeType == runtimeType &&
    other.snapping == snapping &&
    other.isLg == isLg &&
    other.value == value &&
    other.min == min &&
    other.max == max &&
    other.currentMin == currentMin &&
    other.currentMax == currentMax;

  @override
  int get hashCode {
    return Object.hash(snapping, isLg, value, min, max, currentMin, currentMax);
  }

}
final class _CBorders extends ffi.Struct {
  external _COptional_double snapping;

  @ffi.Bool()
  external bool isLg;

  external _CString value;

  @ffi.Double()
  external double min;

  @ffi.Double()
  external double max;

  external _COptional_double currentMin;

  external _COptional_double currentMax;

}
// MARK: - Borders <-> _CBorders

extension _CBordersToDart on _CBorders {
  Borders _toDart() {
    return Borders(
      snapping: this.snapping._toDart(),
      isLg: this.isLg,
      value: this.value._toDart(),
      min: this.min,
      max: this.max,
      currentMin: this.currentMin._toDart(),
      currentMax: this.currentMax._toDart()
    );
  }
}

extension _DartTo_CBorders on Borders {
  _CBorders _copyFromDartTo_CBorders() {
    final res = _CBordersMakeDefault();
    res.snapping = this.snapping._copyFromDartTo_COptional_double();
    res.isLg = this.isLg;
    res.value = this.value._copyFromDartTo_CString();
    res.min = this.min;
    res.max = this.max;
    res.currentMin = this.currentMin._copyFromDartTo_COptional_double();
    res.currentMax = this.currentMax._copyFromDartTo_COptional_double();
    return res;
  }
}
extension _CBordersRelease on _CBorders {
  void _releaseIntermediate() {
    value._releaseIntermediate();
  }
}

// MARK: - OrderedValue

/** Описывает одно значение из набора. */
class OrderedValue {
  /** Значение, по которым происходит фильтрация. */
  final String value;
  /** Название значения. */
  final String? text;

  const OrderedValue({
    required this.value,
    required this.text
  });

  OrderedValue copyWith({
    String? value,
    Optional<String?>? text
  }) {
    return OrderedValue(
      value: value ?? this.value,
      text: text != null ? text.value : this.text
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is OrderedValue &&
    other.runtimeType == runtimeType &&
    other.value == value &&
    other.text == text;

  @override
  int get hashCode {
    return Object.hash(value, text);
  }

}
final class _COrderedValue extends ffi.Struct {
  external _CString value;

  external _COptional_CString text;

}
// MARK: - OrderedValue <-> _COrderedValue

extension _COrderedValueToDart on _COrderedValue {
  OrderedValue _toDart() {
    return OrderedValue(
      value: this.value._toDart(),
      text: this.text._toDart()
    );
  }
}

extension _DartTo_COrderedValue on OrderedValue {
  _COrderedValue _copyFromDartTo_COrderedValue() {
    final res = _COrderedValueMakeDefault();
    res.value = this.value._copyFromDartTo_CString();
    res.text = this.text._copyFromDartTo_COptional_CString();
    return res;
  }
}
extension _COrderedValueRelease on _COrderedValue {
  void _releaseIntermediate() {
    value._releaseIntermediate();
    text._releaseIntermediate();
  }
}

// MARK: - List<OrderedValue> <-> _CArray_COrderedValue

final class _CArray_COrderedValue extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_COrderedValueToDart on _CArray_COrderedValue {
  List<OrderedValue> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_COrderedValue on List<OrderedValue> {
  _CArray_COrderedValue _copyFromDartTo_CArray_COrderedValue() {
    final cArray = _CArray_COrderedValuemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_COrderedValue();
        _CArray_COrderedValueaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_COrderedValueBasicFunctions on _CArray_COrderedValue {
  void _releaseIntermediate() {
    _CArray_COrderedValue_release(this);
  }

  static final _listToFill = <OrderedValue>[];

  static void _iterate(_COrderedValue item) {
    _listToFill.add(item._toDart());
  }

  List<OrderedValue> _fillFromC() {
    _forEach_CArray_COrderedValue(this, ffi.Pointer.fromFunction<ffi.Void Function(_COrderedValue)>(_iterate));
    final result = List<OrderedValue>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - OrderedValues

/** Описывает набор дискретных упорядоченных значений. */
class OrderedValues {
  /** Набор значений. Упорядочен по возрастанию. */
  final List<OrderedValue> values;
  /** Индекс текущего установленного минимального значения. */
  final int? currentMinIndex;
  /** Индекс текущего установленного максимального значения. */
  final int? currentMaxIndex;

  const OrderedValues({
    required this.values,
    this.currentMinIndex = null,
    this.currentMaxIndex = null
  });

  OrderedValues copyWith({
    List<OrderedValue>? values,
    Optional<int?>? currentMinIndex,
    Optional<int?>? currentMaxIndex
  }) {
    return OrderedValues(
      values: values ?? this.values,
      currentMinIndex: currentMinIndex != null ? currentMinIndex.value : this.currentMinIndex,
      currentMaxIndex: currentMaxIndex != null ? currentMaxIndex.value : this.currentMaxIndex
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is OrderedValues &&
    other.runtimeType == runtimeType &&
    other.values == values &&
    other.currentMinIndex == currentMinIndex &&
    other.currentMaxIndex == currentMaxIndex;

  @override
  int get hashCode {
    return Object.hash(values, currentMinIndex, currentMaxIndex);
  }

}
final class _COrderedValues extends ffi.Struct {
  external _CArray_COrderedValue values;

  external _COptional_uint64_t currentMinIndex;

  external _COptional_uint64_t currentMaxIndex;

}
// MARK: - OrderedValues <-> _COrderedValues

extension _COrderedValuesToDart on _COrderedValues {
  OrderedValues _toDart() {
    return OrderedValues(
      values: this.values._toDart(),
      currentMinIndex: this.currentMinIndex._toDart(),
      currentMaxIndex: this.currentMaxIndex._toDart()
    );
  }
}

extension _DartTo_COrderedValues on OrderedValues {
  _COrderedValues _copyFromDartTo_COrderedValues() {
    final res = _COrderedValuesMakeDefault();
    res.values = this.values._copyFromDartTo_CArray_COrderedValue();
    res.currentMinIndex = this.currentMinIndex._copyFromDartTo_COptional_uint64_t();
    res.currentMaxIndex = this.currentMaxIndex._copyFromDartTo_COptional_uint64_t();
    return res;
  }
}
extension _COrderedValuesRelease on _COrderedValues {
  void _releaseIntermediate() {
    values._releaseIntermediate();
  }
}

// MARK: - Range

/** Описывает набор непрерывных или дискретных упорядоченных значений. */
final class Range {
  final Object? _value;
  final int _index;

  Range._raw(this._value, this._index);

  Range.borders(Borders value) : this._raw(value, 0);
  Range.orderedValues(OrderedValues value) : this._raw(value, 1);

  bool get isBorders => this._index == 0;
  Borders? get asBorders => this.isBorders ? this._value as Borders : null;

  bool get isOrderedValues => this._index == 1;
  OrderedValues? get asOrderedValues => this.isOrderedValues ? this._value as OrderedValues : null;

  T match<T>({
    required T Function(Borders value) borders,
    required T Function(OrderedValues value) orderedValues,
  }) {
    return switch (this._index) {
      0 => borders(this._value as Borders),
      1 => orderedValues(this._value as OrderedValues),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "Range(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Range &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CRangeImpl extends ffi.Union {
  external _CBorders _borders;
  external _COrderedValues _orderedValues;
}

final class _CRange extends ffi.Struct {
  external _CRangeImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CRangeBasicFunctions on _CRange {
  void _releaseIntermediate() {
    _CRange_release(this);
  }
}
	
// MARK: - Range <-> CRange

extension _CRangeToDart on _CRange {
  Range _toDart() {
    return switch (this._index) {
      0 => Range.borders(this._impl._borders._toDart()),
      1 => Range.orderedValues(this._impl._orderedValues._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CRange on Range {
  _CRange _copyFromDartTo_CRange() {
    var res = _CRangeMakeDefault();
    this.match<void>(
      borders: (Borders value) {
        res._impl._borders = value._copyFromDartTo_CBorders();
        res._index = 0;
      },
      orderedValues: (OrderedValues value) {
        res._impl._orderedValues = value._copyFromDartTo_COrderedValues();
        res._index = 1;
      },
    );
    return res;
  }
}

// MARK: - RangeWidget

/** Виджет для представления непрерывного или дискретного набора упорядоченных значений. */
class RangeWidget extends Widget implements ffi.Finalizable {
  /**
   Получение набора упорядоченных значений.
  
   - Returns: набор упорядоченных значений.
  */
  Range get range {
    _CRange res = _CRangeWidget_range(_CRangeWidgetMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRangeWidget_releasePtr);

  RangeWidget._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory RangeWidget._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RangeWidget._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RangeWidget &&
    other.runtimeType == runtimeType &&
    _CRangeWidget_cg_objectIdentifier(this._self) == _CRangeWidget_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRangeWidget_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RangeWidget: Methods

  /**
   Установка текущих выбранных значений.
  
   - Parameter min: текущее минимальное значение.
   - Parameter max: текущее максимальное значение.
  */
  void setValues(
    double min,
    double max
  )  {
    void res = _CRangeWidget_setValues_double_double(_CRangeWidgetMakeDefault().._impl=_self, min, max);
    return res;
  }

}

// MARK: - RangeWidget <-> CRangeWidget

final class _CRangeWidget extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRangeWidgetBasicFunctions on _CRangeWidget {
  void _releaseIntermediate() {
    _CRangeWidget_release(_impl);
  }

  _CRangeWidget _retain() {
    return _CRangeWidget_retain(_impl);
  }
}

extension _CRangeWidgetToDart on _CRangeWidget {
  RangeWidget _toDart() {
    return RangeWidget._create(_retain()._impl);
  }
}


extension _DartToCRangeWidget on RangeWidget {
  _CRangeWidget _copyFromDartTo_CRangeWidget() {
    return (_CRangeWidgetMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - SearchResult

/** Результат работы поисковика. */
class SearchResult implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Первая страница результатов поиска.
  
   - Returns: ненулевой указатель на первую страницу, если результаты есть
   нулевой указатель, если ничего не найдено
  */
  Page? get firstPage {
    _COptional_CPage res = _CSearchResult_firstPage(_CSearchResultMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Прямоугольная область, подходящая для отображения результатов поиска. */
  Geometry? get representativeArea {
    _COptional_CGeometry res = _CSearchResult_representativeArea(_CSearchResultMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Асинхронное получение маркеров. */
  CancelableOperation<List<ItemMarkerInfo>?> get itemMarkerInfos {
    _CFuture_COptional_CArray_CItemMarkerInfo res = _CSearchResult_itemMarkerInfos(_CSearchResultMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Тип поискового запроса. */
  SearchResultType get searchResultType {
    _CSearchResultType res = _CSearchResult_searchResultType(_CSearchResultMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Динамические фильтры для этого запроса. */
  List<DynamicFilter> get dynamicFilters {
    _CArray_CDynamicFilter res = _CSearchResult_dynamicFilters(_CSearchResultMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Виджеты быстрых фильтров.
  
   - Note: Это так называемые "быстрые фильтры" - фильтры, наиболее интересные пользователю. Их не больше 5.
  */
  List<Widget> get actionWidgets {
    _CArray_CWidget res = _CSearchResult_actionWidgets(_CSearchResultMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Виджеты фильтров. */
  List<Widget> get mainWidgets {
    _CArray_CWidget res = _CSearchResult_mainWidgets(_CSearchResultMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Признак того, что первый результат пригоден для непосредственного использования. */
  bool get autoUseFirstResult {
    bool res = _CSearchResult_autoUseFirstResult(_CSearchResultMakeDefault().._impl=_self);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CSearchResult_releasePtr);

  SearchResult._raw(this._self);
  factory SearchResult._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SearchResult._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SearchResult &&
    other.runtimeType == runtimeType &&
    _CSearchResult_cg_objectIdentifier(this._self) == _CSearchResult_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSearchResult_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: SearchResult: Methods

  /**
   Получение текстов маркеров по их идентификаторам.
   Возвращается vector
   <future
   >,
   так как в облако за запрос можно отправить не более 50 идентификаторов.
  
   - Parameter objectIds: Идентификаторы маркеров.
  */
  List<CancelableOperation<List<UIMarkerInfo>>> markerTitles(
    List<DgisObjectId> objectIds
  )  {
    var _a1 = objectIds._copyFromDartTo_CArray_CDgisObjectId();
    _CArray_CFuture_CArray_CUIMarkerInfo res = _CSearchResult_markerTitles_CArray_CDgisObjectId(_CSearchResultMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - SearchResult <-> CSearchResult

final class _CSearchResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSearchResultBasicFunctions on _CSearchResult {
  void _releaseIntermediate() {
    _CSearchResult_release(_impl);
  }

  _CSearchResult _retain() {
    return _CSearchResult_retain(_impl);
  }
}

extension _CSearchResultToDart on _CSearchResult {
  SearchResult _toDart() {
    return SearchResult._create(_retain()._impl);
  }
}


extension _DartToCSearchResult on SearchResult {
  _CSearchResult _copyFromDartTo_CSearchResult() {
    return (_CSearchResultMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - GeometryKind

enum GeometryKind {
  point(0),
  polyline(1),
  polygon(2),
  complex(3),
  ;

  const GeometryKind(this.rawValue);
  final int rawValue;

  static GeometryKind getByValue(int value) {
    return GeometryKind.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CGeometryKind extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CGeometryKindBasicFunctions on _CGeometryKind {
  void _releaseIntermediate() {
  }
}

extension _CGeometryKindToDart on _CGeometryKind {
  GeometryKind _toDart() {
    return GeometryKind.getByValue(this.rawValue);
  }
}

extension _DartTo_CGeometryKind on GeometryKind {
  _CGeometryKind _copyFromDartTo_CGeometryKind() {
    return _CGeometryKindMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - Geometry

/** Объект геометрии. */
class Geometry implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  GeometryKind get kind {
    _CGeometryKind res = _CGeometry_kind(_CGeometryMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Прямоугольник минимального размера, содержащий геометрию. */
  GeoRect get bounds {
    _CGeoRect res = _CGeometry_bounds(_CGeometryMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Минимальнная точка ограничивающего прямоугольника. */
  GeoPoint get minPoint {
    _CGeoPoint res = _CGeometry_minPoint(_CGeometryMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Максимальная точка ограничивающего прямоугольника. */
  GeoPoint get maxPoint {
    _CGeoPoint res = _CGeometry_maxPoint(_CGeometryMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CGeometry_releasePtr);

  Geometry._raw(this._self);
  factory Geometry._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Geometry._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Geometry &&
    other.runtimeType == runtimeType &&
    _CGeometry_cg_objectIdentifier(this._self) == _CGeometry_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CGeometry_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: Geometry: Methods

  /**
   Функция intersects позволяет определить, имеет ли данная геометрия
   пересечение с другим объектом геометрии
  
   - Parameter geometry: объект геометрии для проверки пересечения
   При вычислении пересечения с IPointGeometry высота (elevation) игнорируется
  */
  bool intersects(
    Geometry geometry
  )  {
    var _a1 = geometry._copyFromDartTo_CGeometry();
    bool res = _CGeometry_intersects_CGeometry(_CGeometryMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - Geometry <-> CGeometry

final class _CGeometry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CGeometryBasicFunctions on _CGeometry {
  void _releaseIntermediate() {
    _CGeometry_release(_impl);
  }

  _CGeometry _retain() {
    return _CGeometry_retain(_impl);
  }
}

extension _CGeometryToDart on _CGeometry {
  Geometry _toDart() {
    final selector = _CGeometry_cg_getSelector(this);
    switch (selector) {
      case 0:
        final res = Geometry._create(_retain()._impl);
        return res;
      case 1:
        final res = PointGeometry._create(_retain()._impl);
        return res;
      case 2:
        final res = PolygonGeometry._create(_retain()._impl);
        return res;
      case 3:
        final res = PolylineGeometry._create(_retain()._impl);
        return res;
      case 4:
        final res = ComplexGeometry._create(_retain()._impl);
        return res;
      default: throw Exception("Unrecognized case index $selector");
    }
  }
}

extension _DartToCGeometry on Geometry {
  _CGeometry _copyFromDartTo_CGeometry() {
    return (_CGeometryMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Geometry? <-> _COptional_CGeometry

final class _COptional_CGeometry extends ffi.Struct {
  
  external _CGeometry value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CGeometryBasicFunctions on _COptional_CGeometry {
  void _releaseIntermediate() {
    _COptional_CGeometry_release(this);
  }
}

extension _COptional_CGeometryToDart on _COptional_CGeometry {
  Geometry? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CGeometry on Geometry? {
  _COptional_CGeometry _copyFromDartTo_COptional_CGeometry() {
    final cOptional = _COptional_CGeometryMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CGeometry();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - CancelableOperation<List<ItemMarkerInfo>?> <-> _CFuture_COptional_CArray_CItemMarkerInfo

final class _CFuture_COptional_CArray_CItemMarkerInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_COptional_CArray_CItemMarkerInfo_Cancellable {
  final Completer<List<ItemMarkerInfo>?> completer;
  final _CFuture_COptional_CArray_CItemMarkerInfo _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_COptional_CArray_CItemMarkerInfo, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_COptional_CArray_CItemMarkerInfo_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_COptional_CArray_CItemMarkerInfoBasicFunctions on _CFuture_COptional_CArray_CItemMarkerInfo {
  void _releaseIntermediate() {
    _CFuture_COptional_CArray_CItemMarkerInfo_release(this);
  }

  _CFuture_COptional_CArray_CItemMarkerInfo _retain() {
    return _CFuture_COptional_CArray_CItemMarkerInfo_retain(this);
  }
}

extension _CFuture_COptional_CArray_CItemMarkerInfoToDart on _CFuture_COptional_CArray_CItemMarkerInfo {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_COptional_CArray_CItemMarkerInfo_Cancellable>{};

  static void valueFunction(_COptional_CArray_CItemMarkerInfo cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<List<ItemMarkerInfo>?> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<List<ItemMarkerInfo>?>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CArray_CItemMarkerInfo, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_COptional_CArray_CItemMarkerInfoReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_COptional_CArray_CItemMarkerInfo_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_COptional_CArray_CItemMarkerInfo on CancelableOperation<List<ItemMarkerInfo>?> {
  _CFuture_COptional_CArray_CItemMarkerInfo _copyFromDartTo_CFuture_COptional_CArray_CItemMarkerInfo() {
    return _CFuture_COptional_CArray_CItemMarkerInfoMakeDefault();
  }
}
	
// MARK: - List<ItemMarkerInfo> <-> _CArray_CItemMarkerInfo

final class _CArray_CItemMarkerInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CItemMarkerInfoToDart on _CArray_CItemMarkerInfo {
  List<ItemMarkerInfo> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CItemMarkerInfo on List<ItemMarkerInfo> {
  _CArray_CItemMarkerInfo _copyFromDartTo_CArray_CItemMarkerInfo() {
    final cArray = _CArray_CItemMarkerInfomakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CItemMarkerInfo();
        _CArray_CItemMarkerInfoaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CItemMarkerInfoBasicFunctions on _CArray_CItemMarkerInfo {
  void _releaseIntermediate() {
    _CArray_CItemMarkerInfo_release(this);
  }

  static final _listToFill = <ItemMarkerInfo>[];

  static void _iterate(_CItemMarkerInfo item) {
    _listToFill.add(item._toDart());
  }

  List<ItemMarkerInfo> _fillFromC() {
    _forEach_CArray_CItemMarkerInfo(this, ffi.Pointer.fromFunction<ffi.Void Function(_CItemMarkerInfo)>(_iterate));
    final result = List<ItemMarkerInfo>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - List<ItemMarkerInfo>? <-> _COptional_CArray_CItemMarkerInfo

final class _COptional_CArray_CItemMarkerInfo extends ffi.Struct {
  
  external _CArray_CItemMarkerInfo value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CArray_CItemMarkerInfoBasicFunctions on _COptional_CArray_CItemMarkerInfo {
  void _releaseIntermediate() {
    _COptional_CArray_CItemMarkerInfo_release(this);
  }
}

extension _COptional_CArray_CItemMarkerInfoToDart on _COptional_CArray_CItemMarkerInfo {
  List<ItemMarkerInfo>? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CArray_CItemMarkerInfo on List<ItemMarkerInfo>? {
  _COptional_CArray_CItemMarkerInfo _copyFromDartTo_COptional_CArray_CItemMarkerInfo() {
    final cOptional = _COptional_CArray_CItemMarkerInfoMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CArray_CItemMarkerInfo();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<CancelableOperation<List<UIMarkerInfo>>> <-> _CArray_CFuture_CArray_CUIMarkerInfo

final class _CArray_CFuture_CArray_CUIMarkerInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CFuture_CArray_CUIMarkerInfoToDart on _CArray_CFuture_CArray_CUIMarkerInfo {
  List<CancelableOperation<List<UIMarkerInfo>>> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CFuture_CArray_CUIMarkerInfo on List<CancelableOperation<List<UIMarkerInfo>>> {
  _CArray_CFuture_CArray_CUIMarkerInfo _copyFromDartTo_CArray_CFuture_CArray_CUIMarkerInfo() {
    final cArray = _CArray_CFuture_CArray_CUIMarkerInfomakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CFuture_CArray_CUIMarkerInfo();
        _CArray_CFuture_CArray_CUIMarkerInfoaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CFuture_CArray_CUIMarkerInfoBasicFunctions on _CArray_CFuture_CArray_CUIMarkerInfo {
  void _releaseIntermediate() {
    _CArray_CFuture_CArray_CUIMarkerInfo_release(this);
  }

  static final _listToFill = <CancelableOperation<List<UIMarkerInfo>>>[];

  static void _iterate(_CFuture_CArray_CUIMarkerInfo item) {
    _listToFill.add(item._toDart());
  }

  List<CancelableOperation<List<UIMarkerInfo>>> _fillFromC() {
    _forEach_CArray_CFuture_CArray_CUIMarkerInfo(this, ffi.Pointer.fromFunction<ffi.Void Function(_CFuture_CArray_CUIMarkerInfo)>(_iterate));
    final result = List<CancelableOperation<List<UIMarkerInfo>>>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - CancelableOperation<List<UIMarkerInfo>> <-> _CFuture_CArray_CUIMarkerInfo

final class _CFuture_CArray_CUIMarkerInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CArray_CUIMarkerInfo_Cancellable {
  final Completer<List<UIMarkerInfo>> completer;
  final _CFuture_CArray_CUIMarkerInfo _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CArray_CUIMarkerInfo, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CArray_CUIMarkerInfo_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CArray_CUIMarkerInfoBasicFunctions on _CFuture_CArray_CUIMarkerInfo {
  void _releaseIntermediate() {
    _CFuture_CArray_CUIMarkerInfo_release(this);
  }

  _CFuture_CArray_CUIMarkerInfo _retain() {
    return _CFuture_CArray_CUIMarkerInfo_retain(this);
  }
}

extension _CFuture_CArray_CUIMarkerInfoToDart on _CFuture_CArray_CUIMarkerInfo {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CArray_CUIMarkerInfo_Cancellable>{};

  static void valueFunction(_CArray_CUIMarkerInfo cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<List<UIMarkerInfo>> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<List<UIMarkerInfo>>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CUIMarkerInfo, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CArray_CUIMarkerInfoReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CArray_CUIMarkerInfo_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CArray_CUIMarkerInfo on CancelableOperation<List<UIMarkerInfo>> {
  _CFuture_CArray_CUIMarkerInfo _copyFromDartTo_CFuture_CArray_CUIMarkerInfo() {
    return _CFuture_CArray_CUIMarkerInfoMakeDefault();
  }
}
	
// MARK: - List<UIMarkerInfo> <-> _CArray_CUIMarkerInfo

final class _CArray_CUIMarkerInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CUIMarkerInfoToDart on _CArray_CUIMarkerInfo {
  List<UIMarkerInfo> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CUIMarkerInfo on List<UIMarkerInfo> {
  _CArray_CUIMarkerInfo _copyFromDartTo_CArray_CUIMarkerInfo() {
    final cArray = _CArray_CUIMarkerInfomakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CUIMarkerInfo();
        _CArray_CUIMarkerInfoaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CUIMarkerInfoBasicFunctions on _CArray_CUIMarkerInfo {
  void _releaseIntermediate() {
    _CArray_CUIMarkerInfo_release(this);
  }

  static final _listToFill = <UIMarkerInfo>[];

  static void _iterate(_CUIMarkerInfo item) {
    _listToFill.add(item._toDart());
  }

  List<UIMarkerInfo> _fillFromC() {
    _forEach_CArray_CUIMarkerInfo(this, ffi.Pointer.fromFunction<ffi.Void Function(_CUIMarkerInfo)>(_iterate));
    final result = List<UIMarkerInfo>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - List<DgisObjectId> <-> _CArray_CDgisObjectId

final class _CArray_CDgisObjectId extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CDgisObjectIdToDart on _CArray_CDgisObjectId {
  List<DgisObjectId> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CDgisObjectId on List<DgisObjectId> {
  _CArray_CDgisObjectId _copyFromDartTo_CArray_CDgisObjectId() {
    final cArray = _CArray_CDgisObjectIdmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CDgisObjectId();
        _CArray_CDgisObjectIdaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CDgisObjectIdBasicFunctions on _CArray_CDgisObjectId {
  void _releaseIntermediate() {
    _CArray_CDgisObjectId_release(this);
  }

  static final _listToFill = <DgisObjectId>[];

  static void _iterate(_CDgisObjectId item) {
    _listToFill.add(item._toDart());
  }

  List<DgisObjectId> _fillFromC() {
    _forEach_CArray_CDgisObjectId(this, ffi.Pointer.fromFunction<ffi.Void Function(_CDgisObjectId)>(_iterate));
    final result = List<DgisObjectId>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - List<Widget> <-> _CArray_CWidget

final class _CArray_CWidget extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CWidgetToDart on _CArray_CWidget {
  List<Widget> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CWidget on List<Widget> {
  _CArray_CWidget _copyFromDartTo_CArray_CWidget() {
    final cArray = _CArray_CWidgetmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CWidget();
        _CArray_CWidgetaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CWidgetBasicFunctions on _CArray_CWidget {
  void _releaseIntermediate() {
    _CArray_CWidget_release(this);
  }

  static final _listToFill = <Widget>[];

  static void _iterate(_CWidget item) {
    _listToFill.add(item._toDart());
  }

  List<Widget> _fillFromC() {
    _forEach_CArray_CWidget(this, ffi.Pointer.fromFunction<ffi.Void Function(_CWidget)>(_iterate));
    final result = List<Widget>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - SearchQuery

/** Поисковый запрос. */
class SearchQuery implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CSearchQuery_releasePtr);

  SearchQuery._raw(this._self);
  factory SearchQuery._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SearchQuery._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SearchQuery &&
    other.runtimeType == runtimeType &&
    _CSearchQuery_cg_objectIdentifier(this._self) == _CSearchQuery_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSearchQuery_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - SearchQuery <-> CSearchQuery

final class _CSearchQuery extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSearchQueryBasicFunctions on _CSearchQuery {
  void _releaseIntermediate() {
    _CSearchQuery_release(_impl);
  }

  _CSearchQuery _retain() {
    return _CSearchQuery_retain(_impl);
  }
}

extension _CSearchQueryToDart on _CSearchQuery {
  SearchQuery _toDart() {
    return SearchQuery._create(_retain()._impl);
  }
}


extension _DartToCSearchQuery on SearchQuery {
  _CSearchQuery _copyFromDartTo_CSearchQuery() {
    return (_CSearchQueryMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - SuggestObjectHandler

/** Предложен конкретный объект справочника. */
class SuggestObjectHandler implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Подсказанный объект. */
  DirectoryObject get item {
    _CDirectoryObject res = _CSuggestObjectHandler_item(_CSuggestObjectHandlerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CSuggestObjectHandler_releasePtr);

  SuggestObjectHandler._raw(this._self);
  factory SuggestObjectHandler._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SuggestObjectHandler._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SuggestObjectHandler &&
    other.runtimeType == runtimeType &&
    _CSuggestObjectHandler_cg_objectIdentifier(this._self) == _CSuggestObjectHandler_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSuggestObjectHandler_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - SuggestObjectHandler <-> CSuggestObjectHandler

final class _CSuggestObjectHandler extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSuggestObjectHandlerBasicFunctions on _CSuggestObjectHandler {
  void _releaseIntermediate() {
    _CSuggestObjectHandler_release(_impl);
  }

  _CSuggestObjectHandler _retain() {
    return _CSuggestObjectHandler_retain(_impl);
  }
}

extension _CSuggestObjectHandlerToDart on _CSuggestObjectHandler {
  SuggestObjectHandler _toDart() {
    return SuggestObjectHandler._create(_retain()._impl);
  }
}


extension _DartToCSuggestObjectHandler on SuggestObjectHandler {
  _CSuggestObjectHandler _copyFromDartTo_CSuggestObjectHandler() {
    return (_CSuggestObjectHandlerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - PerformSearchHandler

/** Предложено поискать определенный набор объектов. */
class PerformSearchHandler implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Запрос для прогона через поисковик. */
  SearchQuery get searchQuery {
    _CSearchQuery res = _CPerformSearchHandler_searchQuery(_CPerformSearchHandlerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CPerformSearchHandler_releasePtr);

  PerformSearchHandler._raw(this._self);
  factory PerformSearchHandler._create(ffi.Pointer<ffi.Void> self) {
    final classObject = PerformSearchHandler._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PerformSearchHandler &&
    other.runtimeType == runtimeType &&
    _CPerformSearchHandler_cg_objectIdentifier(this._self) == _CPerformSearchHandler_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPerformSearchHandler_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - PerformSearchHandler <-> CPerformSearchHandler

final class _CPerformSearchHandler extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPerformSearchHandlerBasicFunctions on _CPerformSearchHandler {
  void _releaseIntermediate() {
    _CPerformSearchHandler_release(_impl);
  }

  _CPerformSearchHandler _retain() {
    return _CPerformSearchHandler_retain(_impl);
  }
}

extension _CPerformSearchHandlerToDart on _CPerformSearchHandler {
  PerformSearchHandler _toDart() {
    return PerformSearchHandler._create(_retain()._impl);
  }
}


extension _DartToCPerformSearchHandler on PerformSearchHandler {
  _CPerformSearchHandler _copyFromDartTo_CPerformSearchHandler() {
    return (_CPerformSearchHandlerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - IncompleteTextHandler

/** Предложено автодополнение для введенного пользователем текста. */
class IncompleteTextHandler implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Нужно подставить в строку поиска этот текст и дать пользователю продолжить вводить запрос. */
  String get queryText {
    _CString res = _CIncompleteTextHandler_queryText(_CIncompleteTextHandlerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CIncompleteTextHandler_releasePtr);

  IncompleteTextHandler._raw(this._self);
  factory IncompleteTextHandler._create(ffi.Pointer<ffi.Void> self) {
    final classObject = IncompleteTextHandler._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is IncompleteTextHandler &&
    other.runtimeType == runtimeType &&
    _CIncompleteTextHandler_cg_objectIdentifier(this._self) == _CIncompleteTextHandler_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CIncompleteTextHandler_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - IncompleteTextHandler <-> CIncompleteTextHandler

final class _CIncompleteTextHandler extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CIncompleteTextHandlerBasicFunctions on _CIncompleteTextHandler {
  void _releaseIntermediate() {
    _CIncompleteTextHandler_release(_impl);
  }

  _CIncompleteTextHandler _retain() {
    return _CIncompleteTextHandler_retain(_impl);
  }
}

extension _CIncompleteTextHandlerToDart on _CIncompleteTextHandler {
  IncompleteTextHandler _toDart() {
    return IncompleteTextHandler._create(_retain()._impl);
  }
}


extension _DartToCIncompleteTextHandler on IncompleteTextHandler {
  _CIncompleteTextHandler _copyFromDartTo_CIncompleteTextHandler() {
    return (_CIncompleteTextHandlerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - SuggestObjectHandler? <-> _COptional_CSuggestObjectHandler

final class _COptional_CSuggestObjectHandler extends ffi.Struct {
  
  external _CSuggestObjectHandler value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CSuggestObjectHandlerBasicFunctions on _COptional_CSuggestObjectHandler {
  void _releaseIntermediate() {
    _COptional_CSuggestObjectHandler_release(this);
  }
}

extension _COptional_CSuggestObjectHandlerToDart on _COptional_CSuggestObjectHandler {
  SuggestObjectHandler? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CSuggestObjectHandler on SuggestObjectHandler? {
  _COptional_CSuggestObjectHandler _copyFromDartTo_COptional_CSuggestObjectHandler() {
    final cOptional = _COptional_CSuggestObjectHandlerMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CSuggestObjectHandler();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - PerformSearchHandler? <-> _COptional_CPerformSearchHandler

final class _COptional_CPerformSearchHandler extends ffi.Struct {
  
  external _CPerformSearchHandler value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CPerformSearchHandlerBasicFunctions on _COptional_CPerformSearchHandler {
  void _releaseIntermediate() {
    _COptional_CPerformSearchHandler_release(this);
  }
}

extension _COptional_CPerformSearchHandlerToDart on _COptional_CPerformSearchHandler {
  PerformSearchHandler? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CPerformSearchHandler on PerformSearchHandler? {
  _COptional_CPerformSearchHandler _copyFromDartTo_COptional_CPerformSearchHandler() {
    final cOptional = _COptional_CPerformSearchHandlerMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CPerformSearchHandler();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - IncompleteTextHandler? <-> _COptional_CIncompleteTextHandler

final class _COptional_CIncompleteTextHandler extends ffi.Struct {
  
  external _CIncompleteTextHandler value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CIncompleteTextHandlerBasicFunctions on _COptional_CIncompleteTextHandler {
  void _releaseIntermediate() {
    _COptional_CIncompleteTextHandler_release(this);
  }
}

extension _COptional_CIncompleteTextHandlerToDart on _COptional_CIncompleteTextHandler {
  IncompleteTextHandler? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CIncompleteTextHandler on IncompleteTextHandler? {
  _COptional_CIncompleteTextHandler _copyFromDartTo_COptional_CIncompleteTextHandler() {
    final cOptional = _COptional_CIncompleteTextHandlerMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CIncompleteTextHandler();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - SuggestHandler

/** Обработчик выбора подсказки. */
final class SuggestHandler {
  final Object? _value;
  final int _index;

  SuggestHandler._raw(this._value, this._index);

  SuggestHandler.objectHandler(SuggestObjectHandler? value) : this._raw(value, 0);
  SuggestHandler.performSearchHandler(PerformSearchHandler? value) : this._raw(value, 1);
  SuggestHandler.incompleteTextHandler(IncompleteTextHandler? value) : this._raw(value, 2);

  bool get isObjectHandler => this._index == 0;
  SuggestObjectHandler? get asObjectHandler => this.isObjectHandler ? this._value as SuggestObjectHandler? : null;

  bool get isPerformSearchHandler => this._index == 1;
  PerformSearchHandler? get asPerformSearchHandler => this.isPerformSearchHandler ? this._value as PerformSearchHandler? : null;

  bool get isIncompleteTextHandler => this._index == 2;
  IncompleteTextHandler? get asIncompleteTextHandler => this.isIncompleteTextHandler ? this._value as IncompleteTextHandler? : null;

  T match<T>({
    required T Function(SuggestObjectHandler? value) objectHandler,
    required T Function(PerformSearchHandler? value) performSearchHandler,
    required T Function(IncompleteTextHandler? value) incompleteTextHandler,
  }) {
    return switch (this._index) {
      0 => objectHandler(this._value as SuggestObjectHandler?),
      1 => performSearchHandler(this._value as PerformSearchHandler?),
      2 => incompleteTextHandler(this._value as IncompleteTextHandler?),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "SuggestHandler(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SuggestHandler &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CSuggestHandlerImpl extends ffi.Union {
  external _COptional_CSuggestObjectHandler _objectHandler;
  external _COptional_CPerformSearchHandler _performSearchHandler;
  external _COptional_CIncompleteTextHandler _incompleteTextHandler;
}

final class _CSuggestHandler extends ffi.Struct {
  external _CSuggestHandlerImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CSuggestHandlerBasicFunctions on _CSuggestHandler {
  void _releaseIntermediate() {
    _CSuggestHandler_release(this);
  }
}
	
// MARK: - SuggestHandler <-> CSuggestHandler

extension _CSuggestHandlerToDart on _CSuggestHandler {
  SuggestHandler _toDart() {
    return switch (this._index) {
      0 => SuggestHandler.objectHandler(this._impl._objectHandler._toDart()),
      1 => SuggestHandler.performSearchHandler(this._impl._performSearchHandler._toDart()),
      2 => SuggestHandler.incompleteTextHandler(this._impl._incompleteTextHandler._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CSuggestHandler on SuggestHandler {
  _CSuggestHandler _copyFromDartTo_CSuggestHandler() {
    var res = _CSuggestHandlerMakeDefault();
    this.match<void>(
      objectHandler: (SuggestObjectHandler? value) {
        res._impl._objectHandler = value._copyFromDartTo_COptional_CSuggestObjectHandler();
        res._index = 0;
      },
      performSearchHandler: (PerformSearchHandler? value) {
        res._impl._performSearchHandler = value._copyFromDartTo_COptional_CPerformSearchHandler();
        res._index = 1;
      },
      incompleteTextHandler: (IncompleteTextHandler? value) {
        res._impl._incompleteTextHandler = value._copyFromDartTo_COptional_CIncompleteTextHandler();
        res._index = 2;
      },
    );
    return res;
  }
}

// MARK: - MarkedUpTextSpan

/** Описывает поднабор байтов строки text. */
class MarkedUpTextSpan {
  final int offset;
  final int length;

  const MarkedUpTextSpan({
    required this.offset,
    required this.length
  });

  MarkedUpTextSpan copyWith({
    int? offset,
    int? length
  }) {
    return MarkedUpTextSpan(
      offset: offset ?? this.offset,
      length: length ?? this.length
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MarkedUpTextSpan &&
    other.runtimeType == runtimeType &&
    other.offset == offset &&
    other.length == length;

  @override
  int get hashCode {
    return Object.hash(offset, length);
  }

}
final class _CMarkedUpTextSpan extends ffi.Struct {
  @ffi.Uint64()
  external int offset;

  @ffi.Uint64()
  external int length;

}
// MARK: - MarkedUpTextSpan <-> _CMarkedUpTextSpan

extension _CMarkedUpTextSpanToDart on _CMarkedUpTextSpan {
  MarkedUpTextSpan _toDart() {
    return MarkedUpTextSpan(
      offset: this.offset,
      length: this.length
    );
  }
}

extension _DartTo_CMarkedUpTextSpan on MarkedUpTextSpan {
  _CMarkedUpTextSpan _copyFromDartTo_CMarkedUpTextSpan() {
    final res = _CMarkedUpTextSpanMakeDefault();
    res.offset = this.offset;
    res.length = this.length;
    return res;
  }
}
extension _CMarkedUpTextSpanRelease on _CMarkedUpTextSpan {
  void _releaseIntermediate() {
  }
}

// MARK: - List<MarkedUpTextSpan> <-> _CArray_CMarkedUpTextSpan

final class _CArray_CMarkedUpTextSpan extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CMarkedUpTextSpanToDart on _CArray_CMarkedUpTextSpan {
  List<MarkedUpTextSpan> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CMarkedUpTextSpan on List<MarkedUpTextSpan> {
  _CArray_CMarkedUpTextSpan _copyFromDartTo_CArray_CMarkedUpTextSpan() {
    final cArray = _CArray_CMarkedUpTextSpanmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CMarkedUpTextSpan();
        _CArray_CMarkedUpTextSpanaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CMarkedUpTextSpanBasicFunctions on _CArray_CMarkedUpTextSpan {
  void _releaseIntermediate() {
    _CArray_CMarkedUpTextSpan_release(this);
  }

  static final _listToFill = <MarkedUpTextSpan>[];

  static void _iterate(_CMarkedUpTextSpan item) {
    _listToFill.add(item._toDart());
  }

  List<MarkedUpTextSpan> _fillFromC() {
    _forEach_CArray_CMarkedUpTextSpan(this, ffi.Pointer.fromFunction<ffi.Void Function(_CMarkedUpTextSpan)>(_iterate));
    final result = List<MarkedUpTextSpan>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - MarkedUpText

/** Размеченный текст. */
class MarkedUpText {
  /** Текст. */
  final String text;
  /**
   Набор непересекающихся Span в порядке их расположения в строке text, описывающих части, совпадающие
   с пользовательским запросом.
  */
  final List<MarkedUpTextSpan> matchedParts;

  const MarkedUpText({
    required this.text,
    required this.matchedParts
  });

  MarkedUpText copyWith({
    String? text,
    List<MarkedUpTextSpan>? matchedParts
  }) {
    return MarkedUpText(
      text: text ?? this.text,
      matchedParts: matchedParts ?? this.matchedParts
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MarkedUpText &&
    other.runtimeType == runtimeType &&
    other.text == text &&
    other.matchedParts == matchedParts;

  @override
  int get hashCode {
    return Object.hash(text, matchedParts);
  }

}
final class _CMarkedUpText extends ffi.Struct {
  external _CString text;

  external _CArray_CMarkedUpTextSpan matchedParts;

}
// MARK: - MarkedUpText <-> _CMarkedUpText

extension _CMarkedUpTextToDart on _CMarkedUpText {
  MarkedUpText _toDart() {
    return MarkedUpText(
      text: this.text._toDart(),
      matchedParts: this.matchedParts._toDart()
    );
  }
}

extension _DartTo_CMarkedUpText on MarkedUpText {
  _CMarkedUpText _copyFromDartTo_CMarkedUpText() {
    final res = _CMarkedUpTextMakeDefault();
    res.text = this.text._copyFromDartTo_CString();
    res.matchedParts = this.matchedParts._copyFromDartTo_CArray_CMarkedUpTextSpan();
    return res;
  }
}
extension _CMarkedUpTextRelease on _CMarkedUpText {
  void _releaseIntermediate() {
    text._releaseIntermediate();
    matchedParts._releaseIntermediate();
  }
}

// MARK: - SuggestedType

/** Тип поисковой подсказки. */
enum SuggestedType {
  /** Город. */
  admDivCity(0),
  /** Страна. */
  admDivCountry(1),
  /** Район. */
  admDivDistrict(2),
  /** Район области. */
  admDivDistrictArea(3),
  /** Округ. */
  admDivDivision(4),
  /** Жилмассив, микрорайон. */
  admDivLivingArea(5),
  /** Разные площадные объекты: парки, пляжи, территории баз отдыха, озёра и прочие места. */
  admDivPlace(6),
  /** Регион (область/край/республика и т.п.). */
  admDivRegion(7),
  /** Населённый пункт (деревня, посёлок и т.п.). */
  admDivSettlement(8),
  /** Достопримечательность. */
  attraction(9),
  /** Дополнительный атрибут. */
  attribute(10),
  /** Компания. */
  branch(11),
  /** Здание. */
  building(12),
  /** Глобальная координата в системе координат WGS84 в формате lon, lat. */
  coordinates(13),
  /** Перекрёсток. */
  crossroad(14),
  /** Знак километра. */
  kilometerRoadSign(15),
  /** Наименования товаров. */
  marketAttribute(16),
  /** Бренд товаров. */
  marketBrand(17),
  /** Категории товаров. Требует наличия market.suggestor_category. */
  marketCategory(18),
  /** Необходим для раскрытия категорий товаров. */
  marketSuggestorCategory(19),
  /** Метакатегория. */
  metaRubric(20),
  /** Организация. */
  org(21),
  /** Парковка. */
  parking(22),
  /** Дорога. */
  road(23),
  /** Маршрут. */
  route(24),
  /** Тип маршрута. */
  routeType(25),
  /** Категория. */
  rubric(26),
  /** Остановка или станция общественного транспорта. */
  station(27),
  /** Вход на станцию. */
  stationEntrance(28),
  /** Станция метро. */
  stationMetro(29),
  /** Улица. */
  street(30),
  /** Текстовая подсказка. */
  text(31),
  /** На случай получения неожиданного типа. */
  unknown(32),
  ;

  const SuggestedType(this.rawValue);
  final int rawValue;

  static SuggestedType getByValue(int value) {
    return SuggestedType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CSuggestedType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CSuggestedTypeBasicFunctions on _CSuggestedType {
  void _releaseIntermediate() {
  }
}

extension _CSuggestedTypeToDart on _CSuggestedType {
  SuggestedType _toDart() {
    return SuggestedType.getByValue(this.rawValue);
  }
}

extension _DartTo_CSuggestedType on SuggestedType {
  _CSuggestedType _copyFromDartTo_CSuggestedType() {
    return _CSuggestedTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - SuggestorType

/** Тип подсказчика. */
enum SuggestorType {
  /** Подсказка адресов. */
  address(0),
  /** Подсказка населённых пунктов. Может использоваться без указания проекта. */
  citySelector(1),
  /** Подсказка по объектам справочника (категории, фирмы, улицы, города и т.д.). */
  object(2),
  /** Подсказка мест. */
  places(3),
  /** Идеально подходит для быстрого поиска конечных объектов маршрута. Все результаты имеют id и координаты. */
  routeEndpoint(4),
  /** Подсказка категорий. */
  rubric(5),
  ;

  const SuggestorType(this.rawValue);
  final int rawValue;

  static SuggestorType getByValue(int value) {
    return SuggestorType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CSuggestorType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CSuggestorTypeBasicFunctions on _CSuggestorType {
  void _releaseIntermediate() {
  }
}

extension _CSuggestorTypeToDart on _CSuggestorType {
  SuggestorType _toDart() {
    return SuggestorType.getByValue(this.rawValue);
  }
}

extension _DartTo_CSuggestorType on SuggestorType {
  _CSuggestorType _copyFromDartTo_CSuggestorType() {
    return _CSuggestorTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - Suggest

/** Поисковая подсказка. */
class Suggest implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Обработчик выбора подсказки. */
  SuggestHandler get handler {
    _CSuggestHandler res = _CSuggest_handler(_CSuggestMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Тип подсказки. */
  SuggestedType get suggestedType {
    _CSuggestedType res = _CSuggest_suggestedType(_CSuggestMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Заголовок подсказки. */
  MarkedUpText get title {
    _CMarkedUpText res = _CSuggest_title(_CSuggestMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Подзаголовок подсказки. */
  MarkedUpText get subtitle {
    _CMarkedUpText res = _CSuggest_subtitle(_CSuggestMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CSuggest_releasePtr);

  Suggest._raw(this._self);
  factory Suggest._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Suggest._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Suggest &&
    other.runtimeType == runtimeType &&
    _CSuggest_cg_objectIdentifier(this._self) == _CSuggest_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSuggest_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Suggest <-> CSuggest

final class _CSuggest extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSuggestBasicFunctions on _CSuggest {
  void _releaseIntermediate() {
    _CSuggest_release(_impl);
  }

  _CSuggest _retain() {
    return _CSuggest_retain(_impl);
  }
}

extension _CSuggestToDart on _CSuggest {
  Suggest _toDart() {
    return Suggest._create(_retain()._impl);
  }
}


extension _DartToCSuggest on Suggest {
  _CSuggest _copyFromDartTo_CSuggest() {
    return (_CSuggestMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - SuggestResult

/** Результат работы подсказчика. */
class SuggestResult implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Набор предложенных вариантов подсказок.
  
   - Note: набор пуст, если подходящие подсказки не найдены
  */
  List<Suggest> get suggests {
    _CArray_CSuggest res = _CSuggestResult_suggests(_CSuggestResultMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CSuggestResult_releasePtr);

  SuggestResult._raw(this._self);
  factory SuggestResult._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SuggestResult._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SuggestResult &&
    other.runtimeType == runtimeType &&
    _CSuggestResult_cg_objectIdentifier(this._self) == _CSuggestResult_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSuggestResult_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - SuggestResult <-> CSuggestResult

final class _CSuggestResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSuggestResultBasicFunctions on _CSuggestResult {
  void _releaseIntermediate() {
    _CSuggestResult_release(_impl);
  }

  _CSuggestResult _retain() {
    return _CSuggestResult_retain(_impl);
  }
}

extension _CSuggestResultToDart on _CSuggestResult {
  SuggestResult _toDart() {
    return SuggestResult._create(_retain()._impl);
  }
}


extension _DartToCSuggestResult on SuggestResult {
  _CSuggestResult _copyFromDartTo_CSuggestResult() {
    return (_CSuggestResultMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<Suggest> <-> _CArray_CSuggest

final class _CArray_CSuggest extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CSuggestToDart on _CArray_CSuggest {
  List<Suggest> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CSuggest on List<Suggest> {
  _CArray_CSuggest _copyFromDartTo_CArray_CSuggest() {
    final cArray = _CArray_CSuggestmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CSuggest();
        _CArray_CSuggestaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CSuggestBasicFunctions on _CArray_CSuggest {
  void _releaseIntermediate() {
    _CArray_CSuggest_release(this);
  }

  static final _listToFill = <Suggest>[];

  static void _iterate(_CSuggest item) {
    _listToFill.add(item._toDart());
  }

  List<Suggest> _fillFromC() {
    _forEach_CArray_CSuggest(this, ffi.Pointer.fromFunction<ffi.Void Function(_CSuggest)>(_iterate));
    final result = List<Suggest>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - SuggestQuery

/** Запрос поисковой подсказки. */
class SuggestQuery implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CSuggestQuery_releasePtr);

  SuggestQuery._raw(this._self);
  factory SuggestQuery._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SuggestQuery._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SuggestQuery &&
    other.runtimeType == runtimeType &&
    _CSuggestQuery_cg_objectIdentifier(this._self) == _CSuggestQuery_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSuggestQuery_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - SuggestQuery <-> CSuggestQuery

final class _CSuggestQuery extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSuggestQueryBasicFunctions on _CSuggestQuery {
  void _releaseIntermediate() {
    _CSuggestQuery_release(_impl);
  }

  _CSuggestQuery _retain() {
    return _CSuggestQuery_retain(_impl);
  }
}

extension _CSuggestQueryToDart on _CSuggestQuery {
  SuggestQuery _toDart() {
    return SuggestQuery._create(_retain()._impl);
  }
}


extension _DartToCSuggestQuery on SuggestQuery {
  _CSuggestQuery _copyFromDartTo_CSuggestQuery() {
    return (_CSuggestQueryMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - SearchManager

/**
 Поисковик.
 Основная точка входа для справочного API.
*/
class SearchManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CSearchManager_releasePtr);

  SearchManager._raw(this._self);
  factory SearchManager._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SearchManager._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SearchManager &&
    other.runtimeType == runtimeType &&
    _CSearchManager_cg_objectIdentifier(this._self) == _CSearchManager_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSearchManager_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CSearchManager: Static Methods

  /** Создать поисковик, работающий онлайн. */
  static SearchManager createOnlineManager(
    Context context
  )  {
    var _a0 = context._copyFromDartTo_CContext();
    _CResult_CSearchManager res = _CSearchManager_S_createOnlineManager_CContext(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  // MARK: SearchManager: Methods

  /**
   Получить подсказки, соответствующие данному запросу.
  
   - Returns: future, резолвящаяся в ненулевой указатель на результат подбора подсказок
   или exceptional future, если произошла ошибка при получении подсказок
  */
  CancelableOperation<SuggestResult> suggest(
    SuggestQuery query
  )  {
    var _a1 = query._copyFromDartTo_CSuggestQuery();
    _CFuture_CSuggestResult res = _CSearchManager_suggest_CSuggestQuery(_CSearchManagerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Получить объекты справочника, соответствующие данному запросу.
  
   - Returns: future, резолвящаяся в ненулевой указатель на результат поиска
   или exceptional future, если произошла ошибка при получении результатов поиска
  */
  CancelableOperation<SearchResult> search(
    SearchQuery query
  )  {
    var _a1 = query._copyFromDartTo_CSearchQuery();
    _CFuture_CSearchResult res = _CSearchManager_search_CSearchQuery(_CSearchManagerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Получить объект справочника по строковому идентификатору.
  
   - Returns: future, резолвящаяся в указатель на объект справочника.
   Если объект не найден, то вернется пустой указатель
  */
  CancelableOperation<DirectoryObject?> searchById(
    String id
  )  {
    var _a1 = id._copyFromDartTo_CString();
    _CFuture_COptional_CDirectoryObject res = _CSearchManager_searchById_CString(_CSearchManagerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Получить объект справочника по идентификатору.
  
   - Returns: future, резолвящаяся в указатель на объект справочника.
   Если объект не найден, то вернется пустой указатель
  */
  CancelableOperation<DirectoryObject?> searchByDirectoryObjectId(
    DgisObjectId objectId
  )  {
    var _a1 = objectId._copyFromDartTo_CDgisObjectId();
    _CFuture_COptional_CDirectoryObject res = _CSearchManager_searchByDirectoryObjectId_CDgisObjectId(_CSearchManagerMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Получить объект справочника по строковому идентификатору с указанной локалью.
  
   - Returns: future, резолвящаяся в указатель на объект справочника.
   Если объект не найден, то вернется пустой указатель
  */
  CancelableOperation<DirectoryObject?> searchByIdWithLocale(
    String id,
    Locale? locale
  )  {
    var _a1 = id._copyFromDartTo_CString();
    var _a2 = locale._copyFromDartTo_COptional_CLocale();
    _CFuture_COptional_CDirectoryObject res = _CSearchManager_searchByIdWithLocale_CString_COptional_CLocale(_CSearchManagerMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Получить объект справочника по идентификатору с указанной локалью.
  
   - Returns: future, резолвящаяся в указатель на объект справочника.
   Если объект не найден, то вернется пустой указатель
  */
  CancelableOperation<DirectoryObject?> searchByDirectoryObjectIdWithLocale(
    DgisObjectId objectId,
    Locale? locale
  )  {
    var _a1 = objectId._copyFromDartTo_CDgisObjectId();
    var _a2 = locale._copyFromDartTo_COptional_CLocale();
    _CFuture_COptional_CDirectoryObject res = _CSearchManager_searchByDirectoryObjectIdWithLocale_CDgisObjectId_COptional_CLocale(_CSearchManagerMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - SearchManager <-> CSearchManager

final class _CSearchManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSearchManagerBasicFunctions on _CSearchManager {
  void _releaseIntermediate() {
    _CSearchManager_release(_impl);
  }

  _CSearchManager _retain() {
    return _CSearchManager_retain(_impl);
  }
}

extension _CSearchManagerToDart on _CSearchManager {
  SearchManager _toDart() {
    return SearchManager._create(_retain()._impl);
  }
}


extension _DartToCSearchManager on SearchManager {
  _CSearchManager _copyFromDartTo_CSearchManager() {
    return (_CSearchManagerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - SearchManager <-> _CResult_CSearchManager

final class _CResult_CSearchManagerImpl extends ffi.Union {
  
  external _CSearchManager _value;
  external _CError _error;
}

final class _CResult_CSearchManager extends ffi.Struct {
  external _CResult_CSearchManagerImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CSearchManagerBasicFunctions on _CResult_CSearchManager {
  void _releaseIntermediate() {
    _CResult_CSearchManager_release(this);
  }
}

extension _CResult_CSearchManagerToDart on _CResult_CSearchManager {
  SearchManager _toDart() {
    if (this._index == 0) {
      return this._impl._value._toDart();
    } else {
      throw this._impl._error._toDart();
    }
  }

  _CSearchManager _toCDart() {
    if (this._index == 0) {
      return this._impl._value;
    } else {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - CancelableOperation<SuggestResult> <-> _CFuture_CSuggestResult

final class _CFuture_CSuggestResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CSuggestResult_Cancellable {
  final Completer<SuggestResult> completer;
  final _CFuture_CSuggestResult _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CSuggestResult, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CSuggestResult_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CSuggestResultBasicFunctions on _CFuture_CSuggestResult {
  void _releaseIntermediate() {
    _CFuture_CSuggestResult_release(this);
  }

  _CFuture_CSuggestResult _retain() {
    return _CFuture_CSuggestResult_retain(this);
  }
}

extension _CFuture_CSuggestResultToDart on _CFuture_CSuggestResult {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CSuggestResult_Cancellable>{};

  static void valueFunction(_CSuggestResult cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<SuggestResult> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<SuggestResult>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CSuggestResult, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CSuggestResultReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CSuggestResult_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CSuggestResult on CancelableOperation<SuggestResult> {
  _CFuture_CSuggestResult _copyFromDartTo_CFuture_CSuggestResult() {
    return _CFuture_CSuggestResultMakeDefault();
  }
}
	
// MARK: - CancelableOperation<SearchResult> <-> _CFuture_CSearchResult

final class _CFuture_CSearchResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CSearchResult_Cancellable {
  final Completer<SearchResult> completer;
  final _CFuture_CSearchResult _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CSearchResult, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CSearchResult_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CSearchResultBasicFunctions on _CFuture_CSearchResult {
  void _releaseIntermediate() {
    _CFuture_CSearchResult_release(this);
  }

  _CFuture_CSearchResult _retain() {
    return _CFuture_CSearchResult_retain(this);
  }
}

extension _CFuture_CSearchResultToDart on _CFuture_CSearchResult {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CSearchResult_Cancellable>{};

  static void valueFunction(_CSearchResult cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<SearchResult> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<SearchResult>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CSearchResult, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CSearchResultReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CSearchResult_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CSearchResult on CancelableOperation<SearchResult> {
  _CFuture_CSearchResult _copyFromDartTo_CFuture_CSearchResult() {
    return _CFuture_CSearchResultMakeDefault();
  }
}
	
// MARK: - CancelableOperation<DirectoryObject?> <-> _CFuture_COptional_CDirectoryObject

final class _CFuture_COptional_CDirectoryObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_COptional_CDirectoryObject_Cancellable {
  final Completer<DirectoryObject?> completer;
  final _CFuture_COptional_CDirectoryObject _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_COptional_CDirectoryObject, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_COptional_CDirectoryObject_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_COptional_CDirectoryObjectBasicFunctions on _CFuture_COptional_CDirectoryObject {
  void _releaseIntermediate() {
    _CFuture_COptional_CDirectoryObject_release(this);
  }

  _CFuture_COptional_CDirectoryObject _retain() {
    return _CFuture_COptional_CDirectoryObject_retain(this);
  }
}

extension _CFuture_COptional_CDirectoryObjectToDart on _CFuture_COptional_CDirectoryObject {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_COptional_CDirectoryObject_Cancellable>{};

  static void valueFunction(_COptional_CDirectoryObject cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<DirectoryObject?> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<DirectoryObject?>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CDirectoryObject, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_COptional_CDirectoryObjectReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_COptional_CDirectoryObject_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_COptional_CDirectoryObject on CancelableOperation<DirectoryObject?> {
  _CFuture_COptional_CDirectoryObject _copyFromDartTo_CFuture_COptional_CDirectoryObject() {
    return _CFuture_COptional_CDirectoryObjectMakeDefault();
  }
}
	
// MARK: - DirectoryObject? <-> _COptional_CDirectoryObject

final class _COptional_CDirectoryObject extends ffi.Struct {
  
  external _CDirectoryObject value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CDirectoryObjectBasicFunctions on _COptional_CDirectoryObject {
  void _releaseIntermediate() {
    _COptional_CDirectoryObject_release(this);
  }
}

extension _COptional_CDirectoryObjectToDart on _COptional_CDirectoryObject {
  DirectoryObject? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CDirectoryObject on DirectoryObject? {
  _COptional_CDirectoryObject _copyFromDartTo_COptional_CDirectoryObject() {
    final cOptional = _COptional_CDirectoryObjectMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CDirectoryObject();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Locale

/** Локаль. */
class Locale {
  /** Код языка, описанный в стандарте ISO 639-1, */
  final String language;
  /** Код страны, описанный в стандарте ISO 3166-1. */
  final String region;

  const Locale({
    required this.language,
    required this.region
  });

  // MARK: CLocale: Static Methods

  /** Создать локаль по строковому представлению в виде LanguageTag или POSIX. */
  static Locale? makeLocale(
    String localeStr
  )  {
    var _a0 = localeStr._copyFromDartTo_CString();
    _COptional_CLocale res = _CFunction_G_makeLocale_With_CString(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  Locale copyWith({
    String? language,
    String? region
  }) {
    return Locale(
      language: language ?? this.language,
      region: region ?? this.region
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Locale &&
    other.runtimeType == runtimeType &&
    other.language == language &&
    other.region == region;

  @override
  int get hashCode {
    return Object.hash(language, region);
  }

}
final class _CLocale extends ffi.Struct {
  external _CString language;

  external _CString region;

}
// MARK: - Locale <-> _CLocale

extension _CLocaleToDart on _CLocale {
  Locale _toDart() {
    return Locale(
      language: this.language._toDart(),
      region: this.region._toDart()
    );
  }
}

extension _DartTo_CLocale on Locale {
  _CLocale _copyFromDartTo_CLocale() {
    final res = _CLocaleMakeDefault();
    res.language = this.language._copyFromDartTo_CString();
    res.region = this.region._copyFromDartTo_CString();
    return res;
  }
}
extension _CLocaleRelease on _CLocale {
  void _releaseIntermediate() {
    language._releaseIntermediate();
    region._releaseIntermediate();
  }
}

// MARK: - Locale? <-> _COptional_CLocale

final class _COptional_CLocale extends ffi.Struct {
  
  external _CLocale value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CLocaleBasicFunctions on _COptional_CLocale {
  void _releaseIntermediate() {
    _COptional_CLocale_release(this);
  }
}

extension _COptional_CLocaleToDart on _COptional_CLocale {
  Locale? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CLocale on Locale? {
  _COptional_CLocale _copyFromDartTo_COptional_CLocale() {
    final cOptional = _COptional_CLocaleMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CLocale();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - SearchQueryBuilder

/**
 Построитель поисковых запросов.
 Поиск осуществляется по глобальному индексу, а также по локальным индексам сегментов,
 где сегмент - это некоторый кусок разбиения глобальной карты.
 Процедура выбора сегментов для поиска осуществляется следующими способами (по убыванию приоритета):
 1. Если явно задается область в виде полигона в запросе (spatial_restriction), то она учитывается в первую очередь.
 Способы ниже по приоритету отключаются, однако используются для учёта расстояний в релевантности поиска.
 2. При указании прямоугольной области интереса (bounding_rect), поиск ведется в некоторой ее окрестности.
 3. Если не указаны вышестоящие по приоритету параметры, то учитывается точка положения пользователя.

 - Todo: Данное условие пока не работает. Будет исправлено в ближайших релизах.
 4. При упоминании в тексте запроса широко известного объекта (город, область или другой топоним)
 добавляется в поиск тот сегмент, в который попадает точка найденного объекта из глобального индекса.
 5. Если не указано ничего из вышеперечисленного, то осуществляется поиск по глобальному индексу.
*/
class SearchQueryBuilder implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CSearchQueryBuilder_releasePtr);

  SearchQueryBuilder._raw(this._self);
  factory SearchQueryBuilder._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SearchQueryBuilder._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SearchQueryBuilder &&
    other.runtimeType == runtimeType &&
    _CSearchQueryBuilder_cg_objectIdentifier(this._self) == _CSearchQueryBuilder_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSearchQueryBuilder_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CSearchQueryBuilder: Static Methods

  /** Начать построение текстового поискового запроса c указанным текстом. */
  static SearchQueryBuilder fromQueryText(
    String queryText
  )  {
    var _a0 = queryText._copyFromDartTo_CString();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_S_fromQueryText_CString(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Начать построение поискового запроса на основе идентификаторов рубрик. */
  static SearchQueryBuilder fromRubricIds(
    List<RubricId> rubricIds
  )  {
    var _a0 = rubricIds._copyFromDartTo_CArray_CRubricId();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_S_fromRubricIds_CArray_CRubricId(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Начать построение текстового поискового запроса с фильтрацией по идентификаторам рубрик. */
  static SearchQueryBuilder fromQueryTextAndRubricIds(
    String queryText,
    List<RubricId> rubricIds
  )  {
    var _a0 = queryText._copyFromDartTo_CString();
    var _a1 = rubricIds._copyFromDartTo_CArray_CRubricId();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_S_fromQueryTextAndRubricIds_CString_CArray_CRubricId(_a0, _a1);
    _a1._releaseIntermediate();
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Начать построение запроса на основе запроса #query для изменения части параметров.
  
   - Note: Исходный запрос #query остается без изменений
  */
  static SearchQueryBuilder fromQuery(
    SearchQuery query
  )  {
    var _a0 = query._copyFromDartTo_CSearchQuery();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_S_fromQuery_CSearchQuery(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Начать построение поискового запроса c указанным идентификатором организации. */
  static SearchQueryBuilder fromOrgId(
    OrgId orgId
  )  {
    var _a0 = orgId._copyFromDartTo_COrgId();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_S_fromOrgId_COrgId(_a0);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Начать построение поискового запроса c указанным идентификатором здания. */
  static SearchQueryBuilder fromBuildingId(
    BuildingId buildingId
  )  {
    var _a0 = buildingId._copyFromDartTo_CBuildingId();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_S_fromBuildingId_CBuildingId(_a0);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Начать построение поискового запроса c указанным центром области поиска. Радиус по умолчанию равен 250.
   Конфликтует с методом set_spatial_restriction.
   Работает только с онлайн поиском.
  */
  static SearchQueryBuilder fromGeoPoint(
    GeoPoint geoPoint
  )  {
    var _a0 = geoPoint._copyFromDartTo_CGeoPoint();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_S_fromGeoPoint_CGeoPoint(_a0);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  // MARK: SearchQueryBuilder: Methods

  /**
   Задать ограничение области поиска в форме полигона.
   Первая и последняя точки полигона не обязаны совпадать.
   Конфликтует с методоми set_geo_point и from_geo_point.
  
   - Note: по умолчанию ограничение отсутствует.
  */
  SearchQueryBuilder setSpatialRestriction(
    List<GeoPoint>? spatialRestriction
  )  {
    var _a1 = spatialRestriction._copyFromDartTo_COptional_CArray_CGeoPoint();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_setSpatialRestriction_COptional_CArray_CGeoPoint(_CSearchQueryBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Задать прямоугольную область интереса в географических координатах.
   Типичным значением является visible_rect из ICamera - объемлющий прямоугольник области просмотра.
  */
  SearchQueryBuilder setAreaOfInterest(
    GeoRect? rect
  )  {
    var _a1 = rect._copyFromDartTo_COptional_CGeoRect();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_setAreaOfInterest_COptional_CGeoRect(_CSearchQueryBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Задать типы объектов, разрешенные в результате запроса.
  
   - Note: по умолчанию все, кроме Route
  */
  SearchQueryBuilder setAllowedResultTypes(
    List<ObjectType> allowedResultTypes
  )  {
    var _a1 = allowedResultTypes._copyFromDartTo_CArray_CObjectType();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_setAllowedResultTypes_CArray_CObjectType(_CSearchQueryBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Задать предпочитаемое количество элементов на странице результатов.
   Допустимы значения из диапазона [1; 50]
  
   - Note: по умолчанию 10
  */
  SearchQueryBuilder setPageSize(
    int pageSize
  )  {
    _CSearchQueryBuilder res = _CSearchQueryBuilder_setPageSize_int32_t(_CSearchQueryBuilderMakeDefault().._impl=_self, pageSize);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Задать фильтрацию для поискового запроса. */
  SearchQueryBuilder setDirectoryFilter(
    DirectoryFilter filter
  )  {
    var _a1 = filter._copyFromDartTo_CDirectoryFilter();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_setDirectoryFilter_CDirectoryFilter(_CSearchQueryBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Задать сортировку для поискового запроса. */
  SearchQueryBuilder setSortingType(
    SortingType sortingType
  )  {
    var _a1 = sortingType._copyFromDartTo_CSortingType();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_setSortingType_CSortingType(_CSearchQueryBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Задать центр для поискового запроса. Радиус по умолчанию равен 250 метров.
   Конфликтует с методом set_spatial_restriction.
  */
  SearchQueryBuilder setGeoPoint(
    GeoPoint geoPoint
  )  {
    var _a1 = geoPoint._copyFromDartTo_CGeoPoint();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_setGeoPoint_CGeoPoint(_CSearchQueryBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Задать радиус поиска в метрах.
   Работает в сочетании с установленным geo_point.
   Для поискового запроса в точке ограничение от 0 до 2000.
   Для остальных запросов ограничение от 0 до 50000.
  */
  SearchQueryBuilder setRadius(
    Meter radius
  )  {
    var _a1 = radius._copyFromDartTo_CMeter();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_setRadius_CMeter(_CSearchQueryBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Задать локаль для поискового запроса. */
  SearchQueryBuilder setLocale(
    Locale? locale
  )  {
    var _a1 = locale._copyFromDartTo_COptional_CLocale();
    _CSearchQueryBuilder res = _CSearchQueryBuilder_setLocale_COptional_CLocale(_CSearchQueryBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Сформировать поисковый запрос. */
  SearchQuery build()  {
    _CSearchQuery res = _CSearchQueryBuilder_build(_CSearchQueryBuilderMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - SearchQueryBuilder <-> CSearchQueryBuilder

final class _CSearchQueryBuilder extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSearchQueryBuilderBasicFunctions on _CSearchQueryBuilder {
  void _releaseIntermediate() {
    _CSearchQueryBuilder_release(_impl);
  }

  _CSearchQueryBuilder _retain() {
    return _CSearchQueryBuilder_retain(_impl);
  }
}

extension _CSearchQueryBuilderToDart on _CSearchQueryBuilder {
  SearchQueryBuilder _toDart() {
    return SearchQueryBuilder._create(_retain()._impl);
  }
}


extension _DartToCSearchQueryBuilder on SearchQueryBuilder {
  _CSearchQueryBuilder _copyFromDartTo_CSearchQueryBuilder() {
    return (_CSearchQueryBuilderMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<GeoPoint>? <-> _COptional_CArray_CGeoPoint

final class _COptional_CArray_CGeoPoint extends ffi.Struct {
  
  external _CArray_CGeoPoint value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CArray_CGeoPointBasicFunctions on _COptional_CArray_CGeoPoint {
  void _releaseIntermediate() {
    _COptional_CArray_CGeoPoint_release(this);
  }
}

extension _COptional_CArray_CGeoPointToDart on _COptional_CArray_CGeoPoint {
  List<GeoPoint>? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CArray_CGeoPoint on List<GeoPoint>? {
  _COptional_CArray_CGeoPoint _copyFromDartTo_COptional_CArray_CGeoPoint() {
    final cOptional = _COptional_CArray_CGeoPointMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CArray_CGeoPoint();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - GeoRect? <-> _COptional_CGeoRect

final class _COptional_CGeoRect extends ffi.Struct {
  
  external _CGeoRect value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CGeoRectBasicFunctions on _COptional_CGeoRect {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CGeoRectToDart on _COptional_CGeoRect {
  GeoRect? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CGeoRect on GeoRect? {
  _COptional_CGeoRect _copyFromDartTo_COptional_CGeoRect() {
    final cOptional = _COptional_CGeoRectMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CGeoRect();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - SuggestQueryBuilder

/** Построитель запросов к подсказчику. */
class SuggestQueryBuilder implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CSuggestQueryBuilder_releasePtr);

  SuggestQueryBuilder._raw(this._self);
  factory SuggestQueryBuilder._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SuggestQueryBuilder._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SuggestQueryBuilder &&
    other.runtimeType == runtimeType &&
    _CSuggestQueryBuilder_cg_objectIdentifier(this._self) == _CSuggestQueryBuilder_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSuggestQueryBuilder_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CSuggestQueryBuilder: Static Methods

  /** Начать построение запроса подсказки для заданного текста и области интереса. */
  static SuggestQueryBuilder fromQueryText(
    String queryText
  )  {
    var _a0 = queryText._copyFromDartTo_CString();
    _CSuggestQueryBuilder res = _CSuggestQueryBuilder_S_fromQueryText_CString(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Начать построение запроса подсказки на основе запроса #query для изменения части параметров.
  
   - Note: Исходный запрос #query остается без изменений
  */
  static SuggestQueryBuilder fromQuery(
    SuggestQuery query
  )  {
    var _a0 = query._copyFromDartTo_CSuggestQuery();
    _CSuggestQueryBuilder res = _CSuggestQueryBuilder_S_fromQuery_CSuggestQuery(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  // MARK: SuggestQueryBuilder: Methods

  /**
   Задать ограничение области поиска в форме полигона.
   Первая и последняя точки полигона не обязаны совпадать.
  
   - Note: по умолчанию ограничение отсутствует
  */
  SuggestQueryBuilder setSpatialRestriction(
    List<GeoPoint>? spatialRestriction
  )  {
    var _a1 = spatialRestriction._copyFromDartTo_COptional_CArray_CGeoPoint();
    _CSuggestQueryBuilder res = _CSuggestQueryBuilder_setSpatialRestriction_COptional_CArray_CGeoPoint(_CSuggestQueryBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Задать прямоугольную область интереса в географических координатах.
   Типичным значением является visible_rect из ICamera - объемлющий прямоугольник области просмотра.
  */
  SuggestQueryBuilder setAreaOfInterest(
    GeoRect? rect
  )  {
    var _a1 = rect._copyFromDartTo_COptional_CGeoRect();
    _CSuggestQueryBuilder res = _CSuggestQueryBuilder_setAreaOfInterest_COptional_CGeoRect(_CSuggestQueryBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Задать типы объектов, разрешенные в результате запроса.
  
   - Note: по умолчанию все, кроме Route
  */
  SuggestQueryBuilder setAllowedResultTypes(
    List<SuggestedType> allowedResultTypes
  )  {
    var _a1 = allowedResultTypes._copyFromDartTo_CArray_CSuggestedType();
    _CSuggestQueryBuilder res = _CSuggestQueryBuilder_setAllowedResultTypes_CArray_CSuggestedType(_CSuggestQueryBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Задать тип подсказчика.
  
   - Note: по умолчанию #SuggestorType::Object
  */
  SuggestQueryBuilder setSuggestorType(
    SuggestorType suggestorType
  )  {
    var _a1 = suggestorType._copyFromDartTo_CSuggestorType();
    _CSuggestQueryBuilder res = _CSuggestQueryBuilder_setSuggestorType_CSuggestorType(_CSuggestQueryBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Задать желаемое количество подсказок.
   Допустимы значения из диапазона [1; 50]
  
   - Note: по умолчанию 10
  */
  SuggestQueryBuilder setLimit(
    int limit
  )  {
    _CSuggestQueryBuilder res = _CSuggestQueryBuilder_setLimit_int32_t(_CSuggestQueryBuilderMakeDefault().._impl=_self, limit);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Локаль, с которой производится запрос подсказки и отдаются результаты. */
  SuggestQueryBuilder setLocale(
    Locale? locale
  )  {
    var _a1 = locale._copyFromDartTo_COptional_CLocale();
    _CSuggestQueryBuilder res = _CSuggestQueryBuilder_setLocale_COptional_CLocale(_CSuggestQueryBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Сформировать запрос к подсказчику. */
  SuggestQuery build()  {
    _CSuggestQuery res = _CSuggestQueryBuilder_build(_CSuggestQueryBuilderMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - SuggestQueryBuilder <-> CSuggestQueryBuilder

final class _CSuggestQueryBuilder extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSuggestQueryBuilderBasicFunctions on _CSuggestQueryBuilder {
  void _releaseIntermediate() {
    _CSuggestQueryBuilder_release(_impl);
  }

  _CSuggestQueryBuilder _retain() {
    return _CSuggestQueryBuilder_retain(_impl);
  }
}

extension _CSuggestQueryBuilderToDart on _CSuggestQueryBuilder {
  SuggestQueryBuilder _toDart() {
    return SuggestQueryBuilder._create(_retain()._impl);
  }
}


extension _DartToCSuggestQueryBuilder on SuggestQueryBuilder {
  _CSuggestQueryBuilder _copyFromDartTo_CSuggestQueryBuilder() {
    return (_CSuggestQueryBuilderMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<SuggestedType> <-> _CArray_CSuggestedType

final class _CArray_CSuggestedType extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CSuggestedTypeToDart on _CArray_CSuggestedType {
  List<SuggestedType> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CSuggestedType on List<SuggestedType> {
  _CArray_CSuggestedType _copyFromDartTo_CArray_CSuggestedType() {
    final cArray = _CArray_CSuggestedTypemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CSuggestedType();
        _CArray_CSuggestedTypeaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CSuggestedTypeBasicFunctions on _CArray_CSuggestedType {
  void _releaseIntermediate() {
    _CArray_CSuggestedType_release(this);
  }

  static final _listToFill = <SuggestedType>[];

  static void _iterate(_CSuggestedType item) {
    _listToFill.add(item._toDart());
  }

  List<SuggestedType> _fillFromC() {
    _forEach_CArray_CSuggestedType(this, ffi.Pointer.fromFunction<ffi.Void Function(_CSuggestedType)>(_iterate));
    final result = List<SuggestedType>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - ChangeType

enum ChangeType {
  add(0),
  remove(1),
  ;

  const ChangeType(this.rawValue);
  final int rawValue;

  static ChangeType getByValue(int value) {
    return ChangeType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CChangeType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CChangeTypeBasicFunctions on _CChangeType {
  void _releaseIntermediate() {
  }
}

extension _CChangeTypeToDart on _CChangeType {
  ChangeType _toDart() {
    return ChangeType.getByValue(this.rawValue);
  }
}

extension _DartTo_CChangeType on ChangeType {
  _CChangeType _copyFromDartTo_CChangeType() {
    return _CChangeTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - SearchQueryWithInfo

/** Класс с дополнительной информацией о поисковом запросе для вывода в UI-элементах. */
class SearchQueryWithInfo implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Возвращает объект поискового запроса. */
  SearchQuery get searchQuery {
    _CSearchQuery res = _CSearchQueryWithInfo_searchQuery(_CSearchQueryWithInfoMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Возвращает текст заголовка, который описывает объекты поискового
   запроса. Например, это может быть текст из поля title объекта
   ISuggest.
  */
  String get title {
    _CString res = _CSearchQueryWithInfo_title(_CSearchQueryWithInfoMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Возвращает текст подзаголовка. Например, это может быть текст из поля
   subtitle объекта ISuggest.
  */
  String get subtitle {
    _CString res = _CSearchQueryWithInfo_subtitle(_CSearchQueryWithInfoMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Возвращает список рубрик, по которым производится запрос. */
  List<RubricId> get rubrics {
    _CArray_CRubricId res = _CSearchQueryWithInfo_rubrics(_CSearchQueryWithInfoMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CSearchQueryWithInfo_releasePtr);

  SearchQueryWithInfo._raw(this._self);
  factory SearchQueryWithInfo._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SearchQueryWithInfo._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory SearchQueryWithInfo(
    SearchQuery searchQuery,
    String title,
    String subtitle
  ) {
    var _a0 = searchQuery._copyFromDartTo_CSearchQuery();
    var _a1 = title._copyFromDartTo_CString();
    var _a2 = subtitle._copyFromDartTo_CString();
    _CSearchQueryWithInfo res = _CSearchQueryWithInfo_C_createWith_CSearchQuery_CString_CString(_a0, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    _a0._releaseIntermediate();
    return SearchQueryWithInfo._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SearchQueryWithInfo &&
    other.runtimeType == runtimeType &&
    _CSearchQueryWithInfo_cg_objectIdentifier(this._self) == _CSearchQueryWithInfo_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSearchQueryWithInfo_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - SearchQueryWithInfo <-> CSearchQueryWithInfo

final class _CSearchQueryWithInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSearchQueryWithInfoBasicFunctions on _CSearchQueryWithInfo {
  void _releaseIntermediate() {
    _CSearchQueryWithInfo_release(_impl);
  }

  _CSearchQueryWithInfo _retain() {
    return _CSearchQueryWithInfo_retain(_impl);
  }
}

extension _CSearchQueryWithInfoToDart on _CSearchQueryWithInfo {
  SearchQueryWithInfo _toDart() {
    return SearchQueryWithInfo._create(_retain()._impl);
  }
}


extension _DartToCSearchQueryWithInfo on SearchQueryWithInfo {
  _CSearchQueryWithInfo _copyFromDartTo_CSearchQueryWithInfo() {
    return (_CSearchQueryWithInfoMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - SearchHistoryItem

/** Тип данных для элемента поиска, сохраненного в истории поиска: может быть объект или поисковый запрос. */
final class SearchHistoryItem {
  final Object? _value;
  final int _index;

  SearchHistoryItem._raw(this._value, this._index);

  SearchHistoryItem.directoryObject(DirectoryObject value) : this._raw(value, 0);
  SearchHistoryItem.searchQuery(SearchQueryWithInfo value) : this._raw(value, 1);

  bool get isDirectoryObject => this._index == 0;
  DirectoryObject? get asDirectoryObject => this.isDirectoryObject ? this._value as DirectoryObject : null;

  bool get isSearchQuery => this._index == 1;
  SearchQueryWithInfo? get asSearchQuery => this.isSearchQuery ? this._value as SearchQueryWithInfo : null;

  T match<T>({
    required T Function(DirectoryObject value) directoryObject,
    required T Function(SearchQueryWithInfo value) searchQuery,
  }) {
    return switch (this._index) {
      0 => directoryObject(this._value as DirectoryObject),
      1 => searchQuery(this._value as SearchQueryWithInfo),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "SearchHistoryItem(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SearchHistoryItem &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CSearchHistoryItemImpl extends ffi.Union {
  external _CDirectoryObject _directoryObject;
  external _CSearchQueryWithInfo _searchQuery;
}

final class _CSearchHistoryItem extends ffi.Struct {
  external _CSearchHistoryItemImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CSearchHistoryItemBasicFunctions on _CSearchHistoryItem {
  void _releaseIntermediate() {
    _CSearchHistoryItem_release(this);
  }
}
	
// MARK: - SearchHistoryItem <-> CSearchHistoryItem

extension _CSearchHistoryItemToDart on _CSearchHistoryItem {
  SearchHistoryItem _toDart() {
    return switch (this._index) {
      0 => SearchHistoryItem.directoryObject(this._impl._directoryObject._toDart()),
      1 => SearchHistoryItem.searchQuery(this._impl._searchQuery._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CSearchHistoryItem on SearchHistoryItem {
  _CSearchHistoryItem _copyFromDartTo_CSearchHistoryItem() {
    var res = _CSearchHistoryItemMakeDefault();
    this.match<void>(
      directoryObject: (DirectoryObject value) {
        res._impl._directoryObject = value._copyFromDartTo_CDirectoryObject();
        res._index = 0;
      },
      searchQuery: (SearchQueryWithInfo value) {
        res._impl._searchQuery = value._copyFromDartTo_CSearchQueryWithInfo();
        res._index = 1;
      },
    );
    return res;
  }
}

// MARK: - SearchHistoryResult

/** Результат работы истории поиска при запросе истории. */
class SearchHistoryResult implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Набор элементов истории поиска. */
  List<SearchHistoryItem> get items {
    _CArray_CSearchHistoryItem res = _CSearchHistoryResult_items(_CSearchHistoryResultMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CSearchHistoryResult_releasePtr);

  SearchHistoryResult._raw(this._self);
  factory SearchHistoryResult._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SearchHistoryResult._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SearchHistoryResult &&
    other.runtimeType == runtimeType &&
    _CSearchHistoryResult_cg_objectIdentifier(this._self) == _CSearchHistoryResult_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSearchHistoryResult_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - SearchHistoryResult <-> CSearchHistoryResult

final class _CSearchHistoryResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSearchHistoryResultBasicFunctions on _CSearchHistoryResult {
  void _releaseIntermediate() {
    _CSearchHistoryResult_release(_impl);
  }

  _CSearchHistoryResult _retain() {
    return _CSearchHistoryResult_retain(_impl);
  }
}

extension _CSearchHistoryResultToDart on _CSearchHistoryResult {
  SearchHistoryResult _toDart() {
    return SearchHistoryResult._create(_retain()._impl);
  }
}


extension _DartToCSearchHistoryResult on SearchHistoryResult {
  _CSearchHistoryResult _copyFromDartTo_CSearchHistoryResult() {
    return (_CSearchHistoryResultMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<SearchHistoryItem> <-> _CArray_CSearchHistoryItem

final class _CArray_CSearchHistoryItem extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CSearchHistoryItemToDart on _CArray_CSearchHistoryItem {
  List<SearchHistoryItem> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CSearchHistoryItem on List<SearchHistoryItem> {
  _CArray_CSearchHistoryItem _copyFromDartTo_CArray_CSearchHistoryItem() {
    final cArray = _CArray_CSearchHistoryItemmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CSearchHistoryItem();
        _CArray_CSearchHistoryItemaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CSearchHistoryItemBasicFunctions on _CArray_CSearchHistoryItem {
  void _releaseIntermediate() {
    _CArray_CSearchHistoryItem_release(this);
  }

  static final _listToFill = <SearchHistoryItem>[];

  static void _iterate(_CSearchHistoryItem item) {
    _listToFill.add(item._toDart());
  }

  List<SearchHistoryItem> _fillFromC() {
    _forEach_CArray_CSearchHistoryItem(this, ffi.Pointer.fromFunction<ffi.Void Function(_CSearchHistoryItem)>(_iterate));
    final result = List<SearchHistoryItem>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - SearchHistoryFilter

enum SearchHistoryFilter {
  none(0),
  object(1),
  searchQuery(2),
  ;

  const SearchHistoryFilter(this.rawValue);
  final int rawValue;

  static SearchHistoryFilter getByValue(int value) {
    return SearchHistoryFilter.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CSearchHistoryFilter extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CSearchHistoryFilterBasicFunctions on _CSearchHistoryFilter {
  void _releaseIntermediate() {
  }
}

extension _CSearchHistoryFilterToDart on _CSearchHistoryFilter {
  SearchHistoryFilter _toDart() {
    return SearchHistoryFilter.getByValue(this.rawValue);
  }
}

extension _DartTo_CSearchHistoryFilter on SearchHistoryFilter {
  _CSearchHistoryFilter _copyFromDartTo_CSearchHistoryFilter() {
    return _CSearchHistoryFilterMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - SearchHistoryFilterEnumSet

class SearchHistoryFilterEnumSet extends EnumSet<SearchHistoryFilter> {
  SearchHistoryFilterEnumSet() : super();

  factory SearchHistoryFilterEnumSet.fromRawValue(int rawValue) {
    SearchHistoryFilterEnumSet enumSet = SearchHistoryFilterEnumSet();
    enumSet.rawValue = rawValue;
    return enumSet;
  }

  factory SearchHistoryFilterEnumSet.of(Iterable<SearchHistoryFilter> elements) {
    SearchHistoryFilterEnumSet enumSet = SearchHistoryFilterEnumSet();
    enumSet.addAll(elements);
    return enumSet;
  }

  factory SearchHistoryFilterEnumSet.all() {
    SearchHistoryFilterEnumSet enumSet = SearchHistoryFilterEnumSet();
    enumSet.addAll(SearchHistoryFilter.values);
    return enumSet;
  }

  @override
  bool contains(SearchHistoryFilter value) =>
      (this.rawValue & value.rawValue) == value.rawValue;

  @override
  bool containsAllFromEnumSet(EnumSet<SearchHistoryFilter> other) =>
      (this.rawValue & other.rawValue) == this.rawValue;

  @override
  bool add(SearchHistoryFilter value) {
    if (this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue | value.rawValue;
    return true;
  }

  @override
  void addAllFromEnumSet(EnumSet<SearchHistoryFilter> other) =>
      this.rawValue = this.rawValue | other.rawValue;

  @override
  bool remove(SearchHistoryFilter value) {
    if (!this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue & ~value.rawValue;
    return true;
  }

  @override
  void removeAllFromEnumSet(EnumSet<SearchHistoryFilter> other) =>
      this.rawValue = this.rawValue & ~other.rawValue;

  @override
  EnumSet<SearchHistoryFilter> intersection(EnumSet<SearchHistoryFilter> other) =>
      SearchHistoryFilterEnumSet.fromRawValue(this.rawValue & other.rawValue);

  @override
  EnumSet<SearchHistoryFilter> union(EnumSet<SearchHistoryFilter> other) =>
      SearchHistoryFilterEnumSet.fromRawValue(this.rawValue | other.rawValue);

  @override
  EnumSet<SearchHistoryFilter> difference(EnumSet<SearchHistoryFilter> other) =>
      SearchHistoryFilterEnumSet.fromRawValue(this.rawValue & ~other.rawValue);

  @override
  Set<SearchHistoryFilter> toSet() {
    Set<SearchHistoryFilter> result = {};
    SearchHistoryFilter.values.forEach((element) {
      if (this.contains(element)) {
        result.add(element);
      }
    });
    return result;
  }

  @override
  String toString() {
    List<String> validOptionNames = [];
    SearchHistoryFilter.values.forEach((element) {
      if (this.contains(element)) {
        validOptionNames.add(element.name);
      }
    });

    return "${this.runtimeType}: ${validOptionNames.join(', ')}";
  }
}

final class _COptionSet_CSearchHistoryFilter extends ffi.Struct {
  @ffi.Uint32()
  external int _rawValue;
}

extension _COptionSet_CSearchHistoryFilterBasicFunctions on _COptionSet_CSearchHistoryFilter {
  void _releaseIntermediate() {
  }
}

extension _COptionSet_CSearchHistoryFilterToDart on _COptionSet_CSearchHistoryFilter {
  SearchHistoryFilterEnumSet _toDart() {
    return SearchHistoryFilterEnumSet.fromRawValue(this._rawValue);
  }
}

extension _DartTo_COptionSet_CSearchHistoryFilter on SearchHistoryFilterEnumSet {
  _COptionSet_CSearchHistoryFilter _copyFromDartTo_COptionSet_CSearchHistoryFilter() {
    return _COptionSet_CSearchHistoryFilterMakeDefault().._rawValue = this.rawValue;
  }
}
	
// MARK: - SearchHistoryPage

class SearchHistoryPage {
  final int limit;
  final int offset;
  final SearchHistoryFilterEnumSet filter;

  const SearchHistoryPage({
    this.limit = 100,
    this.offset = 0,
    required this.filter
  });

  SearchHistoryPage copyWith({
    int? limit,
    int? offset,
    SearchHistoryFilterEnumSet? filter
  }) {
    return SearchHistoryPage(
      limit: limit ?? this.limit,
      offset: offset ?? this.offset,
      filter: filter ?? this.filter
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SearchHistoryPage &&
    other.runtimeType == runtimeType &&
    other.limit == limit &&
    other.offset == offset &&
    other.filter == filter;

  @override
  int get hashCode {
    return Object.hash(limit, offset, filter);
  }

}
final class _CSearchHistoryPage extends ffi.Struct {
  @ffi.Uint64()
  external int limit;

  @ffi.Uint64()
  external int offset;

  external _COptionSet_CSearchHistoryFilter filter;

}
// MARK: - SearchHistoryPage <-> _CSearchHistoryPage

extension _CSearchHistoryPageToDart on _CSearchHistoryPage {
  SearchHistoryPage _toDart() {
    return SearchHistoryPage(
      limit: this.limit,
      offset: this.offset,
      filter: this.filter._toDart()
    );
  }
}

extension _DartTo_CSearchHistoryPage on SearchHistoryPage {
  _CSearchHistoryPage _copyFromDartTo_CSearchHistoryPage() {
    final res = _CSearchHistoryPageMakeDefault();
    res.limit = this.limit;
    res.offset = this.offset;
    res.filter = this.filter._copyFromDartTo_COptionSet_CSearchHistoryFilter();
    return res;
  }
}
extension _CSearchHistoryPageRelease on _CSearchHistoryPage {
  void _releaseIntermediate() {
  }
}

// MARK: - SearchHistory

class SearchHistory implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Получает максимальный размер истории поиска. */
  int get capacity {
    int res = _CSearchHistory_capacity(_CSearchHistoryMakeDefault().._impl=_self);
    return res;
  }
  Channel<ChangeType> get onHistoryChanged {
    _CChannel_CChangeType res = _CSearchHistory_onHistoryChanged(_CSearchHistoryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CSearchHistory_releasePtr);

  SearchHistory._raw(this._self);
  factory SearchHistory._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SearchHistory._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory SearchHistory(
    Context context
  ) {
    var _a0 = context._copyFromDartTo_CContext();
    _CSearchHistory res = _CSearchHistory_C_createWith_CContext(_a0);
    _a0._releaseIntermediate();
    return SearchHistory._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SearchHistory &&
    other.runtimeType == runtimeType &&
    _CSearchHistory_cg_objectIdentifier(this._self) == _CSearchHistory_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSearchHistory_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: SearchHistory: Methods

  /**
   Возвращает страницу истории поиска. Элементы возвращаются в упорядоченном
   виде по времени добавления (от самых свежих до самых поздних).
  */
  CancelableOperation<SearchHistoryResult> items(
    SearchHistoryPage page
  )  {
    var _a1 = page._copyFromDartTo_CSearchHistoryPage();
    _CFuture_CSearchHistoryResult res = _CSearchHistory_items_CSearchHistoryPage(_CSearchHistoryMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Добавляет элемент в историю поиска. В случае, если уже существовал
   такой же элемент, ранний дубликат удаляется.
  */
  void addItem(
    SearchHistoryItem item
  )  {
    var _a1 = item._copyFromDartTo_CSearchHistoryItem();
    void res = _CSearchHistory_addItem_CSearchHistoryItem(_CSearchHistoryMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Добавляет список элементов в историю поиска. Считается, что
   порядок в списке хронологический. Все дубликаты будут убраны.
  */
  void addItems(
    List<SearchHistoryItem> items
  )  {
    var _a1 = items._copyFromDartTo_CArray_CSearchHistoryItem();
    void res = _CSearchHistory_addItems_CArray_CSearchHistoryItem(_CSearchHistoryMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Удаляет элемент из истории поиска. */
  void removeItem(
    SearchHistoryItem item
  )  {
    var _a1 = item._copyFromDartTo_CSearchHistoryItem();
    void res = _CSearchHistory_removeItem_CSearchHistoryItem(_CSearchHistoryMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Удаляет список элементов из истории поиска. */
  void removeItems(
    List<SearchHistoryItem> items
  )  {
    var _a1 = items._copyFromDartTo_CArray_CSearchHistoryItem();
    void res = _CSearchHistory_removeItems_CArray_CSearchHistoryItem(_CSearchHistoryMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Очищает историю поиска. */
  void clear()  {
    void res = _CSearchHistory_clear(_CSearchHistoryMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - SearchHistory <-> CSearchHistory

final class _CSearchHistory extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSearchHistoryBasicFunctions on _CSearchHistory {
  void _releaseIntermediate() {
    _CSearchHistory_release(_impl);
  }

  _CSearchHistory _retain() {
    return _CSearchHistory_retain(_impl);
  }
}

extension _CSearchHistoryToDart on _CSearchHistory {
  SearchHistory _toDart() {
    return SearchHistory._create(_retain()._impl);
  }
}


extension _DartToCSearchHistory on SearchHistory {
  _CSearchHistory _copyFromDartTo_CSearchHistory() {
    return (_CSearchHistoryMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CancelableOperation<SearchHistoryResult> <-> _CFuture_CSearchHistoryResult

final class _CFuture_CSearchHistoryResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CSearchHistoryResult_Cancellable {
  final Completer<SearchHistoryResult> completer;
  final _CFuture_CSearchHistoryResult _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CSearchHistoryResult, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CSearchHistoryResult_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CSearchHistoryResultBasicFunctions on _CFuture_CSearchHistoryResult {
  void _releaseIntermediate() {
    _CFuture_CSearchHistoryResult_release(this);
  }

  _CFuture_CSearchHistoryResult _retain() {
    return _CFuture_CSearchHistoryResult_retain(this);
  }
}

extension _CFuture_CSearchHistoryResultToDart on _CFuture_CSearchHistoryResult {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CSearchHistoryResult_Cancellable>{};

  static void valueFunction(_CSearchHistoryResult cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<SearchHistoryResult> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<SearchHistoryResult>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CSearchHistoryResult, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CSearchHistoryResultReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CSearchHistoryResult_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CSearchHistoryResult on CancelableOperation<SearchHistoryResult> {
  _CFuture_CSearchHistoryResult _copyFromDartTo_CFuture_CSearchHistoryResult() {
    return _CFuture_CSearchHistoryResultMakeDefault();
  }
}
	
// MARK: - Channel<ChangeType> <-> _CChannel_CChangeType

class _CChannel_CChangeTypeImpl extends Channel<ChangeType> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<ChangeType>>{};

  final _CChannel_CChangeType _channel;

  _CChannel_CChangeTypeImpl(this._channel);

  static void valueFunction(_CChangeType cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<ChangeType> listen(void onData(ChangeType event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CChangeType, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<ChangeType>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CChannel_CChangeType extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CChannel_CChangeTypeBasicFunctions on _CChannel_CChangeType {
  void _releaseIntermediate() {
    _CChannel_CChangeType_release(this);
  }

  _CChannel_CChangeType _retain() {
    return _CChannel_CChangeType_retain(this);
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CChangeType, ffi.Int64)> callback) {
    return _CChannel_CChangeTypeConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CChannel_CChangeTypeToDart on _CChannel_CChangeType {
  Channel<ChangeType> _toDart() {
    return _CChannel_CChangeTypeImpl(this._retain());
  }
}

extension _DartTo_CChannel_CChangeType on Channel<ChangeType> {
  _CChannel_CChangeType _copyFromDartTo_CChannel_CChangeType() {
    return _CChannel_CChangeTypeMakeDefault();
  }
}
	
// MARK: - PackedSearchQuery

/** Вспомогательный объект для сериализации и десериализации поискового запроса. */
class PackedSearchQuery implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Текст запроса.
   Для некоторых запросов (например, раскрытие рубрики из suggest'а) текст отсутствует,
   т.к. в запросе хранятся идентификаторы, и поведение отличается от поиска по тексту элемента suggest'а.
  */
  String get queryText {
    _CString res = _CPackedSearchQuery_queryText(_CPackedSearchQueryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Идентификатор организации. */
  OrgId? get orgId {
    _COptional_COrgId res = _CPackedSearchQuery_orgId(_CPackedSearchQueryMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Идентификаторы рубрик. */
  List<RubricId> get rubricIds {
    _CArray_CRubricId res = _CPackedSearchQuery_rubricIds(_CPackedSearchQueryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Идентификаторы объектов. */
  List<DgisObjectId> get objectIds {
    _CArray_CDgisObjectId res = _CPackedSearchQuery_objectIds(_CPackedSearchQueryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Идентификатор здания. */
  BuildingId? get buildingId {
    _COptional_CBuildingId res = _CPackedSearchQuery_buildingId(_CPackedSearchQueryMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Геометрия, ограничивающая область поиска. */
  List<GeoPoint>? get spatialRestriction {
    _COptional_CArray_CGeoPoint res = _CPackedSearchQuery_spatialRestriction(_CPackedSearchQueryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Прямоугольная область интереса. */
  GeoRect? get areaOfInterest {
    _COptional_CGeoRect res = _CPackedSearchQuery_areaOfInterest(_CPackedSearchQueryMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Ограничение по возвращаемым поиском типам объектов. */
  List<ObjectType> get allowedResultTypes {
    _CArray_CObjectType res = _CPackedSearchQuery_allowedResultTypes(_CPackedSearchQueryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Размер страницы выдачи. */
  int get pageSize {
    int res = _CPackedSearchQuery_pageSize(_CPackedSearchQueryMakeDefault().._impl=_self);
    return res;
  }
  /** Информация об активных фильтрах. */
  DirectoryFilter get directoryFilter {
    _CDirectoryFilter res = _CPackedSearchQuery_directoryFilter(_CPackedSearchQueryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Тип сортировки результатов. */
  SortingType get sortingType {
    _CSortingType res = _CPackedSearchQuery_sortingType(_CPackedSearchQueryMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Центр для поискового запроса. */
  GeoPoint? get geoPoint {
    _COptional_CGeoPoint res = _CPackedSearchQuery_geoPoint(_CPackedSearchQueryMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Радиус поиска в метрах. */
  Meter? get radius {
    _COptional_CMeter res = _CPackedSearchQuery_radius(_CPackedSearchQueryMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Локаль поискового запроса. */
  Locale? get locale {
    _COptional_CLocale res = _CPackedSearchQuery_locale(_CPackedSearchQueryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CPackedSearchQuery_releasePtr);

  PackedSearchQuery._raw(this._self);
  factory PackedSearchQuery._create(ffi.Pointer<ffi.Void> self) {
    final classObject = PackedSearchQuery._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PackedSearchQuery &&
    other.runtimeType == runtimeType &&
    _CPackedSearchQuery_cg_objectIdentifier(this._self) == _CPackedSearchQuery_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPackedSearchQuery_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CPackedSearchQuery: Static Methods

  /**
   Десериализация запроса поиска.
  
   - Throws: Exception десериализуется неподдерживаемая версия или битые данные.
  */
  static PackedSearchQuery fromBytes(
    ByteData data
  )  {
    var _a0 = data._copyFromDartTo_CData();
    _CResult_CPackedSearchQuery res = _CPackedSearchQuery_S_fromBytes_CData(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static PackedSearchQuery fromSearchQuery(
    SearchQuery searchQuery
  )  {
    var _a0 = searchQuery._copyFromDartTo_CSearchQuery();
    _CPackedSearchQuery res = _CPackedSearchQuery_S_fromSearchQuery_CSearchQuery(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  // MARK: PackedSearchQuery: Methods

  ByteData toBytes()  {
    _CData res = _CPackedSearchQuery_toBytes(_CPackedSearchQueryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  SearchQuery toSearchQuery()  {
    _CSearchQuery res = _CPackedSearchQuery_toSearchQuery(_CPackedSearchQueryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - PackedSearchQuery <-> CPackedSearchQuery

final class _CPackedSearchQuery extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPackedSearchQueryBasicFunctions on _CPackedSearchQuery {
  void _releaseIntermediate() {
    _CPackedSearchQuery_release(_impl);
  }

  _CPackedSearchQuery _retain() {
    return _CPackedSearchQuery_retain(_impl);
  }
}

extension _CPackedSearchQueryToDart on _CPackedSearchQuery {
  PackedSearchQuery _toDart() {
    return PackedSearchQuery._create(_retain()._impl);
  }
}


extension _DartToCPackedSearchQuery on PackedSearchQuery {
  _CPackedSearchQuery _copyFromDartTo_CPackedSearchQuery() {
    return (_CPackedSearchQueryMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - PackedSearchQuery <-> _CResult_CPackedSearchQuery

final class _CResult_CPackedSearchQueryImpl extends ffi.Union {
  
  external _CPackedSearchQuery _value;
  external _CError _error;
}

final class _CResult_CPackedSearchQuery extends ffi.Struct {
  external _CResult_CPackedSearchQueryImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CPackedSearchQueryBasicFunctions on _CResult_CPackedSearchQuery {
  void _releaseIntermediate() {
    _CResult_CPackedSearchQuery_release(this);
  }
}

extension _CResult_CPackedSearchQueryToDart on _CResult_CPackedSearchQuery {
  PackedSearchQuery _toDart() {
    if (this._index == 0) {
      return this._impl._value._toDart();
    } else {
      throw this._impl._error._toDart();
    }
  }

  _CPackedSearchQuery _toCDart() {
    if (this._index == 0) {
      return this._impl._value;
    } else {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - ByteData <-> _CData

final class _CData extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDataBasicFunctions on _CData {
  int _getSize() {
    return _GetSizeWith_CData(this);
  }

  ffi.Pointer<ffi.Uint8> _getData() {
    return _GetDataWith_CData(this);
  }

  void _releaseIntermediate() {
    _CData_release(this);
  }
}

extension _CDataToDart on _CData {
  ByteData _toDart() {
    final size = this._getSize();
    final data = this._getData();
    final bytes = Uint8List.fromList(data.asTypedList(size));
    return ByteData.view(bytes.buffer);
  }
}

extension _DartTo_CData on ByteData {
  _CData _copyFromDartTo_CData() {
    final bytes = this.buffer.asUint8List(this.offsetInBytes, this.lengthInBytes);
    final frameData = ffi_package.malloc<ffi.Uint8>(bytes.length);
    final pointerList = frameData.asTypedList(bytes.length);
    pointerList.setAll(0, bytes);
    final res = _CDataCreateWithData(bytes.length, frameData);
    ffi_package.malloc.free(frameData);
    return res;
  }
}
	
// MARK: - OrgId? <-> _COptional_COrgId

final class _COptional_COrgId extends ffi.Struct {
  
  external _COrgId value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_COrgIdBasicFunctions on _COptional_COrgId {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_COrgIdToDart on _COptional_COrgId {
  OrgId? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_COrgId on OrgId? {
  _COptional_COrgId _copyFromDartTo_COptional_COrgId() {
    final cOptional = _COptional_COrgIdMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_COrgId();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - GeoPoint? <-> _COptional_CGeoPoint

final class _COptional_CGeoPoint extends ffi.Struct {
  
  external _CGeoPoint value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CGeoPointBasicFunctions on _COptional_CGeoPoint {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CGeoPointToDart on _COptional_CGeoPoint {
  GeoPoint? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CGeoPoint on GeoPoint? {
  _COptional_CGeoPoint _copyFromDartTo_COptional_CGeoPoint() {
    final cOptional = _COptional_CGeoPointMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CGeoPoint();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Meter? <-> _COptional_CMeter

final class _COptional_CMeter extends ffi.Struct {
  
  external _CMeter value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CMeterBasicFunctions on _COptional_CMeter {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CMeterToDart on _COptional_CMeter {
  Meter? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CMeter on Meter? {
  _COptional_CMeter _copyFromDartTo_COptional_CMeter() {
    final cOptional = _COptional_CMeterMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CMeter();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - PointGeometryData

/** Данные геометрии точечного объекта. */
final class PointGeometryData {
  final Object? _value;
  final int _index;

  PointGeometryData._raw(this._value, this._index);

  PointGeometryData.geoPoint(GeoPoint value) : this._raw(value, 0);
  PointGeometryData.geoPointWithElevation(GeoPointWithElevation value) : this._raw(value, 1);

  bool get isGeoPoint => this._index == 0;
  GeoPoint? get asGeoPoint => this.isGeoPoint ? this._value as GeoPoint : null;

  bool get isGeoPointWithElevation => this._index == 1;
  GeoPointWithElevation? get asGeoPointWithElevation => this.isGeoPointWithElevation ? this._value as GeoPointWithElevation : null;

  T match<T>({
    required T Function(GeoPoint value) geoPoint,
    required T Function(GeoPointWithElevation value) geoPointWithElevation,
  }) {
    return switch (this._index) {
      0 => geoPoint(this._value as GeoPoint),
      1 => geoPointWithElevation(this._value as GeoPointWithElevation),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "PointGeometryData(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PointGeometryData &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CPointGeometryDataImpl extends ffi.Union {
  external _CGeoPoint _geoPoint;
  external _CGeoPointWithElevation _geoPointWithElevation;
}

final class _CPointGeometryData extends ffi.Struct {
  external _CPointGeometryDataImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CPointGeometryDataBasicFunctions on _CPointGeometryData {
  void _releaseIntermediate() {
    _CPointGeometryData_release(this);
  }
}
	
// MARK: - PointGeometryData <-> CPointGeometryData

extension _CPointGeometryDataToDart on _CPointGeometryData {
  PointGeometryData _toDart() {
    return switch (this._index) {
      0 => PointGeometryData.geoPoint(this._impl._geoPoint._toDart()),
      1 => PointGeometryData.geoPointWithElevation(this._impl._geoPointWithElevation._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CPointGeometryData on PointGeometryData {
  _CPointGeometryData _copyFromDartTo_CPointGeometryData() {
    var res = _CPointGeometryDataMakeDefault();
    this.match<void>(
      geoPoint: (GeoPoint value) {
        res._impl._geoPoint = value._copyFromDartTo_CGeoPoint();
        res._index = 0;
      },
      geoPointWithElevation: (GeoPointWithElevation value) {
        res._impl._geoPointWithElevation = value._copyFromDartTo_CGeoPointWithElevation();
        res._index = 1;
      },
    );
    return res;
  }
}

// MARK: - PointGeometry

/** Точка. */
class PointGeometry extends Geometry implements ffi.Finalizable {
  PointGeometryData get point {
    _CPointGeometryData res = _CPointGeometry_point(_CPointGeometryMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CPointGeometry_releasePtr);

  PointGeometry._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory PointGeometry._create(ffi.Pointer<ffi.Void> self) {
    final classObject = PointGeometry._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory PointGeometry(
    GeoPoint point
  ) {
    var _a0 = point._copyFromDartTo_CGeoPoint();
    _CPointGeometry res = _CPointGeometry_C_createWith_CGeoPoint(_a0);
    return PointGeometry._create(res._impl);
  }

  factory PointGeometry.fromGeoPointWithElevation(
    GeoPointWithElevation point
  ) {
    var _a0 = point._copyFromDartTo_CGeoPointWithElevation();
    _CPointGeometry res = _CPointGeometry_C_createWith_CGeoPointWithElevation(_a0);
    return PointGeometry._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PointGeometry &&
    other.runtimeType == runtimeType &&
    _CPointGeometry_cg_objectIdentifier(this._self) == _CPointGeometry_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPointGeometry_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - PointGeometry <-> CPointGeometry

final class _CPointGeometry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPointGeometryBasicFunctions on _CPointGeometry {
  void _releaseIntermediate() {
    _CPointGeometry_release(_impl);
  }

  _CPointGeometry _retain() {
    return _CPointGeometry_retain(_impl);
  }
}

extension _CPointGeometryToDart on _CPointGeometry {
  PointGeometry _toDart() {
    return PointGeometry._create(_retain()._impl);
  }
}


extension _DartToCPointGeometry on PointGeometry {
  _CPointGeometry _copyFromDartTo_CPointGeometry() {
    return (_CPointGeometryMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - PolygonGeometry

/** Полигон. */
class PolygonGeometry extends Geometry implements ffi.Finalizable {
  List<List<GeoPoint>> get contours {
    _CArray_CArray_CGeoPoint res = _CPolygonGeometry_contours(_CPolygonGeometryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CPolygonGeometry_releasePtr);

  PolygonGeometry._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory PolygonGeometry._create(ffi.Pointer<ffi.Void> self) {
    final classObject = PolygonGeometry._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory PolygonGeometry(
    List<List<GeoPoint>> contours
  ) {
    var _a0 = contours._copyFromDartTo_CArray_CArray_CGeoPoint();
    _CPolygonGeometry res = _CPolygonGeometry_C_createWith_CArray_CArray_CGeoPoint(_a0);
    _a0._releaseIntermediate();
    return PolygonGeometry._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PolygonGeometry &&
    other.runtimeType == runtimeType &&
    _CPolygonGeometry_cg_objectIdentifier(this._self) == _CPolygonGeometry_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPolygonGeometry_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - PolygonGeometry <-> CPolygonGeometry

final class _CPolygonGeometry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPolygonGeometryBasicFunctions on _CPolygonGeometry {
  void _releaseIntermediate() {
    _CPolygonGeometry_release(_impl);
  }

  _CPolygonGeometry _retain() {
    return _CPolygonGeometry_retain(_impl);
  }
}

extension _CPolygonGeometryToDart on _CPolygonGeometry {
  PolygonGeometry _toDart() {
    return PolygonGeometry._create(_retain()._impl);
  }
}


extension _DartToCPolygonGeometry on PolygonGeometry {
  _CPolygonGeometry _copyFromDartTo_CPolygonGeometry() {
    return (_CPolygonGeometryMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - PolylineGeometry

/** Ломаная линия. */
class PolylineGeometry extends Geometry implements ffi.Finalizable {
  List<GeoPoint> get points {
    _CArray_CGeoPoint res = _CPolylineGeometry_points(_CPolylineGeometryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CPolylineGeometry_releasePtr);

  PolylineGeometry._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory PolylineGeometry._create(ffi.Pointer<ffi.Void> self) {
    final classObject = PolylineGeometry._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory PolylineGeometry(
    List<GeoPoint> points
  ) {
    var _a0 = points._copyFromDartTo_CArray_CGeoPoint();
    _CPolylineGeometry res = _CPolylineGeometry_C_createWith_CArray_CGeoPoint(_a0);
    _a0._releaseIntermediate();
    return PolylineGeometry._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PolylineGeometry &&
    other.runtimeType == runtimeType &&
    _CPolylineGeometry_cg_objectIdentifier(this._self) == _CPolylineGeometry_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPolylineGeometry_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - PolylineGeometry <-> CPolylineGeometry

final class _CPolylineGeometry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPolylineGeometryBasicFunctions on _CPolylineGeometry {
  void _releaseIntermediate() {
    _CPolylineGeometry_release(_impl);
  }

  _CPolylineGeometry _retain() {
    return _CPolylineGeometry_retain(_impl);
  }
}

extension _CPolylineGeometryToDart on _CPolylineGeometry {
  PolylineGeometry _toDart() {
    return PolylineGeometry._create(_retain()._impl);
  }
}


extension _DartToCPolylineGeometry on PolylineGeometry {
  _CPolylineGeometry _copyFromDartTo_CPolylineGeometry() {
    return (_CPolylineGeometryMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ComplexGeometry

/**
 Составная геометрия, состоит из набора простых или составных геометрий.

 Поддерживается произвольный уровень вложенности составных геометрий в наборе.
*/
class ComplexGeometry extends Geometry implements ffi.Finalizable {
  List<Geometry> get elements {
    _CArray_CGeometry res = _CComplexGeometry_elements(_CComplexGeometryMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CComplexGeometry_releasePtr);

  ComplexGeometry._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory ComplexGeometry._create(ffi.Pointer<ffi.Void> self) {
    final classObject = ComplexGeometry._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory ComplexGeometry(
    List<Geometry> geometries
  ) {
    var _a0 = geometries._copyFromDartTo_CArray_CGeometry();
    _CComplexGeometry res = _CComplexGeometry_C_createWith_CArray_CGeometry(_a0);
    _a0._releaseIntermediate();
    return ComplexGeometry._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ComplexGeometry &&
    other.runtimeType == runtimeType &&
    _CComplexGeometry_cg_objectIdentifier(this._self) == _CComplexGeometry_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CComplexGeometry_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - ComplexGeometry <-> CComplexGeometry

final class _CComplexGeometry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CComplexGeometryBasicFunctions on _CComplexGeometry {
  void _releaseIntermediate() {
    _CComplexGeometry_release(_impl);
  }

  _CComplexGeometry _retain() {
    return _CComplexGeometry_retain(_impl);
  }
}

extension _CComplexGeometryToDart on _CComplexGeometry {
  ComplexGeometry _toDart() {
    return ComplexGeometry._create(_retain()._impl);
  }
}


extension _DartToCComplexGeometry on ComplexGeometry {
  _CComplexGeometry _copyFromDartTo_CComplexGeometry() {
    return (_CComplexGeometryMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<Geometry> <-> _CArray_CGeometry

final class _CArray_CGeometry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CGeometryToDart on _CArray_CGeometry {
  List<Geometry> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CGeometry on List<Geometry> {
  _CArray_CGeometry _copyFromDartTo_CArray_CGeometry() {
    final cArray = _CArray_CGeometrymakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CGeometry();
        _CArray_CGeometryaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CGeometryBasicFunctions on _CArray_CGeometry {
  void _releaseIntermediate() {
    _CArray_CGeometry_release(this);
  }

  static final _listToFill = <Geometry>[];

  static void _iterate(_CGeometry item) {
    _listToFill.add(item._toDart());
  }

  List<Geometry> _fillFromC() {
    _forEach_CArray_CGeometry(this, ffi.Pointer.fromFunction<ffi.Void Function(_CGeometry)>(_iterate));
    final result = List<Geometry>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - downloadData

@internal
CancelableOperation<ByteData> downloadData(
  Context context,
  String url
){
  var _a0 = context._copyFromDartTo_CContext();
  var _a1 = url._copyFromDartTo_CString();
  _CFuture_CData res = _CFunction_G_downloadData_With_CContext_CString(_a0, _a1);
  _a1._releaseIntermediate();
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - CancelableOperation<ByteData> <-> _CFuture_CData

final class _CFuture_CData extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CData_Cancellable {
  final Completer<ByteData> completer;
  final _CFuture_CData _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CData, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CData_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CDataBasicFunctions on _CFuture_CData {
  void _releaseIntermediate() {
    _CFuture_CData_release(this);
  }

  _CFuture_CData _retain() {
    return _CFuture_CData_retain(this);
  }
}

extension _CFuture_CDataToDart on _CFuture_CData {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CData_Cancellable>{};

  static void valueFunction(_CData cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<ByteData> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<ByteData>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CData, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CDataReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CData_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CData on CancelableOperation<ByteData> {
  _CFuture_CData _copyFromDartTo_CFuture_CData() {
    return _CFuture_CDataMakeDefault();
  }
}
	
// MARK: - Anchor

/**
 Точка привязки изображения
 (0, 0) - левый верхний угол, (1, 1) - правый нижний
*/
class Anchor {
  final double x;
  final double y;

  const Anchor({
    this.x = 0.5,
    this.y = 0.5
  });

  Anchor copyWith({
    double? x,
    double? y
  }) {
    return Anchor(
      x: x ?? this.x,
      y: y ?? this.y
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Anchor &&
    other.runtimeType == runtimeType &&
    other.x == x &&
    other.y == y;

  @override
  int get hashCode {
    return Object.hash(x, y);
  }

}
final class _CAnchor extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

}
// MARK: - Anchor <-> _CAnchor

extension _CAnchorToDart on _CAnchor {
  Anchor _toDart() {
    return Anchor(
      x: this.x,
      y: this.y
    );
  }
}

extension _DartTo_CAnchor on Anchor {
  _CAnchor _copyFromDartTo_CAnchor() {
    final res = _CAnchorMakeDefault();
    res.x = this.x;
    res.y = this.y;
    return res;
  }
}
extension _CAnchorRelease on _CAnchor {
  void _releaseIntermediate() {
  }
}

// MARK: - List<AttributeValue> <-> _CArray_CAttributeValue

final class _CArray_CAttributeValue extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CAttributeValueToDart on _CArray_CAttributeValue {
  List<AttributeValue> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CAttributeValue on List<AttributeValue> {
  _CArray_CAttributeValue _copyFromDartTo_CArray_CAttributeValue() {
    final cArray = _CArray_CAttributeValuemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CAttributeValue();
        _CArray_CAttributeValueaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CAttributeValueBasicFunctions on _CArray_CAttributeValue {
  void _releaseIntermediate() {
    _CArray_CAttributeValue_release(this);
  }

  static final _listToFill = <AttributeValue>[];

  static void _iterate(_CAttributeValue item) {
    _listToFill.add(item._toDart());
  }

  List<AttributeValue> _fillFromC() {
    _forEach_CArray_CAttributeValue(this, ffi.Pointer.fromFunction<ffi.Void Function(_CAttributeValue)>(_iterate));
    final result = List<AttributeValue>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - core.Map<String, AttributeValue> <-> _CDictionary_CString_CAttributeValue

final class _CDictionary_CString_CAttributeValue extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDictionary_CString_CAttributeValueToDart on _CDictionary_CString_CAttributeValue {
  core.Map<String, AttributeValue> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CDictionary_CString_CAttributeValue on core.Map<String, AttributeValue> {
  _CDictionary_CString_CAttributeValue _copyFromDartTo_CDictionary_CString_CAttributeValue() {
    final cDict = _CDictionary_CString_CAttributeValuemakeEmpty();
    forEach((k, v) {
        final cKey = k._copyFromDartTo_CString();
        final cValue = v._copyFromDartTo_CAttributeValue();
        _CDictionary_CString_CAttributeValueaddElement(cDict, cKey, cValue);
        cKey._releaseIntermediate();
        cValue._releaseIntermediate();
    });
    return cDict;
  }
}

extension _CDictionary_CString_CAttributeValueBasicFunctions on _CDictionary_CString_CAttributeValue {
  void _releaseIntermediate() {
    _CDictionary_CString_CAttributeValue_release(this);
  }

  static final _mapToFill = <String, AttributeValue>{};

  static void _iterate(_CString key, _CAttributeValue value) {
    _mapToFill.putIfAbsent(key._toDart(), () => value._toDart());
  }

  core.Map<String, AttributeValue> _fillFromC() {
    _forEach_CDictionary_CString_CAttributeValue(this, ffi.Pointer.fromFunction<ffi.Void Function(_CString, _CAttributeValue value)>(_iterate));
    final result = core.Map<String, AttributeValue>.from(_mapToFill);
    _mapToFill.clear();
    return result;
  }
}
	
// MARK: - AttributeValue

/** Свойства объектов карты. */
final class AttributeValue {
  final Object? _value;
  final int _index;

  AttributeValue._raw(this._value, this._index);

  AttributeValue.empty() : this._raw(null, 0);
  AttributeValue.boolean(bool value) : this._raw(value, 1);
  AttributeValue.number(double value) : this._raw(value, 2);
  AttributeValue.integer(int value) : this._raw(value, 3);
  AttributeValue.string(String value) : this._raw(value, 4);
  AttributeValue.data(ByteData value) : this._raw(value, 5);
  AttributeValue.array(List<AttributeValue> value) : this._raw(value, 6);
  AttributeValue.object(core.Map<String, AttributeValue> value) : this._raw(value, 7);

  bool get isEmpty => this._index == 0;
  Object? get asEmpty => this.isEmpty ? this._value as Object : null;

  bool get isBoolean => this._index == 1;
  bool? get asBoolean => this.isBoolean ? this._value as bool : null;

  bool get isNumber => this._index == 2;
  double? get asNumber => this.isNumber ? this._value as double : null;

  bool get isInteger => this._index == 3;
  int? get asInteger => this.isInteger ? this._value as int : null;

  bool get isString => this._index == 4;
  String? get asString => this.isString ? this._value as String : null;

  bool get isData => this._index == 5;
  ByteData? get asData => this.isData ? this._value as ByteData : null;

  bool get isArray => this._index == 6;
  List<AttributeValue>? get asArray => this.isArray ? this._value as List<AttributeValue> : null;

  bool get isObject => this._index == 7;
  core.Map<String, AttributeValue>? get asObject => this.isObject ? this._value as core.Map<String, AttributeValue> : null;

  T match<T>({
    required T Function() empty,
    required T Function(bool value) boolean,
    required T Function(double value) number,
    required T Function(int value) integer,
    required T Function(String value) string,
    required T Function(ByteData value) data,
    required T Function(List<AttributeValue> value) array,
    required T Function(core.Map<String, AttributeValue> value) object,
  }) {
    return switch (this._index) {
      0 => empty(),
      1 => boolean(this._value as bool),
      2 => number(this._value as double),
      3 => integer(this._value as int),
      4 => string(this._value as String),
      5 => data(this._value as ByteData),
      6 => array(this._value as List<AttributeValue>),
      7 => object(this._value as core.Map<String, AttributeValue>),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "AttributeValue(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is AttributeValue &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CAttributeValueImpl extends ffi.Union {
  external _CEmpty _empty;
  @ffi.Bool()
  external bool _boolean;
  @ffi.Double()
  external double _number;
  @ffi.Int64()
  external int _integer;
  external _CString _string;
  external _CData _data;
  external _CArray_CAttributeValue _array;
  external _CDictionary_CString_CAttributeValue _object;
}

final class _CAttributeValue extends ffi.Struct {
  external _CAttributeValueImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CAttributeValueBasicFunctions on _CAttributeValue {
  void _releaseIntermediate() {
    _CAttributeValue_release(this);
  }
}
	
// MARK: - AttributeValue <-> CAttributeValue

extension _CAttributeValueToDart on _CAttributeValue {
  AttributeValue _toDart() {
    return switch (this._index) {
      0 => AttributeValue.empty(),
      1 => AttributeValue.boolean(this._impl._boolean),
      2 => AttributeValue.number(this._impl._number),
      3 => AttributeValue.integer(this._impl._integer),
      4 => AttributeValue.string(this._impl._string._toDart()),
      5 => AttributeValue.data(this._impl._data._toDart()),
      6 => AttributeValue.array(this._impl._array._toDart()),
      7 => AttributeValue.object(this._impl._object._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CAttributeValue on AttributeValue {
  _CAttributeValue _copyFromDartTo_CAttributeValue() {
    var res = _CAttributeValueMakeDefault();
    this.match<void>(
      empty: () {
        res._index = 0;
      },
      boolean: (bool value) {
        res._impl._boolean = value;
        res._index = 1;
      },
      number: (double value) {
        res._impl._number = value;
        res._index = 2;
      },
      integer: (int value) {
        res._impl._integer = value;
        res._index = 3;
      },
      string: (String value) {
        res._impl._string = value._copyFromDartTo_CString();
        res._index = 4;
      },
      data: (ByteData value) {
        res._impl._data = value._copyFromDartTo_CData();
        res._index = 5;
      },
      array: (List<AttributeValue> value) {
        res._impl._array = value._copyFromDartTo_CArray_CAttributeValue();
        res._index = 6;
      },
      object: (core.Map<String, AttributeValue> value) {
        res._impl._object = value._copyFromDartTo_CDictionary_CString_CAttributeValue();
        res._index = 7;
      },
    );
    return res;
  }
}

// MARK: - BearingSource

/** Источник направления. */
enum BearingSource {
  /** Автоматический выбор источника направления в зависимости от параметров геопозиции. */
  auto(0),
  /** Ориентировать карту по направлению, полученному от GNSS. */
  satellite(1),
  /** Ориентировать карту по компасу. */
  magnetic(2),
  ;

  const BearingSource(this.rawValue);
  final int rawValue;

  static BearingSource getByValue(int value) {
    return BearingSource.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CBearingSource extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CBearingSourceBasicFunctions on _CBearingSource {
  void _releaseIntermediate() {
  }
}

extension _CBearingSourceToDart on _CBearingSource {
  BearingSource _toDart() {
    return BearingSource.getByValue(this.rawValue);
  }
}

extension _DartTo_CBearingSource on BearingSource {
  _CBearingSource _copyFromDartTo_CBearingSource() {
    return _CBearingSourceMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CameraAnimatedMoveReason

/** Причина анимированного перемещения камеры. */
enum CameraAnimatedMoveReason {
  /** Явный вызов ICamera::move() */
  application(0),
  /**
   Анимированное перемещение вызвано обработкой событий (кинематика после перемещения карты, поворот на север
   и другие).
  */
  event(1),
  /** Внутренние причины, например, из-за активного слежения за позицией пользователя. */
  internal(2),
  ;

  const CameraAnimatedMoveReason(this.rawValue);
  final int rawValue;

  static CameraAnimatedMoveReason getByValue(int value) {
    return CameraAnimatedMoveReason.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CCameraAnimatedMoveReason extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CCameraAnimatedMoveReasonBasicFunctions on _CCameraAnimatedMoveReason {
  void _releaseIntermediate() {
  }
}

extension _CCameraAnimatedMoveReasonToDart on _CCameraAnimatedMoveReason {
  CameraAnimatedMoveReason _toDart() {
    return CameraAnimatedMoveReason.getByValue(this.rawValue);
  }
}

extension _DartTo_CCameraAnimatedMoveReason on CameraAnimatedMoveReason {
  _CCameraAnimatedMoveReason _copyFromDartTo_CCameraAnimatedMoveReason() {
    return _CCameraAnimatedMoveReasonMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CameraAnimatedMoveResult

/** Результат перемещения камеры. */
enum CameraAnimatedMoveResult {
  /** Перемещение позиции камеры завершено по достижении конечной точки. */
  finished(0),
  /** Перемещение позиции камеры отменено событием карты (сдвиг, изменение масштаба, и т.д.). */
  cancelledByEvent(1),
  /**
   Запущен новый перелёт, изменена позиция
   (явно или косвенно через ICamera::set_position_point() или ICamera::set_padding())
   или изменён режим слежения.
  */
  cancelledByApplication(2),
  ;

  const CameraAnimatedMoveResult(this.rawValue);
  final int rawValue;

  static CameraAnimatedMoveResult getByValue(int value) {
    return CameraAnimatedMoveResult.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CCameraAnimatedMoveResult extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CCameraAnimatedMoveResultBasicFunctions on _CCameraAnimatedMoveResult {
  void _releaseIntermediate() {
  }
}

extension _CCameraAnimatedMoveResultToDart on _CCameraAnimatedMoveResult {
  CameraAnimatedMoveResult _toDart() {
    return CameraAnimatedMoveResult.getByValue(this.rawValue);
  }
}

extension _DartTo_CCameraAnimatedMoveResult on CameraAnimatedMoveResult {
  _CCameraAnimatedMoveResult _copyFromDartTo_CCameraAnimatedMoveResult() {
    return _CCameraAnimatedMoveResultMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CameraAnimationType

/** Тип перелёта */
enum CameraAnimationType {
  /** Тип перелёта выбирается в зависимости от расстояния между начальной и конечной позициями. */
  default_(0),
  /** Линейное изменение параметров позиции камеры. */
  linear(1),
  /**
   Zoom изменяется таким образом, чтобы постараться в какой-то момент перелёта
   отобразить начальную и конечную позиции. Позиции могут быть не отображены,
   если текущие ограничения (см. ICamera::zoom_restrictions()) не позволяют установить столь малый zoom.
  */
  showBothPositions(2),
  ;

  const CameraAnimationType(this.rawValue);
  final int rawValue;

  static CameraAnimationType getByValue(int value) {
    return CameraAnimationType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CCameraAnimationType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CCameraAnimationTypeBasicFunctions on _CCameraAnimationType {
  void _releaseIntermediate() {
  }
}

extension _CCameraAnimationTypeToDart on _CCameraAnimationType {
  CameraAnimationType _toDart() {
    return CameraAnimationType.getByValue(this.rawValue);
  }
}

extension _DartTo_CCameraAnimationType on CameraAnimationType {
  _CCameraAnimationType _copyFromDartTo_CCameraAnimationType() {
    return _CCameraAnimationTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CameraBehaviourChangeReason

/** Причина изменения режима слежения камеры. */
enum CameraBehaviourChangeReason {
  /**
   Смена режима приложением, установка позиции (явно или косвенно через ICamera::set_position_point()),
   запуск перелёта.
  */
  application(0),
  /**
   Режим слежения изменился из-за события карты.
   В зависимости от события может сброситься режим слежения за позицией, углом поворота,
   углом наклона или масштабом, см. CameraBehaviour.
  */
  event(1),
  ;

  const CameraBehaviourChangeReason(this.rawValue);
  final int rawValue;

  static CameraBehaviourChangeReason getByValue(int value) {
    return CameraBehaviourChangeReason.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CCameraBehaviourChangeReason extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CCameraBehaviourChangeReasonBasicFunctions on _CCameraBehaviourChangeReason {
  void _releaseIntermediate() {
  }
}

extension _CCameraBehaviourChangeReasonToDart on _CCameraBehaviourChangeReason {
  CameraBehaviourChangeReason _toDart() {
    return CameraBehaviourChangeReason.getByValue(this.rawValue);
  }
}

extension _DartTo_CCameraBehaviourChangeReason on CameraBehaviourChangeReason {
  _CCameraBehaviourChangeReason _copyFromDartTo_CCameraBehaviourChangeReason() {
    return _CCameraBehaviourChangeReasonMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CameraPositionPoint

/**
 Относительная экранная позиция точки, к которой привязана камера.

 Область экрана задаётся padding'ами.
 x - отступ от левого края области экрана, y - отступ от верхнего края
 Допустимый интервал значений отступов (0.0f, 1.0f)
 0,0 - левый верхний угол области экрана, 1,1 - правый нижний
*/
class CameraPositionPoint {
  final double x;
  final double y;

  const CameraPositionPoint({
    this.x = 0.5,
    this.y = 0.5
  });

  CameraPositionPoint copyWith({
    double? x,
    double? y
  }) {
    return CameraPositionPoint(
      x: x ?? this.x,
      y: y ?? this.y
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CameraPositionPoint &&
    other.runtimeType == runtimeType &&
    other.x == x &&
    other.y == y;

  @override
  int get hashCode {
    return Object.hash(x, y);
  }

}
final class _CCameraPositionPoint extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

}
// MARK: - CameraPositionPoint <-> _CCameraPositionPoint

extension _CCameraPositionPointToDart on _CCameraPositionPoint {
  CameraPositionPoint _toDart() {
    return CameraPositionPoint(
      x: this.x,
      y: this.y
    );
  }
}

extension _DartTo_CCameraPositionPoint on CameraPositionPoint {
  _CCameraPositionPoint _copyFromDartTo_CCameraPositionPoint() {
    final res = _CCameraPositionPointMakeDefault();
    res.x = this.x;
    res.y = this.y;
    return res;
  }
}
extension _CCameraPositionPointRelease on _CCameraPositionPoint {
  void _releaseIntermediate() {
  }
}

// MARK: - CameraState

/** Состояние камеры. */
enum CameraState {
  /** Камера управляется пользователем. */
  busy(0),
  /** Eсть активный перелёт, запущенный в результате обработки событий или пользователем явно. */
  fly(1),
  /**
   Камера не управляется пользователем и нет активных перелётов.
   Либо с камерой ничего не происходит, либо она следит за позицией и/или наклоном.
  */
  free(2),
  ;

  const CameraState(this.rawValue);
  final int rawValue;

  static CameraState getByValue(int value) {
    return CameraState.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CCameraState extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CCameraStateBasicFunctions on _CCameraState {
  void _releaseIntermediate() {
  }
}

extension _CCameraStateToDart on _CCameraState {
  CameraState _toDart() {
    return CameraState.getByValue(this.rawValue);
  }
}

extension _DartTo_CCameraState on CameraState {
  _CCameraState _copyFromDartTo_CCameraState() {
    return _CCameraStateMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CameraViewPoint

/**
 Относительная экранная позиция точки, в которую направлен взгляд камеры.

 Допустимый интервал значений отступов (0.0f, 1.0f)
 0,0 - левый верхний угол вьюпорта, 1,1 - правый нижний
*/
class CameraViewPoint {
  final double x;
  final double y;

  const CameraViewPoint({
    this.x = 0.5,
    this.y = 0.5
  });

  CameraViewPoint copyWith({
    double? x,
    double? y
  }) {
    return CameraViewPoint(
      x: x ?? this.x,
      y: y ?? this.y
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CameraViewPoint &&
    other.runtimeType == runtimeType &&
    other.x == x &&
    other.y == y;

  @override
  int get hashCode {
    return Object.hash(x, y);
  }

}
final class _CCameraViewPoint extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

}
// MARK: - CameraViewPoint <-> _CCameraViewPoint

extension _CCameraViewPointToDart on _CCameraViewPoint {
  CameraViewPoint _toDart() {
    return CameraViewPoint(
      x: this.x,
      y: this.y
    );
  }
}

extension _DartTo_CCameraViewPoint on CameraViewPoint {
  _CCameraViewPoint _copyFromDartTo_CCameraViewPoint() {
    final res = _CCameraViewPointMakeDefault();
    res.x = this.x;
    res.y = this.y;
    return res;
  }
}
extension _CCameraViewPointRelease on _CCameraViewPoint {
  void _releaseIntermediate() {
  }
}

// MARK: - Color

/** Цвет */
class Color {
  final int argb;

  const Color([this.argb = 4278190080]);

  Color copyWith({
    int? argb
  }) {
    return Color(
      argb ?? this.argb
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Color &&
    other.runtimeType == runtimeType &&
    other.argb == argb;

  @override
  int get hashCode {
    return argb.hashCode;
  }

}
final class _CColor extends ffi.Struct {
  @ffi.Uint32()
  external int argb;

}
// MARK: - Color <-> _CColor

extension _CColorToDart on _CColor {
  Color _toDart() {
    return Color(
      this.argb
    );
  }
}

extension _DartTo_CColor on Color {
  _CColor _copyFromDartTo_CColor() {
    final res = _CColorMakeDefault();
    res.argb = this.argb;
    return res;
  }
}
extension _CColorRelease on _CColor {
  void _releaseIntermediate() {
  }
}

// MARK: - DeviceDensity

/**
 Множитель, который вычисляется как отношение DPI к базовому DPI устройства.

 В Android соответствует resources.displayMetrics.density
 В iOS соответствует nativeScale

 - Note: должен быть положительным.
*/
class DeviceDensity {
  final double value;

  const DeviceDensity([this.value = 0]);

  DeviceDensity copyWith({
    double? value
  }) {
    return DeviceDensity(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DeviceDensity &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CDeviceDensity extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - DeviceDensity <-> _CDeviceDensity

extension _CDeviceDensityToDart on _CDeviceDensity {
  DeviceDensity _toDart() {
    return DeviceDensity(
      this.value
    );
  }
}

extension _DartTo_CDeviceDensity on DeviceDensity {
  _CDeviceDensity _copyFromDartTo_CDeviceDensity() {
    final res = _CDeviceDensityMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CDeviceDensityRelease on _CDeviceDensity {
  void _releaseIntermediate() {
  }
}

// MARK: - DevicePpi

/**
 Разрешающая способность дисплея устройства, в пикселях на дюйм.

 - Note: должна быть положительной.
*/
class DevicePpi {
  final double value;

  const DevicePpi([this.value = 0]);

  DevicePpi copyWith({
    double? value
  }) {
    return DevicePpi(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DevicePpi &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CDevicePpi extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - DevicePpi <-> _CDevicePpi

extension _CDevicePpiToDart on _CDevicePpi {
  DevicePpi _toDart() {
    return DevicePpi(
      this.value
    );
  }
}

extension _DartTo_CDevicePpi on DevicePpi {
  _CDevicePpi _copyFromDartTo_CDevicePpi() {
    final res = _CDevicePpiMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CDevicePpiRelease on _CDevicePpi {
  void _releaseIntermediate() {
  }
}

// MARK: - GraphicsPreset

/** Перечисление доступных режимов графики. */
enum GraphicsPreset {
  /** Упрощенный режим отрисовки, по возможности отключаются тяжелые графические эффекты. */
  lite(0),
  /** Стандартный режим отрисовки, соблюдается баланс между визуальным качеством картинки и потребляемыми ресурсами. */
  normal(1),
  /**
   Иммерсивный режим, включаются все самые "тяжелые" графические эффекты.
  
   - Warning: : Может приводить к значительной деградации производительности на слабых устройствах.
  */
  immersive(2),
  ;

  const GraphicsPreset(this.rawValue);
  final int rawValue;

  static GraphicsPreset getByValue(int value) {
    return GraphicsPreset.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CGraphicsPreset extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CGraphicsPresetBasicFunctions on _CGraphicsPreset {
  void _releaseIntermediate() {
  }
}

extension _CGraphicsPresetToDart on _CGraphicsPreset {
  GraphicsPreset _toDart() {
    return GraphicsPreset.getByValue(this.rawValue);
  }
}

extension _DartTo_CGraphicsPreset on GraphicsPreset {
  _CGraphicsPreset _copyFromDartTo_CGraphicsPreset() {
    return _CGraphicsPresetMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ZIndex

/** Индекс, задающий порядок отрисовки объектов в рамках слоя. */
class ZIndex {
  final int value;

  const ZIndex([this.value = 0]);

  ZIndex copyWith({
    int? value
  }) {
    return ZIndex(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ZIndex &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CZIndex extends ffi.Struct {
  @ffi.Uint32()
  external int value;

}
// MARK: - ZIndex <-> _CZIndex

extension _CZIndexToDart on _CZIndex {
  ZIndex _toDart() {
    return ZIndex(
      this.value
    );
  }
}

extension _DartTo_CZIndex on ZIndex {
  _CZIndex _copyFromDartTo_CZIndex() {
    final res = _CZIndexMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CZIndexRelease on _CZIndex {
  void _releaseIntermediate() {
  }
}

// MARK: - Zoom

/**
 Уровень масштабирования.

 Zoom = 0 это такой масштаб, при котором весь мир вписан в квадрат 256x256 логических пикселей (см. LogicalPixel)
 Zoom = 1 это такой масштаб, при котором весь мир вписан в квадрат 512x512 логических пикселей
 Масштаб пропорционален величине 2^Zoom.

 - Note: Zoom не может быть отрицательным.
*/
class Zoom {
  final double value;

  const Zoom([this.value = 0]);

  Zoom copyWith({
    double? value
  }) {
    return Zoom(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Zoom &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CZoom extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - Zoom <-> _CZoom

extension _CZoomToDart on _CZoom {
  Zoom _toDart() {
    return Zoom(
      this.value
    );
  }
}

extension _DartTo_CZoom on Zoom {
  _CZoom _copyFromDartTo_CZoom() {
    final res = _CZoomMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CZoomRelease on _CZoom {
  void _releaseIntermediate() {
  }
}

// MARK: - Tilt

/**
 Угол наклона в градусах, где 0 - надир (смотрим вертикально вниз), 90 - горизонт спереди.

 Допустимыми считаются значения в интервале от 0 до 70 градусов.
 В случаях, когда точка позиции камеры расположена ближе к нижнему краю экрана,
 значение может быть дополнительно уменьшено.
*/
class Tilt {
  final double value;

  const Tilt([this.value = 0]);

  Tilt copyWith({
    double? value
  }) {
    return Tilt(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Tilt &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CTilt extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - Tilt <-> _CTilt

extension _CTiltToDart on _CTilt {
  Tilt _toDart() {
    return Tilt(
      this.value
    );
  }
}

extension _DartTo_CTilt on Tilt {
  _CTilt _copyFromDartTo_CTilt() {
    final res = _CTiltMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CTiltRelease on _CTilt {
  void _releaseIntermediate() {
  }
}

// MARK: - CameraPosition

/** Позиция камеры. */
class CameraPosition {
  /** Точка местности, которая находится в точке позиции камеры (см. ICamera::position_point()). */
  final GeoPoint point;
  /**
   Уровень масштабирования.
   0 - это весь мир, вписанный в квадрат 256x256 логических пикселей (см. LogicalPixel)
  */
  final Zoom zoom;
  /**
   Угол наклона направления взгляда по вертикали.
  
   - Note: 0 - надир (смотрим вертикально вниз), максимальное значение - 60 градусов.
  */
  final Tilt tilt;
  /**
   Угол поворота направления взгляда по горизонтали относительно направления на север.
   Отсчитывается по часовой стрелке, в градусах.
  */
  final Bearing bearing;

  const CameraPosition({
    required this.point,
    required this.zoom,
    this.tilt = const Tilt(0),
    this.bearing = const Bearing(0)
  });

  CameraPosition copyWith({
    GeoPoint? point,
    Zoom? zoom,
    Tilt? tilt,
    Bearing? bearing
  }) {
    return CameraPosition(
      point: point ?? this.point,
      zoom: zoom ?? this.zoom,
      tilt: tilt ?? this.tilt,
      bearing: bearing ?? this.bearing
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CameraPosition &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.zoom == zoom &&
    other.tilt == tilt &&
    other.bearing == bearing;

  @override
  int get hashCode {
    return Object.hash(point, zoom, tilt, bearing);
  }

}
final class _CCameraPosition extends ffi.Struct {
  external _CGeoPoint point;

  external _CZoom zoom;

  external _CTilt tilt;

  external _CBearing bearing;

}
// MARK: - CameraPosition <-> _CCameraPosition

extension _CCameraPositionToDart on _CCameraPosition {
  CameraPosition _toDart() {
    return CameraPosition(
      point: this.point._toDart(),
      zoom: this.zoom._toDart(),
      tilt: this.tilt._toDart(),
      bearing: this.bearing._toDart()
    );
  }
}

extension _DartTo_CCameraPosition on CameraPosition {
  _CCameraPosition _copyFromDartTo_CCameraPosition() {
    final res = _CCameraPositionMakeDefault();
    res.point = this.point._copyFromDartTo_CGeoPoint();
    res.zoom = this.zoom._copyFromDartTo_CZoom();
    res.tilt = this.tilt._copyFromDartTo_CTilt();
    res.bearing = this.bearing._copyFromDartTo_CBearing();
    return res;
  }
}
extension _CCameraPositionRelease on _CCameraPosition {
  void _releaseIntermediate() {
  }
}

// MARK: - _CameraMoveControllerCpp

/**
 Класс, позволяющий управлять положением камеры для нужд анимации

 - Warning: Класс должен быть потокобезопасным.
*/
class _CameraMoveControllerCpp extends CameraMoveController implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CCameraMoveControllerCpp_releasePtr);

  _CameraMoveControllerCpp._raw(this._self);
  factory _CameraMoveControllerCpp._create(ffi.Pointer<ffi.Void> self) {
    final classObject = _CameraMoveControllerCpp._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is _CameraMoveControllerCpp &&
    other.runtimeType == runtimeType &&
    _CCameraMoveControllerCpp_cg_objectIdentifier(this._self) == _CCameraMoveControllerCpp_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCameraMoveControllerCpp_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: _CameraMoveControllerCpp: Methods

  /**
   Позиция области просмотра в конкретный момент времени.
   Контроллер должен быть готов к тому, что время анимации будет передаваться в любом порядке,
   не обязательно в неубывающем.
  
   - Parameter time: Время от начала анимации в миллисекундах.
   - Returns: Положение области просмотра в указанный момент времени.
  */
  CameraPosition position(
    Duration time
  )  {
    var _a1 = time._copyFromDartTo_CTimeInterval();
    _CCameraPosition res = _CCameraMoveControllerCpp_position_CTimeInterval(_CCameraMoveControllerCppMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Продолжительность анимации в миллисекундах.
  
   - Returns: Продолжительность анимации в миллисекундах.
  */
  Duration animationTime()  {
    _CTimeInterval res = _CCameraMoveControllerCpp_animationTime(_CCameraMoveControllerCppMakeDefault().._impl=_self);
    return res._toDart();
  }

}

// MARK: - _CameraMoveControllerCpp <-> CCameraMoveControllerCpp

final class _CCameraMoveControllerCpp extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCameraMoveControllerCppBasicFunctions on _CCameraMoveControllerCpp {
  void _releaseIntermediate() {
    _CCameraMoveControllerCpp_release(_impl);
  }

  _CCameraMoveControllerCpp _retain() {
    return _CCameraMoveControllerCpp_retain(_impl);
  }
}

extension _CCameraMoveControllerCppToDart on _CCameraMoveControllerCpp {
  _CameraMoveControllerCpp _toDart() {
    return _CameraMoveControllerCpp._create(_retain()._impl);
  }
}


extension _DartToCCameraMoveControllerCpp on _CameraMoveControllerCpp {
  _CCameraMoveControllerCpp _copyFromDartTo_CCameraMoveControllerCpp() {
    return (_CCameraMoveControllerCppMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CameraMoveController

/**
 Класс, позволяющий управлять положением камеры для нужд анимации

 - Warning: Класс должен быть потокобезопасным.
*/
abstract class CameraMoveController {
  CameraPosition position(
    Duration time
  );
  Duration animationTime();
}

class _CameraMoveController {
  final CameraMoveController object;
  int refCounter = 1;

  _CameraMoveController(this.object);
}

final class _CCameraMoveController extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.Void> _cppValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CCameraPosition)>>, _CTimeInterval)>> _position_CTimeInterval;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CTimeInterval)>>)>> _animationTime;
}

extension _CCameraMoveControllerBasicFunctions on _CCameraMoveController {
  void _releaseIntermediate() {
    _CCameraMoveController_release(this);
  }
}

int _CCameraMoveControllerInstanceCounter = 1;
final _CCameraMoveControllerInstanceMap = <int, _CameraMoveController>{};

extension _CCameraMoveControllerToDart on _CCameraMoveController {
  CameraMoveController _toDart() {
    late CameraMoveController? result;
    final platformValue = this._value.cast<ffi.Int64>();
    if (platformValue.address != 0) {
      result = _CCameraMoveControllerInstanceMap[platformValue.address]?.object;
    } else if (this._cppValue.address != 0) {
      final cppValue = _CCameraMoveControllerCppMakeDefault().._impl = this._cppValue;
      result = cppValue._toDart();
    }
    if (result == null) {
      throw Exception("Invalid intermediate object of type _CCameraMoveController");
    }
    return result;
  }
}

extension _DartTo_CCameraMoveController on CameraMoveController {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    _CCameraMoveControllerInstanceMap[platformValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    final platformObject = _CCameraMoveControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      return;
    }
    platformObject.refCounter -= 1;
    if (platformObject.refCounter > 0) {
      return;
    }
    _CCameraMoveControllerInstanceMap.remove(platformValue.address);
  }

  _CCameraMoveController _copyFromDartTo_CCameraMoveController() {
    var res = _CCameraMoveControllerMakeDefault();
    if (this is _CameraMoveControllerCpp) {
      final cppValue = this as _CameraMoveControllerCpp;
      res._cppValue = cppValue._copyFromDartTo_CCameraMoveControllerCpp()._impl;
      return res;
    }
    final instanceId = _CCameraMoveControllerInstanceCounter;
    _CCameraMoveControllerInstanceCounter += 1;
    _CCameraMoveControllerInstanceMap[instanceId] = _CameraMoveController(this);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;

    final position_CTimeIntervalFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CCameraPosition)>>, _CTimeInterval)>.listener(position_CTimeIntervalFunction);
    res._position_CTimeInterval = position_CTimeIntervalFunctionCallable.nativeFunction;
    final animationTimeFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CTimeInterval)>>)>.listener(animationTimeFunction);
    res._animationTime = animationTimeFunctionCallable.nativeFunction;
    return res;
  }

  static void position_CTimeIntervalFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CCameraPosition)>> resultValueCallback, _CTimeInterval time) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CCameraMoveController");
    }
    final platformObject = _CCameraMoveControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CCameraMoveController");
    }

    final timeDart = time._toDart();
    final res = platformObject.object.position(timeDart);
    time._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _CCameraPosition)>();
    callbackFunction(context, res._copyFromDartTo_CCameraPosition());
  }

  static void animationTimeFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CTimeInterval)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CCameraMoveController");
    }
    final platformObject = _CCameraMoveControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CCameraMoveController");
    }

    final res = platformObject.object.animationTime();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _CTimeInterval)>();
    callbackFunction(context, res._copyFromDartTo_CTimeInterval());
  }


}

// MARK: - NewValuesNotifier

/** Интерфейс объекта, который сообщает о том, что есть изменения в каком-либо из параметров. */
class NewValuesNotifier implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CNewValuesNotifier_releasePtr);

  NewValuesNotifier._raw(this._self);
  factory NewValuesNotifier._create(ffi.Pointer<ffi.Void> self) {
    final classObject = NewValuesNotifier._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is NewValuesNotifier &&
    other.runtimeType == runtimeType &&
    _CNewValuesNotifier_cg_objectIdentifier(this._self) == _CNewValuesNotifier_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CNewValuesNotifier_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: NewValuesNotifier: Methods

  /** Необходимо вызывать, чтобы сообщить об обновлении параметров. */
  void sendNotification()  {
    void res = _CNewValuesNotifier_sendNotification(_CNewValuesNotifierMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - NewValuesNotifier <-> CNewValuesNotifier

final class _CNewValuesNotifier extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CNewValuesNotifierBasicFunctions on _CNewValuesNotifier {
  void _releaseIntermediate() {
    _CNewValuesNotifier_release(_impl);
  }

  _CNewValuesNotifier _retain() {
    return _CNewValuesNotifier_retain(_impl);
  }
}

extension _CNewValuesNotifierToDart on _CNewValuesNotifier {
  NewValuesNotifier _toDart() {
    return NewValuesNotifier._create(_retain()._impl);
  }
}


extension _DartToCNewValuesNotifier on NewValuesNotifier {
  _CNewValuesNotifier _copyFromDartTo_CNewValuesNotifier() {
    return (_CNewValuesNotifierMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - FollowValue

enum FollowValue {
  coordinates(1),
  bearing(2),
  tilt(4),
  styleZoom(8),
  ;

  const FollowValue(this.rawValue);
  final int rawValue;

  static FollowValue getByValue(int value) {
    return FollowValue.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CFollowValue extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CFollowValueBasicFunctions on _CFollowValue {
  void _releaseIntermediate() {
  }
}

extension _CFollowValueToDart on _CFollowValue {
  FollowValue _toDart() {
    return FollowValue.getByValue(this.rawValue);
  }
}

extension _DartTo_CFollowValue on FollowValue {
  _CFollowValue _copyFromDartTo_CFollowValue() {
    return _CFollowValueMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - StyleZoom

/**
 Стилевой уровень масштабирования.

 Задаётся в редакторе стилей и отличается от обычного уровня масштабирования тем, что для одного StyleZoom
 масштаб карты одинаков независимо от широты.
 Однако, при Zoom
 <
 9 или при latitude > 60 градусов StyleZoom == Zoom и масштаб карты на разных широтах отличается.

 - Note: StyleZoom не может быть отрицательным.
*/
class StyleZoom {
  final double value;

  const StyleZoom([this.value = 0]);

  StyleZoom copyWith({
    double? value
  }) {
    return StyleZoom(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is StyleZoom &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CStyleZoom extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - StyleZoom <-> _CStyleZoom

extension _CStyleZoomToDart on _CStyleZoom {
  StyleZoom _toDart() {
    return StyleZoom(
      this.value
    );
  }
}

extension _DartTo_CStyleZoom on StyleZoom {
  _CStyleZoom _copyFromDartTo_CStyleZoom() {
    final res = _CStyleZoomMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CStyleZoomRelease on _CStyleZoom {
  void _releaseIntermediate() {
  }
}

// MARK: - _CustomFollowControllerCpp

/**
 Интерфейс, который можно реализовать на платформе для создания собственного контроллера слежения за параметрами
 Для добавления контроллера в камеру, нужно реализовать этот интерфейс и создать объект FollowController'а передав
 в качестве аргумента объект, реализующий данные интерфейс.
*/
class _CustomFollowControllerCpp extends CustomFollowController implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CCustomFollowControllerCpp_releasePtr);

  _CustomFollowControllerCpp._raw(this._self);
  factory _CustomFollowControllerCpp._create(ffi.Pointer<ffi.Void> self) {
    final classObject = _CustomFollowControllerCpp._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is _CustomFollowControllerCpp &&
    other.runtimeType == runtimeType &&
    _CCustomFollowControllerCpp_cg_objectIdentifier(this._self) == _CCustomFollowControllerCpp_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCustomFollowControllerCpp_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: _CustomFollowControllerCpp: Methods

  /** Набор видов значений, которыми умеет управлять данный контроллер. */
  FollowValueEnumSet availableValues()  {
    _COptionSet_CFollowValue res = _CCustomFollowControllerCpp_availableValues(_CCustomFollowControllerCppMakeDefault().._impl=_self);
    return res._toDart();
  }

  /**
   С помощью этого метода в контроллер сообщается, какие из
   предоставляемых им значений используются. Это позволяет освободить
   ресурсы, связанные с вычислением неиспользуемых значений. Метод может
   вызываться многократно с разными значениями, в этом случае актуальным
   является последнее из них.
  */
  void requestValues(
    FollowValueEnumSet values
  )  {
    var _a1 = values._copyFromDartTo_COptionSet_CFollowValue();
    void res = _CCustomFollowControllerCpp_requestValues_COptionSet_CFollowValue(_CCustomFollowControllerCppMakeDefault().._impl=_self, _a1);
    return res;
  }

  /**
   Установка нотифаера, который оповещает о новых значениях.
   Нотифаер нужно сохранить в реализуемом контроллере
  */
  void setNewValuesNotifier(
    NewValuesNotifier? notifier
  )  {
    var _a1 = notifier._copyFromDartTo_COptional_CNewValuesNotifier();
    void res = _CCustomFollowControllerCpp_setNewValuesNotifier_COptional_CNewValuesNotifier(_CCustomFollowControllerCppMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Географические координаты.
   Метод вызывается только после вызова request_values с соответствующими параметрами.
  */
  GeoPoint? coordinates()  {
    _COptional_CGeoPoint res = _CCustomFollowControllerCpp_coordinates(_CCustomFollowControllerCppMakeDefault().._impl=_self);
    return res._toDart();
  }

  /**
   Направление.
   Метод вызывается только после вызова request_values с соответствующими параметрами.
  */
  Bearing? bearing()  {
    _COptional_CBearing res = _CCustomFollowControllerCpp_bearing(_CCustomFollowControllerCppMakeDefault().._impl=_self);
    return res._toDart();
  }

  /**
   Наклон карты.
   Метод вызывается только после вызова request_values с соответствующими параметрами.
  */
  Tilt? tilt()  {
    _COptional_CTilt res = _CCustomFollowControllerCpp_tilt(_CCustomFollowControllerCppMakeDefault().._impl=_self);
    return res._toDart();
  }

  /**
   Стилевой уровень масштабирования карты.
   Метод вызывается только после вызова request_values с соответствующими параметрами.
  */
  StyleZoom? styleZoom()  {
    _COptional_CStyleZoom res = _CCustomFollowControllerCpp_styleZoom(_CCustomFollowControllerCppMakeDefault().._impl=_self);
    return res._toDart();
  }

}

// MARK: - _CustomFollowControllerCpp <-> CCustomFollowControllerCpp

final class _CCustomFollowControllerCpp extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCustomFollowControllerCppBasicFunctions on _CCustomFollowControllerCpp {
  void _releaseIntermediate() {
    _CCustomFollowControllerCpp_release(_impl);
  }

  _CCustomFollowControllerCpp _retain() {
    return _CCustomFollowControllerCpp_retain(_impl);
  }
}

extension _CCustomFollowControllerCppToDart on _CCustomFollowControllerCpp {
  _CustomFollowControllerCpp _toDart() {
    return _CustomFollowControllerCpp._create(_retain()._impl);
  }
}


extension _DartToCCustomFollowControllerCpp on _CustomFollowControllerCpp {
  _CCustomFollowControllerCpp _copyFromDartTo_CCustomFollowControllerCpp() {
    return (_CCustomFollowControllerCppMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - FollowValueEnumSet

class FollowValueEnumSet extends EnumSet<FollowValue> {
  FollowValueEnumSet() : super();

  factory FollowValueEnumSet.fromRawValue(int rawValue) {
    FollowValueEnumSet enumSet = FollowValueEnumSet();
    enumSet.rawValue = rawValue;
    return enumSet;
  }

  factory FollowValueEnumSet.of(Iterable<FollowValue> elements) {
    FollowValueEnumSet enumSet = FollowValueEnumSet();
    enumSet.addAll(elements);
    return enumSet;
  }

  factory FollowValueEnumSet.all() {
    FollowValueEnumSet enumSet = FollowValueEnumSet();
    enumSet.addAll(FollowValue.values);
    return enumSet;
  }

  @override
  bool contains(FollowValue value) =>
      (this.rawValue & value.rawValue) == value.rawValue;

  @override
  bool containsAllFromEnumSet(EnumSet<FollowValue> other) =>
      (this.rawValue & other.rawValue) == this.rawValue;

  @override
  bool add(FollowValue value) {
    if (this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue | value.rawValue;
    return true;
  }

  @override
  void addAllFromEnumSet(EnumSet<FollowValue> other) =>
      this.rawValue = this.rawValue | other.rawValue;

  @override
  bool remove(FollowValue value) {
    if (!this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue & ~value.rawValue;
    return true;
  }

  @override
  void removeAllFromEnumSet(EnumSet<FollowValue> other) =>
      this.rawValue = this.rawValue & ~other.rawValue;

  @override
  EnumSet<FollowValue> intersection(EnumSet<FollowValue> other) =>
      FollowValueEnumSet.fromRawValue(this.rawValue & other.rawValue);

  @override
  EnumSet<FollowValue> union(EnumSet<FollowValue> other) =>
      FollowValueEnumSet.fromRawValue(this.rawValue | other.rawValue);

  @override
  EnumSet<FollowValue> difference(EnumSet<FollowValue> other) =>
      FollowValueEnumSet.fromRawValue(this.rawValue & ~other.rawValue);

  @override
  Set<FollowValue> toSet() {
    Set<FollowValue> result = {};
    FollowValue.values.forEach((element) {
      if (this.contains(element)) {
        result.add(element);
      }
    });
    return result;
  }

  @override
  String toString() {
    List<String> validOptionNames = [];
    FollowValue.values.forEach((element) {
      if (this.contains(element)) {
        validOptionNames.add(element.name);
      }
    });

    return "${this.runtimeType}: ${validOptionNames.join(', ')}";
  }
}

final class _COptionSet_CFollowValue extends ffi.Struct {
  @ffi.Uint32()
  external int _rawValue;
}

extension _COptionSet_CFollowValueBasicFunctions on _COptionSet_CFollowValue {
  void _releaseIntermediate() {
  }
}

extension _COptionSet_CFollowValueToDart on _COptionSet_CFollowValue {
  FollowValueEnumSet _toDart() {
    return FollowValueEnumSet.fromRawValue(this._rawValue);
  }
}

extension _DartTo_COptionSet_CFollowValue on FollowValueEnumSet {
  _COptionSet_CFollowValue _copyFromDartTo_COptionSet_CFollowValue() {
    return _COptionSet_CFollowValueMakeDefault().._rawValue = this.rawValue;
  }
}
	
// MARK: - NewValuesNotifier? <-> _COptional_CNewValuesNotifier

final class _COptional_CNewValuesNotifier extends ffi.Struct {
  
  external _CNewValuesNotifier value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CNewValuesNotifierBasicFunctions on _COptional_CNewValuesNotifier {
  void _releaseIntermediate() {
    _COptional_CNewValuesNotifier_release(this);
  }
}

extension _COptional_CNewValuesNotifierToDart on _COptional_CNewValuesNotifier {
  NewValuesNotifier? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CNewValuesNotifier on NewValuesNotifier? {
  _COptional_CNewValuesNotifier _copyFromDartTo_COptional_CNewValuesNotifier() {
    final cOptional = _COptional_CNewValuesNotifierMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CNewValuesNotifier();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Tilt? <-> _COptional_CTilt

final class _COptional_CTilt extends ffi.Struct {
  
  external _CTilt value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CTiltBasicFunctions on _COptional_CTilt {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CTiltToDart on _COptional_CTilt {
  Tilt? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CTilt on Tilt? {
  _COptional_CTilt _copyFromDartTo_COptional_CTilt() {
    final cOptional = _COptional_CTiltMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CTilt();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - StyleZoom? <-> _COptional_CStyleZoom

final class _COptional_CStyleZoom extends ffi.Struct {
  
  external _CStyleZoom value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CStyleZoomBasicFunctions on _COptional_CStyleZoom {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CStyleZoomToDart on _COptional_CStyleZoom {
  StyleZoom? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CStyleZoom on StyleZoom? {
  _COptional_CStyleZoom _copyFromDartTo_COptional_CStyleZoom() {
    final cOptional = _COptional_CStyleZoomMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CStyleZoom();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - CustomFollowController

/**
 Интерфейс, который можно реализовать на платформе для создания собственного контроллера слежения за параметрами
 Для добавления контроллера в камеру, нужно реализовать этот интерфейс и создать объект FollowController'а передав
 в качестве аргумента объект, реализующий данные интерфейс.
*/
abstract class CustomFollowController {
  FollowValueEnumSet availableValues();
  void requestValues(
    FollowValueEnumSet values
  );
  void setNewValuesNotifier(
    NewValuesNotifier? notifier
  );
  GeoPoint? coordinates();
  Bearing? bearing();
  Tilt? tilt();
  StyleZoom? styleZoom();
}

class _CustomFollowController {
  final CustomFollowController object;
  int refCounter = 1;

  _CustomFollowController(this.object);
}

final class _CCustomFollowController extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.Void> _cppValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptionSet_CFollowValue)>>)>> _availableValues;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _COptionSet_CFollowValue)>> _requestValues_COptionSet_CFollowValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _COptional_CNewValuesNotifier)>> _setNewValuesNotifier_COptional_CNewValuesNotifier;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CGeoPoint)>>)>> _coordinates;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CBearing)>>)>> _bearing;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CTilt)>>)>> _tilt;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CStyleZoom)>>)>> _styleZoom;
}

extension _CCustomFollowControllerBasicFunctions on _CCustomFollowController {
  void _releaseIntermediate() {
    _CCustomFollowController_release(this);
  }
}

int _CCustomFollowControllerInstanceCounter = 1;
final _CCustomFollowControllerInstanceMap = <int, _CustomFollowController>{};

extension _CCustomFollowControllerToDart on _CCustomFollowController {
  CustomFollowController _toDart() {
    late CustomFollowController? result;
    final platformValue = this._value.cast<ffi.Int64>();
    if (platformValue.address != 0) {
      result = _CCustomFollowControllerInstanceMap[platformValue.address]?.object;
    } else if (this._cppValue.address != 0) {
      final cppValue = _CCustomFollowControllerCppMakeDefault().._impl = this._cppValue;
      result = cppValue._toDart();
    }
    if (result == null) {
      throw Exception("Invalid intermediate object of type _CCustomFollowController");
    }
    return result;
  }
}

extension _DartTo_CCustomFollowController on CustomFollowController {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    _CCustomFollowControllerInstanceMap[platformValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    final platformObject = _CCustomFollowControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      return;
    }
    platformObject.refCounter -= 1;
    if (platformObject.refCounter > 0) {
      return;
    }
    _CCustomFollowControllerInstanceMap.remove(platformValue.address);
  }

  _CCustomFollowController _copyFromDartTo_CCustomFollowController() {
    var res = _CCustomFollowControllerMakeDefault();
    if (this is _CustomFollowControllerCpp) {
      final cppValue = this as _CustomFollowControllerCpp;
      res._cppValue = cppValue._copyFromDartTo_CCustomFollowControllerCpp()._impl;
      return res;
    }
    final instanceId = _CCustomFollowControllerInstanceCounter;
    _CCustomFollowControllerInstanceCounter += 1;
    _CCustomFollowControllerInstanceMap[instanceId] = _CustomFollowController(this);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;

    final availableValuesFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptionSet_CFollowValue)>>)>.listener(availableValuesFunction);
    res._availableValues = availableValuesFunctionCallable.nativeFunction;
    final requestValues_COptionSet_CFollowValueFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _COptionSet_CFollowValue)>.listener(requestValues_COptionSet_CFollowValueFunction);
    res._requestValues_COptionSet_CFollowValue = requestValues_COptionSet_CFollowValueFunctionCallable.nativeFunction;
    final setNewValuesNotifier_COptional_CNewValuesNotifierFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _COptional_CNewValuesNotifier)>.listener(setNewValuesNotifier_COptional_CNewValuesNotifierFunction);
    res._setNewValuesNotifier_COptional_CNewValuesNotifier = setNewValuesNotifier_COptional_CNewValuesNotifierFunctionCallable.nativeFunction;
    final coordinatesFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CGeoPoint)>>)>.listener(coordinatesFunction);
    res._coordinates = coordinatesFunctionCallable.nativeFunction;
    final bearingFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CBearing)>>)>.listener(bearingFunction);
    res._bearing = bearingFunctionCallable.nativeFunction;
    final tiltFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CTilt)>>)>.listener(tiltFunction);
    res._tilt = tiltFunctionCallable.nativeFunction;
    final styleZoomFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CStyleZoom)>>)>.listener(styleZoomFunction);
    res._styleZoom = styleZoomFunctionCallable.nativeFunction;
    return res;
  }

  static void availableValuesFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptionSet_CFollowValue)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }
    final platformObject = _CCustomFollowControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }

    final res = platformObject.object.availableValues();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _COptionSet_CFollowValue)>();
    callbackFunction(context, res._copyFromDartTo_COptionSet_CFollowValue());
  }

  static void requestValues_COptionSet_CFollowValueFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> resultValueCallback, _COptionSet_CFollowValue values) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }
    final platformObject = _CCustomFollowControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }

    final valuesDart = values._toDart();
    platformObject.object.requestValues(valuesDart);
    values._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
    callbackFunction(context);
  }

  static void setNewValuesNotifier_COptional_CNewValuesNotifierFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> resultValueCallback, _COptional_CNewValuesNotifier notifier) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }
    final platformObject = _CCustomFollowControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }

    final notifierDart = notifier._toDart();
    platformObject.object.setNewValuesNotifier(notifierDart);
    notifier._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
    callbackFunction(context);
  }

  static void coordinatesFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CGeoPoint)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }
    final platformObject = _CCustomFollowControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }

    final res = platformObject.object.coordinates();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _COptional_CGeoPoint)>();
    callbackFunction(context, res._copyFromDartTo_COptional_CGeoPoint());
  }

  static void bearingFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CBearing)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }
    final platformObject = _CCustomFollowControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }

    final res = platformObject.object.bearing();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _COptional_CBearing)>();
    callbackFunction(context, res._copyFromDartTo_COptional_CBearing());
  }

  static void tiltFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CTilt)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }
    final platformObject = _CCustomFollowControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }

    final res = platformObject.object.tilt();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _COptional_CTilt)>();
    callbackFunction(context, res._copyFromDartTo_COptional_CTilt());
  }

  static void styleZoomFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _COptional_CStyleZoom)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }
    final platformObject = _CCustomFollowControllerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CCustomFollowController");
    }

    final res = platformObject.object.styleZoom();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _COptional_CStyleZoom)>();
    callbackFunction(context, res._copyFromDartTo_COptional_CStyleZoom());
  }


}

// MARK: - Event

/** Базовый класс для всех обрабатываемых событий. */
class Event implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CEvent_releasePtr);

  Event._raw(this._self);
  factory Event._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Event._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Event &&
    other.runtimeType == runtimeType &&
    _CEvent_cg_objectIdentifier(this._self) == _CEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Event <-> CEvent

final class _CEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CEventBasicFunctions on _CEvent {
  void _releaseIntermediate() {
    _CEvent_release(_impl);
  }

  _CEvent _retain() {
    return _CEvent_retain(_impl);
  }
}

extension _CEventToDart on _CEvent {
  Event _toDart() {
    final selector = _CEvent_cg_getSelector(this);
    switch (selector) {
      case 0:
        final res = Event._create(_retain()._impl);
        return res;
      case 1:
        final res = InputEvent._create(_retain()._impl);
        return res;
      case 2:
        final res = CancelEvent._create(_retain()._impl);
        return res;
      case 3:
        final res = DirectMapControlBeginEvent._create(_retain()._impl);
        return res;
      case 4:
        final res = MapRotationBeginEvent._create(_retain()._impl);
        return res;
      case 5:
        final res = MapRotationEndEvent._create(_retain()._impl);
        return res;
      case 6:
        final res = MapScalingBeginEvent._create(_retain()._impl);
        return res;
      case 7:
        final res = MapScalingEndEvent._create(_retain()._impl);
        return res;
      case 8:
        final res = MapShiftBeginEvent._create(_retain()._impl);
        return res;
      case 9:
        final res = MapShiftEndEvent._create(_retain()._impl);
        return res;
      case 10:
        final res = RotateMapToNorthEvent._create(_retain()._impl);
        return res;
      case 11:
        final res = ScaleMapEvent._create(_retain()._impl);
        return res;
      default: throw Exception("Unrecognized case index $selector");
    }
  }
}

extension _DartToCEvent on Event {
  _CEvent _copyFromDartTo_CEvent() {
    return (_CEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - InputEvent

/** Событие пользовательского ввода. */
class InputEvent extends Event implements ffi.Finalizable {
  /**
   Получение времени регистрации события ввода.
  
   - Returns: время регистрации события, в мс
  */
  Duration get timestamp {
    _CTimeInterval res = _CInputEvent_timestamp(_CInputEventMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CInputEvent_releasePtr);

  InputEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory InputEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = InputEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is InputEvent &&
    other.runtimeType == runtimeType &&
    _CInputEvent_cg_objectIdentifier(this._self) == _CInputEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CInputEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - InputEvent <-> CInputEvent

final class _CInputEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CInputEventBasicFunctions on _CInputEvent {
  void _releaseIntermediate() {
    _CInputEvent_release(_impl);
  }

  _CInputEvent _retain() {
    return _CInputEvent_retain(_impl);
  }
}

extension _CInputEventToDart on _CInputEvent {
  InputEvent _toDart() {
    final selector = _CInputEvent_cg_getSelector(this);
    switch (selector) {
      case 0:
        final res = InputEvent._create(_retain()._impl);
        return res;
      case 1:
        final res = DirectMapControlEndEvent._create(_retain()._impl);
        return res;
      case 2:
        final res = DirectMapRotationEvent._create(_retain()._impl);
        return res;
      case 3:
        final res = DirectMapScalingEvent._create(_retain()._impl);
        return res;
      case 4:
        final res = DirectMapShiftEvent._create(_retain()._impl);
        return res;
      case 5:
        final res = DirectMapTiltEvent._create(_retain()._impl);
        return res;
      default: throw Exception("Unrecognized case index $selector");
    }
  }
}

extension _DartToCInputEvent on InputEvent {
  _CInputEvent _copyFromDartTo_CInputEvent() {
    return (_CInputEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CancelEvent

/**
 Событие отмены текущего действия.

 Вызывается, например, при отмене жеста, потере фокуса окна или при потере захвата мыши.
 Также может быть вызван изнутри карты при смене ограничений уровня масштабирования, некоторых изменениях режима
 слежения и установке интерактивного режима карты.
*/
class CancelEvent extends Event implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CCancelEvent_releasePtr);

  CancelEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory CancelEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = CancelEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory CancelEvent() {
    _CCancelEvent res = _CCancelEvent_C_create();
    return CancelEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CancelEvent &&
    other.runtimeType == runtimeType &&
    _CCancelEvent_cg_objectIdentifier(this._self) == _CCancelEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCancelEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - CancelEvent <-> CCancelEvent

final class _CCancelEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCancelEventBasicFunctions on _CCancelEvent {
  void _releaseIntermediate() {
    _CCancelEvent_release(_impl);
  }

  _CCancelEvent _retain() {
    return _CCancelEvent_retain(_impl);
  }
}

extension _CCancelEventToDart on _CCancelEvent {
  CancelEvent _toDart() {
    return CancelEvent._create(_retain()._impl);
  }
}


extension _DartToCCancelEvent on CancelEvent {
  _CCancelEvent _copyFromDartTo_CCancelEvent() {
    return (_CCancelEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - DgisSourceWorkingMode

/** Установка режима работы источника данных IDgisSource. */
enum DgisSourceWorkingMode {
  /** Получение данных с серверов 2ГИС. */
  online(0),
  ;

  const DgisSourceWorkingMode(this.rawValue);
  final int rawValue;

  static DgisSourceWorkingMode getByValue(int value) {
    return DgisSourceWorkingMode.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CDgisSourceWorkingMode extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CDgisSourceWorkingModeBasicFunctions on _CDgisSourceWorkingMode {
  void _releaseIntermediate() {
  }
}

extension _CDgisSourceWorkingModeToDart on _CDgisSourceWorkingMode {
  DgisSourceWorkingMode _toDart() {
    return DgisSourceWorkingMode.getByValue(this.rawValue);
  }
}

extension _DartTo_CDgisSourceWorkingMode on DgisSourceWorkingMode {
  _CDgisSourceWorkingMode _copyFromDartTo_CDgisSourceWorkingMode() {
    return _CDgisSourceWorkingModeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - DirectMapControlBeginEvent

/**
 Событие начала прямого управления картой.
 Сообщает карте, что необходимо обрабатывать события прямого управления картой.
 События прямого управления работают только от DirectMapControlBeginEvent до DirectMapControlEndEvent.
 После завершения последовательности событий прямого управления может запуститься кинематика.
 Кинематика использует время возникновения события, поэтому лучше использовать время, полученное от системы,
 а не заполнять значение при обработке.
 Пока кинематика работает только для перемещения карты, но не для вращения и масштабирования.
*/
class DirectMapControlBeginEvent extends Event implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CDirectMapControlBeginEvent_releasePtr);

  DirectMapControlBeginEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory DirectMapControlBeginEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = DirectMapControlBeginEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory DirectMapControlBeginEvent() {
    _CDirectMapControlBeginEvent res = _CDirectMapControlBeginEvent_C_create();
    return DirectMapControlBeginEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DirectMapControlBeginEvent &&
    other.runtimeType == runtimeType &&
    _CDirectMapControlBeginEvent_cg_objectIdentifier(this._self) == _CDirectMapControlBeginEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CDirectMapControlBeginEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - DirectMapControlBeginEvent <-> CDirectMapControlBeginEvent

final class _CDirectMapControlBeginEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDirectMapControlBeginEventBasicFunctions on _CDirectMapControlBeginEvent {
  void _releaseIntermediate() {
    _CDirectMapControlBeginEvent_release(_impl);
  }

  _CDirectMapControlBeginEvent _retain() {
    return _CDirectMapControlBeginEvent_retain(_impl);
  }
}

extension _CDirectMapControlBeginEventToDart on _CDirectMapControlBeginEvent {
  DirectMapControlBeginEvent _toDart() {
    return DirectMapControlBeginEvent._create(_retain()._impl);
  }
}


extension _DartToCDirectMapControlBeginEvent on DirectMapControlBeginEvent {
  _CDirectMapControlBeginEvent _copyFromDartTo_CDirectMapControlBeginEvent() {
    return (_CDirectMapControlBeginEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - DirectMapControlEndEvent

/**
 Событие окончания прямого управления картой.
 Завершает прямое управление картой, начатое после получения события DirectMapControlBeginEvent.
 О событиях прямого управления картой описано в DirectMapControlBeginEvent.
*/
class DirectMapControlEndEvent extends InputEvent implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CDirectMapControlEndEvent_releasePtr);

  DirectMapControlEndEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory DirectMapControlEndEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = DirectMapControlEndEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory DirectMapControlEndEvent(
    Duration timestamp
  ) {
    var _a0 = timestamp._copyFromDartTo_CTimeInterval();
    _CDirectMapControlEndEvent res = _CDirectMapControlEndEvent_C_createWith_CTimeInterval(_a0);
    return DirectMapControlEndEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DirectMapControlEndEvent &&
    other.runtimeType == runtimeType &&
    _CDirectMapControlEndEvent_cg_objectIdentifier(this._self) == _CDirectMapControlEndEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CDirectMapControlEndEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - DirectMapControlEndEvent <-> CDirectMapControlEndEvent

final class _CDirectMapControlEndEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDirectMapControlEndEventBasicFunctions on _CDirectMapControlEndEvent {
  void _releaseIntermediate() {
    _CDirectMapControlEndEvent_release(_impl);
  }

  _CDirectMapControlEndEvent _retain() {
    return _CDirectMapControlEndEvent_retain(_impl);
  }
}

extension _CDirectMapControlEndEventToDart on _CDirectMapControlEndEvent {
  DirectMapControlEndEvent _toDart() {
    return DirectMapControlEndEvent._create(_retain()._impl);
  }
}


extension _DartToCDirectMapControlEndEvent on DirectMapControlEndEvent {
  _CDirectMapControlEndEvent _copyFromDartTo_CDirectMapControlEndEvent() {
    return (_CDirectMapControlEndEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ScreenPoint

/**
 Точка в экранных координатах.

 Направления осей: x - вправо, y - вниз.
 (0.0, 0.0) - левый верхний угол левого верхнего пикселя.
 Целая часть координаты - номер пикселя, дробная - относительное местоположение в пикселе.
*/
class ScreenPoint {
  final double x;
  final double y;

  const ScreenPoint({
    this.x = 0,
    this.y = 0
  });

  ScreenPoint copyWith({
    double? x,
    double? y
  }) {
    return ScreenPoint(
      x: x ?? this.x,
      y: y ?? this.y
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ScreenPoint &&
    other.runtimeType == runtimeType &&
    other.x == x &&
    other.y == y;

  @override
  int get hashCode {
    return Object.hash(x, y);
  }

}
final class _CScreenPoint extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

}
// MARK: - ScreenPoint <-> _CScreenPoint

extension _CScreenPointToDart on _CScreenPoint {
  ScreenPoint _toDart() {
    return ScreenPoint(
      x: this.x,
      y: this.y
    );
  }
}

extension _DartTo_CScreenPoint on ScreenPoint {
  _CScreenPoint _copyFromDartTo_CScreenPoint() {
    final res = _CScreenPointMakeDefault();
    res.x = this.x;
    res.y = this.y;
    return res;
  }
}
extension _CScreenPointRelease on _CScreenPoint {
  void _releaseIntermediate() {
  }
}

// MARK: - DirectMapRotationEvent

/** Событие прямого вращения карты. О событиях прямого управления картой описано в DirectMapControlBeginEvent. */
class DirectMapRotationEvent extends InputEvent implements ffi.Finalizable {
  /** Изменение угла поворота карты. */
  Bearing get bearingDelta {
    _CBearing res = _CDirectMapRotationEvent_bearingDelta(_CDirectMapRotationEventMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Точка на экране, вокруг которой вращается карта. */
  ScreenPoint? get rotationCenter {
    _COptional_CScreenPoint res = _CDirectMapRotationEvent_rotationCenter(_CDirectMapRotationEventMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CDirectMapRotationEvent_releasePtr);

  DirectMapRotationEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory DirectMapRotationEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = DirectMapRotationEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   - Parameter bearingDelta: изменение угла поворота карты, в градусах.
   Положительные значения соответствуют направлению вращения против часовой стрелки
   - Parameter timestamp: Время генерации системного события.
   - Parameter rotationCenter: Точка на экране, вокруг которой вращается карта. Если точка не задана,
   то вращение происходит относительно точки позиции карты.
  */
  factory DirectMapRotationEvent(
    Bearing bearingDelta,
    Duration timestamp,
    [ScreenPoint? rotationCenter = null
    ]) {
    var _a0 = bearingDelta._copyFromDartTo_CBearing();
    var _a1 = timestamp._copyFromDartTo_CTimeInterval();
    var _a2 = rotationCenter._copyFromDartTo_COptional_CScreenPoint();
    _CDirectMapRotationEvent res = _CDirectMapRotationEvent_C_createWith_CBearing_CTimeInterval_COptional_CScreenPoint(_a0, _a1, _a2);
    return DirectMapRotationEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DirectMapRotationEvent &&
    other.runtimeType == runtimeType &&
    _CDirectMapRotationEvent_cg_objectIdentifier(this._self) == _CDirectMapRotationEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CDirectMapRotationEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - DirectMapRotationEvent <-> CDirectMapRotationEvent

final class _CDirectMapRotationEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDirectMapRotationEventBasicFunctions on _CDirectMapRotationEvent {
  void _releaseIntermediate() {
    _CDirectMapRotationEvent_release(_impl);
  }

  _CDirectMapRotationEvent _retain() {
    return _CDirectMapRotationEvent_retain(_impl);
  }
}

extension _CDirectMapRotationEventToDart on _CDirectMapRotationEvent {
  DirectMapRotationEvent _toDart() {
    return DirectMapRotationEvent._create(_retain()._impl);
  }
}


extension _DartToCDirectMapRotationEvent on DirectMapRotationEvent {
  _CDirectMapRotationEvent _copyFromDartTo_CDirectMapRotationEvent() {
    return (_CDirectMapRotationEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ScreenPoint? <-> _COptional_CScreenPoint

final class _COptional_CScreenPoint extends ffi.Struct {
  
  external _CScreenPoint value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CScreenPointBasicFunctions on _COptional_CScreenPoint {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CScreenPointToDart on _COptional_CScreenPoint {
  ScreenPoint? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CScreenPoint on ScreenPoint? {
  _COptional_CScreenPoint _copyFromDartTo_COptional_CScreenPoint() {
    final cOptional = _COptional_CScreenPointMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CScreenPoint();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - DirectMapScalingEvent

/** Событие прямого масштабирования карты. События прямого управления картой описаны в DirectMapControlBeginEvent. */
class DirectMapScalingEvent extends InputEvent implements ffi.Finalizable {
  /** Величина, на которую изменится текущее значение масштаба. */
  double get zoomDelta {
    double res = _CDirectMapScalingEvent_zoomDelta(_CDirectMapScalingEventMakeDefault().._impl=_self);
    return res;
  }
  /** Точка на экране, относительно которой масштабируется карта. */
  ScreenPoint? get scalingCenter {
    _COptional_CScreenPoint res = _CDirectMapScalingEvent_scalingCenter(_CDirectMapScalingEventMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CDirectMapScalingEvent_releasePtr);

  DirectMapScalingEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory DirectMapScalingEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = DirectMapScalingEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   - Parameter zoomDelta: Величина, на которую изменится текущее значение масштаба.
   - Parameter timestamp: Время генерации системного события.
   - Parameter scalingCenter: Точка на экране, относительно которой масштабируется карта. Если точка не задана,
   то масштабирование происходит относительно точки позиции карты.
  */
  factory DirectMapScalingEvent(
    double zoomDelta,
    Duration timestamp,
    [ScreenPoint? scalingCenter = null
    ]) {
    var _a1 = timestamp._copyFromDartTo_CTimeInterval();
    var _a2 = scalingCenter._copyFromDartTo_COptional_CScreenPoint();
    _CDirectMapScalingEvent res = _CDirectMapScalingEvent_C_createWith_float_CTimeInterval_COptional_CScreenPoint(zoomDelta, _a1, _a2);
    return DirectMapScalingEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DirectMapScalingEvent &&
    other.runtimeType == runtimeType &&
    _CDirectMapScalingEvent_cg_objectIdentifier(this._self) == _CDirectMapScalingEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CDirectMapScalingEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - DirectMapScalingEvent <-> CDirectMapScalingEvent

final class _CDirectMapScalingEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDirectMapScalingEventBasicFunctions on _CDirectMapScalingEvent {
  void _releaseIntermediate() {
    _CDirectMapScalingEvent_release(_impl);
  }

  _CDirectMapScalingEvent _retain() {
    return _CDirectMapScalingEvent_retain(_impl);
  }
}

extension _CDirectMapScalingEventToDart on _CDirectMapScalingEvent {
  DirectMapScalingEvent _toDart() {
    return DirectMapScalingEvent._create(_retain()._impl);
  }
}


extension _DartToCDirectMapScalingEvent on DirectMapScalingEvent {
  _CDirectMapScalingEvent _copyFromDartTo_CDirectMapScalingEvent() {
    return (_CDirectMapScalingEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ScreenShift

/**
 Смещение карты по горизонтали и вертикали в координатном пространстве экрана.

 Положительное направление смещения: dx - вправо, dy - вниз.
*/
class ScreenShift {
  final double dx;
  final double dy;

  const ScreenShift({
    this.dx = 0,
    this.dy = 0
  });

  ScreenShift copyWith({
    double? dx,
    double? dy
  }) {
    return ScreenShift(
      dx: dx ?? this.dx,
      dy: dy ?? this.dy
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ScreenShift &&
    other.runtimeType == runtimeType &&
    other.dx == dx &&
    other.dy == dy;

  @override
  int get hashCode {
    return Object.hash(dx, dy);
  }

}
final class _CScreenShift extends ffi.Struct {
  @ffi.Float()
  external double dx;

  @ffi.Float()
  external double dy;

}
// MARK: - ScreenShift <-> _CScreenShift

extension _CScreenShiftToDart on _CScreenShift {
  ScreenShift _toDart() {
    return ScreenShift(
      dx: this.dx,
      dy: this.dy
    );
  }
}

extension _DartTo_CScreenShift on ScreenShift {
  _CScreenShift _copyFromDartTo_CScreenShift() {
    final res = _CScreenShiftMakeDefault();
    res.dx = this.dx;
    res.dy = this.dy;
    return res;
  }
}
extension _CScreenShiftRelease on _CScreenShift {
  void _releaseIntermediate() {
  }
}

// MARK: - DirectMapShiftEvent

/** Событие прямого сдвига карты. События прямого управления картой описаны в DirectMapControlBeginEvent. */
class DirectMapShiftEvent extends InputEvent implements ffi.Finalizable {
  /** Изменение экранной позиции карты. */
  ScreenShift get screenShift {
    _CScreenShift res = _CDirectMapShiftEvent_screenShift(_CDirectMapShiftEventMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Центральная точка, от которой производится смещение карты. */
  ScreenPoint get shiftedPoint {
    _CScreenPoint res = _CDirectMapShiftEvent_shiftedPoint(_CDirectMapShiftEventMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CDirectMapShiftEvent_releasePtr);

  DirectMapShiftEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory DirectMapShiftEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = DirectMapShiftEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   - Parameter screenShift: Изменение экранной позиции карты относительно предыдущей, в пикселях.
   - Parameter shiftedPoint: Центральная точка, от которой производится смещение карты.
   - Parameter timestamp: Время генерации системного события.
  */
  factory DirectMapShiftEvent(
    ScreenShift screenShift,
    ScreenPoint shiftedPoint,
    Duration timestamp
  ) {
    var _a0 = screenShift._copyFromDartTo_CScreenShift();
    var _a1 = shiftedPoint._copyFromDartTo_CScreenPoint();
    var _a2 = timestamp._copyFromDartTo_CTimeInterval();
    _CDirectMapShiftEvent res = _CDirectMapShiftEvent_C_createWith_CScreenShift_CScreenPoint_CTimeInterval(_a0, _a1, _a2);
    return DirectMapShiftEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DirectMapShiftEvent &&
    other.runtimeType == runtimeType &&
    _CDirectMapShiftEvent_cg_objectIdentifier(this._self) == _CDirectMapShiftEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CDirectMapShiftEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - DirectMapShiftEvent <-> CDirectMapShiftEvent

final class _CDirectMapShiftEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDirectMapShiftEventBasicFunctions on _CDirectMapShiftEvent {
  void _releaseIntermediate() {
    _CDirectMapShiftEvent_release(_impl);
  }

  _CDirectMapShiftEvent _retain() {
    return _CDirectMapShiftEvent_retain(_impl);
  }
}

extension _CDirectMapShiftEventToDart on _CDirectMapShiftEvent {
  DirectMapShiftEvent _toDart() {
    return DirectMapShiftEvent._create(_retain()._impl);
  }
}


extension _DartToCDirectMapShiftEvent on DirectMapShiftEvent {
  _CDirectMapShiftEvent _copyFromDartTo_CDirectMapShiftEvent() {
    return (_CDirectMapShiftEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - DirectMapTiltEvent

/** Событие прямого наклона камеры. События прямого управления картой описаны в DirectMapControlBeginEvent. */
class DirectMapTiltEvent extends InputEvent implements ffi.Finalizable {
  /** Изменение угла наклона в градусах. */
  double get delta {
    double res = _CDirectMapTiltEvent_delta(_CDirectMapTiltEventMakeDefault().._impl=_self);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CDirectMapTiltEvent_releasePtr);

  DirectMapTiltEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory DirectMapTiltEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = DirectMapTiltEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   - Parameter delta: Изменение угла наклона в градусах.
   - Parameter timestamp: Время генерации системного события.
  */
  factory DirectMapTiltEvent(
    double delta,
    Duration timestamp
  ) {
    var _a1 = timestamp._copyFromDartTo_CTimeInterval();
    _CDirectMapTiltEvent res = _CDirectMapTiltEvent_C_createWith_float_CTimeInterval(delta, _a1);
    return DirectMapTiltEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DirectMapTiltEvent &&
    other.runtimeType == runtimeType &&
    _CDirectMapTiltEvent_cg_objectIdentifier(this._self) == _CDirectMapTiltEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CDirectMapTiltEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - DirectMapTiltEvent <-> CDirectMapTiltEvent

final class _CDirectMapTiltEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDirectMapTiltEventBasicFunctions on _CDirectMapTiltEvent {
  void _releaseIntermediate() {
    _CDirectMapTiltEvent_release(_impl);
  }

  _CDirectMapTiltEvent _retain() {
    return _CDirectMapTiltEvent_retain(_impl);
  }
}

extension _CDirectMapTiltEventToDart on _CDirectMapTiltEvent {
  DirectMapTiltEvent _toDart() {
    return DirectMapTiltEvent._create(_retain()._impl);
  }
}


extension _DartToCDirectMapTiltEvent on DirectMapTiltEvent {
  _CDirectMapTiltEvent _copyFromDartTo_CDirectMapTiltEvent() {
    return (_CDirectMapTiltEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MapRotationDirection

/** Направление вращения карты. */
enum MapRotationDirection {
  /** Вращение карты по часовой стрелке. */
  clockwise(0),
  /** Вращение карты против часовой стрелки. */
  counterclockwise(1),
  ;

  const MapRotationDirection(this.rawValue);
  final int rawValue;

  static MapRotationDirection getByValue(int value) {
    return MapRotationDirection.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CMapRotationDirection extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CMapRotationDirectionBasicFunctions on _CMapRotationDirection {
  void _releaseIntermediate() {
  }
}

extension _CMapRotationDirectionToDart on _CMapRotationDirection {
  MapRotationDirection _toDart() {
    return MapRotationDirection.getByValue(this.rawValue);
  }
}

extension _DartTo_CMapRotationDirection on MapRotationDirection {
  _CMapRotationDirection _copyFromDartTo_CMapRotationDirection() {
    return _CMapRotationDirectionMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - MapRotationBeginEvent

/** Событие начала вращения карты вокруг точки. */
class MapRotationBeginEvent extends Event implements ffi.Finalizable {
  MapRotationDirection get direction {
    _CMapRotationDirection res = _CMapRotationBeginEvent_direction(_CMapRotationBeginEventMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CMapRotationBeginEvent_releasePtr);

  MapRotationBeginEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory MapRotationBeginEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapRotationBeginEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory MapRotationBeginEvent(
    MapRotationDirection inDirection
  ) {
    var _a0 = inDirection._copyFromDartTo_CMapRotationDirection();
    _CMapRotationBeginEvent res = _CMapRotationBeginEvent_C_createWith_CMapRotationDirection(_a0);
    return MapRotationBeginEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapRotationBeginEvent &&
    other.runtimeType == runtimeType &&
    _CMapRotationBeginEvent_cg_objectIdentifier(this._self) == _CMapRotationBeginEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapRotationBeginEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - MapRotationBeginEvent <-> CMapRotationBeginEvent

final class _CMapRotationBeginEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapRotationBeginEventBasicFunctions on _CMapRotationBeginEvent {
  void _releaseIntermediate() {
    _CMapRotationBeginEvent_release(_impl);
  }

  _CMapRotationBeginEvent _retain() {
    return _CMapRotationBeginEvent_retain(_impl);
  }
}

extension _CMapRotationBeginEventToDart on _CMapRotationBeginEvent {
  MapRotationBeginEvent _toDart() {
    return MapRotationBeginEvent._create(_retain()._impl);
  }
}


extension _DartToCMapRotationBeginEvent on MapRotationBeginEvent {
  _CMapRotationBeginEvent _copyFromDartTo_CMapRotationBeginEvent() {
    return (_CMapRotationBeginEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MapRotationEndEvent

/** Событие окончания вращения карты вокруг точки. */
class MapRotationEndEvent extends Event implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CMapRotationEndEvent_releasePtr);

  MapRotationEndEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory MapRotationEndEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapRotationEndEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory MapRotationEndEvent() {
    _CMapRotationEndEvent res = _CMapRotationEndEvent_C_create();
    return MapRotationEndEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapRotationEndEvent &&
    other.runtimeType == runtimeType &&
    _CMapRotationEndEvent_cg_objectIdentifier(this._self) == _CMapRotationEndEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapRotationEndEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - MapRotationEndEvent <-> CMapRotationEndEvent

final class _CMapRotationEndEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapRotationEndEventBasicFunctions on _CMapRotationEndEvent {
  void _releaseIntermediate() {
    _CMapRotationEndEvent_release(_impl);
  }

  _CMapRotationEndEvent _retain() {
    return _CMapRotationEndEvent_retain(_impl);
  }
}

extension _CMapRotationEndEventToDart on _CMapRotationEndEvent {
  MapRotationEndEvent _toDart() {
    return MapRotationEndEvent._create(_retain()._impl);
  }
}


extension _DartToCMapRotationEndEvent on MapRotationEndEvent {
  _CMapRotationEndEvent _copyFromDartTo_CMapRotationEndEvent() {
    return (_CMapRotationEndEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MapScalingDirection

/** Направление изменения масштаба карты. */
enum MapScalingDirection {
  /** Увеличение уровня масштабирования, т.е. увеличение объектов. */
  zoomIn(0),
  /** Уменьшение уровня масштабирования, т.е. уменьшение объектов. */
  zoomOut(1),
  ;

  const MapScalingDirection(this.rawValue);
  final int rawValue;

  static MapScalingDirection getByValue(int value) {
    return MapScalingDirection.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CMapScalingDirection extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CMapScalingDirectionBasicFunctions on _CMapScalingDirection {
  void _releaseIntermediate() {
  }
}

extension _CMapScalingDirectionToDart on _CMapScalingDirection {
  MapScalingDirection _toDart() {
    return MapScalingDirection.getByValue(this.rawValue);
  }
}

extension _DartTo_CMapScalingDirection on MapScalingDirection {
  _CMapScalingDirection _copyFromDartTo_CMapScalingDirection() {
    return _CMapScalingDirectionMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - MapScalingBeginEvent

/** Событие начала изменения масштаба. */
class MapScalingBeginEvent extends Event implements ffi.Finalizable {
  MapScalingDirection get direction {
    _CMapScalingDirection res = _CMapScalingBeginEvent_direction(_CMapScalingBeginEventMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CMapScalingBeginEvent_releasePtr);

  MapScalingBeginEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory MapScalingBeginEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapScalingBeginEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory MapScalingBeginEvent(
    MapScalingDirection inDirection
  ) {
    var _a0 = inDirection._copyFromDartTo_CMapScalingDirection();
    _CMapScalingBeginEvent res = _CMapScalingBeginEvent_C_createWith_CMapScalingDirection(_a0);
    return MapScalingBeginEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapScalingBeginEvent &&
    other.runtimeType == runtimeType &&
    _CMapScalingBeginEvent_cg_objectIdentifier(this._self) == _CMapScalingBeginEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapScalingBeginEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - MapScalingBeginEvent <-> CMapScalingBeginEvent

final class _CMapScalingBeginEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapScalingBeginEventBasicFunctions on _CMapScalingBeginEvent {
  void _releaseIntermediate() {
    _CMapScalingBeginEvent_release(_impl);
  }

  _CMapScalingBeginEvent _retain() {
    return _CMapScalingBeginEvent_retain(_impl);
  }
}

extension _CMapScalingBeginEventToDart on _CMapScalingBeginEvent {
  MapScalingBeginEvent _toDart() {
    return MapScalingBeginEvent._create(_retain()._impl);
  }
}


extension _DartToCMapScalingBeginEvent on MapScalingBeginEvent {
  _CMapScalingBeginEvent _copyFromDartTo_CMapScalingBeginEvent() {
    return (_CMapScalingBeginEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MapScalingEndEvent

/** Событие окончания изменения масштаба. */
class MapScalingEndEvent extends Event implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CMapScalingEndEvent_releasePtr);

  MapScalingEndEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory MapScalingEndEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapScalingEndEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory MapScalingEndEvent() {
    _CMapScalingEndEvent res = _CMapScalingEndEvent_C_create();
    return MapScalingEndEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapScalingEndEvent &&
    other.runtimeType == runtimeType &&
    _CMapScalingEndEvent_cg_objectIdentifier(this._self) == _CMapScalingEndEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapScalingEndEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - MapScalingEndEvent <-> CMapScalingEndEvent

final class _CMapScalingEndEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapScalingEndEventBasicFunctions on _CMapScalingEndEvent {
  void _releaseIntermediate() {
    _CMapScalingEndEvent_release(_impl);
  }

  _CMapScalingEndEvent _retain() {
    return _CMapScalingEndEvent_retain(_impl);
  }
}

extension _CMapScalingEndEventToDart on _CMapScalingEndEvent {
  MapScalingEndEvent _toDart() {
    return MapScalingEndEvent._create(_retain()._impl);
  }
}


extension _DartToCMapScalingEndEvent on MapScalingEndEvent {
  _CMapScalingEndEvent _copyFromDartTo_CMapScalingEndEvent() {
    return (_CMapScalingEndEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MapShiftDirection

/** Направление смещения карты. */
enum MapShiftDirection {
  left(0),
  right(1),
  up(2),
  down(3),
  leftUp(4),
  leftDown(5),
  rightUp(6),
  rightDown(7),
  ;

  const MapShiftDirection(this.rawValue);
  final int rawValue;

  static MapShiftDirection getByValue(int value) {
    return MapShiftDirection.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CMapShiftDirection extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CMapShiftDirectionBasicFunctions on _CMapShiftDirection {
  void _releaseIntermediate() {
  }
}

extension _CMapShiftDirectionToDart on _CMapShiftDirection {
  MapShiftDirection _toDart() {
    return MapShiftDirection.getByValue(this.rawValue);
  }
}

extension _DartTo_CMapShiftDirection on MapShiftDirection {
  _CMapShiftDirection _copyFromDartTo_CMapShiftDirection() {
    return _CMapShiftDirectionMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - MapShiftBeginEvent

/** Событие начала сдвига карты. */
class MapShiftBeginEvent extends Event implements ffi.Finalizable {
  MapShiftDirection get direction {
    _CMapShiftDirection res = _CMapShiftBeginEvent_direction(_CMapShiftBeginEventMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CMapShiftBeginEvent_releasePtr);

  MapShiftBeginEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory MapShiftBeginEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapShiftBeginEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory MapShiftBeginEvent(
    MapShiftDirection inDirection
  ) {
    var _a0 = inDirection._copyFromDartTo_CMapShiftDirection();
    _CMapShiftBeginEvent res = _CMapShiftBeginEvent_C_createWith_CMapShiftDirection(_a0);
    return MapShiftBeginEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapShiftBeginEvent &&
    other.runtimeType == runtimeType &&
    _CMapShiftBeginEvent_cg_objectIdentifier(this._self) == _CMapShiftBeginEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapShiftBeginEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - MapShiftBeginEvent <-> CMapShiftBeginEvent

final class _CMapShiftBeginEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapShiftBeginEventBasicFunctions on _CMapShiftBeginEvent {
  void _releaseIntermediate() {
    _CMapShiftBeginEvent_release(_impl);
  }

  _CMapShiftBeginEvent _retain() {
    return _CMapShiftBeginEvent_retain(_impl);
  }
}

extension _CMapShiftBeginEventToDart on _CMapShiftBeginEvent {
  MapShiftBeginEvent _toDart() {
    return MapShiftBeginEvent._create(_retain()._impl);
  }
}


extension _DartToCMapShiftBeginEvent on MapShiftBeginEvent {
  _CMapShiftBeginEvent _copyFromDartTo_CMapShiftBeginEvent() {
    return (_CMapShiftBeginEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MapShiftEndEvent

/** Событие окончания смещения карты. */
class MapShiftEndEvent extends Event implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CMapShiftEndEvent_releasePtr);

  MapShiftEndEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory MapShiftEndEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapShiftEndEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory MapShiftEndEvent() {
    _CMapShiftEndEvent res = _CMapShiftEndEvent_C_create();
    return MapShiftEndEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapShiftEndEvent &&
    other.runtimeType == runtimeType &&
    _CMapShiftEndEvent_cg_objectIdentifier(this._self) == _CMapShiftEndEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapShiftEndEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - MapShiftEndEvent <-> CMapShiftEndEvent

final class _CMapShiftEndEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapShiftEndEventBasicFunctions on _CMapShiftEndEvent {
  void _releaseIntermediate() {
    _CMapShiftEndEvent_release(_impl);
  }

  _CMapShiftEndEvent _retain() {
    return _CMapShiftEndEvent_retain(_impl);
  }
}

extension _CMapShiftEndEventToDart on _CMapShiftEndEvent {
  MapShiftEndEvent _toDart() {
    return MapShiftEndEvent._create(_retain()._impl);
  }
}


extension _DartToCMapShiftEndEvent on MapShiftEndEvent {
  _CMapShiftEndEvent _copyFromDartTo_CMapShiftEndEvent() {
    return (_CMapShiftEndEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RotateMapToNorthEvent

/** Событие поворота карты на север. */
class RotateMapToNorthEvent extends Event implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CRotateMapToNorthEvent_releasePtr);

  RotateMapToNorthEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory RotateMapToNorthEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RotateMapToNorthEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory RotateMapToNorthEvent() {
    _CRotateMapToNorthEvent res = _CRotateMapToNorthEvent_C_create();
    return RotateMapToNorthEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RotateMapToNorthEvent &&
    other.runtimeType == runtimeType &&
    _CRotateMapToNorthEvent_cg_objectIdentifier(this._self) == _CRotateMapToNorthEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRotateMapToNorthEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - RotateMapToNorthEvent <-> CRotateMapToNorthEvent

final class _CRotateMapToNorthEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRotateMapToNorthEventBasicFunctions on _CRotateMapToNorthEvent {
  void _releaseIntermediate() {
    _CRotateMapToNorthEvent_release(_impl);
  }

  _CRotateMapToNorthEvent _retain() {
    return _CRotateMapToNorthEvent_retain(_impl);
  }
}

extension _CRotateMapToNorthEventToDart on _CRotateMapToNorthEvent {
  RotateMapToNorthEvent _toDart() {
    return RotateMapToNorthEvent._create(_retain()._impl);
  }
}


extension _DartToCRotateMapToNorthEvent on RotateMapToNorthEvent {
  _CRotateMapToNorthEvent _copyFromDartTo_CRotateMapToNorthEvent() {
    return (_CRotateMapToNorthEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ScaleMapEvent

/** Событие изменения масштаба карты. */
class ScaleMapEvent extends Event implements ffi.Finalizable {
  /** Величина, на которую изменится текущее значение масштаба. */
  double get zoomDelta {
    double res = _CScaleMapEvent_zoomDelta(_CScaleMapEventMakeDefault().._impl=_self);
    return res;
  }
  /** Точка на экране, относительно которой масштабируется карта. */
  ScreenPoint? get scalingCenter {
    _COptional_CScreenPoint res = _CScaleMapEvent_scalingCenter(_CScaleMapEventMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CScaleMapEvent_releasePtr);

  ScaleMapEvent._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory ScaleMapEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = ScaleMapEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Конструктор события изменения масштаба.
  
   - Parameter zoomDelta: Величина, на которую изменится текущее значение масштаба.
   - Parameter scalingCenter: Точка на экране, относительно которой масштабируется карта. Если точка не задана,
   то масштабирование происходит относительно точки позиции карты.
  */
  factory ScaleMapEvent(
    double zoomDelta,
    [ScreenPoint? scalingCenter = null
    ]) {
    var _a1 = scalingCenter._copyFromDartTo_COptional_CScreenPoint();
    _CScaleMapEvent res = _CScaleMapEvent_C_createWith_float_COptional_CScreenPoint(zoomDelta, _a1);
    return ScaleMapEvent._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ScaleMapEvent &&
    other.runtimeType == runtimeType &&
    _CScaleMapEvent_cg_objectIdentifier(this._self) == _CScaleMapEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CScaleMapEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - ScaleMapEvent <-> CScaleMapEvent

final class _CScaleMapEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CScaleMapEventBasicFunctions on _CScaleMapEvent {
  void _releaseIntermediate() {
    _CScaleMapEvent_release(_impl);
  }

  _CScaleMapEvent _retain() {
    return _CScaleMapEvent_retain(_impl);
  }
}

extension _CScaleMapEventToDart on _CScaleMapEvent {
  ScaleMapEvent _toDart() {
    return ScaleMapEvent._create(_retain()._impl);
  }
}


extension _DartToCScaleMapEvent on ScaleMapEvent {
  _CScaleMapEvent _copyFromDartTo_CScaleMapEvent() {
    return (_CScaleMapEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Object? <-> _CAny

class _Any {
  final Object object;
  int refCounter = 1;

  _Any(this.object);
}

final class _CAny extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;
}

extension _CAnyBasicFunctions on _CAny {
  void _releaseIntermediate() {
    _CAny_release(this);
  }
}

int _CAnyInstanceCounter = 1;
final _CAnyInstanceMap = <int, _Any>{};

extension _CAnyToDart on _CAny {
  Object? _toDart() {
    final anyValue = this._value.cast<ffi.Int64>();
    if (anyValue.address == 0) {
      return null;
    }
    return _CAnyInstanceMap[anyValue.address]?.object;
  }
}

extension _DartTo_CAny on Object? {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final anyValue = value.cast<ffi.Int64>();
    if (anyValue.address == 0) {
      return;
    }
    _CAnyInstanceMap[anyValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final anyValue = value.cast<ffi.Int64>();
    if (anyValue.address == 0) {
      return;
    }
    final anyObject = _CAnyInstanceMap[anyValue.address];
    if (anyObject == null) {
      return;
    }
    anyObject.refCounter -= 1;
    if (anyObject.refCounter > 0) {
      return;
    }
    _CAnyInstanceMap.remove(anyValue.address);
  }

  _CAny _copyFromDartTo_CAny() {
    var res = _CAnyMakeDefault();
    if (this == null) {
      return res;
    }
    final instanceId = _CAnyInstanceCounter;
    _CAnyInstanceCounter += 1;
    _CAnyInstanceMap[instanceId] = _Any(this!);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;
    return res;
  }
}
	
// MARK: - ClusterOptions

/** Параметры маркера кластера. */
class ClusterOptions {
  /** Атрибуты кластера. */
  final core.Map<String, AttributeValue> attributes;
  /** Пользовательские данные. Возвращаются в IClusterObject. */
  final Object? userData;

  const ClusterOptions({
    required this.attributes,
    this.userData = const {}
  });

  ClusterOptions copyWith({
    core.Map<String, AttributeValue>? attributes,
    Optional<Object?>? userData
  }) {
    return ClusterOptions(
      attributes: attributes ?? this.attributes,
      userData: userData != null ? userData.value : this.userData
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ClusterOptions &&
    other.runtimeType == runtimeType &&
    other.attributes == attributes &&
    other.userData == userData;

  @override
  int get hashCode {
    return Object.hash(attributes, userData);
  }

}
final class _CClusterOptions extends ffi.Struct {
  external _CDictionary_CString_CAttributeValue attributes;

  external _CAny userData;

}
// MARK: - ClusterOptions <-> _CClusterOptions

extension _CClusterOptionsToDart on _CClusterOptions {
  ClusterOptions _toDart() {
    return ClusterOptions(
      attributes: this.attributes._toDart(),
      userData: this.userData._toDart()
    );
  }
}

extension _DartTo_CClusterOptions on ClusterOptions {
  _CClusterOptions _copyFromDartTo_CClusterOptions() {
    final res = _CClusterOptionsMakeDefault();
    res.attributes = this.attributes._copyFromDartTo_CDictionary_CString_CAttributeValue();
    res.userData = this.userData._copyFromDartTo_CAny();
    return res;
  }
}
extension _CClusterOptionsRelease on _CClusterOptions {
  void _releaseIntermediate() {
    attributes._releaseIntermediate();
    userData._releaseIntermediate();
  }
}

// MARK: - FollowBearing

enum FollowBearing {
  off(0),
  on_(1),
  ;

  const FollowBearing(this.rawValue);
  final int rawValue;

  static FollowBearing getByValue(int value) {
    return FollowBearing.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CFollowBearing extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CFollowBearingBasicFunctions on _CFollowBearing {
  void _releaseIntermediate() {
  }
}

extension _CFollowBearingToDart on _CFollowBearing {
  FollowBearing _toDart() {
    return FollowBearing.getByValue(this.rawValue);
  }
}

extension _DartTo_CFollowBearing on FollowBearing {
  _CFollowBearing _copyFromDartTo_CFollowBearing() {
    return _CFollowBearingMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - FollowStyleZoom

enum FollowStyleZoom {
  off(0),
  on_(1),
  ;

  const FollowStyleZoom(this.rawValue);
  final int rawValue;

  static FollowStyleZoom getByValue(int value) {
    return FollowStyleZoom.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CFollowStyleZoom extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CFollowStyleZoomBasicFunctions on _CFollowStyleZoom {
  void _releaseIntermediate() {
  }
}

extension _CFollowStyleZoomToDart on _CFollowStyleZoom {
  FollowStyleZoom _toDart() {
    return FollowStyleZoom.getByValue(this.rawValue);
  }
}

extension _DartTo_CFollowStyleZoom on FollowStyleZoom {
  _CFollowStyleZoom _copyFromDartTo_CFollowStyleZoom() {
    return _CFollowStyleZoomMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - FollowPosition

/** Настройки слежения за позицией. */
class FollowPosition {
  final FollowBearing bearing;
  final FollowStyleZoom styleZoom;

  const FollowPosition({
    this.bearing = FollowBearing.off,
    this.styleZoom = FollowStyleZoom.off
  });

  FollowPosition copyWith({
    FollowBearing? bearing,
    FollowStyleZoom? styleZoom
  }) {
    return FollowPosition(
      bearing: bearing ?? this.bearing,
      styleZoom: styleZoom ?? this.styleZoom
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is FollowPosition &&
    other.runtimeType == runtimeType &&
    other.bearing == bearing &&
    other.styleZoom == styleZoom;

  @override
  int get hashCode {
    return Object.hash(bearing, styleZoom);
  }

}
final class _CFollowPosition extends ffi.Struct {
  external _CFollowBearing bearing;

  external _CFollowStyleZoom styleZoom;

}
// MARK: - FollowPosition <-> _CFollowPosition

extension _CFollowPositionToDart on _CFollowPosition {
  FollowPosition _toDart() {
    return FollowPosition(
      bearing: this.bearing._toDart(),
      styleZoom: this.styleZoom._toDart()
    );
  }
}

extension _DartTo_CFollowPosition on FollowPosition {
  _CFollowPosition _copyFromDartTo_CFollowPosition() {
    final res = _CFollowPositionMakeDefault();
    res.bearing = this.bearing._copyFromDartTo_CFollowBearing();
    res.styleZoom = this.styleZoom._copyFromDartTo_CFollowStyleZoom();
    return res;
  }
}
extension _CFollowPositionRelease on _CFollowPosition {
  void _releaseIntermediate() {
  }
}

// MARK: - FollowTilt

enum FollowTilt {
  off(0),
  on_(1),
  ;

  const FollowTilt(this.rawValue);
  final int rawValue;

  static FollowTilt getByValue(int value) {
    return FollowTilt.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CFollowTilt extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CFollowTiltBasicFunctions on _CFollowTilt {
  void _releaseIntermediate() {
  }
}

extension _CFollowTiltToDart on _CFollowTilt {
  FollowTilt _toDart() {
    return FollowTilt.getByValue(this.rawValue);
  }
}

extension _DartTo_CFollowTilt on FollowTilt {
  _CFollowTilt _copyFromDartTo_CFollowTilt() {
    return _CFollowTiltMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - Attributes

/**
 Интерфейс для управления свойствами объекта карты.

 Свойства есть только у объектов карты, но можно задавать свойства по умолчанию для всей карты,
 для стиля и для источника (подробнее см. ISource).
*/
class Attributes implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Получение списка свойств. */
  List<String> get attributeNames {
    _CArray_CString res = _CAttributes_attributeNames(_CAttributesMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение канала, уведомляющего об изменении свойств. */
  Channel<List<String>> get changed {
    _CChannel_CArray_CString res = _CAttributes_changed(_CAttributesMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CAttributes_releasePtr);

  Attributes._raw(this._self);
  factory Attributes._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Attributes._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Attributes &&
    other.runtimeType == runtimeType &&
    _CAttributes_cg_objectIdentifier(this._self) == _CAttributes_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CAttributes_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: Attributes: Methods

  /**
   Установка свойства.
  
   - Parameter name: Название свойства.
   - Parameter value: Значение.
  */
  void setAttributeValue(
    String name,
    AttributeValue value
  )  {
    var _a1 = name._copyFromDartTo_CString();
    var _a2 = value._copyFromDartTo_CAttributeValue();
    void res = _CAttributes_setAttributeValue_CString_CAttributeValue(_CAttributesMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Установка набора свойств.
   Сначала удаляются свойства attributes_to_remove, затем добавляются свойства values.
   Если свойство с таким названием уже было добавлено, то оно заменяется.
  
   - Parameter values: Набор пар "имя":"значение" для добавляемых свойства.
   - Parameter attributesToRemove: Список имён свойств, которые нужно удалить.
  */
  void setAttributeValues(
    core.Map<String, AttributeValue> values,
    [List<String> attributesToRemove = const []
    ])  {
    var _a1 = values._copyFromDartTo_CDictionary_CString_CAttributeValue();
    var _a2 = attributesToRemove._copyFromDartTo_CArray_CString();
    void res = _CAttributes_setAttributeValues_CDictionary_CString_CAttributeValue_CArray_CString(_CAttributesMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Удаление свойства.
  
   - Parameter name: Имя свойства для удаления.
  */
  void removeAttribute(
    String name
  )  {
    var _a1 = name._copyFromDartTo_CString();
    void res = _CAttributes_removeAttribute_CString(_CAttributesMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Получение свойства.
  
   - Parameter name: Имя свойства для получения.
  */
  AttributeValue getAttributeValue(
    String name
  )  {
    var _a1 = name._copyFromDartTo_CString();
    _CAttributeValue res = _CAttributes_getAttributeValue_CString(_CAttributesMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - Attributes <-> CAttributes

final class _CAttributes extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CAttributesBasicFunctions on _CAttributes {
  void _releaseIntermediate() {
    _CAttributes_release(_impl);
  }

  _CAttributes _retain() {
    return _CAttributes_retain(_impl);
  }
}

extension _CAttributesToDart on _CAttributes {
  Attributes _toDart() {
    return Attributes._create(_retain()._impl);
  }
}


extension _DartToCAttributes on Attributes {
  _CAttributes _copyFromDartTo_CAttributes() {
    return (_CAttributesMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Channel<List<String>> <-> _CChannel_CArray_CString

class _CChannel_CArray_CStringImpl extends Channel<List<String>> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<List<String>>>{};

  final _CChannel_CArray_CString _channel;

  _CChannel_CArray_CStringImpl(this._channel);

  static void valueFunction(_CArray_CString cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<List<String>> listen(void onData(List<String> event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CString, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<List<String>>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CChannel_CArray_CString extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CChannel_CArray_CStringBasicFunctions on _CChannel_CArray_CString {
  void _releaseIntermediate() {
    _CChannel_CArray_CString_release(this);
  }

  _CChannel_CArray_CString _retain() {
    return _CChannel_CArray_CString_retain(this);
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CArray_CString, ffi.Int64)> callback) {
    return _CChannel_CArray_CStringConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CChannel_CArray_CStringToDart on _CChannel_CArray_CString {
  Channel<List<String>> _toDart() {
    return _CChannel_CArray_CStringImpl(this._retain());
  }
}

extension _DartTo_CChannel_CArray_CString on Channel<List<String>> {
  _CChannel_CArray_CString _copyFromDartTo_CChannel_CArray_CString() {
    return _CChannel_CArray_CStringMakeDefault();
  }
}
	
// MARK: - AnimationSettings

/**
 Настройки анимаций объектов карты.
 Применяются для слоев стилей, в которых указан источник модели.
 Например, такими слоями являются слои с типами "3D model" и "Directional model".
 Индекс анимации должен быть обязательно указан для анимированной модели.
*/
class AnimationSettings implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Индекс текущей анимации модели.
   Если null, то используется значение из стилей.
   Если в стилях значение не задано или задано отрицательное, никакая анимация не проигрывается.
  */
  int? get animationIndex {
    _COptional_int32_t res = _CAnimationSettings_animationIndex(_CAnimationSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set animationIndex(int? index) {
    var _a1 = index._copyFromDartTo_COptional_int32_t();
    void res = _CAnimationSettings_setAnimationIndex_COptional_int32_t(_CAnimationSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Название текущей анимации модели.
   Если null, то используется значение из стилей.
   Если в стилях значение не задано, никакая анимация не проигрывается.
  */
  String? get animationName {
    _COptional_CString res = _CAnimationSettings_animationName(_CAnimationSettingsMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set animationName(String? name) {
    var _a1 = name._copyFromDartTo_COptional_CString();
    void res = _CAnimationSettings_setAnimationName_COptional_CString(_CAnimationSettingsMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /**
   Индекс текущей сцены модели.
   Если null, то используется значение из стилей.
   Если в стилях значение не задано или задано отрицательное,
   используется сцена по умолчанию, которая определена в самой модели.
  */
  int? get sceneIndex {
    _COptional_int32_t res = _CAnimationSettings_sceneIndex(_CAnimationSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set sceneIndex(int? index) {
    var _a1 = index._copyFromDartTo_COptional_int32_t();
    void res = _CAnimationSettings_setSceneIndex_COptional_int32_t(_CAnimationSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Название текущей сцены модели.
   Если null, то используется значение из стилей.
   Если в стилях значение не задано, используется сцена по умолчанию, которая определена в самой модели.
  */
  String? get sceneName {
    _COptional_CString res = _CAnimationSettings_sceneName(_CAnimationSettingsMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set sceneName(String? name) {
    var _a1 = name._copyFromDartTo_COptional_CString();
    void res = _CAnimationSettings_setSceneName_COptional_CString(_CAnimationSettingsMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /**
   Количество повторений анимации модели.
   Если null, то используется значение из стилей.
   Если в стилях значение не задано или задано отрицательное, анимация будет проигрываться бесконечно.
  */
  int? get animationRepeatCount {
    _COptional_int32_t res = _CAnimationSettings_animationRepeatCount(_CAnimationSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set animationRepeatCount(int? count) {
    var _a1 = count._copyFromDartTo_COptional_int32_t();
    void res = _CAnimationSettings_setAnimationRepeatCount_COptional_int32_t(_CAnimationSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Скорость проигрывания анимации модели.
   Если null, то используется значение из стилей.
   Значения больше единицы ускоряют проигрывание, меньше замедляют.
   Если в стилях значение не задано, используется скорость по умолчанию.
  */
  double? get animationSpeed {
    _COptional_float res = _CAnimationSettings_animationSpeed(_CAnimationSettingsMakeDefault().._impl=_self);
    return res._toDart();
  }
  set animationSpeed(double? speed) {
    var _a1 = speed._copyFromDartTo_COptional_float();
    void res = _CAnimationSettings_setAnimationSpeed_COptional_float(_CAnimationSettingsMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CAnimationSettings_releasePtr);

  AnimationSettings._raw(this._self);
  factory AnimationSettings._create(ffi.Pointer<ffi.Void> self) {
    final classObject = AnimationSettings._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is AnimationSettings &&
    other.runtimeType == runtimeType &&
    _CAnimationSettings_cg_objectIdentifier(this._self) == _CAnimationSettings_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CAnimationSettings_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - AnimationSettings <-> CAnimationSettings

final class _CAnimationSettings extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CAnimationSettingsBasicFunctions on _CAnimationSettings {
  void _releaseIntermediate() {
    _CAnimationSettings_release(_impl);
  }

  _CAnimationSettings _retain() {
    return _CAnimationSettings_retain(_impl);
  }
}

extension _CAnimationSettingsToDart on _CAnimationSettings {
  AnimationSettings _toDart() {
    return AnimationSettings._create(_retain()._impl);
  }
}


extension _DartToCAnimationSettings on AnimationSettings {
  _CAnimationSettings _copyFromDartTo_CAnimationSettings() {
    return (_CAnimationSettingsMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - int? <-> _COptional_int32_t

final class _COptional_int32_t extends ffi.Struct {
  @ffi.Int32()
  external int value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_int32_tBasicFunctions on _COptional_int32_t {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_int32_tToDart on _COptional_int32_t {
  int? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value;
  }
}

extension _DartTo_COptional_int32_t on int? {
  _COptional_int32_t _copyFromDartTo_COptional_int32_t() {
    final cOptional = _COptional_int32_tMakeDefault();
    if (this != null) {
      cOptional.value = this!;
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - double? <-> _COptional_float

final class _COptional_float extends ffi.Struct {
  @ffi.Float()
  external double value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_floatBasicFunctions on _COptional_float {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_floatToDart on _COptional_float {
  double? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value;
  }
}

extension _DartTo_COptional_float on double? {
  _COptional_float _copyFromDartTo_COptional_float() {
    final cOptional = _COptional_floatMakeDefault();
    if (this != null) {
      cOptional.value = this!;
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - MapObject

/** Объект на карте. */
class MapObject implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Произвольные пользовательские данные, прикрепленные к объекту. */
  Object? get userData {
    _CAny res = _CMapObject_userData(_CMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set userData(Object? userData) {
    var _a1 = userData._copyFromDartTo_CAny();
    void res = _CMapObject_setUserData_CAny(_CMapObjectMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CMapObject_releasePtr);

  MapObject._raw(this._self);
  factory MapObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapObject &&
    other.runtimeType == runtimeType &&
    _CMapObject_cg_objectIdentifier(this._self) == _CMapObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - MapObject <-> CMapObject

final class _CMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapObjectBasicFunctions on _CMapObject {
  void _releaseIntermediate() {
    _CMapObject_release(_impl);
  }

  _CMapObject _retain() {
    return _CMapObject_retain(_impl);
  }
}

extension _CMapObjectToDart on _CMapObject {
  MapObject _toDart() {
    final selector = _CMapObject_cg_getSelector(this);
    switch (selector) {
      case 0:
        final res = MapObject._create(_retain()._impl);
        return res;
      case 1:
        final res = GeometryMapObject._create(_retain()._impl);
        return res;
      case 2:
        final res = ClusterObject._create(_retain()._impl);
        return res;
      case 3:
        final res = DgisMapObject._create(_retain()._impl);
        return res;
      case 4:
        final res = MyLocationMapObject._create(_retain()._impl);
        return res;
      case 5:
        final res = RoadEventMapObject._create(_retain()._impl);
        return res;
      case 6:
        final res = SimpleMapObject._create(_retain()._impl);
        return res;
      case 7:
        final res = SimpleClusterObject._create(_retain()._impl);
        return res;
      default: throw Exception("Unrecognized case index $selector");
    }
  }
}

extension _DartToCMapObject on MapObject {
  _CMapObject _copyFromDartTo_CMapObject() {
    return (_CMapObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - GeometryMapObject

/**
 Геометрический объект карты.

 - Note: методы потокобезопасны
 - Note: объект будет отображаться на карте при выполнении следующих условий:
 - объект видимый;
 - объект добавлен в источник данных;
 - источник данных, содержащий объект, добавлен в карту;
 - в стилях, установленных в карту, есть параметры отображения, применимые к этому объекту.
 Подробнее про отображение на карте - см. ISource.
*/
class GeometryMapObject extends MapObject implements ffi.Finalizable {
  /** Геометрия объекта. */
  StatefulChannel<Geometry> get geometryChannel {
    _CStatefulChannel_CGeometry res = _CGeometryMapObject_geometryChannel(_CGeometryMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Геометрия объекта. */
  Geometry get geometry {
    _CGeometry res = _CGeometryMapObject_geometry(_CGeometryMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set geometry(Geometry geometry) {
    var _a1 = geometry._copyFromDartTo_CGeometry();
    void res = _CGeometryMapObject_setGeometry_CGeometry(_CGeometryMapObjectMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /** Получение свойств объекта карты для чтения и изменения. */
  Attributes get objectAttributes {
    _CAttributes res = _CGeometryMapObject_objectAttributes(_CGeometryMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Текущий флаг видимости объекта. */
  StatefulChannel<bool> get isVisibleChannel {
    _CStatefulChannel_bool res = _CGeometryMapObject_isVisibleChannel(_CGeometryMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Текущий флаг видимости объекта. */
  bool get isVisible {
    bool res = _CGeometryMapObject_isVisible(_CGeometryMapObjectMakeDefault().._impl=_self);
    return res;
  }
  set isVisible(bool visible) {
    void res = _CGeometryMapObject_setVisible_bool(_CGeometryMapObjectMakeDefault().._impl=_self, visible);
    return res;
  }
  /** Текущий флаг перемещаемости объекта. */
  StatefulChannel<bool> get isDraggableChannel {
    _CStatefulChannel_bool res = _CGeometryMapObject_isDraggableChannel(_CGeometryMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Текущий флаг перемещаемости объекта. */
  bool get isDraggable {
    bool res = _CGeometryMapObject_isDraggable(_CGeometryMapObjectMakeDefault().._impl=_self);
    return res;
  }
  set isDraggable(bool draggable) {
    void res = _CGeometryMapObject_setDraggable_bool(_CGeometryMapObjectMakeDefault().._impl=_self, draggable);
    return res;
  }
  /**
   Получение настроек анимации.
   Применяется для объектов с типом "3D model" или "Directional model".
  */
  AnimationSettings get animationSettings {
    _CAnimationSettings res = _CGeometryMapObject_animationSettings(_CGeometryMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Прямоугольник минимального размера, содержащий геометрию. */
  GeoRect get bounds {
    _CGeoRect res = _CGeometryMapObject_bounds(_CGeometryMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CGeometryMapObject_releasePtr);

  GeometryMapObject._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory GeometryMapObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = GeometryMapObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GeometryMapObject &&
    other.runtimeType == runtimeType &&
    _CGeometryMapObject_cg_objectIdentifier(this._self) == _CGeometryMapObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CGeometryMapObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - GeometryMapObject <-> CGeometryMapObject

final class _CGeometryMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CGeometryMapObjectBasicFunctions on _CGeometryMapObject {
  void _releaseIntermediate() {
    _CGeometryMapObject_release(_impl);
  }

  _CGeometryMapObject _retain() {
    return _CGeometryMapObject_retain(_impl);
  }
}

extension _CGeometryMapObjectToDart on _CGeometryMapObject {
  GeometryMapObject _toDart() {
    return GeometryMapObject._create(_retain()._impl);
  }
}


extension _DartToCGeometryMapObject on GeometryMapObject {
  _CGeometryMapObject _copyFromDartTo_CGeometryMapObject() {
    return (_CGeometryMapObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<Geometry> <-> _CStatefulChannel_CGeometry

class _CStatefulChannel_CGeometryImpl extends StatefulChannel<Geometry> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<Geometry>>{};

  final _CStatefulChannel_CGeometry _channel;

  _CStatefulChannel_CGeometryImpl(this._channel);

  @override
  Geometry get value {
    return this._channel._getter();
  }

  static void valueFunction(_CGeometry cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<Geometry> listen(void onData(Geometry event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CGeometry, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<Geometry>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CGeometry extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CGeometryBasicFunctions on _CStatefulChannel_CGeometry {
  void _releaseIntermediate() {
    _CStatefulChannel_CGeometry_release(this);
  }

  _CStatefulChannel_CGeometry _retain() {
    return _CStatefulChannel_CGeometry_retain(this);
  }

  Geometry _getter() {
    final cValue = _CStatefulChannel_CGeometryGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CGeometry, ffi.Int64)> callback) {
    return _CStatefulChannel_CGeometryConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CGeometryToDart on _CStatefulChannel_CGeometry {
  StatefulChannel<Geometry> _toDart() {
    return _CStatefulChannel_CGeometryImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CGeometry on StatefulChannel<Geometry> {
  _CStatefulChannel_CGeometry _copyFromDartTo_CStatefulChannel_CGeometry() {
    return _CStatefulChannel_CGeometryMakeDefault();
  }
}
	
// MARK: - StatefulChannel<bool> <-> _CStatefulChannel_bool

class _CStatefulChannel_boolImpl extends StatefulChannel<bool> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<bool>>{};

  final _CStatefulChannel_bool _channel;

  _CStatefulChannel_boolImpl(this._channel);

  @override
  bool get value {
    return this._channel._getter();
  }

  static void valueFunction(bool cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue);
    }
    
  }

  @override
  StreamSubscription<bool> listen(void onData(bool event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Bool, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<bool>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_bool extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_boolBasicFunctions on _CStatefulChannel_bool {
  void _releaseIntermediate() {
    _CStatefulChannel_bool_release(this);
  }

  _CStatefulChannel_bool _retain() {
    return _CStatefulChannel_bool_retain(this);
  }

  bool _getter() {
    final cValue = _CStatefulChannel_boolGetCurrentValue(this);
    final res = cValue;
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(ffi.Bool, ffi.Int64)> callback) {
    return _CStatefulChannel_boolConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_boolToDart on _CStatefulChannel_bool {
  StatefulChannel<bool> _toDart() {
    return _CStatefulChannel_boolImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_bool on StatefulChannel<bool> {
  _CStatefulChannel_bool _copyFromDartTo_CStatefulChannel_bool() {
    return _CStatefulChannel_boolMakeDefault();
  }
}
	
// MARK: - ClusterObject

/** Кластер объектов. */
class ClusterObject extends MapObject implements ffi.Finalizable {
  /** Получение позиции кластера на карте. */
  GeoPointWithElevation get position {
    _CGeoPointWithElevation res = _CClusterObject_position(_CClusterObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Получение количества маркеров в кластере. */
  int get objectCount {
    int res = _CClusterObject_objectCount(_CClusterObjectMakeDefault().._impl=_self);
    return res;
  }
  /** Получение списка маркеров в кластере. */
  List<GeometryMapObject> get objects {
    _CArray_CGeometryMapObject res = _CClusterObject_objects(_CClusterObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение геометрического объекта кластера. */
  GeometryMapObject? get geometryObject {
    _COptional_CGeometryMapObject res = _CClusterObject_geometryObject(_CClusterObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CClusterObject_releasePtr);

  ClusterObject._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory ClusterObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = ClusterObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ClusterObject &&
    other.runtimeType == runtimeType &&
    _CClusterObject_cg_objectIdentifier(this._self) == _CClusterObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CClusterObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - ClusterObject <-> CClusterObject

final class _CClusterObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CClusterObjectBasicFunctions on _CClusterObject {
  void _releaseIntermediate() {
    _CClusterObject_release(_impl);
  }

  _CClusterObject _retain() {
    return _CClusterObject_retain(_impl);
  }
}

extension _CClusterObjectToDart on _CClusterObject {
  ClusterObject _toDart() {
    return ClusterObject._create(_retain()._impl);
  }
}


extension _DartToCClusterObject on ClusterObject {
  _CClusterObject _copyFromDartTo_CClusterObject() {
    return (_CClusterObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<GeometryMapObject> <-> _CArray_CGeometryMapObject

final class _CArray_CGeometryMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CGeometryMapObjectToDart on _CArray_CGeometryMapObject {
  List<GeometryMapObject> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CGeometryMapObject on List<GeometryMapObject> {
  _CArray_CGeometryMapObject _copyFromDartTo_CArray_CGeometryMapObject() {
    final cArray = _CArray_CGeometryMapObjectmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CGeometryMapObject();
        _CArray_CGeometryMapObjectaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CGeometryMapObjectBasicFunctions on _CArray_CGeometryMapObject {
  void _releaseIntermediate() {
    _CArray_CGeometryMapObject_release(this);
  }

  static final _listToFill = <GeometryMapObject>[];

  static void _iterate(_CGeometryMapObject item) {
    _listToFill.add(item._toDart());
  }

  List<GeometryMapObject> _fillFromC() {
    _forEach_CArray_CGeometryMapObject(this, ffi.Pointer.fromFunction<ffi.Void Function(_CGeometryMapObject)>(_iterate));
    final result = List<GeometryMapObject>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - GeometryMapObject? <-> _COptional_CGeometryMapObject

final class _COptional_CGeometryMapObject extends ffi.Struct {
  
  external _CGeometryMapObject value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CGeometryMapObjectBasicFunctions on _COptional_CGeometryMapObject {
  void _releaseIntermediate() {
    _COptional_CGeometryMapObject_release(this);
  }
}

extension _COptional_CGeometryMapObjectToDart on _COptional_CGeometryMapObject {
  GeometryMapObject? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CGeometryMapObject on GeometryMapObject? {
  _COptional_CGeometryMapObject _copyFromDartTo_COptional_CGeometryMapObject() {
    final cOptional = _COptional_CGeometryMapObjectMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CGeometryMapObject();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - DgisMapObject

/**
 Объект карты 2GIS.

 - Note: информацию об объекте можно получить через справочник (directory)
*/
class DgisMapObject extends MapObject implements ffi.Finalizable {
  /** Стабильный числовой идентификатор объекта. */
  DgisObjectId get id {
    _CDgisObjectId res = _CDgisMapObject_id(_CDgisMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CDgisMapObject_releasePtr);

  DgisMapObject._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory DgisMapObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = DgisMapObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DgisMapObject &&
    other.runtimeType == runtimeType &&
    _CDgisMapObject_cg_objectIdentifier(this._self) == _CDgisMapObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CDgisMapObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - DgisMapObject <-> CDgisMapObject

final class _CDgisMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDgisMapObjectBasicFunctions on _CDgisMapObject {
  void _releaseIntermediate() {
    _CDgisMapObject_release(_impl);
  }

  _CDgisMapObject _retain() {
    return _CDgisMapObject_retain(_impl);
  }
}

extension _CDgisMapObjectToDart on _CDgisMapObject {
  DgisMapObject _toDart() {
    return DgisMapObject._create(_retain()._impl);
  }
}


extension _DartToCDgisMapObject on DgisMapObject {
  _CDgisMapObject _copyFromDartTo_CDgisMapObject() {
    return (_CDgisMapObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Source

/**
 Источник данных на карте.

 Это может быть источник пробочных данных, маршрутов, маркеров, произвольных геометрических или других объектов карты.
 У любого объекта карты могут быть свои свойства.
 Свойства объекта влияют на то, какие к нему применяются правила и параметры отображения, описаные в стилях карты.
 Стиль - набор параметров и правил отображения объектов карты, получаемый через редактор стилей и использующийся для
 отрисовки карты.

 Свойства объекта могут быть заданы:
 - непосредственно для объекта;
 - источнику данных (все объекты, добавленные в источник, получают эти свойства);
 - карте (все объекты, добавленные на карту, получают эти свойства);
 - стилю (все объекты, к которым применён стиль, получают эти свойства).
 Список приведён в порядке понижения приоритета применения свойств.
 Даже если на карту не добавлен ни один источник данных, свойства стиля и карты всё равно повлияют на карту,
 т.к. есть специальные отображаемые объекты, например - фон.
*/
class Source implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CSource_releasePtr);

  Source._raw(this._self);
  factory Source._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Source._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Source &&
    other.runtimeType == runtimeType &&
    _CSource_cg_objectIdentifier(this._self) == _CSource_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSource_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Source <-> CSource

final class _CSource extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSourceBasicFunctions on _CSource {
  void _releaseIntermediate() {
    _CSource_release(_impl);
  }

  _CSource _retain() {
    return _CSource_retain(_impl);
  }
}

extension _CSourceToDart on _CSource {
  Source _toDart() {
    final selector = _CSource_cg_getSelector(this);
    switch (selector) {
      case 0:
        final res = Source._create(_retain()._impl);
        return res;
      case 1:
        final res = DgisSource._create(_retain()._impl);
        return res;
      case 2:
        final res = GeometryMapObjectSource._create(_retain()._impl);
        return res;
      case 3:
        final res = MyLocationMapObjectSource._create(_retain()._impl);
        return res;
      case 4:
        final res = TrafficSource._create(_retain()._impl);
        return res;
      case 5:
        final res = RoadEventSource._create(_retain()._impl);
        return res;
      case 6:
        final res = RasterTileSource._create(_retain()._impl);
        return res;
      default: throw Exception("Unrecognized case index $selector");
    }
  }
}

extension _DartToCSource on Source {
  _CSource _copyFromDartTo_CSource() {
    return (_CSourceMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - DgisSource

/** Основной интерфейс источников данных 2ГИС. */
class DgisSource extends Source implements ffi.Finalizable {
  /** Получение списка идентификаторов выделенных объектов. */
  StatefulChannel<List<DgisObjectId>> get highlightedObjectsChannel {
    _CStatefulChannel_CArray_CDgisObjectId res = _CDgisSource_highlightedObjectsChannel(_CDgisSourceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение списка идентификаторов выделенных объектов. */
  List<DgisObjectId> get highlightedObjects {
    _CArray_CDgisObjectId res = _CDgisSource_highlightedObjects(_CDgisSourceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CDgisSource_releasePtr);

  DgisSource._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory DgisSource._create(ffi.Pointer<ffi.Void> self) {
    final classObject = DgisSource._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DgisSource &&
    other.runtimeType == runtimeType &&
    _CDgisSource_cg_objectIdentifier(this._self) == _CDgisSource_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CDgisSource_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CDgisSource: Static Methods

  /** Создание источника, получающего данные с серверов 2ГИС. */
  static Source createDgisSource(
    Context context
  )  {
    var _a0 = context._copyFromDartTo_CContext();
    _CSource res = _CDgisSource_S_createDgisSource_CContext(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  // MARK: DgisSource: Methods

  /**
   Установка или снятие выделения объектов.
  
   - Note: добавляет объекту атрибут "selected", который можно использовать в стилях.
   - Parameter directoryObjectIds: Идентификаторы изменяемых объектов.
   - Parameter highlighted: Установка или снятие выделения.
  */
  void setHighlighted(
    List<DgisObjectId> directoryObjectIds,
    bool highlighted
  )  {
    var _a1 = directoryObjectIds._copyFromDartTo_CArray_CDgisObjectId();
    void res = _CDgisSource_setHighlighted_CArray_CDgisObjectId_bool(_CDgisSourceMakeDefault().._impl=_self, _a1, highlighted);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - DgisSource <-> CDgisSource

final class _CDgisSource extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDgisSourceBasicFunctions on _CDgisSource {
  void _releaseIntermediate() {
    _CDgisSource_release(_impl);
  }

  _CDgisSource _retain() {
    return _CDgisSource_retain(_impl);
  }
}

extension _CDgisSourceToDart on _CDgisSource {
  DgisSource _toDart() {
    return DgisSource._create(_retain()._impl);
  }
}


extension _DartToCDgisSource on DgisSource {
  _CDgisSource _copyFromDartTo_CDgisSource() {
    return (_CDgisSourceMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<List<DgisObjectId>> <-> _CStatefulChannel_CArray_CDgisObjectId

class _CStatefulChannel_CArray_CDgisObjectIdImpl extends StatefulChannel<List<DgisObjectId>> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<List<DgisObjectId>>>{};

  final _CStatefulChannel_CArray_CDgisObjectId _channel;

  _CStatefulChannel_CArray_CDgisObjectIdImpl(this._channel);

  @override
  List<DgisObjectId> get value {
    return this._channel._getter();
  }

  static void valueFunction(_CArray_CDgisObjectId cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<List<DgisObjectId>> listen(void onData(List<DgisObjectId> event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CDgisObjectId, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<List<DgisObjectId>>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CArray_CDgisObjectId extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CArray_CDgisObjectIdBasicFunctions on _CStatefulChannel_CArray_CDgisObjectId {
  void _releaseIntermediate() {
    _CStatefulChannel_CArray_CDgisObjectId_release(this);
  }

  _CStatefulChannel_CArray_CDgisObjectId _retain() {
    return _CStatefulChannel_CArray_CDgisObjectId_retain(this);
  }

  List<DgisObjectId> _getter() {
    final cValue = _CStatefulChannel_CArray_CDgisObjectIdGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CArray_CDgisObjectId, ffi.Int64)> callback) {
    return _CStatefulChannel_CArray_CDgisObjectIdConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CArray_CDgisObjectIdToDart on _CStatefulChannel_CArray_CDgisObjectId {
  StatefulChannel<List<DgisObjectId>> _toDart() {
    return _CStatefulChannel_CArray_CDgisObjectIdImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CArray_CDgisObjectId on StatefulChannel<List<DgisObjectId>> {
  _CStatefulChannel_CArray_CDgisObjectId _copyFromDartTo_CStatefulChannel_CArray_CDgisObjectId() {
    return _CStatefulChannel_CArray_CDgisObjectIdMakeDefault();
  }
}
	
// MARK: - FollowController

/**
 Класс, позволяющий управлять положением камеры.
 Реализации всех его методов должны быть потокобезопасны. У большинства
 методов есть тривиальные реализации по умолчанию (таким образом
 FollowController, отвечающий за масштаб, не обязан переопределять методы
 coordinates() и т.п.).
 Один контроллер может быть единомоментно добавлен только в одну карту.
*/
class FollowController implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CFollowController_releasePtr);

  FollowController._raw(this._self);
  factory FollowController._create(ffi.Pointer<ffi.Void> self) {
    final classObject = FollowController._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is FollowController &&
    other.runtimeType == runtimeType &&
    _CFollowController_cg_objectIdentifier(this._self) == _CFollowController_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CFollowController_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - FollowController <-> CFollowController

final class _CFollowController extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CFollowControllerBasicFunctions on _CFollowController {
  void _releaseIntermediate() {
    _CFollowController_release(_impl);
  }

  _CFollowController _retain() {
    return _CFollowController_retain(_impl);
  }
}

extension _CFollowControllerToDart on _CFollowController {
  FollowController _toDart() {
    final selector = _CFollowController_cg_getSelector(this);
    switch (selector) {
      case 0:
        final res = FollowController._create(_retain()._impl);
        return res;
      case 1:
        final res = BearingFollowController._create(_retain()._impl);
        return res;
      case 2:
        final res = CoordinatesFollowController._create(_retain()._impl);
        return res;
      case 3:
        final res = StyleZoomFollowController._create(_retain()._impl);
        return res;
      case 4:
        final res = TiltFollowController._create(_retain()._impl);
        return res;
      default: throw Exception("Unrecognized case index $selector");
    }
  }
}

extension _DartToCFollowController on FollowController {
  _CFollowController _copyFromDartTo_CFollowController() {
    return (_CFollowControllerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - GeometryMapObjectSource

/** Источник геометрических объектов карты. */
class GeometryMapObjectSource extends Source implements ffi.Finalizable {
  /** Получить все объекты, добавленные в источник. */
  List<GeometryMapObject> get objects {
    _CArray_CGeometryMapObject res = _CGeometryMapObjectSource_objects(_CGeometryMapObjectSourceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение значений свойств по умолчанию для всех объектов, добавленных в источник (см. IAttributes). */
  Attributes get sourceAttributes {
    _CAttributes res = _CGeometryMapObjectSource_sourceAttributes(_CGeometryMapObjectSourceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CGeometryMapObjectSource_releasePtr);

  GeometryMapObjectSource._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory GeometryMapObjectSource._create(ffi.Pointer<ffi.Void> self) {
    final classObject = GeometryMapObjectSource._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GeometryMapObjectSource &&
    other.runtimeType == runtimeType &&
    _CGeometryMapObjectSource_cg_objectIdentifier(this._self) == _CGeometryMapObjectSource_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CGeometryMapObjectSource_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: GeometryMapObjectSource: Methods

  /**
   Получить список объектов, участвующих в кластеризации при переданной позиции камеры.
   В списке будут присутствовать как кластеры, так и геометрические объекты.
  */
  List<MapObject> clusteringObjects(
    CameraPosition position
  )  {
    var _a1 = position._copyFromDartTo_CCameraPosition();
    _CArray_CMapObject res = _CGeometryMapObjectSource_clusteringObjects_CCameraPosition(_CGeometryMapObjectSourceMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Добавление объекта в источник.
  
   - Note: Добавление объектов по группой эффективнее, чем добавление по одному, особенно в случае,
   когда источник уже добавлен в одну или несколько карт.
   - Note: Добавление асинхронное, потокобезопасное, метод можно использовать из любого потока.
   - Note: Для источника с кластеризацией добавление пока не реализовано, будет выброшено исключение.
  */
  void addObject(
    GeometryMapObject item
  )  {
    var _a1 = item._copyFromDartTo_CGeometryMapObject();
    void res = _CGeometryMapObjectSource_addObject_CGeometryMapObject(_CGeometryMapObjectSourceMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Добавление нескольких объектов в источник.
  
   - Note: Добавление объектов по группой эффективнее, чем добавление по одному, особенно в случае,
   когда источник уже добавлен в одну или несколько карт.
   - Note: Добавление асинхронное, потокобезопасное, метод можно использовать из любого потока.
   - Note: Для источника с кластеризацией добавление пока не реализовано, будет выброшено исключение.
  */
  void addObjects(
    List<GeometryMapObject> objects
  )  {
    var _a1 = objects._copyFromDartTo_CArray_CGeometryMapObject();
    void res = _CGeometryMapObjectSource_addObjects_CArray_CGeometryMapObject(_CGeometryMapObjectSourceMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Удаление объекта из источника.
  
   - Note: Удаление асинхронное, потокобезопасное, метод можно использовать из любого потока.
  */
  void removeObject(
    GeometryMapObject item
  )  {
    var _a1 = item._copyFromDartTo_CGeometryMapObject();
    void res = _CGeometryMapObjectSource_removeObject_CGeometryMapObject(_CGeometryMapObjectSourceMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Удаление объектов из источника. */
  void removeObjects(
    List<GeometryMapObject> objects
  )  {
    var _a1 = objects._copyFromDartTo_CArray_CGeometryMapObject();
    void res = _CGeometryMapObjectSource_removeObjects_CArray_CGeometryMapObject(_CGeometryMapObjectSourceMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Удаление и добавление объектов в источник. */
  void removeAndAddObjects(
    List<GeometryMapObject> objectsToRemove,
    List<GeometryMapObject> objectsToAdd
  )  {
    var _a1 = objectsToRemove._copyFromDartTo_CArray_CGeometryMapObject();
    var _a2 = objectsToAdd._copyFromDartTo_CArray_CGeometryMapObject();
    void res = _CGeometryMapObjectSource_removeAndAddObjects_CArray_CGeometryMapObject_CArray_CGeometryMapObject(_CGeometryMapObjectSourceMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    return res;
  }

  /** Удаление всех объектов из источника. */
  void clear()  {
    void res = _CGeometryMapObjectSource_clear(_CGeometryMapObjectSourceMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - GeometryMapObjectSource <-> CGeometryMapObjectSource

final class _CGeometryMapObjectSource extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CGeometryMapObjectSourceBasicFunctions on _CGeometryMapObjectSource {
  void _releaseIntermediate() {
    _CGeometryMapObjectSource_release(_impl);
  }

  _CGeometryMapObjectSource _retain() {
    return _CGeometryMapObjectSource_retain(_impl);
  }
}

extension _CGeometryMapObjectSourceToDart on _CGeometryMapObjectSource {
  GeometryMapObjectSource _toDart() {
    return GeometryMapObjectSource._create(_retain()._impl);
  }
}


extension _DartToCGeometryMapObjectSource on GeometryMapObjectSource {
  _CGeometryMapObjectSource _copyFromDartTo_CGeometryMapObjectSource() {
    return (_CGeometryMapObjectSourceMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<MapObject> <-> _CArray_CMapObject

final class _CArray_CMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CMapObjectToDart on _CArray_CMapObject {
  List<MapObject> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CMapObject on List<MapObject> {
  _CArray_CMapObject _copyFromDartTo_CArray_CMapObject() {
    final cArray = _CArray_CMapObjectmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CMapObject();
        _CArray_CMapObjectaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CMapObjectBasicFunctions on _CArray_CMapObject {
  void _releaseIntermediate() {
    _CArray_CMapObject_release(this);
  }

  static final _listToFill = <MapObject>[];

  static void _iterate(_CMapObject item) {
    _listToFill.add(item._toDart());
  }

  List<MapObject> _fillFromC() {
    _forEach_CArray_CMapObject(this, ffi.Pointer.fromFunction<ffi.Void Function(_CMapObject)>(_iterate));
    final result = List<MapObject>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - Image

/** Изображение. */
class Image implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CImage_releasePtr);

  Image._raw(this._self);
  factory Image._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Image._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Image &&
    other.runtimeType == runtimeType &&
    _CImage_cg_objectIdentifier(this._self) == _CImage_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CImage_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Image <-> CImage

final class _CImage extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CImageBasicFunctions on _CImage {
  void _releaseIntermediate() {
    _CImage_release(_impl);
  }

  _CImage _retain() {
    return _CImage_retain(_impl);
  }
}

extension _CImageToDart on _CImage {
  Image _toDart() {
    return Image._create(_retain()._impl);
  }
}


extension _DartToCImage on Image {
  _CImage _copyFromDartTo_CImage() {
    return (_CImageMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ImageFormat

enum ImageFormat {
  /** Изображение PNG формата. */
  png(0),
  /** Изображение SVG формата. */
  svg(1),
  /** Битмап. */
  rgba8888(2),
  /** JSON файл с Lottie анимацией. */
  lottieJson(3),
  ;

  const ImageFormat(this.rawValue);
  final int rawValue;

  static ImageFormat getByValue(int value) {
    return ImageFormat.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CImageFormat extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CImageFormatBasicFunctions on _CImageFormat {
  void _releaseIntermediate() {
  }
}

extension _CImageFormatToDart on _CImageFormat {
  ImageFormat _toDart() {
    return ImageFormat.getByValue(this.rawValue);
  }
}

extension _DartTo_CImageFormat on ImageFormat {
  _CImageFormat _copyFromDartTo_CImageFormat() {
    return _CImageFormatMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ImageData

/** Данные изображения: размер, формат и бинарные данные. */
class ImageData {
  final ScreenSize size;
  final ImageFormat format;
  final ByteData data;

  const ImageData({
    required this.size,
    required this.format,
    required this.data
  });

  ImageData copyWith({
    ScreenSize? size,
    ImageFormat? format,
    ByteData? data
  }) {
    return ImageData(
      size: size ?? this.size,
      format: format ?? this.format,
      data: data ?? this.data
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ImageData &&
    other.runtimeType == runtimeType &&
    other.size == size &&
    other.format == format &&
    other.data == data;

  @override
  int get hashCode {
    return Object.hash(size, format, data);
  }

}
final class _CImageData extends ffi.Struct {
  external _CScreenSize size;

  external _CImageFormat format;

  external _CData data;

}
// MARK: - ImageData <-> _CImageData

extension _CImageDataToDart on _CImageData {
  ImageData _toDart() {
    return ImageData(
      size: this.size._toDart(),
      format: this.format._toDart(),
      data: this.data._toDart()
    );
  }
}

extension _DartTo_CImageData on ImageData {
  _CImageData _copyFromDartTo_CImageData() {
    final res = _CImageDataMakeDefault();
    res.size = this.size._copyFromDartTo_CScreenSize();
    res.format = this.format._copyFromDartTo_CImageFormat();
    res.data = this.data._copyFromDartTo_CData();
    return res;
  }
}
extension _CImageDataRelease on _CImageData {
  void _releaseIntermediate() {
    data._releaseIntermediate();
  }
}

// MARK: - _ImageLoaderCpp

class _ImageLoaderCpp extends ImageLoader implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CImageLoaderCpp_releasePtr);

  _ImageLoaderCpp._raw(this._self);
  factory _ImageLoaderCpp._create(ffi.Pointer<ffi.Void> self) {
    final classObject = _ImageLoaderCpp._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is _ImageLoaderCpp &&
    other.runtimeType == runtimeType &&
    _CImageLoaderCpp_cg_objectIdentifier(this._self) == _CImageLoaderCpp_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CImageLoaderCpp_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: _ImageLoaderCpp: Methods

  ImageData load()  {
    _CImageData res = _CImageLoaderCpp_load(_CImageLoaderCppMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - _ImageLoaderCpp <-> CImageLoaderCpp

final class _CImageLoaderCpp extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CImageLoaderCppBasicFunctions on _CImageLoaderCpp {
  void _releaseIntermediate() {
    _CImageLoaderCpp_release(_impl);
  }

  _CImageLoaderCpp _retain() {
    return _CImageLoaderCpp_retain(_impl);
  }
}

extension _CImageLoaderCppToDart on _CImageLoaderCpp {
  _ImageLoaderCpp _toDart() {
    return _ImageLoaderCpp._create(_retain()._impl);
  }
}


extension _DartToCImageLoaderCpp on _ImageLoaderCpp {
  _CImageLoaderCpp _copyFromDartTo_CImageLoaderCpp() {
    return (_CImageLoaderCppMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ImageLoader

@internal
abstract class ImageLoader {
  ImageData load();
}

class _ImageLoader {
  final ImageLoader object;
  int refCounter = 1;

  _ImageLoader(this.object);
}

final class _CImageLoader extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.Void> _cppValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CImageData)>>)>> _load;
}

extension _CImageLoaderBasicFunctions on _CImageLoader {
  void _releaseIntermediate() {
    _CImageLoader_release(this);
  }
}

int _CImageLoaderInstanceCounter = 1;
final _CImageLoaderInstanceMap = <int, _ImageLoader>{};

extension _CImageLoaderToDart on _CImageLoader {
  ImageLoader _toDart() {
    late ImageLoader? result;
    final platformValue = this._value.cast<ffi.Int64>();
    if (platformValue.address != 0) {
      result = _CImageLoaderInstanceMap[platformValue.address]?.object;
    } else if (this._cppValue.address != 0) {
      final cppValue = _CImageLoaderCppMakeDefault().._impl = this._cppValue;
      result = cppValue._toDart();
    }
    if (result == null) {
      throw Exception("Invalid intermediate object of type _CImageLoader");
    }
    return result;
  }
}

extension _DartTo_CImageLoader on ImageLoader {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    _CImageLoaderInstanceMap[platformValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    final platformObject = _CImageLoaderInstanceMap[platformValue.address];
    if (platformObject == null) {
      return;
    }
    platformObject.refCounter -= 1;
    if (platformObject.refCounter > 0) {
      return;
    }
    _CImageLoaderInstanceMap.remove(platformValue.address);
  }

  _CImageLoader _copyFromDartTo_CImageLoader() {
    var res = _CImageLoaderMakeDefault();
    if (this is _ImageLoaderCpp) {
      final cppValue = this as _ImageLoaderCpp;
      res._cppValue = cppValue._copyFromDartTo_CImageLoaderCpp()._impl;
      return res;
    }
    final instanceId = _CImageLoaderInstanceCounter;
    _CImageLoaderInstanceCounter += 1;
    _CImageLoaderInstanceMap[instanceId] = _ImageLoader(this);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;

    final loadFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CImageData)>>)>.listener(loadFunction);
    res._load = loadFunctionCallable.nativeFunction;
    return res;
  }

  static void loadFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CImageData)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CImageLoader");
    }
    final platformObject = _CImageLoaderInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CImageLoader");
    }

    final res = platformObject.object.load();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _CImageData)>();
    callbackFunction(context, res._copyFromDartTo_CImageData());
  }


}

// MARK: - BearingFollowController

/** Контроллер слежения за направлением карты. */
class BearingFollowController extends FollowController implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CBearingFollowController_releasePtr);

  BearingFollowController._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory BearingFollowController._create(ffi.Pointer<ffi.Void> self) {
    final classObject = BearingFollowController._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Создание контроллера слежения за направлением карты.
  
   - Parameter bearingSource: источник информации о направлении.
   - Parameter animationDuration: неотрицательная длительность изменения реального направления.
   - Parameter valueThreshold: неотрицательное пороговое значение учитываемого изменения реального направления.
  */
  factory BearingFollowController(
    BearingSource bearingSource,
    [Duration animationDuration = const Duration(milliseconds: 1000),
    Bearing valueThreshold = const Bearing(1)
    ]) {
    var _a0 = bearingSource._copyFromDartTo_CBearingSource();
    var _a1 = animationDuration._copyFromDartTo_CTimeInterval();
    var _a2 = valueThreshold._copyFromDartTo_CBearing();
    _CBearingFollowController res = _CBearingFollowController_C_createWith_CBearingSource_CTimeInterval_CBearing(_a0, _a1, _a2);
    return BearingFollowController._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BearingFollowController &&
    other.runtimeType == runtimeType &&
    _CBearingFollowController_cg_objectIdentifier(this._self) == _CBearingFollowController_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CBearingFollowController_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - BearingFollowController <-> CBearingFollowController

final class _CBearingFollowController extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CBearingFollowControllerBasicFunctions on _CBearingFollowController {
  void _releaseIntermediate() {
    _CBearingFollowController_release(_impl);
  }

  _CBearingFollowController _retain() {
    return _CBearingFollowController_retain(_impl);
  }
}

extension _CBearingFollowControllerToDart on _CBearingFollowController {
  BearingFollowController _toDart() {
    return BearingFollowController._create(_retain()._impl);
  }
}


extension _DartToCBearingFollowController on BearingFollowController {
  _CBearingFollowController _copyFromDartTo_CBearingFollowController() {
    return (_CBearingFollowControllerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CoordinatesFollowController

/** Контроллер слежения за координатами позиции карты. */
class CoordinatesFollowController extends FollowController implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CCoordinatesFollowController_releasePtr);

  CoordinatesFollowController._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory CoordinatesFollowController._create(ffi.Pointer<ffi.Void> self) {
    final classObject = CoordinatesFollowController._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Создание контроллера слежения за координатами позиции карты.
  
   - Parameter animationDuration: длительность изменения реальной позиции.
   - Parameter valueThreshold: неотрицательное пороговое значение учитываемого изменения реальной позиции.
  */
  factory CoordinatesFollowController(
    [Duration animationDuration = const Duration(milliseconds: 1000),
    Meter valueThreshold = const Meter(0.10000000149011612)
    ]) {
    var _a0 = animationDuration._copyFromDartTo_CTimeInterval();
    var _a1 = valueThreshold._copyFromDartTo_CMeter();
    _CCoordinatesFollowController res = _CCoordinatesFollowController_C_createWith_CTimeInterval_CMeter(_a0, _a1);
    return CoordinatesFollowController._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CoordinatesFollowController &&
    other.runtimeType == runtimeType &&
    _CCoordinatesFollowController_cg_objectIdentifier(this._self) == _CCoordinatesFollowController_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCoordinatesFollowController_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - CoordinatesFollowController <-> CCoordinatesFollowController

final class _CCoordinatesFollowController extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCoordinatesFollowControllerBasicFunctions on _CCoordinatesFollowController {
  void _releaseIntermediate() {
    _CCoordinatesFollowController_release(_impl);
  }

  _CCoordinatesFollowController _retain() {
    return _CCoordinatesFollowController_retain(_impl);
  }
}

extension _CCoordinatesFollowControllerToDart on _CCoordinatesFollowController {
  CoordinatesFollowController _toDart() {
    return CoordinatesFollowController._create(_retain()._impl);
  }
}


extension _DartToCCoordinatesFollowController on CoordinatesFollowController {
  _CCoordinatesFollowController _copyFromDartTo_CCoordinatesFollowController() {
    return (_CCoordinatesFollowControllerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - BearingSource? <-> _COptional_CBearingSource

final class _COptional_CBearingSource extends ffi.Struct {
  
  external _CBearingSource value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CBearingSourceBasicFunctions on _COptional_CBearingSource {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CBearingSourceToDart on _COptional_CBearingSource {
  BearingSource? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CBearingSource on BearingSource? {
  _COptional_CBearingSource _copyFromDartTo_COptional_CBearingSource() {
    final cOptional = _COptional_CBearingSourceMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CBearingSource();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - MyLocationControllerSettings

/** Настройки контроллера перемещения маркера геопозиции. */
class MyLocationControllerSettings {
  /** Источник направления. Если отсутствует, будет отображаться маркер без направления. */
  final BearingSource? bearingSource;
  /** Неотрицательная длительность изменения реального направления. */
  final Duration animationDuration;
  /** Неотрицательное пороговое значение учитываемого изменения реальной позиции и её точности. */
  final Meter coordinatesThreshold;
  /** Неотрицательное пороговое значение учитываемого изменения реального направления. */
  final Bearing bearingThreshold;

  const MyLocationControllerSettings({
    this.bearingSource = BearingSource.auto,
    this.animationDuration = const Duration(milliseconds: 1000),
    this.coordinatesThreshold = const Meter(0.10000000149011612),
    this.bearingThreshold = const Bearing(1)
  });

  MyLocationControllerSettings copyWith({
    Optional<BearingSource?>? bearingSource,
    Duration? animationDuration,
    Meter? coordinatesThreshold,
    Bearing? bearingThreshold
  }) {
    return MyLocationControllerSettings(
      bearingSource: bearingSource != null ? bearingSource.value : this.bearingSource,
      animationDuration: animationDuration ?? this.animationDuration,
      coordinatesThreshold: coordinatesThreshold ?? this.coordinatesThreshold,
      bearingThreshold: bearingThreshold ?? this.bearingThreshold
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MyLocationControllerSettings &&
    other.runtimeType == runtimeType &&
    other.bearingSource == bearingSource &&
    other.animationDuration == animationDuration &&
    other.coordinatesThreshold == coordinatesThreshold &&
    other.bearingThreshold == bearingThreshold;

  @override
  int get hashCode {
    return Object.hash(bearingSource, animationDuration, coordinatesThreshold, bearingThreshold);
  }

}
final class _CMyLocationControllerSettings extends ffi.Struct {
  external _COptional_CBearingSource bearingSource;

  external _CTimeInterval animationDuration;

  external _CMeter coordinatesThreshold;

  external _CBearing bearingThreshold;

}
// MARK: - MyLocationControllerSettings <-> _CMyLocationControllerSettings

extension _CMyLocationControllerSettingsToDart on _CMyLocationControllerSettings {
  MyLocationControllerSettings _toDart() {
    return MyLocationControllerSettings(
      bearingSource: this.bearingSource._toDart(),
      animationDuration: this.animationDuration._toDart(),
      coordinatesThreshold: this.coordinatesThreshold._toDart(),
      bearingThreshold: this.bearingThreshold._toDart()
    );
  }
}

extension _DartTo_CMyLocationControllerSettings on MyLocationControllerSettings {
  _CMyLocationControllerSettings _copyFromDartTo_CMyLocationControllerSettings() {
    final res = _CMyLocationControllerSettingsMakeDefault();
    res.bearingSource = this.bearingSource._copyFromDartTo_COptional_CBearingSource();
    res.animationDuration = this.animationDuration._copyFromDartTo_CTimeInterval();
    res.coordinatesThreshold = this.coordinatesThreshold._copyFromDartTo_CMeter();
    res.bearingThreshold = this.bearingThreshold._copyFromDartTo_CBearing();
    return res;
  }
}
extension _CMyLocationControllerSettingsRelease on _CMyLocationControllerSettings {
  void _releaseIntermediate() {
  }
}

// MARK: - MyLocationMapObjectMarkerType

/** Тип маркера геопозиции. */
enum MyLocationMapObjectMarkerType {
  /**
   Использовать стандартные модели из стилей. Есть возможность менять модель через редактор стилей.
   Соответствующие слои: s_dvg_vehicle_gps_marker, s_dvg_vehicle_gps_marker_degraded,
   s_dvg_foot_gps_model, s_dvg_foot_gps_model_degraded, s_dvg_foot_gps_direction_model
  */
  model(0),
  /**
   Использовать SVG иконки. Есть возможность менять иконку через редактор стилей. Соответствующие слои:
   s_dvg_foot_gps_marker_with_direction, s_dvg_foot_gps_marker2, s_dvg_foot_gps_marker_degraded2
  */
  svgIcon(1),
  ;

  const MyLocationMapObjectMarkerType(this.rawValue);
  final int rawValue;

  static MyLocationMapObjectMarkerType getByValue(int value) {
    return MyLocationMapObjectMarkerType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CMyLocationMapObjectMarkerType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CMyLocationMapObjectMarkerTypeBasicFunctions on _CMyLocationMapObjectMarkerType {
  void _releaseIntermediate() {
  }
}

extension _CMyLocationMapObjectMarkerTypeToDart on _CMyLocationMapObjectMarkerType {
  MyLocationMapObjectMarkerType _toDart() {
    return MyLocationMapObjectMarkerType.getByValue(this.rawValue);
  }
}

extension _DartTo_CMyLocationMapObjectMarkerType on MyLocationMapObjectMarkerType {
  _CMyLocationMapObjectMarkerType _copyFromDartTo_CMyLocationMapObjectMarkerType() {
    return _CMyLocationMapObjectMarkerTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ModelData

/** Данные модели. */
class ModelData implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CModelData_releasePtr);

  ModelData._raw(this._self);
  factory ModelData._create(ffi.Pointer<ffi.Void> self) {
    final classObject = ModelData._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ModelData &&
    other.runtimeType == runtimeType &&
    _CModelData_cg_objectIdentifier(this._self) == _CModelData_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CModelData_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - ModelData <-> CModelData

final class _CModelData extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CModelDataBasicFunctions on _CModelData {
  void _releaseIntermediate() {
    _CModelData_release(_impl);
  }

  _CModelData _retain() {
    return _CModelData_retain(_impl);
  }
}

extension _CModelDataToDart on _CModelData {
  ModelData _toDart() {
    return ModelData._create(_retain()._impl);
  }
}


extension _DartToCModelData on ModelData {
  _CModelData _copyFromDartTo_CModelData() {
    return (_CModelDataMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MyLocationMapObject

/** Маркер геопозиции. */
class MyLocationMapObject extends MapObject implements ffi.Finalizable {
  /** Получение настроек анимации для чтения и изменения. */
  AnimationSettings get animationSettings {
    _CAnimationSettings res = _CMyLocationMapObject_animationSettings(_CMyLocationMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение свойств объекта карты для чтения и изменения. */
  Attributes get objectAttributes {
    _CAttributes res = _CMyLocationMapObject_objectAttributes(_CMyLocationMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CMyLocationMapObject_releasePtr);

  MyLocationMapObject._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory MyLocationMapObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MyLocationMapObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MyLocationMapObject &&
    other.runtimeType == runtimeType &&
    _CMyLocationMapObject_cg_objectIdentifier(this._self) == _CMyLocationMapObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMyLocationMapObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: MyLocationMapObject: Methods

  /** Установить данные модели. */
  void setModelData(
    ModelData? data
  )  {
    var _a1 = data._copyFromDartTo_COptional_CModelData();
    void res = _CMyLocationMapObject_setModelData_COptional_CModelData(_CMyLocationMapObjectMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - MyLocationMapObject <-> CMyLocationMapObject

final class _CMyLocationMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMyLocationMapObjectBasicFunctions on _CMyLocationMapObject {
  void _releaseIntermediate() {
    _CMyLocationMapObject_release(_impl);
  }

  _CMyLocationMapObject _retain() {
    return _CMyLocationMapObject_retain(_impl);
  }
}

extension _CMyLocationMapObjectToDart on _CMyLocationMapObject {
  MyLocationMapObject _toDart() {
    return MyLocationMapObject._create(_retain()._impl);
  }
}


extension _DartToCMyLocationMapObject on MyLocationMapObject {
  _CMyLocationMapObject _copyFromDartTo_CMyLocationMapObject() {
    return (_CMyLocationMapObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ModelData? <-> _COptional_CModelData

final class _COptional_CModelData extends ffi.Struct {
  
  external _CModelData value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CModelDataBasicFunctions on _COptional_CModelData {
  void _releaseIntermediate() {
    _COptional_CModelData_release(this);
  }
}

extension _COptional_CModelDataToDart on _COptional_CModelData {
  ModelData? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CModelData on ModelData? {
  _COptional_CModelData _copyFromDartTo_COptional_CModelData() {
    final cOptional = _COptional_CModelDataMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CModelData();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - MyLocationMapObjectSource

/** Источник, содержащий маркер геопозиции. */
class MyLocationMapObjectSource extends Source implements ffi.Finalizable {
  /** Получить маркер геопозиции. */
  MyLocationMapObject get item {
    _CMyLocationMapObject res = _CMyLocationMapObjectSource_item(_CMyLocationMapObjectSourceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CMyLocationMapObjectSource_releasePtr);

  MyLocationMapObjectSource._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory MyLocationMapObjectSource._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MyLocationMapObjectSource._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /** Создать источник маркера геопозиции. */
  factory MyLocationMapObjectSource(
    Context context,
    [MyLocationControllerSettings controllerSettings = const MyLocationControllerSettings(),
    MyLocationMapObjectMarkerType markerType = MyLocationMapObjectMarkerType.model
    ]) {
    var _a0 = context._copyFromDartTo_CContext();
    var _a1 = controllerSettings._copyFromDartTo_CMyLocationControllerSettings();
    var _a2 = markerType._copyFromDartTo_CMyLocationMapObjectMarkerType();
    _CMyLocationMapObjectSource res = _CMyLocationMapObjectSource_C_createWith_CContext_CMyLocationControllerSettings_CMyLocationMapObjectMarkerType(_a0, _a1, _a2);
    _a0._releaseIntermediate();
    return MyLocationMapObjectSource._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MyLocationMapObjectSource &&
    other.runtimeType == runtimeType &&
    _CMyLocationMapObjectSource_cg_objectIdentifier(this._self) == _CMyLocationMapObjectSource_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMyLocationMapObjectSource_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - MyLocationMapObjectSource <-> CMyLocationMapObjectSource

final class _CMyLocationMapObjectSource extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMyLocationMapObjectSourceBasicFunctions on _CMyLocationMapObjectSource {
  void _releaseIntermediate() {
    _CMyLocationMapObjectSource_release(_impl);
  }

  _CMyLocationMapObjectSource _retain() {
    return _CMyLocationMapObjectSource_retain(_impl);
  }
}

extension _CMyLocationMapObjectSourceToDart on _CMyLocationMapObjectSource {
  MyLocationMapObjectSource _toDart() {
    return MyLocationMapObjectSource._create(_retain()._impl);
  }
}


extension _DartToCMyLocationMapObjectSource on MyLocationMapObjectSource {
  _CMyLocationMapObjectSource _copyFromDartTo_CMyLocationMapObjectSource() {
    return (_CMyLocationMapObjectSourceMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RoadEventMapObject

/** Объект карты "Дорожное событие". */
class RoadEventMapObject extends MapObject implements ffi.Finalizable {
  DgisObjectId get id {
    _CDgisObjectId res = _CRoadEventMapObject_id(_CRoadEventMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Получение дорожного события. */
  RoadEvent get event {
    _CRoadEvent res = _CRoadEventMapObject_event(_CRoadEventMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение настроек анимации дорожных событий для чтения и изменения. */
  AnimationSettings get animationSettings {
    _CAnimationSettings res = _CRoadEventMapObject_animationSettings(_CRoadEventMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRoadEventMapObject_releasePtr);

  RoadEventMapObject._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory RoadEventMapObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RoadEventMapObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadEventMapObject &&
    other.runtimeType == runtimeType &&
    _CRoadEventMapObject_cg_objectIdentifier(this._self) == _CRoadEventMapObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRoadEventMapObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - RoadEventMapObject <-> CRoadEventMapObject

final class _CRoadEventMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRoadEventMapObjectBasicFunctions on _CRoadEventMapObject {
  void _releaseIntermediate() {
    _CRoadEventMapObject_release(_impl);
  }

  _CRoadEventMapObject _retain() {
    return _CRoadEventMapObject_retain(_impl);
  }
}

extension _CRoadEventMapObjectToDart on _CRoadEventMapObject {
  RoadEventMapObject _toDart() {
    return RoadEventMapObject._create(_retain()._impl);
  }
}


extension _DartToCRoadEventMapObject on RoadEventMapObject {
  _CRoadEventMapObject _copyFromDartTo_CRoadEventMapObject() {
    return (_CRoadEventMapObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RoadEventType

/** Тип события. */
enum RoadEventType {
  /** ДТП. */
  accident(0),
  /** Дорожные работы. */
  roadWorks(1),
  /** Камера. */
  camera(2),
  /** Комментарий. */
  comment(3),
  /** Перекрытие дорожного движения. */
  roadRestriction(4),
  /** Событие "Другое". */
  other(5),
  ;

  const RoadEventType(this.rawValue);
  final int rawValue;

  static RoadEventType getByValue(int value) {
    return RoadEventType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRoadEventType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRoadEventTypeBasicFunctions on _CRoadEventType {
  void _releaseIntermediate() {
  }
}

extension _CRoadEventTypeToDart on _CRoadEventType {
  RoadEventType _toDart() {
    return RoadEventType.getByValue(this.rawValue);
  }
}

extension _DartTo_CRoadEventType on RoadEventType {
  _CRoadEventType _copyFromDartTo_CRoadEventType() {
    return _CRoadEventTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RoadEvent

/** Дорожное событие. */
class RoadEvent implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Тип события. */
  RoadEventType get type {
    _CRoadEventType res = _CRoadEvent_type(_CRoadEventMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Идентификатор события. */
  String get id {
    _CString res = _CRoadEvent_id(_CRoadEventMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Локализованное название события. */
  String get name {
    _CString res = _CRoadEvent_name(_CRoadEventMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Информация о пользователе, добавившем событие. */
  AuthorInfo get author {
    _CAuthorInfo res = _CRoadEvent_author(_CRoadEventMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Временная метка создания события. */
  DateTime? get timestamp {
    _COptional_CDate res = _CRoadEvent_timestamp(_CRoadEventMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Координаты события. */
  GeoPoint get location {
    _CGeoPoint res = _CRoadEvent_location(_CRoadEventMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Пользовательское описание дорожного события. */
  String get description {
    _CString res = _CRoadEvent_description(_CRoadEventMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Информация о камере.
  
   - Note: Доступна только для событий типа "Camera".
  */
  RoadCameraInfo? get cameraInfo {
    _COptional_CRoadCameraInfo res = _CRoadEvent_cameraInfo(_CRoadEventMakeDefault().._impl=_self);
    return res._toDart();
  }
  /**
   Расписание.
  
   - Note: На текущий момент доступно только для перекрытий, и даже для них может отсутствовать.
  */
  Schedule? get schedule {
    _COptional_CSchedule res = _CRoadEvent_schedule(_CRoadEventMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Затронутые событием полосы.
  
   - Note: На текущий момент могут быть проставлены только у пользовательских событий.
  */
  LaneEnumSet get lanes {
    _COptionSet_CLane res = _CRoadEvent_lanes(_CRoadEventMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Список доступных действий с событием. */
  List<RoadEventAction> get availableActions {
    _CArray_CRoadEventAction res = _CRoadEvent_availableActions(_CRoadEventMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение объекта для удаления события.
  
   - Returns: объект для удаления события.
   В случае, если событие создано другим пользователем, вернётся пустой объект.
  */
  Remover? get remover {
    _COptional_CRemover res = _CRoadEvent_remover(_CRoadEventMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRoadEvent_releasePtr);

  RoadEvent._raw(this._self);
  factory RoadEvent._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RoadEvent._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadEvent &&
    other.runtimeType == runtimeType &&
    _CRoadEvent_cg_objectIdentifier(this._self) == _CRoadEvent_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRoadEvent_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RoadEvent: Methods

  /** Фотографии события. */
  CancelableOperation<List<RoadEventPhoto>> photos()  {
    _CFuture_CArray_CRoadEventPhoto res = _CRoadEvent_photos(_CRoadEventMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - RoadEvent <-> CRoadEvent

final class _CRoadEvent extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRoadEventBasicFunctions on _CRoadEvent {
  void _releaseIntermediate() {
    _CRoadEvent_release(_impl);
  }

  _CRoadEvent _retain() {
    return _CRoadEvent_retain(_impl);
  }
}

extension _CRoadEventToDart on _CRoadEvent {
  RoadEvent _toDart() {
    return RoadEvent._create(_retain()._impl);
  }
}


extension _DartToCRoadEvent on RoadEvent {
  _CRoadEvent _copyFromDartTo_CRoadEvent() {
    return (_CRoadEventMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - AuthorType

/** Категория автора контента. */
enum AuthorType {
  /** Анонимный пользователь. */
  anonymous(0),
  /** Компания 2ГИС. */
  doubleGis(1),
  /** Авторизированный пользователь. */
  user(2),
  /** Текущий пользователь приложения. */
  me(3),
  ;

  const AuthorType(this.rawValue);
  final int rawValue;

  static AuthorType getByValue(int value) {
    return AuthorType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CAuthorType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CAuthorTypeBasicFunctions on _CAuthorType {
  void _releaseIntermediate() {
  }
}

extension _CAuthorTypeToDart on _CAuthorType {
  AuthorType _toDart() {
    return AuthorType.getByValue(this.rawValue);
  }
}

extension _DartTo_CAuthorType on AuthorType {
  _CAuthorType _copyFromDartTo_CAuthorType() {
    return _CAuthorTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - AuthorInfo

/** Информация об авторе события или фотографии. */
class AuthorInfo {
  /** Категория автора контента. */
  final AuthorType type;
  /**
   Строка, содержащая имя пользователя, добавившего событие или фотографию.
  
   - Имя пользователя в случае, если автор является авторизированным пользователем
   и согласился на отображение своего имени.
   - Пустая строка для анонимного пользователя или пользователя, отказавшегося от отображения своего имени.
  */
  final String name;

  const AuthorInfo({
    required this.type,
    required this.name
  });

  AuthorInfo copyWith({
    AuthorType? type,
    String? name
  }) {
    return AuthorInfo(
      type: type ?? this.type,
      name: name ?? this.name
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is AuthorInfo &&
    other.runtimeType == runtimeType &&
    other.type == type &&
    other.name == name;

  @override
  int get hashCode {
    return Object.hash(type, name);
  }

}
final class _CAuthorInfo extends ffi.Struct {
  external _CAuthorType type;

  external _CString name;

}
// MARK: - AuthorInfo <-> _CAuthorInfo

extension _CAuthorInfoToDart on _CAuthorInfo {
  AuthorInfo _toDart() {
    return AuthorInfo(
      type: this.type._toDart(),
      name: this.name._toDart()
    );
  }
}

extension _DartTo_CAuthorInfo on AuthorInfo {
  _CAuthorInfo _copyFromDartTo_CAuthorInfo() {
    final res = _CAuthorInfoMakeDefault();
    res.type = this.type._copyFromDartTo_CAuthorType();
    res.name = this.name._copyFromDartTo_CString();
    return res;
  }
}
extension _CAuthorInfoRelease on _CAuthorInfo {
  void _releaseIntermediate() {
    name._releaseIntermediate();
  }
}

// MARK: - DateTime <-> _CDate

final class _CDate extends ffi.Struct {
  @ffi.Double()
  external double secondsSinceEpoch;
}

extension _CDateToDart on _CDate {
  DateTime _toDart() {
    final msSinceEpoch = secondsSinceEpoch * 1000;
    return DateTime.fromMillisecondsSinceEpoch(msSinceEpoch.ceil(), isUtc: true);
  }
}

extension _DartTo_CDate on DateTime {
  _CDate _copyFromDartTo_CDate() {
    return _CDateMakeDefault()..secondsSinceEpoch = millisecondsSinceEpoch / 1000;
  }
}
	
// MARK: - DateTime? <-> _COptional_CDate

final class _COptional_CDate extends ffi.Struct {
  
  external _CDate value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CDateBasicFunctions on _COptional_CDate {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CDateToDart on _COptional_CDate {
  DateTime? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CDate on DateTime? {
  _COptional_CDate _copyFromDartTo_COptional_CDate() {
    final cOptional = _COptional_CDateMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CDate();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - CameraPurpose

/** Назначение камеры. */
enum CameraPurpose {
  /** Фиксация превышения скорости. */
  speedControl(1),
  /** Фиксация превышения средней скорости на участке. */
  averageSpeedControl(2),
  /** Фиксация движения по выделенной полосе для общественного транспорта. */
  publicTransportLaneMovementControl(4),
  /** Фиксация пересечения сплошной линии разметки, движения по обочине. */
  roadMarkingsCrossingControl(8),
  /** Фиксация проезда на запрещающий сигнал светофора. */
  trafficLightsViolationControl(16),
  /** Фиксация выезда за стоп-линию, проезда без остановки знака "Стоп", выезда на перекрёсток во время затора. */
  stopLineCrossingControl(32),
  /** Фиксация движения по встречной полосе. */
  oncomingTrafficLaneMovementControl(64),
  /** Фиксация непредоставления приоритета пешеходам. */
  pedestrianAdvantageViolationControl(128),
  /** Фиксация нарушения рядности поворота на перекрёстке. */
  laneDisciplineControl(256),
  /** Фиксация нарушения запрета остановки. */
  noStoppingViolationControl(512),
  /** Муляж. */
  dummy(1024),
  /** Камера системы "Платон", камера контроля ограничений для грузовых автомобилей */
  truck(2048),
  ;

  const CameraPurpose(this.rawValue);
  final int rawValue;

  static CameraPurpose getByValue(int value) {
    return CameraPurpose.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CCameraPurpose extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CCameraPurposeBasicFunctions on _CCameraPurpose {
  void _releaseIntermediate() {
  }
}

extension _CCameraPurposeToDart on _CCameraPurpose {
  CameraPurpose _toDart() {
    return CameraPurpose.getByValue(this.rawValue);
  }
}

extension _DartTo_CCameraPurpose on CameraPurpose {
  _CCameraPurpose _copyFromDartTo_CCameraPurpose() {
    return _CCameraPurposeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CameraPurposeEnumSet

class CameraPurposeEnumSet extends EnumSet<CameraPurpose> {
  CameraPurposeEnumSet() : super();

  factory CameraPurposeEnumSet.fromRawValue(int rawValue) {
    CameraPurposeEnumSet enumSet = CameraPurposeEnumSet();
    enumSet.rawValue = rawValue;
    return enumSet;
  }

  factory CameraPurposeEnumSet.of(Iterable<CameraPurpose> elements) {
    CameraPurposeEnumSet enumSet = CameraPurposeEnumSet();
    enumSet.addAll(elements);
    return enumSet;
  }

  factory CameraPurposeEnumSet.all() {
    CameraPurposeEnumSet enumSet = CameraPurposeEnumSet();
    enumSet.addAll(CameraPurpose.values);
    return enumSet;
  }

  @override
  bool contains(CameraPurpose value) =>
      (this.rawValue & value.rawValue) == value.rawValue;

  @override
  bool containsAllFromEnumSet(EnumSet<CameraPurpose> other) =>
      (this.rawValue & other.rawValue) == this.rawValue;

  @override
  bool add(CameraPurpose value) {
    if (this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue | value.rawValue;
    return true;
  }

  @override
  void addAllFromEnumSet(EnumSet<CameraPurpose> other) =>
      this.rawValue = this.rawValue | other.rawValue;

  @override
  bool remove(CameraPurpose value) {
    if (!this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue & ~value.rawValue;
    return true;
  }

  @override
  void removeAllFromEnumSet(EnumSet<CameraPurpose> other) =>
      this.rawValue = this.rawValue & ~other.rawValue;

  @override
  EnumSet<CameraPurpose> intersection(EnumSet<CameraPurpose> other) =>
      CameraPurposeEnumSet.fromRawValue(this.rawValue & other.rawValue);

  @override
  EnumSet<CameraPurpose> union(EnumSet<CameraPurpose> other) =>
      CameraPurposeEnumSet.fromRawValue(this.rawValue | other.rawValue);

  @override
  EnumSet<CameraPurpose> difference(EnumSet<CameraPurpose> other) =>
      CameraPurposeEnumSet.fromRawValue(this.rawValue & ~other.rawValue);

  @override
  Set<CameraPurpose> toSet() {
    Set<CameraPurpose> result = {};
    CameraPurpose.values.forEach((element) {
      if (this.contains(element)) {
        result.add(element);
      }
    });
    return result;
  }

  @override
  String toString() {
    List<String> validOptionNames = [];
    CameraPurpose.values.forEach((element) {
      if (this.contains(element)) {
        validOptionNames.add(element.name);
      }
    });

    return "${this.runtimeType}: ${validOptionNames.join(', ')}";
  }
}

final class _COptionSet_CCameraPurpose extends ffi.Struct {
  @ffi.Uint32()
  external int _rawValue;
}

extension _COptionSet_CCameraPurposeBasicFunctions on _COptionSet_CCameraPurpose {
  void _releaseIntermediate() {
  }
}

extension _COptionSet_CCameraPurposeToDart on _COptionSet_CCameraPurpose {
  CameraPurposeEnumSet _toDart() {
    return CameraPurposeEnumSet.fromRawValue(this._rawValue);
  }
}

extension _DartTo_COptionSet_CCameraPurpose on CameraPurposeEnumSet {
  _COptionSet_CCameraPurpose _copyFromDartTo_COptionSet_CCameraPurpose() {
    return _COptionSet_CCameraPurposeMakeDefault().._rawValue = this.rawValue;
  }
}
	
// MARK: - RoadCameraInfo

/** Информация о камере. */
class RoadCameraInfo {
  /**
   Назначения камеры.
  
   - Note: Могут отсутствовать, если нет информации, или если камеру добавил пользователь.
  */
  final CameraPurposeEnumSet purposes;
  /**
   Ограничение скорости в км/ч.
  
   - Note: На текущий момент доступно только для камер, контролирующих скорость и среднюю скорость на участке.
   - Note: Может отсутствовать и для камер контроля скорости, если значение неизвестно.
  */
  final int? speedLimit;

  const RoadCameraInfo({
    required this.purposes,
    required this.speedLimit
  });

  RoadCameraInfo copyWith({
    CameraPurposeEnumSet? purposes,
    Optional<int?>? speedLimit
  }) {
    return RoadCameraInfo(
      purposes: purposes ?? this.purposes,
      speedLimit: speedLimit != null ? speedLimit.value : this.speedLimit
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadCameraInfo &&
    other.runtimeType == runtimeType &&
    other.purposes == purposes &&
    other.speedLimit == speedLimit;

  @override
  int get hashCode {
    return Object.hash(purposes, speedLimit);
  }

}
final class _CRoadCameraInfo extends ffi.Struct {
  external _COptionSet_CCameraPurpose purposes;

  external _COptional_uint16_t speedLimit;

}
// MARK: - RoadCameraInfo <-> _CRoadCameraInfo

extension _CRoadCameraInfoToDart on _CRoadCameraInfo {
  RoadCameraInfo _toDart() {
    return RoadCameraInfo(
      purposes: this.purposes._toDart(),
      speedLimit: this.speedLimit._toDart()
    );
  }
}

extension _DartTo_CRoadCameraInfo on RoadCameraInfo {
  _CRoadCameraInfo _copyFromDartTo_CRoadCameraInfo() {
    final res = _CRoadCameraInfoMakeDefault();
    res.purposes = this.purposes._copyFromDartTo_COptionSet_CCameraPurpose();
    res.speedLimit = this.speedLimit._copyFromDartTo_COptional_uint16_t();
    return res;
  }
}
extension _CRoadCameraInfoRelease on _CRoadCameraInfo {
  void _releaseIntermediate() {
  }
}

// MARK: - RoadCameraInfo? <-> _COptional_CRoadCameraInfo

final class _COptional_CRoadCameraInfo extends ffi.Struct {
  
  external _CRoadCameraInfo value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CRoadCameraInfoBasicFunctions on _COptional_CRoadCameraInfo {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CRoadCameraInfoToDart on _COptional_CRoadCameraInfo {
  RoadCameraInfo? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CRoadCameraInfo on RoadCameraInfo? {
  _COptional_CRoadCameraInfo _copyFromDartTo_COptional_CRoadCameraInfo() {
    final cOptional = _COptional_CRoadCameraInfoMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CRoadCameraInfo();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Schedule

/** Расписание действия дорожного события. */
class Schedule {
  /** Время начала действия. Отсутствует, если неизвестно. */
  final DateTime? startTime;
  /** Время начала действия. Отсутствует, если неизвестно. */
  final DateTime? finishTime;
  /**
   Интервалы работы внутри недели.
  
   - Note: Интервалы упорядочены по времени.
   - Note: Первый интервал может начинаться с прошлой недели.
  */
  final List<WeekTimeInterval> weekTimeIntervals;

  const Schedule({
    required this.startTime,
    required this.finishTime,
    required this.weekTimeIntervals
  });

  Schedule copyWith({
    Optional<DateTime?>? startTime,
    Optional<DateTime?>? finishTime,
    List<WeekTimeInterval>? weekTimeIntervals
  }) {
    return Schedule(
      startTime: startTime != null ? startTime.value : this.startTime,
      finishTime: finishTime != null ? finishTime.value : this.finishTime,
      weekTimeIntervals: weekTimeIntervals ?? this.weekTimeIntervals
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Schedule &&
    other.runtimeType == runtimeType &&
    other.startTime == startTime &&
    other.finishTime == finishTime &&
    other.weekTimeIntervals == weekTimeIntervals;

  @override
  int get hashCode {
    return Object.hash(startTime, finishTime, weekTimeIntervals);
  }

}
final class _CSchedule extends ffi.Struct {
  external _COptional_CDate startTime;

  external _COptional_CDate finishTime;

  external _CArray_CWeekTimeInterval weekTimeIntervals;

}
// MARK: - Schedule <-> _CSchedule

extension _CScheduleToDart on _CSchedule {
  Schedule _toDart() {
    return Schedule(
      startTime: this.startTime._toDart(),
      finishTime: this.finishTime._toDart(),
      weekTimeIntervals: this.weekTimeIntervals._toDart()
    );
  }
}

extension _DartTo_CSchedule on Schedule {
  _CSchedule _copyFromDartTo_CSchedule() {
    final res = _CScheduleMakeDefault();
    res.startTime = this.startTime._copyFromDartTo_COptional_CDate();
    res.finishTime = this.finishTime._copyFromDartTo_COptional_CDate();
    res.weekTimeIntervals = this.weekTimeIntervals._copyFromDartTo_CArray_CWeekTimeInterval();
    return res;
  }
}
extension _CScheduleRelease on _CSchedule {
  void _releaseIntermediate() {
    weekTimeIntervals._releaseIntermediate();
  }
}

// MARK: - Schedule? <-> _COptional_CSchedule

final class _COptional_CSchedule extends ffi.Struct {
  
  external _CSchedule value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CScheduleBasicFunctions on _COptional_CSchedule {
  void _releaseIntermediate() {
    _COptional_CSchedule_release(this);
  }
}

extension _COptional_CScheduleToDart on _COptional_CSchedule {
  Schedule? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CSchedule on Schedule? {
  _COptional_CSchedule _copyFromDartTo_COptional_CSchedule() {
    final cOptional = _COptional_CScheduleMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CSchedule();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Lane

/** Полоса, которую затрагивает дорожное событие. */
enum Lane {
  /** Левая полоса. */
  left(1),
  /** Средняя полоса. */
  center(2),
  /** Правая полоса. */
  right(4),
  ;

  const Lane(this.rawValue);
  final int rawValue;

  static Lane getByValue(int value) {
    return Lane.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CLane extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CLaneBasicFunctions on _CLane {
  void _releaseIntermediate() {
  }
}

extension _CLaneToDart on _CLane {
  Lane _toDart() {
    return Lane.getByValue(this.rawValue);
  }
}

extension _DartTo_CLane on Lane {
  _CLane _copyFromDartTo_CLane() {
    return _CLaneMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - LaneEnumSet

class LaneEnumSet extends EnumSet<Lane> {
  LaneEnumSet() : super();

  factory LaneEnumSet.fromRawValue(int rawValue) {
    LaneEnumSet enumSet = LaneEnumSet();
    enumSet.rawValue = rawValue;
    return enumSet;
  }

  factory LaneEnumSet.of(Iterable<Lane> elements) {
    LaneEnumSet enumSet = LaneEnumSet();
    enumSet.addAll(elements);
    return enumSet;
  }

  factory LaneEnumSet.all() {
    LaneEnumSet enumSet = LaneEnumSet();
    enumSet.addAll(Lane.values);
    return enumSet;
  }

  @override
  bool contains(Lane value) =>
      (this.rawValue & value.rawValue) == value.rawValue;

  @override
  bool containsAllFromEnumSet(EnumSet<Lane> other) =>
      (this.rawValue & other.rawValue) == this.rawValue;

  @override
  bool add(Lane value) {
    if (this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue | value.rawValue;
    return true;
  }

  @override
  void addAllFromEnumSet(EnumSet<Lane> other) =>
      this.rawValue = this.rawValue | other.rawValue;

  @override
  bool remove(Lane value) {
    if (!this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue & ~value.rawValue;
    return true;
  }

  @override
  void removeAllFromEnumSet(EnumSet<Lane> other) =>
      this.rawValue = this.rawValue & ~other.rawValue;

  @override
  EnumSet<Lane> intersection(EnumSet<Lane> other) =>
      LaneEnumSet.fromRawValue(this.rawValue & other.rawValue);

  @override
  EnumSet<Lane> union(EnumSet<Lane> other) =>
      LaneEnumSet.fromRawValue(this.rawValue | other.rawValue);

  @override
  EnumSet<Lane> difference(EnumSet<Lane> other) =>
      LaneEnumSet.fromRawValue(this.rawValue & ~other.rawValue);

  @override
  Set<Lane> toSet() {
    Set<Lane> result = {};
    Lane.values.forEach((element) {
      if (this.contains(element)) {
        result.add(element);
      }
    });
    return result;
  }

  @override
  String toString() {
    List<String> validOptionNames = [];
    Lane.values.forEach((element) {
      if (this.contains(element)) {
        validOptionNames.add(element.name);
      }
    });

    return "${this.runtimeType}: ${validOptionNames.join(', ')}";
  }
}

final class _COptionSet_CLane extends ffi.Struct {
  @ffi.Uint32()
  external int _rawValue;
}

extension _COptionSet_CLaneBasicFunctions on _COptionSet_CLane {
  void _releaseIntermediate() {
  }
}

extension _COptionSet_CLaneToDart on _COptionSet_CLane {
  LaneEnumSet _toDart() {
    return LaneEnumSet.fromRawValue(this._rawValue);
  }
}

extension _DartTo_COptionSet_CLane on LaneEnumSet {
  _COptionSet_CLane _copyFromDartTo_COptionSet_CLane() {
    return _COptionSet_CLaneMakeDefault().._rawValue = this.rawValue;
  }
}
	
// MARK: - CancelableOperation<List<RoadEventPhoto>> <-> _CFuture_CArray_CRoadEventPhoto

final class _CFuture_CArray_CRoadEventPhoto extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CArray_CRoadEventPhoto_Cancellable {
  final Completer<List<RoadEventPhoto>> completer;
  final _CFuture_CArray_CRoadEventPhoto _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CArray_CRoadEventPhoto, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CArray_CRoadEventPhoto_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CArray_CRoadEventPhotoBasicFunctions on _CFuture_CArray_CRoadEventPhoto {
  void _releaseIntermediate() {
    _CFuture_CArray_CRoadEventPhoto_release(this);
  }

  _CFuture_CArray_CRoadEventPhoto _retain() {
    return _CFuture_CArray_CRoadEventPhoto_retain(this);
  }
}

extension _CFuture_CArray_CRoadEventPhotoToDart on _CFuture_CArray_CRoadEventPhoto {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CArray_CRoadEventPhoto_Cancellable>{};

  static void valueFunction(_CArray_CRoadEventPhoto cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<List<RoadEventPhoto>> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<List<RoadEventPhoto>>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CRoadEventPhoto, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CArray_CRoadEventPhotoReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CArray_CRoadEventPhoto_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CArray_CRoadEventPhoto on CancelableOperation<List<RoadEventPhoto>> {
  _CFuture_CArray_CRoadEventPhoto _copyFromDartTo_CFuture_CArray_CRoadEventPhoto() {
    return _CFuture_CArray_CRoadEventPhotoMakeDefault();
  }
}
	
// MARK: - List<RoadEventPhoto> <-> _CArray_CRoadEventPhoto

final class _CArray_CRoadEventPhoto extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CRoadEventPhotoToDart on _CArray_CRoadEventPhoto {
  List<RoadEventPhoto> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CRoadEventPhoto on List<RoadEventPhoto> {
  _CArray_CRoadEventPhoto _copyFromDartTo_CArray_CRoadEventPhoto() {
    final cArray = _CArray_CRoadEventPhotomakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CRoadEventPhoto();
        _CArray_CRoadEventPhotoaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CRoadEventPhotoBasicFunctions on _CArray_CRoadEventPhoto {
  void _releaseIntermediate() {
    _CArray_CRoadEventPhoto_release(this);
  }

  static final _listToFill = <RoadEventPhoto>[];

  static void _iterate(_CRoadEventPhoto item) {
    _listToFill.add(item._toDart());
  }

  List<RoadEventPhoto> _fillFromC() {
    _forEach_CArray_CRoadEventPhoto(this, ffi.Pointer.fromFunction<ffi.Void Function(_CRoadEventPhoto)>(_iterate));
    final result = List<RoadEventPhoto>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - RoadEventPhoto

/** Фотография дорожного события. */
class RoadEventPhoto implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** URL полноразмерной фотографии. */
  String get photoUrl {
    _CString res = _CRoadEventPhoto_photoUrl(_CRoadEventPhotoMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Информация о пользователе, добавившем фотографию. */
  AuthorInfo get author {
    _CAuthorInfo res = _CRoadEventPhoto_author(_CRoadEventPhotoMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Временная метка. */
  DateTime get timestamp {
    _CDate res = _CRoadEventPhoto_timestamp(_CRoadEventPhotoMakeDefault().._impl=_self);
    return res._toDart();
  }
  /**
   Получение объекта для удаления фотографии.
  
   - Returns: объект для удаления фотографии.
   В случае, если фотография добавлена другим пользователем, вернётся пустой объект.
  */
  Remover? get remover {
    _COptional_CRemover res = _CRoadEventPhoto_remover(_CRoadEventPhotoMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRoadEventPhoto_releasePtr);

  RoadEventPhoto._raw(this._self);
  factory RoadEventPhoto._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RoadEventPhoto._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadEventPhoto &&
    other.runtimeType == runtimeType &&
    _CRoadEventPhoto_cg_objectIdentifier(this._self) == _CRoadEventPhoto_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRoadEventPhoto_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RoadEventPhoto: Methods

  /** URL превью фотографии. */
  String previewUrl(
    ScreenSize desiredSize
  )  {
    var _a1 = desiredSize._copyFromDartTo_CScreenSize();
    _CString res = _CRoadEventPhoto_previewUrl_CScreenSize(_CRoadEventPhotoMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Отправка жалобы на фотографию.
  
   - Note: жалоба на свою фотографию ни к чему не приведёт.
  */
  CancelableOperation<ActionResult> report()  {
    _CFuture_CActionResult res = _CRoadEventPhoto_report(_CRoadEventPhotoMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - RoadEventPhoto <-> CRoadEventPhoto

final class _CRoadEventPhoto extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRoadEventPhotoBasicFunctions on _CRoadEventPhoto {
  void _releaseIntermediate() {
    _CRoadEventPhoto_release(_impl);
  }

  _CRoadEventPhoto _retain() {
    return _CRoadEventPhoto_retain(_impl);
  }
}

extension _CRoadEventPhotoToDart on _CRoadEventPhoto {
  RoadEventPhoto _toDart() {
    return RoadEventPhoto._create(_retain()._impl);
  }
}


extension _DartToCRoadEventPhoto on RoadEventPhoto {
  _CRoadEventPhoto _copyFromDartTo_CRoadEventPhoto() {
    return (_CRoadEventPhotoMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ActionResult

/** Тип результата действия. */
enum ActionResult {
  /** Действие успешно выполнено. */
  ok(0),
  /** Сетевая ошибка. */
  networkError(1),
  ;

  const ActionResult(this.rawValue);
  final int rawValue;

  static ActionResult getByValue(int value) {
    return ActionResult.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CActionResult extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CActionResultBasicFunctions on _CActionResult {
  void _releaseIntermediate() {
  }
}

extension _CActionResultToDart on _CActionResult {
  ActionResult _toDart() {
    return ActionResult.getByValue(this.rawValue);
  }
}

extension _DartTo_CActionResult on ActionResult {
  _CActionResult _copyFromDartTo_CActionResult() {
    return _CActionResultMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - CancelableOperation<ActionResult> <-> _CFuture_CActionResult

final class _CFuture_CActionResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CActionResult_Cancellable {
  final Completer<ActionResult> completer;
  final _CFuture_CActionResult _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CActionResult, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CActionResult_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CActionResultBasicFunctions on _CFuture_CActionResult {
  void _releaseIntermediate() {
    _CFuture_CActionResult_release(this);
  }

  _CFuture_CActionResult _retain() {
    return _CFuture_CActionResult_retain(this);
  }
}

extension _CFuture_CActionResultToDart on _CFuture_CActionResult {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CActionResult_Cancellable>{};

  static void valueFunction(_CActionResult cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<ActionResult> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<ActionResult>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CActionResult, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CActionResultReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CActionResult_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CActionResult on CancelableOperation<ActionResult> {
  _CFuture_CActionResult _copyFromDartTo_CFuture_CActionResult() {
    return _CFuture_CActionResultMakeDefault();
  }
}
	
// MARK: - Remover

/** Объект для удаления пользовательского контента. */
class Remover implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CRemover_releasePtr);

  Remover._raw(this._self);
  factory Remover._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Remover._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Remover &&
    other.runtimeType == runtimeType &&
    _CRemover_cg_objectIdentifier(this._self) == _CRemover_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRemover_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: Remover: Methods

  /**
   Удаление контента.
  
   - Note: действие доступно для контента, автором которого является пользователь.
  */
  CancelableOperation<ActionResult> remove()  {
    _CFuture_CActionResult res = _CRemover_remove(_CRemoverMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - Remover <-> CRemover

final class _CRemover extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRemoverBasicFunctions on _CRemover {
  void _releaseIntermediate() {
    _CRemover_release(_impl);
  }

  _CRemover _retain() {
    return _CRemover_retain(_impl);
  }
}

extension _CRemoverToDart on _CRemover {
  Remover _toDart() {
    return Remover._create(_retain()._impl);
  }
}


extension _DartToCRemover on Remover {
  _CRemover _copyFromDartTo_CRemover() {
    return (_CRemoverMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Remover? <-> _COptional_CRemover

final class _COptional_CRemover extends ffi.Struct {
  
  external _CRemover value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CRemoverBasicFunctions on _COptional_CRemover {
  void _releaseIntermediate() {
    _COptional_CRemover_release(this);
  }
}

extension _COptional_CRemoverToDart on _COptional_CRemover {
  Remover? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CRemover on Remover? {
  _COptional_CRemover _copyFromDartTo_COptional_CRemover() {
    final cOptional = _COptional_CRemoverMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CRemover();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - List<RoadEventAction> <-> _CArray_CRoadEventAction

final class _CArray_CRoadEventAction extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CRoadEventActionToDart on _CArray_CRoadEventAction {
  List<RoadEventAction> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CRoadEventAction on List<RoadEventAction> {
  _CArray_CRoadEventAction _copyFromDartTo_CArray_CRoadEventAction() {
    final cArray = _CArray_CRoadEventActionmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CRoadEventAction();
        _CArray_CRoadEventActionaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CRoadEventActionBasicFunctions on _CArray_CRoadEventAction {
  void _releaseIntermediate() {
    _CArray_CRoadEventAction_release(this);
  }

  static final _listToFill = <RoadEventAction>[];

  static void _iterate(_CRoadEventAction item) {
    _listToFill.add(item._toDart());
  }

  List<RoadEventAction> _fillFromC() {
    _forEach_CArray_CRoadEventAction(this, ffi.Pointer.fromFunction<ffi.Void Function(_CRoadEventAction)>(_iterate));
    final result = List<RoadEventAction>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - RoadEventActionType

/** Тип действия дорожного события. */
enum RoadEventActionType {
  /** Добавление отметки "нравится". */
  like(0),
  /** Добавление отметки "не нравится". */
  dislike(1),
  /** Подтверждение события. */
  confirmation(2),
  /** Опровержение события. */
  disproof(3),
  ;

  const RoadEventActionType(this.rawValue);
  final int rawValue;

  static RoadEventActionType getByValue(int value) {
    return RoadEventActionType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRoadEventActionType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRoadEventActionTypeBasicFunctions on _CRoadEventActionType {
  void _releaseIntermediate() {
  }
}

extension _CRoadEventActionTypeToDart on _CRoadEventActionType {
  RoadEventActionType _toDart() {
    return RoadEventActionType.getByValue(this.rawValue);
  }
}

extension _DartTo_CRoadEventActionType on RoadEventActionType {
  _CRoadEventActionType _copyFromDartTo_CRoadEventActionType() {
    return _CRoadEventActionTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RoadEventAction

/** Действие события. */
class RoadEventAction implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Тип действия. */
  RoadEventActionType get type {
    _CRoadEventActionType res = _CRoadEventAction_type(_CRoadEventActionMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Локализованное название действия. */
  String get name {
    _CString res = _CRoadEventAction_name(_CRoadEventActionMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Информация о действии. */
  StatefulChannel<RoadEventActionInfo> get infoChannel {
    _CStatefulChannel_CRoadEventActionInfo res = _CRoadEventAction_infoChannel(_CRoadEventActionMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Информация о действии. */
  RoadEventActionInfo get info {
    _CRoadEventActionInfo res = _CRoadEventAction_info(_CRoadEventActionMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CRoadEventAction_releasePtr);

  RoadEventAction._raw(this._self);
  factory RoadEventAction._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RoadEventAction._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadEventAction &&
    other.runtimeType == runtimeType &&
    _CRoadEventAction_cg_objectIdentifier(this._self) == _CRoadEventAction_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRoadEventAction_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RoadEventAction: Methods

  /**
   Применение действия (например, добавление отметки "нравится", подтверждение события).
  
   - Note: Есть действия, противоположные друг другу, например, "нравится" и "не нравится".
   Если для события доступны оба действия, вызов метода сбрасывает применение противоположного -
   невозможно одновременно поставить "нравится" и "не нравится".
  */
  CancelableOperation<ActionResult> set()  {
    _CFuture_CActionResult res = _CRoadEventAction_set(_CRoadEventActionMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Отмена действия (например, сброс отметки "нравится", сброс подтверждения события).
  
   - Note: Есть действия, противоположные друг другу, например, "нравится" и "не нравится".
   Если для события доступны оба действия, вызов метода не вызывает применение противоположного действия.
  */
  CancelableOperation<ActionResult> reset()  {
    _CFuture_CActionResult res = _CRoadEventAction_reset(_CRoadEventActionMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - RoadEventAction <-> CRoadEventAction

final class _CRoadEventAction extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRoadEventActionBasicFunctions on _CRoadEventAction {
  void _releaseIntermediate() {
    _CRoadEventAction_release(_impl);
  }

  _CRoadEventAction _retain() {
    return _CRoadEventAction_retain(_impl);
  }
}

extension _CRoadEventActionToDart on _CRoadEventAction {
  RoadEventAction _toDart() {
    return RoadEventAction._create(_retain()._impl);
  }
}


extension _DartToCRoadEventAction on RoadEventAction {
  _CRoadEventAction _copyFromDartTo_CRoadEventAction() {
    return (_CRoadEventActionMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<RoadEventActionInfo> <-> _CStatefulChannel_CRoadEventActionInfo

class _CStatefulChannel_CRoadEventActionInfoImpl extends StatefulChannel<RoadEventActionInfo> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<RoadEventActionInfo>>{};

  final _CStatefulChannel_CRoadEventActionInfo _channel;

  _CStatefulChannel_CRoadEventActionInfoImpl(this._channel);

  @override
  RoadEventActionInfo get value {
    return this._channel._getter();
  }

  static void valueFunction(_CRoadEventActionInfo cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<RoadEventActionInfo> listen(void onData(RoadEventActionInfo event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CRoadEventActionInfo, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<RoadEventActionInfo>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CRoadEventActionInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CRoadEventActionInfoBasicFunctions on _CStatefulChannel_CRoadEventActionInfo {
  void _releaseIntermediate() {
    _CStatefulChannel_CRoadEventActionInfo_release(this);
  }

  _CStatefulChannel_CRoadEventActionInfo _retain() {
    return _CStatefulChannel_CRoadEventActionInfo_retain(this);
  }

  RoadEventActionInfo _getter() {
    final cValue = _CStatefulChannel_CRoadEventActionInfoGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CRoadEventActionInfo, ffi.Int64)> callback) {
    return _CStatefulChannel_CRoadEventActionInfoConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CRoadEventActionInfoToDart on _CStatefulChannel_CRoadEventActionInfo {
  StatefulChannel<RoadEventActionInfo> _toDart() {
    return _CStatefulChannel_CRoadEventActionInfoImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CRoadEventActionInfo on StatefulChannel<RoadEventActionInfo> {
  _CStatefulChannel_CRoadEventActionInfo _copyFromDartTo_CStatefulChannel_CRoadEventActionInfo() {
    return _CStatefulChannel_CRoadEventActionInfoMakeDefault();
  }
}
	
// MARK: - RoadEventActionState

/** Состояние действия. */
enum RoadEventActionState {
  /** Применено. */
  set_(0),
  /** Не применено. */
  notSet(1),
  ;

  const RoadEventActionState(this.rawValue);
  final int rawValue;

  static RoadEventActionState getByValue(int value) {
    return RoadEventActionState.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRoadEventActionState extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRoadEventActionStateBasicFunctions on _CRoadEventActionState {
  void _releaseIntermediate() {
  }
}

extension _CRoadEventActionStateToDart on _CRoadEventActionState {
  RoadEventActionState _toDart() {
    return RoadEventActionState.getByValue(this.rawValue);
  }
}

extension _DartTo_CRoadEventActionState on RoadEventActionState {
  _CRoadEventActionState _copyFromDartTo_CRoadEventActionState() {
    return _CRoadEventActionStateMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - int? <-> _COptional_uint32_t

final class _COptional_uint32_t extends ffi.Struct {
  @ffi.Uint32()
  external int value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_uint32_tBasicFunctions on _COptional_uint32_t {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_uint32_tToDart on _COptional_uint32_t {
  int? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value;
  }
}

extension _DartTo_COptional_uint32_t on int? {
  _COptional_uint32_t _copyFromDartTo_COptional_uint32_t() {
    final cOptional = _COptional_uint32_tMakeDefault();
    if (this != null) {
      cOptional.value = this!;
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - RoadEventActionInfo

/** Информация о действии. */
class RoadEventActionInfo {
  /** Состояние действия. */
  final RoadEventActionState state;
  /** Количество действий, применённых к событию всеми пользователями (только для пользовательских событий). */
  final int? count;

  const RoadEventActionInfo({
    required this.state,
    required this.count
  });

  RoadEventActionInfo copyWith({
    RoadEventActionState? state,
    Optional<int?>? count
  }) {
    return RoadEventActionInfo(
      state: state ?? this.state,
      count: count != null ? count.value : this.count
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadEventActionInfo &&
    other.runtimeType == runtimeType &&
    other.state == state &&
    other.count == count;

  @override
  int get hashCode {
    return Object.hash(state, count);
  }

}
final class _CRoadEventActionInfo extends ffi.Struct {
  external _CRoadEventActionState state;

  external _COptional_uint32_t count;

}
// MARK: - RoadEventActionInfo <-> _CRoadEventActionInfo

extension _CRoadEventActionInfoToDart on _CRoadEventActionInfo {
  RoadEventActionInfo _toDart() {
    return RoadEventActionInfo(
      state: this.state._toDart(),
      count: this.count._toDart()
    );
  }
}

extension _DartTo_CRoadEventActionInfo on RoadEventActionInfo {
  _CRoadEventActionInfo _copyFromDartTo_CRoadEventActionInfo() {
    final res = _CRoadEventActionInfoMakeDefault();
    res.state = this.state._copyFromDartTo_CRoadEventActionState();
    res.count = this.count._copyFromDartTo_COptional_uint32_t();
    return res;
  }
}
extension _CRoadEventActionInfoRelease on _CRoadEventActionInfo {
  void _releaseIntermediate() {
  }
}

// MARK: - Style

/** Стиль с набором свойств объектов карты (cм. ISource). */
class Style implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Получение свойств по умолчанию для объектов, к которым применён указанный слой. */
  Attributes get styleAttributes {
    _CAttributes res = _CStyle_styleAttributes(_CStyleMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CStyle_releasePtr);

  Style._raw(this._self);
  factory Style._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Style._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Style &&
    other.runtimeType == runtimeType &&
    _CStyle_cg_objectIdentifier(this._self) == _CStyle_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CStyle_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Style <-> CStyle

final class _CStyle extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStyleBasicFunctions on _CStyle {
  void _releaseIntermediate() {
    _CStyle_release(_impl);
  }

  _CStyle _retain() {
    return _CStyle_retain(_impl);
  }
}

extension _CStyleToDart on _CStyle {
  Style _toDart() {
    return Style._create(_retain()._impl);
  }
}


extension _DartToCStyle on Style {
  _CStyle _copyFromDartTo_CStyle() {
    return (_CStyleMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StyleZoomFollowController

/** Контроллер слежения за стилевым уровнем масштабирования карты. */
class StyleZoomFollowController extends FollowController implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CStyleZoomFollowController_releasePtr);

  StyleZoomFollowController._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory StyleZoomFollowController._create(ffi.Pointer<ffi.Void> self) {
    final classObject = StyleZoomFollowController._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /** Создание контроллера слежения за стилевым уровнем масштабирования карты. */
  factory StyleZoomFollowController(
    [Duration animationDuration = const Duration(milliseconds: 300)
    ]) {
    var _a0 = animationDuration._copyFromDartTo_CTimeInterval();
    _CStyleZoomFollowController res = _CStyleZoomFollowController_C_createWith_CTimeInterval(_a0);
    return StyleZoomFollowController._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is StyleZoomFollowController &&
    other.runtimeType == runtimeType &&
    _CStyleZoomFollowController_cg_objectIdentifier(this._self) == _CStyleZoomFollowController_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CStyleZoomFollowController_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: StyleZoomFollowController: Methods

  /** Установка нового значения стилевого уровня масштабирования. */
  void setStyleZoom(
    StyleZoom styleZoom
  )  {
    var _a1 = styleZoom._copyFromDartTo_CStyleZoom();
    void res = _CStyleZoomFollowController_setStyleZoom_CStyleZoom(_CStyleZoomFollowControllerMakeDefault().._impl=_self, _a1);
    return res;
  }

  /** Установка интервала допустимых значений стилевого уровня масштабирования. */
  void setStyleZoomRange(
    StyleZoom minStyleZoom,
    StyleZoom maxStyleZoom
  )  {
    var _a1 = minStyleZoom._copyFromDartTo_CStyleZoom();
    var _a2 = maxStyleZoom._copyFromDartTo_CStyleZoom();
    void res = _CStyleZoomFollowController_setStyleZoomRange_CStyleZoom_CStyleZoom(_CStyleZoomFollowControllerMakeDefault().._impl=_self, _a1, _a2);
    return res;
  }

}

// MARK: - StyleZoomFollowController <-> CStyleZoomFollowController

final class _CStyleZoomFollowController extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStyleZoomFollowControllerBasicFunctions on _CStyleZoomFollowController {
  void _releaseIntermediate() {
    _CStyleZoomFollowController_release(_impl);
  }

  _CStyleZoomFollowController _retain() {
    return _CStyleZoomFollowController_retain(_impl);
  }
}

extension _CStyleZoomFollowControllerToDart on _CStyleZoomFollowController {
  StyleZoomFollowController _toDart() {
    return StyleZoomFollowController._create(_retain()._impl);
  }
}


extension _DartToCStyleZoomFollowController on StyleZoomFollowController {
  _CStyleZoomFollowController _copyFromDartTo_CStyleZoomFollowController() {
    return (_CStyleZoomFollowControllerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - _StyleZoomToTiltRelationCpp

/** Объект для описания зависимости угла наклона камеры от стилевого уровня масштабирования. */
class _StyleZoomToTiltRelationCpp extends StyleZoomToTiltRelation implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CStyleZoomToTiltRelationCpp_releasePtr);

  _StyleZoomToTiltRelationCpp._raw(this._self);
  factory _StyleZoomToTiltRelationCpp._create(ffi.Pointer<ffi.Void> self) {
    final classObject = _StyleZoomToTiltRelationCpp._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is _StyleZoomToTiltRelationCpp &&
    other.runtimeType == runtimeType &&
    _CStyleZoomToTiltRelationCpp_cg_objectIdentifier(this._self) == _CStyleZoomToTiltRelationCpp_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CStyleZoomToTiltRelationCpp_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: _StyleZoomToTiltRelationCpp: Methods

  /**
   Получение наклона камеры по стилевому уровню масштабирования.
  
   - Parameter styleZoom: Стилевой уровень масштабирования.
   - Returns: угол наклона камеры
   - Note: Функция должна быть непрерывной и монотонной.
   - Note: Функция должна быть потокобезопасной.
  */
  Tilt styleZoomToTilt(
    StyleZoom styleZoom
  )  {
    var _a1 = styleZoom._copyFromDartTo_CStyleZoom();
    _CTilt res = _CStyleZoomToTiltRelationCpp_styleZoomToTilt_CStyleZoom(_CStyleZoomToTiltRelationCppMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

}

// MARK: - _StyleZoomToTiltRelationCpp <-> CStyleZoomToTiltRelationCpp

final class _CStyleZoomToTiltRelationCpp extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStyleZoomToTiltRelationCppBasicFunctions on _CStyleZoomToTiltRelationCpp {
  void _releaseIntermediate() {
    _CStyleZoomToTiltRelationCpp_release(_impl);
  }

  _CStyleZoomToTiltRelationCpp _retain() {
    return _CStyleZoomToTiltRelationCpp_retain(_impl);
  }
}

extension _CStyleZoomToTiltRelationCppToDart on _CStyleZoomToTiltRelationCpp {
  _StyleZoomToTiltRelationCpp _toDart() {
    return _StyleZoomToTiltRelationCpp._create(_retain()._impl);
  }
}


extension _DartToCStyleZoomToTiltRelationCpp on _StyleZoomToTiltRelationCpp {
  _CStyleZoomToTiltRelationCpp _copyFromDartTo_CStyleZoomToTiltRelationCpp() {
    return (_CStyleZoomToTiltRelationCppMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StyleZoomToTiltRelation

/** Объект для описания зависимости угла наклона камеры от стилевого уровня масштабирования. */
abstract class StyleZoomToTiltRelation {
  Tilt styleZoomToTilt(
    StyleZoom styleZoom
  );
}

class _StyleZoomToTiltRelation {
  final StyleZoomToTiltRelation object;
  int refCounter = 1;

  _StyleZoomToTiltRelation(this.object);
}

final class _CStyleZoomToTiltRelation extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.Void> _cppValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CTilt)>>, _CStyleZoom)>> _styleZoomToTilt_CStyleZoom;
}

extension _CStyleZoomToTiltRelationBasicFunctions on _CStyleZoomToTiltRelation {
  void _releaseIntermediate() {
    _CStyleZoomToTiltRelation_release(this);
  }
}

int _CStyleZoomToTiltRelationInstanceCounter = 1;
final _CStyleZoomToTiltRelationInstanceMap = <int, _StyleZoomToTiltRelation>{};

extension _CStyleZoomToTiltRelationToDart on _CStyleZoomToTiltRelation {
  StyleZoomToTiltRelation _toDart() {
    late StyleZoomToTiltRelation? result;
    final platformValue = this._value.cast<ffi.Int64>();
    if (platformValue.address != 0) {
      result = _CStyleZoomToTiltRelationInstanceMap[platformValue.address]?.object;
    } else if (this._cppValue.address != 0) {
      final cppValue = _CStyleZoomToTiltRelationCppMakeDefault().._impl = this._cppValue;
      result = cppValue._toDart();
    }
    if (result == null) {
      throw Exception("Invalid intermediate object of type _CStyleZoomToTiltRelation");
    }
    return result;
  }
}

extension _DartTo_CStyleZoomToTiltRelation on StyleZoomToTiltRelation {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    _CStyleZoomToTiltRelationInstanceMap[platformValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    final platformObject = _CStyleZoomToTiltRelationInstanceMap[platformValue.address];
    if (platformObject == null) {
      return;
    }
    platformObject.refCounter -= 1;
    if (platformObject.refCounter > 0) {
      return;
    }
    _CStyleZoomToTiltRelationInstanceMap.remove(platformValue.address);
  }

  _CStyleZoomToTiltRelation _copyFromDartTo_CStyleZoomToTiltRelation() {
    var res = _CStyleZoomToTiltRelationMakeDefault();
    if (this is _StyleZoomToTiltRelationCpp) {
      final cppValue = this as _StyleZoomToTiltRelationCpp;
      res._cppValue = cppValue._copyFromDartTo_CStyleZoomToTiltRelationCpp()._impl;
      return res;
    }
    final instanceId = _CStyleZoomToTiltRelationInstanceCounter;
    _CStyleZoomToTiltRelationInstanceCounter += 1;
    _CStyleZoomToTiltRelationInstanceMap[instanceId] = _StyleZoomToTiltRelation(this);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;

    final styleZoomToTilt_CStyleZoomFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CTilt)>>, _CStyleZoom)>.listener(styleZoomToTilt_CStyleZoomFunction);
    res._styleZoomToTilt_CStyleZoom = styleZoomToTilt_CStyleZoomFunctionCallable.nativeFunction;
    return res;
  }

  static void styleZoomToTilt_CStyleZoomFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CTilt)>> resultValueCallback, _CStyleZoom styleZoom) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CStyleZoomToTiltRelation");
    }
    final platformObject = _CStyleZoomToTiltRelationInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CStyleZoomToTiltRelation");
    }

    final styleZoomDart = styleZoom._toDart();
    final res = platformObject.object.styleZoomToTilt(styleZoomDart);
    styleZoom._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _CTilt)>();
    callbackFunction(context, res._copyFromDartTo_CTilt());
  }


}

// MARK: - TiltFollowController

/** Контроллер слежения за углом наклона карты. */
class TiltFollowController extends FollowController implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CTiltFollowController_releasePtr);

  TiltFollowController._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory TiltFollowController._create(ffi.Pointer<ffi.Void> self) {
    final classObject = TiltFollowController._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Создание контроллера слежения за углом наклона карты.
  
   - Parameter styleZoomToTilt: зависимость угла наклона камеры от стилевого уровня масштабирования.
  */
  factory TiltFollowController(
    StyleZoomToTiltRelation styleZoomToTilt
  ) {
    var _a0 = styleZoomToTilt._copyFromDartTo_CStyleZoomToTiltRelation();
    _CTiltFollowController res = _CTiltFollowController_C_createWith_CStyleZoomToTiltRelation(_a0);
    _a0._releaseIntermediate();
    return TiltFollowController._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TiltFollowController &&
    other.runtimeType == runtimeType &&
    _CTiltFollowController_cg_objectIdentifier(this._self) == _CTiltFollowController_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CTiltFollowController_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - TiltFollowController <-> CTiltFollowController

final class _CTiltFollowController extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CTiltFollowControllerBasicFunctions on _CTiltFollowController {
  void _releaseIntermediate() {
    _CTiltFollowController_release(_impl);
  }

  _CTiltFollowController _retain() {
    return _CTiltFollowController_retain(_impl);
  }
}

extension _CTiltFollowControllerToDart on _CTiltFollowController {
  TiltFollowController _toDart() {
    return TiltFollowController._create(_retain()._impl);
  }
}


extension _DartToCTiltFollowController on TiltFollowController {
  _CTiltFollowController _copyFromDartTo_CTiltFollowController() {
    return (_CTiltFollowControllerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - TrafficSource

/** Интерфейс класса, управляющего отображением пробок на карте. */
class TrafficSource extends Source implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CTrafficSource_releasePtr);

  TrafficSource._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory TrafficSource._create(ffi.Pointer<ffi.Void> self) {
    final classObject = TrafficSource._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory TrafficSource(
    Context context
  ) {
    var _a0 = context._copyFromDartTo_CContext();
    _CTrafficSource res = _CTrafficSource_C_createWith_CContext(_a0);
    _a0._releaseIntermediate();
    return TrafficSource._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TrafficSource &&
    other.runtimeType == runtimeType &&
    _CTrafficSource_cg_objectIdentifier(this._self) == _CTrafficSource_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CTrafficSource_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - TrafficSource <-> CTrafficSource

final class _CTrafficSource extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CTrafficSourceBasicFunctions on _CTrafficSource {
  void _releaseIntermediate() {
    _CTrafficSource_release(_impl);
  }

  _CTrafficSource _retain() {
    return _CTrafficSource_retain(_impl);
  }
}

extension _CTrafficSourceToDart on _CTrafficSource {
  TrafficSource _toDart() {
    return TrafficSource._create(_retain()._impl);
  }
}


extension _DartToCTrafficSource on TrafficSource {
  _CTrafficSource _copyFromDartTo_CTrafficSource() {
    return (_CTrafficSourceMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RoadEventDisplayCategory

/** Категория дорожного события для отображения на карте. */
enum RoadEventDisplayCategory {
  /** Камеры всех типов, в том числе и добавленные пользователем. */
  camera(1),
  /** Комментарии на дорогах. */
  comment(2),
  /** ДТП. */
  accident(4),
  /** Перекрытия дорог. */
  roadRestriction(8),
  /** Дорожные работы. */
  roadWorks(16),
  /** События категории "Другое". */
  other(32),
  /** Всегда отображать события, созданные текущим пользователем, вне зависимости от их категории. */
  user(64),
  ;

  const RoadEventDisplayCategory(this.rawValue);
  final int rawValue;

  static RoadEventDisplayCategory getByValue(int value) {
    return RoadEventDisplayCategory.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRoadEventDisplayCategory extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRoadEventDisplayCategoryBasicFunctions on _CRoadEventDisplayCategory {
  void _releaseIntermediate() {
  }
}

extension _CRoadEventDisplayCategoryToDart on _CRoadEventDisplayCategory {
  RoadEventDisplayCategory _toDart() {
    return RoadEventDisplayCategory.getByValue(this.rawValue);
  }
}

extension _DartTo_CRoadEventDisplayCategory on RoadEventDisplayCategory {
  _CRoadEventDisplayCategory _copyFromDartTo_CRoadEventDisplayCategory() {
    return _CRoadEventDisplayCategoryMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - RoadEventSource

/** Интерфейс класса, управляющего отображением дорожных событий (tUGC) на карте. */
class RoadEventSource extends Source implements ffi.Finalizable {
  /** Получение текущих категорий событий, предоставляемых данным источником. */
  RoadEventDisplayCategoryEnumSet get visibleEvents {
    _COptionSet_CRoadEventDisplayCategory res = _CRoadEventSource_getVisibleEvents(_CRoadEventSourceMakeDefault().._impl=_self);
    return res._toDart();
  }
  set visibleEvents(RoadEventDisplayCategoryEnumSet types) {
    var _a1 = types._copyFromDartTo_COptionSet_CRoadEventDisplayCategory();
    void res = _CRoadEventSource_setVisibleEvents_COptionSet_CRoadEventDisplayCategory(_CRoadEventSourceMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Получение списка идентификаторов выделенных дорожных событий. */
  StatefulChannel<List<DgisObjectId>> get highlightedObjectsChannel {
    _CStatefulChannel_CArray_CDgisObjectId res = _CRoadEventSource_highlightedObjectsChannel(_CRoadEventSourceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение списка идентификаторов выделенных дорожных событий. */
  List<DgisObjectId> get highlightedObjects {
    _CArray_CDgisObjectId res = _CRoadEventSource_highlightedObjects(_CRoadEventSourceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CRoadEventSource_releasePtr);

  RoadEventSource._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory RoadEventSource._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RoadEventSource._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /** Создание источника, отображающего дорожные события на карте. */
  factory RoadEventSource(
    Context context
  ) {
    var _a0 = context._copyFromDartTo_CContext();
    _CRoadEventSource res = _CRoadEventSource_C_createWith_CContext(_a0);
    _a0._releaseIntermediate();
    return RoadEventSource._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadEventSource &&
    other.runtimeType == runtimeType &&
    _CRoadEventSource_cg_objectIdentifier(this._self) == _CRoadEventSource_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRoadEventSource_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RoadEventSource: Methods

  /**
   Установка или снятие выделения дорожных событий.
  
   - Note: добавляет событию атрибут "selected", который можно использовать в стилях.
   - Parameter directoryObjectIds: Идентификаторы изменяемых событий. Можно получить из RoadEventMapObject.
   - Parameter highlighted: Установка или снятие выделения.
  */
  void setHighlighted(
    List<DgisObjectId> directoryObjectIds,
    bool highlighted
  )  {
    var _a1 = directoryObjectIds._copyFromDartTo_CArray_CDgisObjectId();
    void res = _CRoadEventSource_setHighlighted_CArray_CDgisObjectId_bool(_CRoadEventSourceMakeDefault().._impl=_self, _a1, highlighted);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - RoadEventSource <-> CRoadEventSource

final class _CRoadEventSource extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRoadEventSourceBasicFunctions on _CRoadEventSource {
  void _releaseIntermediate() {
    _CRoadEventSource_release(_impl);
  }

  _CRoadEventSource _retain() {
    return _CRoadEventSource_retain(_impl);
  }
}

extension _CRoadEventSourceToDart on _CRoadEventSource {
  RoadEventSource _toDart() {
    return RoadEventSource._create(_retain()._impl);
  }
}


extension _DartToCRoadEventSource on RoadEventSource {
  _CRoadEventSource _copyFromDartTo_CRoadEventSource() {
    return (_CRoadEventSourceMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - RoadEventDisplayCategoryEnumSet

class RoadEventDisplayCategoryEnumSet extends EnumSet<RoadEventDisplayCategory> {
  RoadEventDisplayCategoryEnumSet() : super();

  factory RoadEventDisplayCategoryEnumSet.fromRawValue(int rawValue) {
    RoadEventDisplayCategoryEnumSet enumSet = RoadEventDisplayCategoryEnumSet();
    enumSet.rawValue = rawValue;
    return enumSet;
  }

  factory RoadEventDisplayCategoryEnumSet.of(Iterable<RoadEventDisplayCategory> elements) {
    RoadEventDisplayCategoryEnumSet enumSet = RoadEventDisplayCategoryEnumSet();
    enumSet.addAll(elements);
    return enumSet;
  }

  factory RoadEventDisplayCategoryEnumSet.all() {
    RoadEventDisplayCategoryEnumSet enumSet = RoadEventDisplayCategoryEnumSet();
    enumSet.addAll(RoadEventDisplayCategory.values);
    return enumSet;
  }

  @override
  bool contains(RoadEventDisplayCategory value) =>
      (this.rawValue & value.rawValue) == value.rawValue;

  @override
  bool containsAllFromEnumSet(EnumSet<RoadEventDisplayCategory> other) =>
      (this.rawValue & other.rawValue) == this.rawValue;

  @override
  bool add(RoadEventDisplayCategory value) {
    if (this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue | value.rawValue;
    return true;
  }

  @override
  void addAllFromEnumSet(EnumSet<RoadEventDisplayCategory> other) =>
      this.rawValue = this.rawValue | other.rawValue;

  @override
  bool remove(RoadEventDisplayCategory value) {
    if (!this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue & ~value.rawValue;
    return true;
  }

  @override
  void removeAllFromEnumSet(EnumSet<RoadEventDisplayCategory> other) =>
      this.rawValue = this.rawValue & ~other.rawValue;

  @override
  EnumSet<RoadEventDisplayCategory> intersection(EnumSet<RoadEventDisplayCategory> other) =>
      RoadEventDisplayCategoryEnumSet.fromRawValue(this.rawValue & other.rawValue);

  @override
  EnumSet<RoadEventDisplayCategory> union(EnumSet<RoadEventDisplayCategory> other) =>
      RoadEventDisplayCategoryEnumSet.fromRawValue(this.rawValue | other.rawValue);

  @override
  EnumSet<RoadEventDisplayCategory> difference(EnumSet<RoadEventDisplayCategory> other) =>
      RoadEventDisplayCategoryEnumSet.fromRawValue(this.rawValue & ~other.rawValue);

  @override
  Set<RoadEventDisplayCategory> toSet() {
    Set<RoadEventDisplayCategory> result = {};
    RoadEventDisplayCategory.values.forEach((element) {
      if (this.contains(element)) {
        result.add(element);
      }
    });
    return result;
  }

  @override
  String toString() {
    List<String> validOptionNames = [];
    RoadEventDisplayCategory.values.forEach((element) {
      if (this.contains(element)) {
        validOptionNames.add(element.name);
      }
    });

    return "${this.runtimeType}: ${validOptionNames.join(', ')}";
  }
}

final class _COptionSet_CRoadEventDisplayCategory extends ffi.Struct {
  @ffi.Uint32()
  external int _rawValue;
}

extension _COptionSet_CRoadEventDisplayCategoryBasicFunctions on _COptionSet_CRoadEventDisplayCategory {
  void _releaseIntermediate() {
  }
}

extension _COptionSet_CRoadEventDisplayCategoryToDart on _COptionSet_CRoadEventDisplayCategory {
  RoadEventDisplayCategoryEnumSet _toDart() {
    return RoadEventDisplayCategoryEnumSet.fromRawValue(this._rawValue);
  }
}

extension _DartTo_COptionSet_CRoadEventDisplayCategory on RoadEventDisplayCategoryEnumSet {
  _COptionSet_CRoadEventDisplayCategory _copyFromDartTo_COptionSet_CRoadEventDisplayCategory() {
    return _COptionSet_CRoadEventDisplayCategoryMakeDefault().._rawValue = this.rawValue;
  }
}
	
// MARK: - Alignment

enum Alignment {
  topLeft(0),
  topRight(1),
  bottomLeft(2),
  bottomRight(3),
  ;

  const Alignment(this.rawValue);
  final int rawValue;

  static Alignment getByValue(int value) {
    return Alignment.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CAlignment extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CAlignmentBasicFunctions on _CAlignment {
  void _releaseIntermediate() {
  }
}

extension _CAlignmentToDart on _CAlignment {
  Alignment _toDart() {
    return Alignment.getByValue(this.rawValue);
  }
}

extension _DartTo_CAlignment on Alignment {
  _CAlignment _copyFromDartTo_CAlignment() {
    return _CAlignmentMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - AnimationMode

/** Режим анимации. */
enum AnimationMode {
  /** Обычная. Анимация объекта отображается один раз. */
  normal(0),
  /** Зацикленная. Анимация объекта отображается циклически. */
  loop(1),
  ;

  const AnimationMode(this.rawValue);
  final int rawValue;

  static AnimationMode getByValue(int value) {
    return AnimationMode.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CAnimationMode extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CAnimationModeBasicFunctions on _CAnimationMode {
  void _releaseIntermediate() {
  }
}

extension _CAnimationModeToDart on _CAnimationMode {
  AnimationMode _toDart() {
    return AnimationMode.getByValue(this.rawValue);
  }
}

extension _DartTo_CAnimationMode on AnimationMode {
  _CAnimationMode _copyFromDartTo_CAnimationMode() {
    return _CAnimationModeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - LogicalPixel

/**
 Пиксель, размер которого не зависит от плотности экрана.

 1 логический пиксель соответствует  1 / (базовый ppi) дюйма.
 Базовый PPI зависит от устройства и вычисляется из отношения DevicePpi/DeviceDensity.
 DevicePpi и DeviceDensity, в свою очередь, задаются с ОС через интерфейс карты.
 Для Android LogicalPixel соответствует dp, для iOS - point'у.
*/
class LogicalPixel {
  final double value;

  const LogicalPixel([this.value = 0]);

  LogicalPixel copyWith({
    double? value
  }) {
    return LogicalPixel(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LogicalPixel &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CLogicalPixel extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - LogicalPixel <-> _CLogicalPixel

extension _CLogicalPixelToDart on _CLogicalPixel {
  LogicalPixel _toDart() {
    return LogicalPixel(
      this.value
    );
  }
}

extension _DartTo_CLogicalPixel on LogicalPixel {
  _CLogicalPixel _copyFromDartTo_CLogicalPixel() {
    final res = _CLogicalPixelMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CLogicalPixelRelease on _CLogicalPixel {
  void _releaseIntermediate() {
  }
}

// MARK: - MapDataLoadingState

enum MapDataLoadingState {
  /** Данные загружаются и, возможно, будут добавлены позже. */
  loading(0),
  /** Данные загружены. */
  loaded(1),
  ;

  const MapDataLoadingState(this.rawValue);
  final int rawValue;

  static MapDataLoadingState getByValue(int value) {
    return MapDataLoadingState.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CMapDataLoadingState extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CMapDataLoadingStateBasicFunctions on _CMapDataLoadingState {
  void _releaseIntermediate() {
  }
}

extension _CMapDataLoadingStateToDart on _CMapDataLoadingState {
  MapDataLoadingState _toDart() {
    return MapDataLoadingState.getByValue(this.rawValue);
  }
}

extension _DartTo_CMapDataLoadingState on MapDataLoadingState {
  _CMapDataLoadingState _copyFromDartTo_CMapDataLoadingState() {
    return _CMapDataLoadingStateMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - MapDirection

/** Угол поворота объекта относительно направления на север, в градусах, отсчитывается по часовой стрелке. */
class MapDirection {
  final double value;

  const MapDirection([this.value = 0]);

  MapDirection copyWith({
    double? value
  }) {
    return MapDirection(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapDirection &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CMapDirection extends ffi.Struct {
  @ffi.Double()
  external double value;

}
// MARK: - MapDirection <-> _CMapDirection

extension _CMapDirectionToDart on _CMapDirection {
  MapDirection _toDart() {
    return MapDirection(
      this.value
    );
  }
}

extension _DartTo_CMapDirection on MapDirection {
  _CMapDirection _copyFromDartTo_CMapDirection() {
    final res = _CMapDirectionMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CMapDirectionRelease on _CMapDirection {
  void _releaseIntermediate() {
  }
}

// MARK: - MapId

/** Идентификатор экземпляра карты, уникальный в рамках процесса. */
class MapId {
  final int value;

  const MapId([this.value = 0]);

  MapId copyWith({
    int? value
  }) {
    return MapId(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapId &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CMapId extends ffi.Struct {
  @ffi.Int32()
  external int value;

}
// MARK: - MapId <-> _CMapId

extension _CMapIdToDart on _CMapId {
  MapId _toDart() {
    return MapId(
      this.value
    );
  }
}

extension _DartTo_CMapId on MapId {
  _CMapId _copyFromDartTo_CMapId() {
    final res = _CMapIdMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CMapIdRelease on _CMapId {
  void _releaseIntermediate() {
  }
}

// MARK: - MapVisibilityState

/** Статус видимости карты */
enum MapVisibilityState {
  /** Карту полностью видно */
  visible(0),
  /** Карта полностью скрыта от пользователя */
  hidden(1),
  ;

  const MapVisibilityState(this.rawValue);
  final int rawValue;

  static MapVisibilityState getByValue(int value) {
    return MapVisibilityState.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CMapVisibilityState extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CMapVisibilityStateBasicFunctions on _CMapVisibilityState {
  void _releaseIntermediate() {
  }
}

extension _CMapVisibilityStateToDart on _CMapVisibilityState {
  MapVisibilityState _toDart() {
    return MapVisibilityState.getByValue(this.rawValue);
  }
}

extension _DartTo_CMapVisibilityState on MapVisibilityState {
  _CMapVisibilityState _copyFromDartTo_CMapVisibilityState() {
    return _CMapVisibilityStateMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - Opacity

/** Непрозрачность - от 0.0 (полная прозрачность) до 1.0 (полная непрозрачность). */
class Opacity {
  final double value;

  const Opacity([this.value = 0]);

  Opacity copyWith({
    double? value
  }) {
    return Opacity(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Opacity &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _COpacity extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - Opacity <-> _COpacity

extension _COpacityToDart on _COpacity {
  Opacity _toDart() {
    return Opacity(
      this.value
    );
  }
}

extension _DartTo_COpacity on Opacity {
  _COpacity _copyFromDartTo_COpacity() {
    final res = _COpacityMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _COpacityRelease on _COpacity {
  void _releaseIntermediate() {
  }
}

// MARK: - Padding

/**
 Отступы от краёв камеры.

 Задаётся от краёв внутрь, в физических пикселях.
 Отступы влияют на:
 - точку позиции;
 - анимированное перемещение карты;
 - расположение динамических объектов карты (например баблы маршрутов).
*/
class Padding {
  /** Отступ слева внутрь. */
  final int left;
  /** Отступ сверху внутрь. */
  final int top;
  /** Отступ справа внутрь. */
  final int right;
  /** Отступ снизу внутрь. */
  final int bottom;

  const Padding({
    this.left = 0,
    this.top = 0,
    this.right = 0,
    this.bottom = 0
  });

  Padding copyWith({
    int? left,
    int? top,
    int? right,
    int? bottom
  }) {
    return Padding(
      left: left ?? this.left,
      top: top ?? this.top,
      right: right ?? this.right,
      bottom: bottom ?? this.bottom
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Padding &&
    other.runtimeType == runtimeType &&
    other.left == left &&
    other.top == top &&
    other.right == right &&
    other.bottom == bottom;

  @override
  int get hashCode {
    return Object.hash(left, top, right, bottom);
  }

}
final class _CPadding extends ffi.Struct {
  @ffi.Uint32()
  external int left;

  @ffi.Uint32()
  external int top;

  @ffi.Uint32()
  external int right;

  @ffi.Uint32()
  external int bottom;

}
// MARK: - Padding <-> _CPadding

extension _CPaddingToDart on _CPadding {
  Padding _toDart() {
    return Padding(
      left: this.left,
      top: this.top,
      right: this.right,
      bottom: this.bottom
    );
  }
}

extension _DartTo_CPadding on Padding {
  _CPadding _copyFromDartTo_CPadding() {
    final res = _CPaddingMakeDefault();
    res.left = this.left;
    res.top = this.top;
    res.right = this.right;
    res.bottom = this.bottom;
    return res;
  }
}
extension _CPaddingRelease on _CPadding {
  void _releaseIntermediate() {
  }
}

// MARK: - ProductType

@internal
enum ProductType {
  dgis(0),
  urbi(1),
  ;

  const ProductType(this.rawValue);
  final int rawValue;

  static ProductType getByValue(int value) {
    return ProductType.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CProductType extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CProductTypeBasicFunctions on _CProductType {
  void _releaseIntermediate() {
  }
}

extension _CProductTypeToDart on _CProductType {
  ProductType _toDart() {
    return ProductType.getByValue(this.rawValue);
  }
}

extension _DartTo_CProductType on ProductType {
  _CProductType _copyFromDartTo_CProductType() {
    return _CProductTypeMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ModelScale

/** Коэффициент масштабирования модели. Подбирается вручную. Значение варьируется от 0.0 до 64.0. */
class ModelScale {
  final double value;

  const ModelScale([this.value = 0]);

  ModelScale copyWith({
    double? value
  }) {
    return ModelScale(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ModelScale &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CModelScale extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - ModelScale <-> _CModelScale

extension _CModelScaleToDart on _CModelScale {
  ModelScale _toDart() {
    return ModelScale(
      this.value
    );
  }
}

extension _DartTo_CModelScale on ModelScale {
  _CModelScale _copyFromDartTo_CModelScale() {
    final res = _CModelScaleMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CModelScaleRelease on _CModelScale {
  void _releaseIntermediate() {
  }
}

// MARK: - RenderedObject

/** Отображаемый объект карты. */
class RenderedObject {
  /** Объект карты. */
  final MapObject item;
  /** Источник данных, содержащий объект карты. */
  final Source source;
  /** Идентификатор этажного плана здания, на котором расположен объект. */
  final LevelId? levelId;

  const RenderedObject({
    required this.item,
    required this.source,
    this.levelId = null
  });

  RenderedObject copyWith({
    MapObject? item,
    Source? source,
    Optional<LevelId?>? levelId
  }) {
    return RenderedObject(
      item: item ?? this.item,
      source: source ?? this.source,
      levelId: levelId != null ? levelId.value : this.levelId
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RenderedObject &&
    other.runtimeType == runtimeType &&
    other.item == item &&
    other.source == source &&
    other.levelId == levelId;

  @override
  int get hashCode {
    return Object.hash(item, source, levelId);
  }

}
final class _CRenderedObject extends ffi.Struct {
  external _CMapObject item;

  external _CSource source;

  external _COptional_CLevelId levelId;

}
// MARK: - RenderedObject <-> _CRenderedObject

extension _CRenderedObjectToDart on _CRenderedObject {
  RenderedObject _toDart() {
    return RenderedObject(
      item: this.item._toDart(),
      source: this.source._toDart(),
      levelId: this.levelId._toDart()
    );
  }
}

extension _DartTo_CRenderedObject on RenderedObject {
  _CRenderedObject _copyFromDartTo_CRenderedObject() {
    final res = _CRenderedObjectMakeDefault();
    res.item = this.item._copyFromDartTo_CMapObject();
    res.source = this.source._copyFromDartTo_CSource();
    res.levelId = this.levelId._copyFromDartTo_COptional_CLevelId();
    return res;
  }
}
extension _CRenderedObjectRelease on _CRenderedObject {
  void _releaseIntermediate() {
    item._releaseIntermediate();
    source._releaseIntermediate();
  }
}

// MARK: - ScreenDistance

/**
 Расстояние между объектами на экране в миллиметрах.

 - Note: не может быть отрицательным
*/
class ScreenDistance {
  final double value;

  const ScreenDistance([this.value = 0]);

  ScreenDistance copyWith({
    double? value
  }) {
    return ScreenDistance(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ScreenDistance &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CScreenDistance extends ffi.Struct {
  @ffi.Float()
  external double value;

}
// MARK: - ScreenDistance <-> _CScreenDistance

extension _CScreenDistanceToDart on _CScreenDistance {
  ScreenDistance _toDart() {
    return ScreenDistance(
      this.value
    );
  }
}

extension _DartTo_CScreenDistance on ScreenDistance {
  _CScreenDistance _copyFromDartTo_CScreenDistance() {
    final res = _CScreenDistanceMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CScreenDistanceRelease on _CScreenDistance {
  void _releaseIntermediate() {
  }
}

// MARK: - StyleLayerId

/** Идентификатор слоя стиля. */
class StyleLayerId {
  final String id;

  const StyleLayerId(this.id);

  StyleLayerId copyWith({
    String? id
  }) {
    return StyleLayerId(
      id ?? this.id
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is StyleLayerId &&
    other.runtimeType == runtimeType &&
    other.id == id;

  @override
  int get hashCode {
    return id.hashCode;
  }

}
final class _CStyleLayerId extends ffi.Struct {
  external _CString id;

}
// MARK: - StyleLayerId <-> _CStyleLayerId

extension _CStyleLayerIdToDart on _CStyleLayerId {
  StyleLayerId _toDart() {
    return StyleLayerId(
      this.id._toDart()
    );
  }
}

extension _DartTo_CStyleLayerId on StyleLayerId {
  _CStyleLayerId _copyFromDartTo_CStyleLayerId() {
    final res = _CStyleLayerIdMakeDefault();
    res.id = this.id._copyFromDartTo_CString();
    return res;
  }
}
extension _CStyleLayerIdRelease on _CStyleLayerId {
  void _releaseIntermediate() {
    id._releaseIntermediate();
  }
}

// MARK: - TextHorizontalAlignment

/** Выравнивание надписи по горизонтали. */
enum TextHorizontalAlignment {
  /** Автоматическое выравнивание. */
  auto(0),
  /** Выравнивание по центру. */
  center(1),
  /** Выравнивание по левому краю. */
  left(2),
  /** Выравнивание по правому краю. */
  right(3),
  ;

  const TextHorizontalAlignment(this.rawValue);
  final int rawValue;

  static TextHorizontalAlignment getByValue(int value) {
    return TextHorizontalAlignment.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CTextHorizontalAlignment extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CTextHorizontalAlignmentBasicFunctions on _CTextHorizontalAlignment {
  void _releaseIntermediate() {
  }
}

extension _CTextHorizontalAlignmentToDart on _CTextHorizontalAlignment {
  TextHorizontalAlignment _toDart() {
    return TextHorizontalAlignment.getByValue(this.rawValue);
  }
}

extension _DartTo_CTextHorizontalAlignment on TextHorizontalAlignment {
  _CTextHorizontalAlignment _copyFromDartTo_CTextHorizontalAlignment() {
    return _CTextHorizontalAlignmentMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - TextPlacement

/**
 Варианты положения подписи относительно иконки.
 Само положение определяется следующим образом:
 1. Первая часть enum обозначает область, относительно которой определяется зона положения подписи:
 A. "Circle" - значит рассматривается окружность вокруг маркера.
 B. Пустая строка - значит рассматривается квадрат.
 2. Вторая часть enum определяет зону относительно области вокруг маркера.
 3. Третья часть enum определяет расположение подписи внутри зоны.
*/
enum TextPlacement {
  /** Нет подписи. */
  noLabel(0),
  /** В центре области ниже квадрата вокруг маркера. */
  bottomCenter(1),
  /** С правой стороны области ниже квадрата вокруг маркера. */
  bottomRight(2),
  /** С левой стороны области ниже квадрата вокруг маркера. */
  bottomLeft(3),
  /** В нижней правой области относительно окружности вокруг маркера. */
  circleBottomRight(4),
  /** Снизу области правее квадрата вокруг маркера. */
  rightBottom(5),
  /** В центре области правее квадрата вокруг маркера. */
  rightCenter(6),
  /** Сверху области правее квадрата вокруг маркера. */
  rightTop(7),
  /** В верхней правой области относительно окружности вокруг маркера. */
  circleTopRight(8),
  /** В центре области выше квадрата вокруг маркера. */
  topCenter(9),
  /** С правой стороны области выше квадрата вокруг маркера. */
  topRight(10),
  /** С левой стороны области выше квадрата вокруг маркера. */
  topLeft(11),
  /** В верхней левой области относительно окружности вокруг маркера. */
  circleTopLeft(12),
  /** Сверху области левее квадрата вокруг маркера. */
  leftTop(13),
  /** В центре области левее квадрата вокруг маркера. */
  leftCenter(14),
  /** Снизу области левее квадрата вокруг маркера. */
  leftBottom(15),
  /** В нижней левой области относительно окружности вокруг маркера. */
  circleBottomLeft(16),
  /** По центру квадрата вокруг маркера. */
  centerCenter(17),
  ;

  const TextPlacement(this.rawValue);
  final int rawValue;

  static TextPlacement getByValue(int value) {
    return TextPlacement.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CTextPlacement extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CTextPlacementBasicFunctions on _CTextPlacement {
  void _releaseIntermediate() {
  }
}

extension _CTextPlacementToDart on _CTextPlacement {
  TextPlacement _toDart() {
    return TextPlacement.getByValue(this.rawValue);
  }
}

extension _DartTo_CTextPlacement on TextPlacement {
  _CTextPlacement _copyFromDartTo_CTextPlacement() {
    return _CTextPlacementMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - TextStyle

/** Настройки внешнего вида текста. */
class TextStyle {
  final LogicalPixel fontSize;
  final Color color;
  final LogicalPixel strokeWidth;
  final Color strokeColor;
  final TextHorizontalAlignment textHorizontalAlignment;
  final TextPlacement textPlacement;
  final LogicalPixel textOffset;
  final String? fontName;
  /** Скрывать ли текст при наложении с другими объектами (маркеры, подписи других объектов). */
  final bool suppressOnOverlap;

  const TextStyle({
    this.fontSize = const LogicalPixel(8),
    this.color = const Color(),
    this.strokeWidth = const LogicalPixel(0.3499999940395355),
    this.strokeColor = const Color(4294967295),
    this.textHorizontalAlignment = TextHorizontalAlignment.auto,
    this.textPlacement = TextPlacement.bottomCenter,
    this.textOffset = const LogicalPixel(0),
    this.fontName = null,
    this.suppressOnOverlap = true
  });

  TextStyle copyWith({
    LogicalPixel? fontSize,
    Color? color,
    LogicalPixel? strokeWidth,
    Color? strokeColor,
    TextHorizontalAlignment? textHorizontalAlignment,
    TextPlacement? textPlacement,
    LogicalPixel? textOffset,
    Optional<String?>? fontName,
    bool? suppressOnOverlap
  }) {
    return TextStyle(
      fontSize: fontSize ?? this.fontSize,
      color: color ?? this.color,
      strokeWidth: strokeWidth ?? this.strokeWidth,
      strokeColor: strokeColor ?? this.strokeColor,
      textHorizontalAlignment: textHorizontalAlignment ?? this.textHorizontalAlignment,
      textPlacement: textPlacement ?? this.textPlacement,
      textOffset: textOffset ?? this.textOffset,
      fontName: fontName != null ? fontName.value : this.fontName,
      suppressOnOverlap: suppressOnOverlap ?? this.suppressOnOverlap
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TextStyle &&
    other.runtimeType == runtimeType &&
    other.fontSize == fontSize &&
    other.color == color &&
    other.strokeWidth == strokeWidth &&
    other.strokeColor == strokeColor &&
    other.textHorizontalAlignment == textHorizontalAlignment &&
    other.textPlacement == textPlacement &&
    other.textOffset == textOffset &&
    other.fontName == fontName &&
    other.suppressOnOverlap == suppressOnOverlap;

  @override
  int get hashCode {
    return Object.hash(fontSize, color, strokeWidth, strokeColor, textHorizontalAlignment, textPlacement, textOffset, fontName, suppressOnOverlap);
  }

}
final class _CTextStyle extends ffi.Struct {
  external _CLogicalPixel fontSize;

  external _CColor color;

  external _CLogicalPixel strokeWidth;

  external _CColor strokeColor;

  external _CTextHorizontalAlignment textHorizontalAlignment;

  external _CTextPlacement textPlacement;

  external _CLogicalPixel textOffset;

  external _COptional_CString fontName;

  @ffi.Bool()
  external bool suppressOnOverlap;

}
// MARK: - TextStyle <-> _CTextStyle

extension _CTextStyleToDart on _CTextStyle {
  TextStyle _toDart() {
    return TextStyle(
      fontSize: this.fontSize._toDart(),
      color: this.color._toDart(),
      strokeWidth: this.strokeWidth._toDart(),
      strokeColor: this.strokeColor._toDart(),
      textHorizontalAlignment: this.textHorizontalAlignment._toDart(),
      textPlacement: this.textPlacement._toDart(),
      textOffset: this.textOffset._toDart(),
      fontName: this.fontName._toDart(),
      suppressOnOverlap: this.suppressOnOverlap
    );
  }
}

extension _DartTo_CTextStyle on TextStyle {
  _CTextStyle _copyFromDartTo_CTextStyle() {
    final res = _CTextStyleMakeDefault();
    res.fontSize = this.fontSize._copyFromDartTo_CLogicalPixel();
    res.color = this.color._copyFromDartTo_CColor();
    res.strokeWidth = this.strokeWidth._copyFromDartTo_CLogicalPixel();
    res.strokeColor = this.strokeColor._copyFromDartTo_CColor();
    res.textHorizontalAlignment = this.textHorizontalAlignment._copyFromDartTo_CTextHorizontalAlignment();
    res.textPlacement = this.textPlacement._copyFromDartTo_CTextPlacement();
    res.textOffset = this.textOffset._copyFromDartTo_CLogicalPixel();
    res.fontName = this.fontName._copyFromDartTo_COptional_CString();
    res.suppressOnOverlap = this.suppressOnOverlap;
    return res;
  }
}
extension _CTextStyleRelease on _CTextStyle {
  void _releaseIntermediate() {
    fontName._releaseIntermediate();
  }
}

// MARK: - FollowPosition? <-> _COptional_CFollowPosition

final class _COptional_CFollowPosition extends ffi.Struct {
  
  external _CFollowPosition value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CFollowPositionBasicFunctions on _COptional_CFollowPosition {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CFollowPositionToDart on _COptional_CFollowPosition {
  FollowPosition? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CFollowPosition on FollowPosition? {
  _COptional_CFollowPosition _copyFromDartTo_COptional_CFollowPosition() {
    final cOptional = _COptional_CFollowPositionMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CFollowPosition();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - CameraBehaviour

/**
 Режим слежения камеры.

 Режимы камеры деградируются по следующим правилам:
 * смещение карты сбрасывает слежение за позицией (включая слежение за направлением и стилевым уровнем
 масштабирования)
 события: DirectMapShiftEvent, MapShiftBeginEvent, DirectMapRotationEvent с указанием центра события,
 DirectMapScalingEvent с указанием центра события, ScaleMapEvent с указанием центра события
 * поворот карты относительно точки позиции отбрасывает Bearing
 события: MapRotationBeginEvent, RotateMapToNorthEvent, DirectMapRotationEvent без центра события
 * изменение масштаба относительно точки позиции отбрасывает StyleZoom
 события: MapScalingBeginEvent, DirectMapScalingEvent без центра события, ScaleMapEvent без центра события
 * наклон отбрасывает Tilt
 события: DirectMapTiltEvent
*/
class CameraBehaviour {
  final FollowPosition? position;
  final FollowTilt tilt;

  const CameraBehaviour({
    required this.position,
    this.tilt = FollowTilt.off
  });

  CameraBehaviour copyWith({
    Optional<FollowPosition?>? position,
    FollowTilt? tilt
  }) {
    return CameraBehaviour(
      position: position != null ? position.value : this.position,
      tilt: tilt ?? this.tilt
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CameraBehaviour &&
    other.runtimeType == runtimeType &&
    other.position == position &&
    other.tilt == tilt;

  @override
  int get hashCode {
    return Object.hash(position, tilt);
  }

}
final class _CCameraBehaviour extends ffi.Struct {
  external _COptional_CFollowPosition position;

  external _CFollowTilt tilt;

}
// MARK: - CameraBehaviour <-> _CCameraBehaviour

extension _CCameraBehaviourToDart on _CCameraBehaviour {
  CameraBehaviour _toDart() {
    return CameraBehaviour(
      position: this.position._toDart(),
      tilt: this.tilt._toDart()
    );
  }
}

extension _DartTo_CCameraBehaviour on CameraBehaviour {
  _CCameraBehaviour _copyFromDartTo_CCameraBehaviour() {
    final res = _CCameraBehaviourMakeDefault();
    res.position = this.position._copyFromDartTo_COptional_CFollowPosition();
    res.tilt = this.tilt._copyFromDartTo_CFollowTilt();
    return res;
  }
}
extension _CCameraBehaviourRelease on _CCameraBehaviour {
  void _releaseIntermediate() {
  }
}

// MARK: - CameraBehaviourChange

/** Изменение режима слежения. */
class CameraBehaviourChange {
  /** Новый режим слежения. */
  final CameraBehaviour newBehaviour;
  /** Причина изменения режима слежения. */
  final CameraBehaviourChangeReason changeReason;

  const CameraBehaviourChange({
    required this.newBehaviour,
    this.changeReason = CameraBehaviourChangeReason.application
  });

  CameraBehaviourChange copyWith({
    CameraBehaviour? newBehaviour,
    CameraBehaviourChangeReason? changeReason
  }) {
    return CameraBehaviourChange(
      newBehaviour: newBehaviour ?? this.newBehaviour,
      changeReason: changeReason ?? this.changeReason
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CameraBehaviourChange &&
    other.runtimeType == runtimeType &&
    other.newBehaviour == newBehaviour &&
    other.changeReason == changeReason;

  @override
  int get hashCode {
    return Object.hash(newBehaviour, changeReason);
  }

}
final class _CCameraBehaviourChange extends ffi.Struct {
  external _CCameraBehaviour newBehaviour;

  external _CCameraBehaviourChangeReason changeReason;

}
// MARK: - CameraBehaviourChange <-> _CCameraBehaviourChange

extension _CCameraBehaviourChangeToDart on _CCameraBehaviourChange {
  CameraBehaviourChange _toDart() {
    return CameraBehaviourChange(
      newBehaviour: this.newBehaviour._toDart(),
      changeReason: this.changeReason._toDart()
    );
  }
}

extension _DartTo_CCameraBehaviourChange on CameraBehaviourChange {
  _CCameraBehaviourChange _copyFromDartTo_CCameraBehaviourChange() {
    final res = _CCameraBehaviourChangeMakeDefault();
    res.newBehaviour = this.newBehaviour._copyFromDartTo_CCameraBehaviour();
    res.changeReason = this.changeReason._copyFromDartTo_CCameraBehaviourChangeReason();
    return res;
  }
}
extension _CCameraBehaviourChangeRelease on _CCameraBehaviourChange {
  void _releaseIntermediate() {
  }
}

// MARK: - Zoom? <-> _COptional_CZoom

final class _COptional_CZoom extends ffi.Struct {
  
  external _CZoom value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CZoomBasicFunctions on _COptional_CZoom {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CZoomToDart on _COptional_CZoom {
  Zoom? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CZoom on Zoom? {
  _COptional_CZoom _copyFromDartTo_COptional_CZoom() {
    final cOptional = _COptional_CZoomMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CZoom();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - CameraPositionChange

/** Описание изменения части параметров позиции камеры. */
class CameraPositionChange {
  final GeoPoint? point;
  final Zoom? zoom;
  final Tilt? tilt;
  final Bearing? bearing;

  const CameraPositionChange({
    this.point = null,
    this.zoom = null,
    this.tilt = null,
    this.bearing = null
  });

  CameraPositionChange copyWith({
    Optional<GeoPoint?>? point,
    Optional<Zoom?>? zoom,
    Optional<Tilt?>? tilt,
    Optional<Bearing?>? bearing
  }) {
    return CameraPositionChange(
      point: point != null ? point.value : this.point,
      zoom: zoom != null ? zoom.value : this.zoom,
      tilt: tilt != null ? tilt.value : this.tilt,
      bearing: bearing != null ? bearing.value : this.bearing
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CameraPositionChange &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.zoom == zoom &&
    other.tilt == tilt &&
    other.bearing == bearing;

  @override
  int get hashCode {
    return Object.hash(point, zoom, tilt, bearing);
  }

}
final class _CCameraPositionChange extends ffi.Struct {
  external _COptional_CGeoPoint point;

  external _COptional_CZoom zoom;

  external _COptional_CTilt tilt;

  external _COptional_CBearing bearing;

}
// MARK: - CameraPositionChange <-> _CCameraPositionChange

extension _CCameraPositionChangeToDart on _CCameraPositionChange {
  CameraPositionChange _toDart() {
    return CameraPositionChange(
      point: this.point._toDart(),
      zoom: this.zoom._toDart(),
      tilt: this.tilt._toDart(),
      bearing: this.bearing._toDart()
    );
  }
}

extension _DartTo_CCameraPositionChange on CameraPositionChange {
  _CCameraPositionChange _copyFromDartTo_CCameraPositionChange() {
    final res = _CCameraPositionChangeMakeDefault();
    res.point = this.point._copyFromDartTo_COptional_CGeoPoint();
    res.zoom = this.zoom._copyFromDartTo_COptional_CZoom();
    res.tilt = this.tilt._copyFromDartTo_COptional_CTilt();
    res.bearing = this.bearing._copyFromDartTo_COptional_CBearing();
    return res;
  }
}
extension _CCameraPositionChangeRelease on _CCameraPositionChange {
  void _releaseIntermediate() {
  }
}

// MARK: - CameraZoomRestrictions

/** Допустимый диапазон изменения уровня масштабирования. */
class CameraZoomRestrictions {
  /** Минимальный уровень масштабирования должен быть меньше максимального. */
  final Zoom minZoom;
  /** Максимальный масштаб ограничен величиной 20. */
  final Zoom maxZoom;

  const CameraZoomRestrictions({
    this.minZoom = const Zoom(0),
    this.maxZoom = const Zoom(20)
  });

  CameraZoomRestrictions copyWith({
    Zoom? minZoom,
    Zoom? maxZoom
  }) {
    return CameraZoomRestrictions(
      minZoom: minZoom ?? this.minZoom,
      maxZoom: maxZoom ?? this.maxZoom
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CameraZoomRestrictions &&
    other.runtimeType == runtimeType &&
    other.minZoom == minZoom &&
    other.maxZoom == maxZoom;

  @override
  int get hashCode {
    return Object.hash(minZoom, maxZoom);
  }

}
final class _CCameraZoomRestrictions extends ffi.Struct {
  external _CZoom minZoom;

  external _CZoom maxZoom;

}
// MARK: - CameraZoomRestrictions <-> _CCameraZoomRestrictions

extension _CCameraZoomRestrictionsToDart on _CCameraZoomRestrictions {
  CameraZoomRestrictions _toDart() {
    return CameraZoomRestrictions(
      minZoom: this.minZoom._toDart(),
      maxZoom: this.maxZoom._toDart()
    );
  }
}

extension _DartTo_CCameraZoomRestrictions on CameraZoomRestrictions {
  _CCameraZoomRestrictions _copyFromDartTo_CCameraZoomRestrictions() {
    final res = _CCameraZoomRestrictionsMakeDefault();
    res.minZoom = this.minZoom._copyFromDartTo_CZoom();
    res.maxZoom = this.maxZoom._copyFromDartTo_CZoom();
    return res;
  }
}
extension _CCameraZoomRestrictionsRelease on _CCameraZoomRestrictions {
  void _releaseIntermediate() {
  }
}

// MARK: - GeometryMapObjectBuilder

/** Класс для установки свойств и последующего создания геометрических объектов. */
class GeometryMapObjectBuilder implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CGeometryMapObjectBuilder_releasePtr);

  GeometryMapObjectBuilder._raw(this._self);
  factory GeometryMapObjectBuilder._create(ffi.Pointer<ffi.Void> self) {
    final classObject = GeometryMapObjectBuilder._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory GeometryMapObjectBuilder() {
    _CGeometryMapObjectBuilder res = _CGeometryMapObjectBuilder_C_create();
    return GeometryMapObjectBuilder._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GeometryMapObjectBuilder &&
    other.runtimeType == runtimeType &&
    _CGeometryMapObjectBuilder_cg_objectIdentifier(this._self) == _CGeometryMapObjectBuilder_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CGeometryMapObjectBuilder_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: GeometryMapObjectBuilder: Methods

  /**
   Установка свойства объекта карты.
  
   - Parameter name: Имя свойства объекта карты.
   - Parameter value: Значение свойства объекта карты.
  */
  GeometryMapObjectBuilder setObjectAttribute(
    String name,
    AttributeValue value
  )  {
    var _a1 = name._copyFromDartTo_CString();
    var _a2 = value._copyFromDartTo_CAttributeValue();
    _CGeometryMapObjectBuilder res = _CGeometryMapObjectBuilder_setObjectAttribute_CString_CAttributeValue(_CGeometryMapObjectBuilderMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Установка свойств объекта карты.
  
   - Parameter values: набор пар "имя":"значение" для добавляемых свойства объекта карты
   - Note: метод не заменяет весь набор свойств объекта, т.е. если свойство в values отсутствует,
   но уже добавлено в объект ранее, оно не будет изменено.
  */
  GeometryMapObjectBuilder setObjectAttributes(
    core.Map<String, AttributeValue> values
  )  {
    var _a1 = values._copyFromDartTo_CDictionary_CString_CAttributeValue();
    _CGeometryMapObjectBuilder res = _CGeometryMapObjectBuilder_setObjectAttributes_CDictionary_CString_CAttributeValue(_CGeometryMapObjectBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Установка геометрии объекта карты. */
  GeometryMapObjectBuilder setGeometry(
    Geometry geometry
  )  {
    var _a1 = geometry._copyFromDartTo_CGeometry();
    _CGeometryMapObjectBuilder res = _CGeometryMapObjectBuilder_setGeometry_CGeometry(_CGeometryMapObjectBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Установка видимости объекта карты. */
  GeometryMapObjectBuilder setVisible(
    bool visible
  )  {
    _CGeometryMapObjectBuilder res = _CGeometryMapObjectBuilder_setVisible_bool(_CGeometryMapObjectBuilderMakeDefault().._impl=_self, visible);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Установка возможности перетаскивания объекта карты. */
  GeometryMapObjectBuilder setDraggable(
    bool draggable
  )  {
    _CGeometryMapObjectBuilder res = _CGeometryMapObjectBuilder_setDraggable_bool(_CGeometryMapObjectBuilderMakeDefault().._impl=_self, draggable);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Установка пользовательских данных.
  
   - Note: пользовательские данные никак не используются в SDK и нужны только чтобы возвращать их пользователю.
  */
  GeometryMapObjectBuilder setUserData(
    Object? userData
  )  {
    var _a1 = userData._copyFromDartTo_CAny();
    _CGeometryMapObjectBuilder res = _CGeometryMapObjectBuilder_setUserData_CAny(_CGeometryMapObjectBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Конструирование объекта карты.
  
   - Note: у объекта обязательно должна быть установлена геометрия
   - Note: после вызова этой функции GeometryMapObjectBuilder непригоден для задания параметров объекта карты или
   для его создания
  */
  GeometryMapObject createObject()  {
    _CGeometryMapObject res = _CGeometryMapObjectBuilder_createObject(_CGeometryMapObjectBuilderMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - GeometryMapObjectBuilder <-> CGeometryMapObjectBuilder

final class _CGeometryMapObjectBuilder extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CGeometryMapObjectBuilderBasicFunctions on _CGeometryMapObjectBuilder {
  void _releaseIntermediate() {
    _CGeometryMapObjectBuilder_release(_impl);
  }

  _CGeometryMapObjectBuilder _retain() {
    return _CGeometryMapObjectBuilder_retain(_impl);
  }
}

extension _CGeometryMapObjectBuilderToDart on _CGeometryMapObjectBuilder {
  GeometryMapObjectBuilder _toDart() {
    return GeometryMapObjectBuilder._create(_retain()._impl);
  }
}


extension _DartToCGeometryMapObjectBuilder on GeometryMapObjectBuilder {
  _CGeometryMapObjectBuilder _copyFromDartTo_CGeometryMapObjectBuilder() {
    return (_CGeometryMapObjectBuilderMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - GeometryMapObjectSourceBuilder

class GeometryMapObjectSourceBuilder implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CGeometryMapObjectSourceBuilder_releasePtr);

  GeometryMapObjectSourceBuilder._raw(this._self);
  factory GeometryMapObjectSourceBuilder._create(ffi.Pointer<ffi.Void> self) {
    final classObject = GeometryMapObjectSourceBuilder._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory GeometryMapObjectSourceBuilder(
    Context context
  ) {
    var _a0 = context._copyFromDartTo_CContext();
    _CGeometryMapObjectSourceBuilder res = _CGeometryMapObjectSourceBuilder_C_createWith_CContext(_a0);
    _a0._releaseIntermediate();
    return GeometryMapObjectSourceBuilder._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GeometryMapObjectSourceBuilder &&
    other.runtimeType == runtimeType &&
    _CGeometryMapObjectSourceBuilder_cg_objectIdentifier(this._self) == _CGeometryMapObjectSourceBuilder_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CGeometryMapObjectSourceBuilder_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: GeometryMapObjectSourceBuilder: Methods

  /**
   Установка свойства объектов карты, общего для всего источника (см. ISource).
  
   - Parameter name: Имя свойства.
   - Parameter value: Значение свойства.
  */
  GeometryMapObjectSourceBuilder setSourceAttribute(
    String name,
    AttributeValue value
  )  {
    var _a1 = name._copyFromDartTo_CString();
    var _a2 = value._copyFromDartTo_CAttributeValue();
    _CGeometryMapObjectSourceBuilder res = _CGeometryMapObjectSourceBuilder_setSourceAttribute_CString_CAttributeValue(_CGeometryMapObjectSourceBuilderMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Установка свойств объектов карты, общих для всего источника.
  
   - Parameter values: набор пар "имя":"значение" свойств
  */
  GeometryMapObjectSourceBuilder setSourceAttributes(
    core.Map<String, AttributeValue> values
  )  {
    var _a1 = values._copyFromDartTo_CDictionary_CString_CAttributeValue();
    _CGeometryMapObjectSourceBuilder res = _CGeometryMapObjectSourceBuilder_setSourceAttributes_CDictionary_CString_CAttributeValue(_CGeometryMapObjectSourceBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Добавление геометрического объекта карты в источник. */
  GeometryMapObjectSourceBuilder addObject(
    GeometryMapObject item
  )  {
    var _a1 = item._copyFromDartTo_CGeometryMapObject();
    _CGeometryMapObjectSourceBuilder res = _CGeometryMapObjectSourceBuilder_addObject_CGeometryMapObject(_CGeometryMapObjectSourceBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Добавление нескольких геометрических объектов карты в источник. */
  GeometryMapObjectSourceBuilder addObjects(
    List<GeometryMapObject> objects
  )  {
    var _a1 = objects._copyFromDartTo_CArray_CGeometryMapObject();
    _CGeometryMapObjectSourceBuilder res = _CGeometryMapObjectSourceBuilder_addObjects_CArray_CGeometryMapObject(_CGeometryMapObjectSourceBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Создание источника геометрических объектов.
  
   - Note: после вызова этой функции использовать GeometryMapObjectSourceBuilder для создания источника данных или
   для задания параметров источника данных нельзя
  */
  GeometryMapObjectSource createSource()  {
    _CGeometryMapObjectSource res = _CGeometryMapObjectSourceBuilder_createSource(_CGeometryMapObjectSourceBuilderMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - GeometryMapObjectSourceBuilder <-> CGeometryMapObjectSourceBuilder

final class _CGeometryMapObjectSourceBuilder extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CGeometryMapObjectSourceBuilderBasicFunctions on _CGeometryMapObjectSourceBuilder {
  void _releaseIntermediate() {
    _CGeometryMapObjectSourceBuilder_release(_impl);
  }

  _CGeometryMapObjectSourceBuilder _retain() {
    return _CGeometryMapObjectSourceBuilder_retain(_impl);
  }
}

extension _CGeometryMapObjectSourceBuilderToDart on _CGeometryMapObjectSourceBuilder {
  GeometryMapObjectSourceBuilder _toDart() {
    return GeometryMapObjectSourceBuilder._create(_retain()._impl);
  }
}


extension _DartToCGeometryMapObjectSourceBuilder on GeometryMapObjectSourceBuilder {
  _CGeometryMapObjectSourceBuilder _copyFromDartTo_CGeometryMapObjectSourceBuilder() {
    return (_CGeometryMapObjectSourceBuilderMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - IndoorBuilding

/** Здание с этажными планами. */
class IndoorBuilding implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Идентификатор здания с этажными планами. */
  DgisObjectId get id {
    _CDgisObjectId res = _CIndoorBuilding_id(_CIndoorBuildingMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Индекс этажа по умолчанию. */
  int get defaultLevelIndex {
    int res = _CIndoorBuilding_defaultLevelIndex(_CIndoorBuildingMakeDefault().._impl=_self);
    return res;
  }
  /** Информация обо всех этажах. */
  List<LevelInfo> get levels {
    _CArray_CLevelInfo res = _CIndoorBuilding_levels(_CIndoorBuildingMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Порядковый индекс активного этажа в levels. */
  StatefulChannel<int> get activeLevelIndexChannel {
    _CStatefulChannel_uint64_t res = _CIndoorBuilding_activeLevelIndexChannel(_CIndoorBuildingMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Порядковый индекс активного этажа в levels. */
  int get activeLevelIndex {
    int res = _CIndoorBuilding_activeLevelIndex(_CIndoorBuildingMakeDefault().._impl=_self);
    return res;
  }
  set activeLevelIndex(int levelIndex) {
    void res = _CIndoorBuilding_setActiveLevelIndex_uint64_t(_CIndoorBuildingMakeDefault().._impl=_self, levelIndex);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CIndoorBuilding_releasePtr);

  IndoorBuilding._raw(this._self);
  factory IndoorBuilding._create(ffi.Pointer<ffi.Void> self) {
    final classObject = IndoorBuilding._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is IndoorBuilding &&
    other.runtimeType == runtimeType &&
    _CIndoorBuilding_cg_objectIdentifier(this._self) == _CIndoorBuilding_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CIndoorBuilding_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - IndoorBuilding <-> CIndoorBuilding

final class _CIndoorBuilding extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CIndoorBuildingBasicFunctions on _CIndoorBuilding {
  void _releaseIntermediate() {
    _CIndoorBuilding_release(_impl);
  }

  _CIndoorBuilding _retain() {
    return _CIndoorBuilding_retain(_impl);
  }
}

extension _CIndoorBuildingToDart on _CIndoorBuilding {
  IndoorBuilding _toDart() {
    return IndoorBuilding._create(_retain()._impl);
  }
}


extension _DartToCIndoorBuilding on IndoorBuilding {
  _CIndoorBuilding _copyFromDartTo_CIndoorBuilding() {
    return (_CIndoorBuildingMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<int> <-> _CStatefulChannel_uint64_t

class _CStatefulChannel_uint64_tImpl extends StatefulChannel<int> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<int>>{};

  final _CStatefulChannel_uint64_t _channel;

  _CStatefulChannel_uint64_tImpl(this._channel);

  @override
  int get value {
    return this._channel._getter();
  }

  static void valueFunction(int cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue);
    }
    
  }

  @override
  StreamSubscription<int> listen(void onData(int event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Uint64, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<int>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_uint64_t extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_uint64_tBasicFunctions on _CStatefulChannel_uint64_t {
  void _releaseIntermediate() {
    _CStatefulChannel_uint64_t_release(this);
  }

  _CStatefulChannel_uint64_t _retain() {
    return _CStatefulChannel_uint64_t_retain(this);
  }

  int _getter() {
    final cValue = _CStatefulChannel_uint64_tGetCurrentValue(this);
    final res = cValue;
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(ffi.Uint64, ffi.Int64)> callback) {
    return _CStatefulChannel_uint64_tConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_uint64_tToDart on _CStatefulChannel_uint64_t {
  StatefulChannel<int> _toDart() {
    return _CStatefulChannel_uint64_tImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_uint64_t on StatefulChannel<int> {
  _CStatefulChannel_uint64_t _copyFromDartTo_CStatefulChannel_uint64_t() {
    return _CStatefulChannel_uint64_tMakeDefault();
  }
}
	
// MARK: - IndoorManagerState

/** Состояние отображения этажных планов. */
enum IndoorManagerState {
  /** Этажи не отображаются. */
  disabled(0),
  /** Этажи отображаются. */
  enabled(1),
  ;

  const IndoorManagerState(this.rawValue);
  final int rawValue;

  static IndoorManagerState getByValue(int value) {
    return IndoorManagerState.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CIndoorManagerState extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CIndoorManagerStateBasicFunctions on _CIndoorManagerState {
  void _releaseIntermediate() {
  }
}

extension _CIndoorManagerStateToDart on _CIndoorManagerState {
  IndoorManagerState _toDart() {
    return IndoorManagerState.getByValue(this.rawValue);
  }
}

extension _DartTo_CIndoorManagerState on IndoorManagerState {
  _CIndoorManagerState _copyFromDartTo_CIndoorManagerState() {
    return _CIndoorManagerStateMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - IndoorManager

/** Класс для получения текущего здания с этажными планами. */
class IndoorManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Получение текущего здания с этажными планами.
  
   - Returns: Текущее здание с этажными планами или нулевой указатель, если текущего здания нет
  */
  StatefulChannel<IndoorBuilding?> get focusedBuildingChannel {
    _CStatefulChannel_COptional_CIndoorBuilding res = _CIndoorManager_focusedBuildingChannel(_CIndoorManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение текущего здания с этажными планами.
  
   - Returns: Текущее здание с этажными планами или нулевой указатель, если текущего здания нет
  */
  IndoorBuilding? get focusedBuilding {
    _COptional_CIndoorBuilding res = _CIndoorManager_focusedBuilding(_CIndoorManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CIndoorManager_releasePtr);

  IndoorManager._raw(this._self);
  factory IndoorManager._create(ffi.Pointer<ffi.Void> self) {
    final classObject = IndoorManager._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is IndoorManager &&
    other.runtimeType == runtimeType &&
    _CIndoorManager_cg_objectIdentifier(this._self) == _CIndoorManager_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CIndoorManager_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: IndoorManager: Methods

  /** Переключение включенности/выключенности менеджера этажных планов */
  void setIndoorState(
    IndoorManagerState newState
  )  {
    var _a1 = newState._copyFromDartTo_CIndoorManagerState();
    void res = _CIndoorManager_setIndoorState_CIndoorManagerState(_CIndoorManagerMakeDefault().._impl=_self, _a1);
    return res;
  }

}

// MARK: - IndoorManager <-> CIndoorManager

final class _CIndoorManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CIndoorManagerBasicFunctions on _CIndoorManager {
  void _releaseIntermediate() {
    _CIndoorManager_release(_impl);
  }

  _CIndoorManager _retain() {
    return _CIndoorManager_retain(_impl);
  }
}

extension _CIndoorManagerToDart on _CIndoorManager {
  IndoorManager _toDart() {
    return IndoorManager._create(_retain()._impl);
  }
}


extension _DartToCIndoorManager on IndoorManager {
  _CIndoorManager _copyFromDartTo_CIndoorManager() {
    return (_CIndoorManagerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<IndoorBuilding?> <-> _CStatefulChannel_COptional_CIndoorBuilding

class _CStatefulChannel_COptional_CIndoorBuildingImpl extends StatefulChannel<IndoorBuilding?> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<IndoorBuilding?>>{};

  final _CStatefulChannel_COptional_CIndoorBuilding _channel;

  _CStatefulChannel_COptional_CIndoorBuildingImpl(this._channel);

  @override
  IndoorBuilding? get value {
    return this._channel._getter();
  }

  static void valueFunction(_COptional_CIndoorBuilding cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<IndoorBuilding?> listen(void onData(IndoorBuilding? event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CIndoorBuilding, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<IndoorBuilding?>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_COptional_CIndoorBuilding extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_COptional_CIndoorBuildingBasicFunctions on _CStatefulChannel_COptional_CIndoorBuilding {
  void _releaseIntermediate() {
    _CStatefulChannel_COptional_CIndoorBuilding_release(this);
  }

  _CStatefulChannel_COptional_CIndoorBuilding _retain() {
    return _CStatefulChannel_COptional_CIndoorBuilding_retain(this);
  }

  IndoorBuilding? _getter() {
    final cValue = _CStatefulChannel_COptional_CIndoorBuildingGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_COptional_CIndoorBuilding, ffi.Int64)> callback) {
    return _CStatefulChannel_COptional_CIndoorBuildingConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_COptional_CIndoorBuildingToDart on _CStatefulChannel_COptional_CIndoorBuilding {
  StatefulChannel<IndoorBuilding?> _toDart() {
    return _CStatefulChannel_COptional_CIndoorBuildingImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_COptional_CIndoorBuilding on StatefulChannel<IndoorBuilding?> {
  _CStatefulChannel_COptional_CIndoorBuilding _copyFromDartTo_CStatefulChannel_COptional_CIndoorBuilding() {
    return _CStatefulChannel_COptional_CIndoorBuildingMakeDefault();
  }
}
	
// MARK: - IndoorBuilding? <-> _COptional_CIndoorBuilding

final class _COptional_CIndoorBuilding extends ffi.Struct {
  
  external _CIndoorBuilding value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CIndoorBuildingBasicFunctions on _COptional_CIndoorBuilding {
  void _releaseIntermediate() {
    _COptional_CIndoorBuilding_release(this);
  }
}

extension _COptional_CIndoorBuildingToDart on _COptional_CIndoorBuilding {
  IndoorBuilding? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CIndoorBuilding on IndoorBuilding? {
  _COptional_CIndoorBuilding _copyFromDartTo_COptional_CIndoorBuilding() {
    final cOptional = _COptional_CIndoorBuildingMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CIndoorBuilding();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - IndoorControlModel

/** Модель элемента управления этажами. */
class IndoorControlModel implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Индекс активного этажа. */
  StatefulChannel<int?> get activeLevelIndexChannel {
    _CStatefulChannel_COptional_uint64_t res = _CIndoorControlModel_activeLevelIndexChannel(_CIndoorControlModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Индекс активного этажа. */
  int? get activeLevelIndex {
    _COptional_uint64_t res = _CIndoorControlModel_activeLevelIndex(_CIndoorControlModelMakeDefault().._impl=_self);
    return res._toDart();
  }
  set activeLevelIndex(int? activeIndex) {
    var _a1 = activeIndex._copyFromDartTo_COptional_uint64_t();
    void res = _CIndoorControlModel_setActiveLevelIndex_COptional_uint64_t(_CIndoorControlModelMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Этажи, на которых отображаются пометки. */
  Set<LevelId> get markedLevels {
    _CSet_CLevelId res = _CIndoorControlModel_markedLevels(_CIndoorControlModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set markedLevels(Set<LevelId> markedLevels) {
    var _a1 = markedLevels._copyFromDartTo_CSet_CLevelId();
    void res = _CIndoorControlModel_setMarkedLevels_CSet_CLevelId(_CIndoorControlModelMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /**
   Названия этажей.
   Пусто, если на карте не отображается здание с этажными планами, или у здания всего один этаж.
  */
  StatefulChannel<List<String>> get levelNamesChannel {
    _CStatefulChannel_CArray_CString res = _CIndoorControlModel_levelNamesChannel(_CIndoorControlModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Названия этажей.
   Пусто, если на карте не отображается здание с этажными планами, или у здания всего один этаж.
  */
  List<String> get levelNames {
    _CArray_CString res = _CIndoorControlModel_levelNames(_CIndoorControlModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CIndoorControlModel_releasePtr);

  IndoorControlModel._raw(this._self);
  factory IndoorControlModel._create(ffi.Pointer<ffi.Void> self) {
    final classObject = IndoorControlModel._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory IndoorControlModel(
    Map map
  ) {
    var _a0 = map._copyFromDartTo_CMap();
    _CIndoorControlModel res = _CIndoorControlModel_C_createWith_CMap(_a0);
    _a0._releaseIntermediate();
    return IndoorControlModel._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is IndoorControlModel &&
    other.runtimeType == runtimeType &&
    _CIndoorControlModel_cg_objectIdentifier(this._self) == _CIndoorControlModel_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CIndoorControlModel_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: IndoorControlModel: Methods

  /** Нужно ли отображать пометку у этажа с указанным индексом. */
  bool isLevelMarked(
    int index
  )  {
    bool res = _CIndoorControlModel_isLevelMarked_uint64_t(_CIndoorControlModelMakeDefault().._impl=_self, index);
    return res;
  }

}

// MARK: - IndoorControlModel <-> CIndoorControlModel

final class _CIndoorControlModel extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CIndoorControlModelBasicFunctions on _CIndoorControlModel {
  void _releaseIntermediate() {
    _CIndoorControlModel_release(_impl);
  }

  _CIndoorControlModel _retain() {
    return _CIndoorControlModel_retain(_impl);
  }
}

extension _CIndoorControlModelToDart on _CIndoorControlModel {
  IndoorControlModel _toDart() {
    return IndoorControlModel._create(_retain()._impl);
  }
}


extension _DartToCIndoorControlModel on IndoorControlModel {
  _CIndoorControlModel _copyFromDartTo_CIndoorControlModel() {
    return (_CIndoorControlModelMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<int?> <-> _CStatefulChannel_COptional_uint64_t

class _CStatefulChannel_COptional_uint64_tImpl extends StatefulChannel<int?> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<int?>>{};

  final _CStatefulChannel_COptional_uint64_t _channel;

  _CStatefulChannel_COptional_uint64_tImpl(this._channel);

  @override
  int? get value {
    return this._channel._getter();
  }

  static void valueFunction(_COptional_uint64_t cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<int?> listen(void onData(int? event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_uint64_t, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<int?>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_COptional_uint64_t extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_COptional_uint64_tBasicFunctions on _CStatefulChannel_COptional_uint64_t {
  void _releaseIntermediate() {
    _CStatefulChannel_COptional_uint64_t_release(this);
  }

  _CStatefulChannel_COptional_uint64_t _retain() {
    return _CStatefulChannel_COptional_uint64_t_retain(this);
  }

  int? _getter() {
    final cValue = _CStatefulChannel_COptional_uint64_tGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_COptional_uint64_t, ffi.Int64)> callback) {
    return _CStatefulChannel_COptional_uint64_tConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_COptional_uint64_tToDart on _CStatefulChannel_COptional_uint64_t {
  StatefulChannel<int?> _toDart() {
    return _CStatefulChannel_COptional_uint64_tImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_COptional_uint64_t on StatefulChannel<int?> {
  _CStatefulChannel_COptional_uint64_t _copyFromDartTo_CStatefulChannel_COptional_uint64_t() {
    return _CStatefulChannel_COptional_uint64_tMakeDefault();
  }
}
	
// MARK: - Set<LevelId> <-> _CSet_CLevelId

final class _CSet_CLevelId extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSet_CLevelIdToDart on _CSet_CLevelId {
  Set<LevelId> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CSet_CLevelId on Set<LevelId> {
  _CSet_CLevelId _copyFromDartTo_CSet_CLevelId() {
    final cSet = _CSet_CLevelIdmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CLevelId();
        _CSet_CLevelIdaddElement(cSet, cItem);
        
    });
    return cSet;
  }
}

extension _CSet_CLevelIdBasicFunctions on _CSet_CLevelId {
  void _releaseIntermediate() {
    _CSet_CLevelId_release(this);
  }

 static final _setToFill = <LevelId>{};

  static void _iterate(_CLevelId item) {
    _setToFill.add(item._toDart());
  }

  Set<LevelId> _fillFromC() {
    _forEach_CSet_CLevelId(this, ffi.Pointer.fromFunction<ffi.Void Function(_CLevelId)>(_iterate));
    final result = Set<LevelId>.from(_setToFill);
    _setToFill.clear();
    return result;
  }
}
	
// MARK: - StatefulChannel<List<String>> <-> _CStatefulChannel_CArray_CString

class _CStatefulChannel_CArray_CStringImpl extends StatefulChannel<List<String>> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<List<String>>>{};

  final _CStatefulChannel_CArray_CString _channel;

  _CStatefulChannel_CArray_CStringImpl(this._channel);

  @override
  List<String> get value {
    return this._channel._getter();
  }

  static void valueFunction(_CArray_CString cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<List<String>> listen(void onData(List<String> event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CString, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<List<String>>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CArray_CString extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CArray_CStringBasicFunctions on _CStatefulChannel_CArray_CString {
  void _releaseIntermediate() {
    _CStatefulChannel_CArray_CString_release(this);
  }

  _CStatefulChannel_CArray_CString _retain() {
    return _CStatefulChannel_CArray_CString_retain(this);
  }

  List<String> _getter() {
    final cValue = _CStatefulChannel_CArray_CStringGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CArray_CString, ffi.Int64)> callback) {
    return _CStatefulChannel_CArray_CStringConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CArray_CStringToDart on _CStatefulChannel_CArray_CString {
  StatefulChannel<List<String>> _toDart() {
    return _CStatefulChannel_CArray_CStringImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CArray_CString on StatefulChannel<List<String>> {
  _CStatefulChannel_CArray_CString _copyFromDartTo_CStatefulChannel_CArray_CString() {
    return _CStatefulChannel_CArray_CStringMakeDefault();
  }
}
	
// MARK: - Map

/** Карта. */
class Map implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Идентификатор экземпляра карты, уникальный в рамках процесса. */
  MapId get id {
    _CMapId res = _CMap_id(_CMapMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Получение камеры. */
  Camera get camera {
    _CCamera res = _CMap_camera(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение менеджера этажных планов. */
  IndoorManager get indoorManager {
    _CIndoorManager res = _CMap_indoorManager(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Нотификация о состоянии загружаемых в карту данных.
  
   - Note: При слежении за позицией камеры состояние карты всегда будет MapDataLoadingState::Loading.
  */
  StatefulChannel<MapDataLoadingState> get dataLoadingStateChannel {
    _CStatefulChannel_CMapDataLoadingState res = _CMap_dataLoadingStateChannel(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Нотификация о состоянии загружаемых в карту данных.
  
   - Note: При слежении за позицией камеры состояние карты всегда будет MapDataLoadingState::Loading.
  */
  MapDataLoadingState get dataLoadingState {
    _CMapDataLoadingState res = _CMap_dataLoadingState(_CMapMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Получение текущих стилей карты. */
  StatefulChannel<Style> get styleChannel {
    _CStatefulChannel_CStyle res = _CMap_styleChannel(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение текущих стилей карты. */
  Style get style {
    _CStyle res = _CMap_style(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set style(Style style) {
    var _a1 = style._copyFromDartTo_CStyle();
    void res = _CMap_setStyle_CStyle(_CMapMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /**
   Множитель размера иконок и шрифтов, полученный из приложения.
  
   Размер иконок и шрифтов задаётся в логических пикселях (см. LogicalPixel)
   и умножается на множитель размера шрифтов и иконок.
  */
  StatefulChannel<double> get fontIconSizeMultiplierChannel {
    _CStatefulChannel_float res = _CMap_fontIconSizeMultiplierChannel(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Множитель размера иконок и шрифтов, полученный из приложения.
  
   Размер иконок и шрифтов задаётся в логических пикселях (см. LogicalPixel)
   и умножается на множитель размера шрифтов и иконок.
  */
  double get fontIconSizeMultiplier {
    double res = _CMap_fontIconSizeMultiplier(_CMapMakeDefault().._impl=_self);
    return res;
  }
  set fontIconSizeMultiplier(double multiplier) {
    _CResult_CEmpty res = _CMap_setFontIconSizeMultiplier_float(_CMapMakeDefault().._impl=_self, multiplier);
    res._toDart();
    res._releaseIntermediate();
  }
  /**
   Получение источников данных карты.
  
   - Note: Происходит асинхронно. Метод может вызываться из любого потока, потокобезопасен.
  */
  List<Source> get sources {
    _CArray_CSource res = _CMap_getSources(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  StatefulChannel<MapVisibilityState> get mapVisibilityStateChannel {
    _CStatefulChannel_CMapVisibilityState res = _CMap_mapVisibilityStateChannel(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  MapVisibilityState get mapVisibilityState {
    _CMapVisibilityState res = _CMap_mapVisibilityState(_CMapMakeDefault().._impl=_self);
    return res._toDart();
  }
  set mapVisibilityState(MapVisibilityState state) {
    var _a1 = state._copyFromDartTo_CMapVisibilityState();
    void res = _CMap_setMapVisibilityState_CMapVisibilityState(_CMapMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Сигнал, сообщающий о необходимости отрисовки очередного кадра.
  
   - Note: Может быть вызван из метода paint(), например, если активна какая-то анимация или производится перелёт.
  */
  Channel<bool> get needRedraw {
    _CChannel_bool res = _CMap_needRedraw(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение атрибутов.
  
   - Note: должны быть указаны свойства:
   "theme"="day|night"
   "navigatorOn"="true|false"
   - Todo: стилевые свойства для пробок
  */
  Attributes get attributes {
    _CAttributes res = _CMap_attributes(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Интерактивность карты.
   Под интерактивностью понимается наличие у пользователя возможности взаимодействия с картой.
   При отключении интерактивности карта перестанет реагировать на события ввода, пришедшие от пользователя.
   Также перестанут работать контролы для работы с картой (приближения и перехода к текущему положению).
   При этом остаётся возможность работать с картой через set_position/move.
   При переходе в неинтерактивное состояние незавершённые жесты будут сброшены.
   По умолчанию карта интерактивна (interactive == true).
  
   - Note: функция может быть вызвана из любого потока.
  */
  StatefulChannel<bool> get interactiveChannel {
    _CStatefulChannel_bool res = _CMap_interactiveChannel(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Интерактивность карты.
   Под интерактивностью понимается наличие у пользователя возможности взаимодействия с картой.
   При отключении интерактивности карта перестанет реагировать на события ввода, пришедшие от пользователя.
   Также перестанут работать контролы для работы с картой (приближения и перехода к текущему положению).
   При этом остаётся возможность работать с картой через set_position/move.
   При переходе в неинтерактивное состояние незавершённые жесты будут сброшены.
   По умолчанию карта интерактивна (interactive == true).
  
   - Note: функция может быть вызвана из любого потока.
  */
  bool get interactive {
    bool res = _CMap_interactive(_CMapMakeDefault().._impl=_self);
    return res;
  }
  set interactive(bool interactive) {
    void res = _CMap_setInteractive_bool(_CMapMakeDefault().._impl=_self, interactive);
    return res;
  }
  /**
   Необходимость скрытия копирайта на карте.
   По умолчанию копирайт отображается (hide_copyright == false).
  
   - Note: функция может быть вызвана из любого потока.
  */
  StatefulChannel<bool> get hideCopyrightChannel {
    _CStatefulChannel_bool res = _CMap_hideCopyrightChannel(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Необходимость скрытия копирайта на карте.
   По умолчанию копирайт отображается (hide_copyright == false).
  
   - Note: функция может быть вызвана из любого потока.
  */
  bool get hideCopyright {
    bool res = _CMap_hideCopyright(_CMapMakeDefault().._impl=_self);
    return res;
  }
  /**
   Тип продукта в копирайте, который настраивается в ключе.
   По умолчанию отображается 2GIS (product_type == dgis).
  
   - Note: функция может быть вызвана из любого потока.
  */
  StatefulChannel<ProductType> get productTypeChannel {
    _CStatefulChannel_CProductType res = _CMap_productTypeChannel(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Тип продукта в копирайте, который настраивается в ключе.
   По умолчанию отображается 2GIS (product_type == dgis).
  
   - Note: функция может быть вызвана из любого потока.
  */
  ProductType get productType {
    _CProductType res = _CMap_productType(_CMapMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Получение рекомендуемого режима графики для данного устройства. */
  StatefulChannel<GraphicsPreset?> get graphicsPresetHintChannel {
    _CStatefulChannel_COptional_CGraphicsPreset res = _CMap_graphicsPresetHintChannel(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение рекомендуемого режима графики для данного устройства. */
  GraphicsPreset? get graphicsPresetHint {
    _COptional_CGraphicsPreset res = _CMap_graphicsPresetHint(_CMapMakeDefault().._impl=_self);
    return res._toDart();
  }
  /**
   Получение режима графики.
   В случае null используется рекомендуемый режим.
   Если определить рекомендуемый режим не удалось, то используется Normal.
  */
  StatefulChannel<GraphicsPreset?> get graphicsPresetChannel {
    _CStatefulChannel_COptional_CGraphicsPreset res = _CMap_graphicsPresetChannel(_CMapMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение режима графики.
   В случае null используется рекомендуемый режим.
   Если определить рекомендуемый режим не удалось, то используется Normal.
  */
  GraphicsPreset? get graphicsPreset {
    _COptional_CGraphicsPreset res = _CMap_graphicsPreset(_CMapMakeDefault().._impl=_self);
    return res._toDart();
  }
  set graphicsPreset(GraphicsPreset? graphicsPreset) {
    var _a1 = graphicsPreset._copyFromDartTo_COptional_CGraphicsPreset();
    void res = _CMap_setGraphicsPreset_COptional_CGraphicsPreset(_CMapMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CMap_releasePtr);

  Map._raw(this._self);
  factory Map._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Map._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Map &&
    other.runtimeType == runtimeType &&
    _CMap_cg_objectIdentifier(this._self) == _CMap_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMap_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: Map: Methods

  /** Сбросить множитель размера для иконок. */
  void resetFontIconSizeMultiplier()  {
    void res = _CMap_resetFontIconSizeMultiplier(_CMapMakeDefault().._impl=_self);
    return res;
  }

  /**
   Добавление источника данных на карту.
  
   - Note: Происходит асинхронно. Метод может вызываться из любого потока, потокобезопасен.
  */
  void addSource(
    Source source
  )  {
    var _a1 = source._copyFromDartTo_CSource();
    void res = _CMap_addSource_CSource(_CMapMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Удаление источника данных из карты.
  
   - Note: Происходит асинхронно. Метод может вызываться из любого потока, потокобезопасен.
  */
  void removeSource(
    Source source
  )  {
    var _a1 = source._copyFromDartTo_CSource();
    void res = _CMap_removeSource_CSource(_CMapMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Получение отображаемых объектов карты, проецирующихся на окружность на экране.
  
   - Parameter centerPoint: центр окружности.
   - Parameter radius: радиус окружности.
   - Note: Список объектов формируется в порядке отрисовки от поздних к ранним.
  */
  CancelableOperation<List<RenderedObjectInfo>> getRenderedObjects(
    ScreenPoint centerPoint,
    [ScreenDistance radius = const ScreenDistance(1)
    ])  {
    var _a1 = centerPoint._copyFromDartTo_CScreenPoint();
    var _a2 = radius._copyFromDartTo_CScreenDistance();
    _CFuture_CArray_CRenderedObjectInfo res = _CMap_getRenderedObjects_CScreenPoint_CScreenDistance(_CMapMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Получение атрибутов подслоя.
  
   - Parameter sublayerName: Название подслоя.
   - Note: Полученные атрибуты содержат только добавленные туда ранее (явно).
  */
  Attributes sublayerAttributes(
    String sublayerName
  )  {
    var _a1 = sublayerName._copyFromDartTo_CString();
    _CAttributes res = _CMap_sublayerAttributes_CString(_CMapMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

@internal
extension MapInternalMethods on Map {
  /** Установка множителя размера для иконок шрифтов, получаемый из системы. */
  @internal
  void setSystemFontIconSizeMultiplier(
    double multiplier
  )  {
    _CResult_CEmpty res = _CMap_setSystemFontIconSizeMultiplier_float(_CMapMakeDefault().._impl=_self, multiplier);
    res._toDart();
    res._releaseIntermediate();
  }

  /** Обработка события управления картой. */
  @internal
  void processEvent(
    Event event
  )  {
    var _a1 = event._copyFromDartTo_CEvent();
    void res = _CMap_processEvent_CEvent(_CMapMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /**
   Получение изображения карты.
   Возможно только после отрисовки карты.
  
   - Note: функция должна вызываться из render-очереди.
  */
  @internal
  ImageData takeSnapshot(
    Alignment copyrightAlign
  )  {
    var _a1 = copyrightAlign._copyFromDartTo_CAlignment();
    _CResult_CImageData res = _CMap_takeSnapshot_CAlignment(_CMapMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  @internal
  CancelableOperation<RenderedObjectInfo?> getMapObject(
    ScreenPoint centerPoint,
    ScreenDistance radius
  )  {
    var _a1 = centerPoint._copyFromDartTo_CScreenPoint();
    var _a2 = radius._copyFromDartTo_CScreenDistance();
    _CFuture_COptional_CRenderedObjectInfo res = _CMap_getMapObject_CScreenPoint_CScreenDistance(_CMapMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - Map <-> CMap

final class _CMap extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapBasicFunctions on _CMap {
  void _releaseIntermediate() {
    _CMap_release(_impl);
  }

  _CMap _retain() {
    return _CMap_retain(_impl);
  }
}

extension _CMapToDart on _CMap {
  Map _toDart() {
    return Map._create(_retain()._impl);
  }
}


extension _DartToCMap on Map {
  _CMap _copyFromDartTo_CMap() {
    return (_CMapMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Camera

/** Камера для запуска перемещения карты и настроек слежения. */
class Camera extends BaseCamera implements ffi.Finalizable {
  /** Получение актуального состояния камеры. */
  StatefulChannel<CameraState> get stateChannel {
    _CStatefulChannel_CCameraState res = _CCamera_stateChannel(_CCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение актуального состояния камеры. */
  CameraState get state {
    _CCameraState res = _CCamera_state(_CCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Режим слежения камеры. */
  StatefulChannel<CameraBehaviourChange> get behaviourChannel {
    _CStatefulChannel_CCameraBehaviourChange res = _CCamera_behaviourChannel(_CCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Режим слежения камеры. */
  CameraBehaviourChange get behaviour {
    _CCameraBehaviourChange res = _CCamera_behaviour(_CCameraMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CCamera_releasePtr);

  Camera._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory Camera._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Camera._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Camera &&
    other.runtimeType == runtimeType &&
    _CCamera_cg_objectIdentifier(this._self) == _CCamera_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCamera_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: Camera: Methods

  /**
   Запуск анимированного перемещения карты с использованием встроенного контроллера перемещений карты.
  
   - Note: Сбрасывает слежение за позицией, уровнем масштабирования, наклоном и направлением и прерывает обработку жестов.
   - Parameter position: Конечная позиция камеры.
   - Parameter time: Время, выделенное на перемещение карты.
   - Parameter animationType: Тип анимации при перемещении камеры.
  */
  CancelableOperation<CameraAnimatedMoveResult> moveToCameraPosition(
    CameraPosition position,
    [Duration time = const Duration(milliseconds: 300),
    CameraAnimationType animationType = CameraAnimationType.default_
    ])  {
    var _a1 = position._copyFromDartTo_CCameraPosition();
    var _a2 = time._copyFromDartTo_CTimeInterval();
    var _a3 = animationType._copyFromDartTo_CCameraAnimationType();
    _CFuture_CCameraAnimatedMoveResult res = _CCamera_moveToCameraPosition_CCameraPosition_CTimeInterval_CCameraAnimationType(_CCameraMakeDefault().._impl=_self, _a1, _a2, _a3);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Запуск анимированного перемещения карты с использованием встроенного контроллера перемещений карты.
  
   - Note: Сбрасывает слежение за позицией, уровнем масштабирования и направлением и прерывает обработку жестов.
   - Note: Если tilt задан, то сбрасывается слежение за наклоном.
   - Note: Если tilt не задан и слежения за наклоном нет, то используется текущее значение наклона.
   - Parameter point: точка конечной позиции камеры
   - Parameter zoom: уровень масштабирования в конечной позиции камеры
   - Parameter tilt: наклон в конечной позиции камеры или пустое значение, если нужно
   в зависимости от активного режима слежения использовать значение из follow controller'а или текущее значение
   - Parameter bearing: поворот в конечной позиции камеры
   - Parameter time: время, выделенное на перемещение карты
   - Parameter animationType: тип анимации при перемещении камеры
  */
  CancelableOperation<CameraAnimatedMoveResult> move(
    GeoPoint point,
    Zoom zoom,
    Tilt? tilt,
    Bearing bearing,
    [Duration time = const Duration(milliseconds: 300),
    CameraAnimationType animationType = CameraAnimationType.default_
    ])  {
    var _a1 = point._copyFromDartTo_CGeoPoint();
    var _a2 = zoom._copyFromDartTo_CZoom();
    var _a3 = tilt._copyFromDartTo_COptional_CTilt();
    var _a4 = bearing._copyFromDartTo_CBearing();
    var _a5 = time._copyFromDartTo_CTimeInterval();
    var _a6 = animationType._copyFromDartTo_CCameraAnimationType();
    _CFuture_CCameraAnimatedMoveResult res = _CCamera_move_CGeoPoint_CZoom_COptional_CTilt_CBearing_CTimeInterval_CCameraAnimationType(_CCameraMakeDefault().._impl=_self, _a1, _a2, _a3, _a4, _a5, _a6);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Установка позиции камеры в соответствие с текущим временем и прекращение анимированного перемещения.
  
   - Note: Вызов прерывает перелёт и обработку жестов,
   а также сбрасывает слежение за позицией, уровнем масштабирования и направлением.
  */
  void processMovementAndStop()  {
    void res = _CCamera_processMovementAndStop(_CCameraMakeDefault().._impl=_self);
    return res;
  }

  /**
   Смена режима слежения камеры.
   Если новый режим более ограниченный, чем текущий, вызов прервёт перелёт и обработку жестов.
  */
  void setBehaviour(
    CameraBehaviour behaviour
  )  {
    var _a1 = behaviour._copyFromDartTo_CCameraBehaviour();
    void res = _CCamera_setBehaviour_CCameraBehaviour(_CCameraMakeDefault().._impl=_self, _a1);
    return res;
  }

  /**
   Добавление контроллера слежения.
  
   Их может быть несколько разных, например контроллер слежения за масштабом, за углом наклона карты,
   за геолокацией и т.д.
  */
  void addFollowController(
    FollowController followController
  )  {
    var _a1 = followController._copyFromDartTo_CFollowController();
    void res = _CCamera_addFollowController_CFollowController(_CCameraMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Удаление контроллера слежения. */
  void removeFollowController(
    FollowController followController
  )  {
    var _a1 = followController._copyFromDartTo_CFollowController();
    void res = _CCamera_removeFollowController_CFollowController(_CCameraMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Удаление контроллера слежения, реализованного на платформе. */
  void removeCustomFollowController()  {
    void res = _CCamera_removeCustomFollowController(_CCameraMakeDefault().._impl=_self);
    return res;
  }

  CancelableOperation<CameraAnimatedMoveResult> moveWithController(
    CameraMoveController moveController
  )  {
    var _a1 = moveController._copyFromDartTo_CCameraMoveController();
    _CFuture_CCameraAnimatedMoveResult res = _CCamera_moveWithController_CCameraMoveController(_CCameraMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  void setCustomFollowController(
    CustomFollowController followController
  )  {
    var _a1 = followController._copyFromDartTo_CCustomFollowController();
    void res = _CCamera_setCustomFollowController_CCustomFollowController(_CCameraMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - Camera <-> CCamera

final class _CCamera extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCameraBasicFunctions on _CCamera {
  void _releaseIntermediate() {
    _CCamera_release(_impl);
  }

  _CCamera _retain() {
    return _CCamera_retain(_impl);
  }
}

extension _CCameraToDart on _CCamera {
  Camera _toDart() {
    return Camera._create(_retain()._impl);
  }
}


extension _DartToCCamera on Camera {
  _CCamera _copyFromDartTo_CCamera() {
    return (_CCameraMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CancelableOperation<CameraAnimatedMoveResult> <-> _CFuture_CCameraAnimatedMoveResult

final class _CFuture_CCameraAnimatedMoveResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CCameraAnimatedMoveResult_Cancellable {
  final Completer<CameraAnimatedMoveResult> completer;
  final _CFuture_CCameraAnimatedMoveResult _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CCameraAnimatedMoveResult, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CCameraAnimatedMoveResult_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CCameraAnimatedMoveResultBasicFunctions on _CFuture_CCameraAnimatedMoveResult {
  void _releaseIntermediate() {
    _CFuture_CCameraAnimatedMoveResult_release(this);
  }

  _CFuture_CCameraAnimatedMoveResult _retain() {
    return _CFuture_CCameraAnimatedMoveResult_retain(this);
  }
}

extension _CFuture_CCameraAnimatedMoveResultToDart on _CFuture_CCameraAnimatedMoveResult {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CCameraAnimatedMoveResult_Cancellable>{};

  static void valueFunction(_CCameraAnimatedMoveResult cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<CameraAnimatedMoveResult> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<CameraAnimatedMoveResult>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CCameraAnimatedMoveResult, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CCameraAnimatedMoveResultReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CCameraAnimatedMoveResult_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CCameraAnimatedMoveResult on CancelableOperation<CameraAnimatedMoveResult> {
  _CFuture_CCameraAnimatedMoveResult _copyFromDartTo_CFuture_CCameraAnimatedMoveResult() {
    return _CFuture_CCameraAnimatedMoveResultMakeDefault();
  }
}
	
// MARK: - StatefulChannel<CameraState> <-> _CStatefulChannel_CCameraState

class _CStatefulChannel_CCameraStateImpl extends StatefulChannel<CameraState> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<CameraState>>{};

  final _CStatefulChannel_CCameraState _channel;

  _CStatefulChannel_CCameraStateImpl(this._channel);

  @override
  CameraState get value {
    return this._channel._getter();
  }

  static void valueFunction(_CCameraState cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<CameraState> listen(void onData(CameraState event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CCameraState, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<CameraState>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CCameraState extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CCameraStateBasicFunctions on _CStatefulChannel_CCameraState {
  void _releaseIntermediate() {
    _CStatefulChannel_CCameraState_release(this);
  }

  _CStatefulChannel_CCameraState _retain() {
    return _CStatefulChannel_CCameraState_retain(this);
  }

  CameraState _getter() {
    final cValue = _CStatefulChannel_CCameraStateGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CCameraState, ffi.Int64)> callback) {
    return _CStatefulChannel_CCameraStateConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CCameraStateToDart on _CStatefulChannel_CCameraState {
  StatefulChannel<CameraState> _toDart() {
    return _CStatefulChannel_CCameraStateImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CCameraState on StatefulChannel<CameraState> {
  _CStatefulChannel_CCameraState _copyFromDartTo_CStatefulChannel_CCameraState() {
    return _CStatefulChannel_CCameraStateMakeDefault();
  }
}
	
// MARK: - StatefulChannel<CameraBehaviourChange> <-> _CStatefulChannel_CCameraBehaviourChange

class _CStatefulChannel_CCameraBehaviourChangeImpl extends StatefulChannel<CameraBehaviourChange> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<CameraBehaviourChange>>{};

  final _CStatefulChannel_CCameraBehaviourChange _channel;

  _CStatefulChannel_CCameraBehaviourChangeImpl(this._channel);

  @override
  CameraBehaviourChange get value {
    return this._channel._getter();
  }

  static void valueFunction(_CCameraBehaviourChange cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<CameraBehaviourChange> listen(void onData(CameraBehaviourChange event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CCameraBehaviourChange, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<CameraBehaviourChange>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CCameraBehaviourChange extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CCameraBehaviourChangeBasicFunctions on _CStatefulChannel_CCameraBehaviourChange {
  void _releaseIntermediate() {
    _CStatefulChannel_CCameraBehaviourChange_release(this);
  }

  _CStatefulChannel_CCameraBehaviourChange _retain() {
    return _CStatefulChannel_CCameraBehaviourChange_retain(this);
  }

  CameraBehaviourChange _getter() {
    final cValue = _CStatefulChannel_CCameraBehaviourChangeGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CCameraBehaviourChange, ffi.Int64)> callback) {
    return _CStatefulChannel_CCameraBehaviourChangeConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CCameraBehaviourChangeToDart on _CStatefulChannel_CCameraBehaviourChange {
  StatefulChannel<CameraBehaviourChange> _toDart() {
    return _CStatefulChannel_CCameraBehaviourChangeImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CCameraBehaviourChange on StatefulChannel<CameraBehaviourChange> {
  _CStatefulChannel_CCameraBehaviourChange _copyFromDartTo_CStatefulChannel_CCameraBehaviourChange() {
    return _CStatefulChannel_CCameraBehaviourChangeMakeDefault();
  }
}
	
// MARK: - StatefulChannel<MapDataLoadingState> <-> _CStatefulChannel_CMapDataLoadingState

class _CStatefulChannel_CMapDataLoadingStateImpl extends StatefulChannel<MapDataLoadingState> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<MapDataLoadingState>>{};

  final _CStatefulChannel_CMapDataLoadingState _channel;

  _CStatefulChannel_CMapDataLoadingStateImpl(this._channel);

  @override
  MapDataLoadingState get value {
    return this._channel._getter();
  }

  static void valueFunction(_CMapDataLoadingState cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<MapDataLoadingState> listen(void onData(MapDataLoadingState event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CMapDataLoadingState, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<MapDataLoadingState>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CMapDataLoadingState extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CMapDataLoadingStateBasicFunctions on _CStatefulChannel_CMapDataLoadingState {
  void _releaseIntermediate() {
    _CStatefulChannel_CMapDataLoadingState_release(this);
  }

  _CStatefulChannel_CMapDataLoadingState _retain() {
    return _CStatefulChannel_CMapDataLoadingState_retain(this);
  }

  MapDataLoadingState _getter() {
    final cValue = _CStatefulChannel_CMapDataLoadingStateGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CMapDataLoadingState, ffi.Int64)> callback) {
    return _CStatefulChannel_CMapDataLoadingStateConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CMapDataLoadingStateToDart on _CStatefulChannel_CMapDataLoadingState {
  StatefulChannel<MapDataLoadingState> _toDart() {
    return _CStatefulChannel_CMapDataLoadingStateImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CMapDataLoadingState on StatefulChannel<MapDataLoadingState> {
  _CStatefulChannel_CMapDataLoadingState _copyFromDartTo_CStatefulChannel_CMapDataLoadingState() {
    return _CStatefulChannel_CMapDataLoadingStateMakeDefault();
  }
}
	
// MARK: - StatefulChannel<Style> <-> _CStatefulChannel_CStyle

class _CStatefulChannel_CStyleImpl extends StatefulChannel<Style> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<Style>>{};

  final _CStatefulChannel_CStyle _channel;

  _CStatefulChannel_CStyleImpl(this._channel);

  @override
  Style get value {
    return this._channel._getter();
  }

  static void valueFunction(_CStyle cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<Style> listen(void onData(Style event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CStyle, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<Style>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CStyle extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CStyleBasicFunctions on _CStatefulChannel_CStyle {
  void _releaseIntermediate() {
    _CStatefulChannel_CStyle_release(this);
  }

  _CStatefulChannel_CStyle _retain() {
    return _CStatefulChannel_CStyle_retain(this);
  }

  Style _getter() {
    final cValue = _CStatefulChannel_CStyleGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CStyle, ffi.Int64)> callback) {
    return _CStatefulChannel_CStyleConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CStyleToDart on _CStatefulChannel_CStyle {
  StatefulChannel<Style> _toDart() {
    return _CStatefulChannel_CStyleImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CStyle on StatefulChannel<Style> {
  _CStatefulChannel_CStyle _copyFromDartTo_CStatefulChannel_CStyle() {
    return _CStatefulChannel_CStyleMakeDefault();
  }
}
	
// MARK: - StatefulChannel<double> <-> _CStatefulChannel_float

class _CStatefulChannel_floatImpl extends StatefulChannel<double> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<double>>{};

  final _CStatefulChannel_float _channel;

  _CStatefulChannel_floatImpl(this._channel);

  @override
  double get value {
    return this._channel._getter();
  }

  static void valueFunction(double cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue);
    }
    
  }

  @override
  StreamSubscription<double> listen(void onData(double event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Float, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<double>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_float extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_floatBasicFunctions on _CStatefulChannel_float {
  void _releaseIntermediate() {
    _CStatefulChannel_float_release(this);
  }

  _CStatefulChannel_float _retain() {
    return _CStatefulChannel_float_retain(this);
  }

  double _getter() {
    final cValue = _CStatefulChannel_floatGetCurrentValue(this);
    final res = cValue;
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(ffi.Float, ffi.Int64)> callback) {
    return _CStatefulChannel_floatConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_floatToDart on _CStatefulChannel_float {
  StatefulChannel<double> _toDart() {
    return _CStatefulChannel_floatImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_float on StatefulChannel<double> {
  _CStatefulChannel_float _copyFromDartTo_CStatefulChannel_float() {
    return _CStatefulChannel_floatMakeDefault();
  }
}
	
// MARK: - void <-> _CResult_CEmpty

final class _CResult_CEmptyImpl extends ffi.Union {
  external _CEmpty _value;
  external _CError _error;
}

final class _CResult_CEmpty extends ffi.Struct {
  external _CResult_CEmptyImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CEmptyBasicFunctions on _CResult_CEmpty {
  void _releaseIntermediate() {
    _CResult_CEmpty_release(this);
  }
}

extension _CResult_CEmptyToDart on _CResult_CEmpty {
  void _toDart() {
    if (this._index == 1) {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - List<Source> <-> _CArray_CSource

final class _CArray_CSource extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CSourceToDart on _CArray_CSource {
  List<Source> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CSource on List<Source> {
  _CArray_CSource _copyFromDartTo_CArray_CSource() {
    final cArray = _CArray_CSourcemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CSource();
        _CArray_CSourceaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CSourceBasicFunctions on _CArray_CSource {
  void _releaseIntermediate() {
    _CArray_CSource_release(this);
  }

  static final _listToFill = <Source>[];

  static void _iterate(_CSource item) {
    _listToFill.add(item._toDart());
  }

  List<Source> _fillFromC() {
    _forEach_CArray_CSource(this, ffi.Pointer.fromFunction<ffi.Void Function(_CSource)>(_iterate));
    final result = List<Source>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - CancelableOperation<List<RenderedObjectInfo>> <-> _CFuture_CArray_CRenderedObjectInfo

final class _CFuture_CArray_CRenderedObjectInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CArray_CRenderedObjectInfo_Cancellable {
  final Completer<List<RenderedObjectInfo>> completer;
  final _CFuture_CArray_CRenderedObjectInfo _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CArray_CRenderedObjectInfo, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CArray_CRenderedObjectInfo_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CArray_CRenderedObjectInfoBasicFunctions on _CFuture_CArray_CRenderedObjectInfo {
  void _releaseIntermediate() {
    _CFuture_CArray_CRenderedObjectInfo_release(this);
  }

  _CFuture_CArray_CRenderedObjectInfo _retain() {
    return _CFuture_CArray_CRenderedObjectInfo_retain(this);
  }
}

extension _CFuture_CArray_CRenderedObjectInfoToDart on _CFuture_CArray_CRenderedObjectInfo {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CArray_CRenderedObjectInfo_Cancellable>{};

  static void valueFunction(_CArray_CRenderedObjectInfo cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<List<RenderedObjectInfo>> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<List<RenderedObjectInfo>>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CRenderedObjectInfo, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CArray_CRenderedObjectInfoReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CArray_CRenderedObjectInfo_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CArray_CRenderedObjectInfo on CancelableOperation<List<RenderedObjectInfo>> {
  _CFuture_CArray_CRenderedObjectInfo _copyFromDartTo_CFuture_CArray_CRenderedObjectInfo() {
    return _CFuture_CArray_CRenderedObjectInfoMakeDefault();
  }
}
	
// MARK: - List<RenderedObjectInfo> <-> _CArray_CRenderedObjectInfo

final class _CArray_CRenderedObjectInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CRenderedObjectInfoToDart on _CArray_CRenderedObjectInfo {
  List<RenderedObjectInfo> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CRenderedObjectInfo on List<RenderedObjectInfo> {
  _CArray_CRenderedObjectInfo _copyFromDartTo_CArray_CRenderedObjectInfo() {
    final cArray = _CArray_CRenderedObjectInfomakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CRenderedObjectInfo();
        _CArray_CRenderedObjectInfoaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CRenderedObjectInfoBasicFunctions on _CArray_CRenderedObjectInfo {
  void _releaseIntermediate() {
    _CArray_CRenderedObjectInfo_release(this);
  }

  static final _listToFill = <RenderedObjectInfo>[];

  static void _iterate(_CRenderedObjectInfo item) {
    _listToFill.add(item._toDart());
  }

  List<RenderedObjectInfo> _fillFromC() {
    _forEach_CArray_CRenderedObjectInfo(this, ffi.Pointer.fromFunction<ffi.Void Function(_CRenderedObjectInfo)>(_iterate));
    final result = List<RenderedObjectInfo>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - RenderedObjectInfo

/** Подробная информация об отображаемом объекте карты. */
class RenderedObjectInfo {
  /** Ближайшая точка объекта в координатах экрана. */
  final ScreenPoint closestViewportPoint;
  /** Ближайшая точка объекта в координатах карты. */
  final GeoPointWithElevation closestMapPoint;
  /** Отображаемый объект карты. */
  final RenderedObject item;

  const RenderedObjectInfo({
    required this.closestViewportPoint,
    required this.closestMapPoint,
    required this.item
  });

  RenderedObjectInfo copyWith({
    ScreenPoint? closestViewportPoint,
    GeoPointWithElevation? closestMapPoint,
    RenderedObject? item
  }) {
    return RenderedObjectInfo(
      closestViewportPoint: closestViewportPoint ?? this.closestViewportPoint,
      closestMapPoint: closestMapPoint ?? this.closestMapPoint,
      item: item ?? this.item
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RenderedObjectInfo &&
    other.runtimeType == runtimeType &&
    other.closestViewportPoint == closestViewportPoint &&
    other.closestMapPoint == closestMapPoint &&
    other.item == item;

  @override
  int get hashCode {
    return Object.hash(closestViewportPoint, closestMapPoint, item);
  }

}
final class _CRenderedObjectInfo extends ffi.Struct {
  external _CScreenPoint closestViewportPoint;

  external _CGeoPointWithElevation closestMapPoint;

  external _CRenderedObject item;

}
// MARK: - RenderedObjectInfo <-> _CRenderedObjectInfo

extension _CRenderedObjectInfoToDart on _CRenderedObjectInfo {
  RenderedObjectInfo _toDart() {
    return RenderedObjectInfo(
      closestViewportPoint: this.closestViewportPoint._toDart(),
      closestMapPoint: this.closestMapPoint._toDart(),
      item: this.item._toDart()
    );
  }
}

extension _DartTo_CRenderedObjectInfo on RenderedObjectInfo {
  _CRenderedObjectInfo _copyFromDartTo_CRenderedObjectInfo() {
    final res = _CRenderedObjectInfoMakeDefault();
    res.closestViewportPoint = this.closestViewportPoint._copyFromDartTo_CScreenPoint();
    res.closestMapPoint = this.closestMapPoint._copyFromDartTo_CGeoPointWithElevation();
    res.item = this.item._copyFromDartTo_CRenderedObject();
    return res;
  }
}
extension _CRenderedObjectInfoRelease on _CRenderedObjectInfo {
  void _releaseIntermediate() {
    item._releaseIntermediate();
  }
}

// MARK: - StatefulChannel<MapVisibilityState> <-> _CStatefulChannel_CMapVisibilityState

class _CStatefulChannel_CMapVisibilityStateImpl extends StatefulChannel<MapVisibilityState> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<MapVisibilityState>>{};

  final _CStatefulChannel_CMapVisibilityState _channel;

  _CStatefulChannel_CMapVisibilityStateImpl(this._channel);

  @override
  MapVisibilityState get value {
    return this._channel._getter();
  }

  static void valueFunction(_CMapVisibilityState cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<MapVisibilityState> listen(void onData(MapVisibilityState event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CMapVisibilityState, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<MapVisibilityState>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CMapVisibilityState extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CMapVisibilityStateBasicFunctions on _CStatefulChannel_CMapVisibilityState {
  void _releaseIntermediate() {
    _CStatefulChannel_CMapVisibilityState_release(this);
  }

  _CStatefulChannel_CMapVisibilityState _retain() {
    return _CStatefulChannel_CMapVisibilityState_retain(this);
  }

  MapVisibilityState _getter() {
    final cValue = _CStatefulChannel_CMapVisibilityStateGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CMapVisibilityState, ffi.Int64)> callback) {
    return _CStatefulChannel_CMapVisibilityStateConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CMapVisibilityStateToDart on _CStatefulChannel_CMapVisibilityState {
  StatefulChannel<MapVisibilityState> _toDart() {
    return _CStatefulChannel_CMapVisibilityStateImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CMapVisibilityState on StatefulChannel<MapVisibilityState> {
  _CStatefulChannel_CMapVisibilityState _copyFromDartTo_CStatefulChannel_CMapVisibilityState() {
    return _CStatefulChannel_CMapVisibilityStateMakeDefault();
  }
}
	
// MARK: - Channel<bool> <-> _CChannel_bool

class _CChannel_boolImpl extends Channel<bool> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<bool>>{};

  final _CChannel_bool _channel;

  _CChannel_boolImpl(this._channel);

  static void valueFunction(bool cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue);
    }
    
  }

  @override
  StreamSubscription<bool> listen(void onData(bool event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Bool, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<bool>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CChannel_bool extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CChannel_boolBasicFunctions on _CChannel_bool {
  void _releaseIntermediate() {
    _CChannel_bool_release(this);
  }

  _CChannel_bool _retain() {
    return _CChannel_bool_retain(this);
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(ffi.Bool, ffi.Int64)> callback) {
    return _CChannel_boolConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CChannel_boolToDart on _CChannel_bool {
  Channel<bool> _toDart() {
    return _CChannel_boolImpl(this._retain());
  }
}

extension _DartTo_CChannel_bool on Channel<bool> {
  _CChannel_bool _copyFromDartTo_CChannel_bool() {
    return _CChannel_boolMakeDefault();
  }
}
	
// MARK: - StatefulChannel<ProductType> <-> _CStatefulChannel_CProductType

class _CStatefulChannel_CProductTypeImpl extends StatefulChannel<ProductType> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<ProductType>>{};

  final _CStatefulChannel_CProductType _channel;

  _CStatefulChannel_CProductTypeImpl(this._channel);

  @override
  ProductType get value {
    return this._channel._getter();
  }

  static void valueFunction(_CProductType cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<ProductType> listen(void onData(ProductType event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CProductType, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<ProductType>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CProductType extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CProductTypeBasicFunctions on _CStatefulChannel_CProductType {
  void _releaseIntermediate() {
    _CStatefulChannel_CProductType_release(this);
  }

  _CStatefulChannel_CProductType _retain() {
    return _CStatefulChannel_CProductType_retain(this);
  }

  ProductType _getter() {
    final cValue = _CStatefulChannel_CProductTypeGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CProductType, ffi.Int64)> callback) {
    return _CStatefulChannel_CProductTypeConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CProductTypeToDart on _CStatefulChannel_CProductType {
  StatefulChannel<ProductType> _toDart() {
    return _CStatefulChannel_CProductTypeImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CProductType on StatefulChannel<ProductType> {
  _CStatefulChannel_CProductType _copyFromDartTo_CStatefulChannel_CProductType() {
    return _CStatefulChannel_CProductTypeMakeDefault();
  }
}
	
// MARK: - ImageData <-> _CResult_CImageData

final class _CResult_CImageDataImpl extends ffi.Union {
  
  external _CImageData _value;
  external _CError _error;
}

final class _CResult_CImageData extends ffi.Struct {
  external _CResult_CImageDataImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CImageDataBasicFunctions on _CResult_CImageData {
  void _releaseIntermediate() {
    _CResult_CImageData_release(this);
  }
}

extension _CResult_CImageDataToDart on _CResult_CImageData {
  ImageData _toDart() {
    if (this._index == 0) {
      return this._impl._value._toDart();
    } else {
      throw this._impl._error._toDart();
    }
  }

  _CImageData _toCDart() {
    if (this._index == 0) {
      return this._impl._value;
    } else {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - StatefulChannel<GraphicsPreset?> <-> _CStatefulChannel_COptional_CGraphicsPreset

class _CStatefulChannel_COptional_CGraphicsPresetImpl extends StatefulChannel<GraphicsPreset?> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<GraphicsPreset?>>{};

  final _CStatefulChannel_COptional_CGraphicsPreset _channel;

  _CStatefulChannel_COptional_CGraphicsPresetImpl(this._channel);

  @override
  GraphicsPreset? get value {
    return this._channel._getter();
  }

  static void valueFunction(_COptional_CGraphicsPreset cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<GraphicsPreset?> listen(void onData(GraphicsPreset? event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CGraphicsPreset, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<GraphicsPreset?>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_COptional_CGraphicsPreset extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_COptional_CGraphicsPresetBasicFunctions on _CStatefulChannel_COptional_CGraphicsPreset {
  void _releaseIntermediate() {
    _CStatefulChannel_COptional_CGraphicsPreset_release(this);
  }

  _CStatefulChannel_COptional_CGraphicsPreset _retain() {
    return _CStatefulChannel_COptional_CGraphicsPreset_retain(this);
  }

  GraphicsPreset? _getter() {
    final cValue = _CStatefulChannel_COptional_CGraphicsPresetGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_COptional_CGraphicsPreset, ffi.Int64)> callback) {
    return _CStatefulChannel_COptional_CGraphicsPresetConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_COptional_CGraphicsPresetToDart on _CStatefulChannel_COptional_CGraphicsPreset {
  StatefulChannel<GraphicsPreset?> _toDart() {
    return _CStatefulChannel_COptional_CGraphicsPresetImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_COptional_CGraphicsPreset on StatefulChannel<GraphicsPreset?> {
  _CStatefulChannel_COptional_CGraphicsPreset _copyFromDartTo_CStatefulChannel_COptional_CGraphicsPreset() {
    return _CStatefulChannel_COptional_CGraphicsPresetMakeDefault();
  }
}
	
// MARK: - GraphicsPreset? <-> _COptional_CGraphicsPreset

final class _COptional_CGraphicsPreset extends ffi.Struct {
  
  external _CGraphicsPreset value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CGraphicsPresetBasicFunctions on _COptional_CGraphicsPreset {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CGraphicsPresetToDart on _COptional_CGraphicsPreset {
  GraphicsPreset? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CGraphicsPreset on GraphicsPreset? {
  _COptional_CGraphicsPreset _copyFromDartTo_COptional_CGraphicsPreset() {
    final cOptional = _COptional_CGraphicsPresetMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CGraphicsPreset();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - CancelableOperation<RenderedObjectInfo?> <-> _CFuture_COptional_CRenderedObjectInfo

final class _CFuture_COptional_CRenderedObjectInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_COptional_CRenderedObjectInfo_Cancellable {
  final Completer<RenderedObjectInfo?> completer;
  final _CFuture_COptional_CRenderedObjectInfo _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_COptional_CRenderedObjectInfo, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_COptional_CRenderedObjectInfo_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_COptional_CRenderedObjectInfoBasicFunctions on _CFuture_COptional_CRenderedObjectInfo {
  void _releaseIntermediate() {
    _CFuture_COptional_CRenderedObjectInfo_release(this);
  }

  _CFuture_COptional_CRenderedObjectInfo _retain() {
    return _CFuture_COptional_CRenderedObjectInfo_retain(this);
  }
}

extension _CFuture_COptional_CRenderedObjectInfoToDart on _CFuture_COptional_CRenderedObjectInfo {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_COptional_CRenderedObjectInfo_Cancellable>{};

  static void valueFunction(_COptional_CRenderedObjectInfo cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<RenderedObjectInfo?> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<RenderedObjectInfo?>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CRenderedObjectInfo, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_COptional_CRenderedObjectInfoReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_COptional_CRenderedObjectInfo_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_COptional_CRenderedObjectInfo on CancelableOperation<RenderedObjectInfo?> {
  _CFuture_COptional_CRenderedObjectInfo _copyFromDartTo_CFuture_COptional_CRenderedObjectInfo() {
    return _CFuture_COptional_CRenderedObjectInfoMakeDefault();
  }
}
	
// MARK: - RenderedObjectInfo? <-> _COptional_CRenderedObjectInfo

final class _COptional_CRenderedObjectInfo extends ffi.Struct {
  
  external _CRenderedObjectInfo value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CRenderedObjectInfoBasicFunctions on _COptional_CRenderedObjectInfo {
  void _releaseIntermediate() {
    _COptional_CRenderedObjectInfo_release(this);
  }
}

extension _COptional_CRenderedObjectInfoToDart on _COptional_CRenderedObjectInfo {
  RenderedObjectInfo? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CRenderedObjectInfo on RenderedObjectInfo? {
  _COptional_CRenderedObjectInfo _copyFromDartTo_COptional_CRenderedObjectInfo() {
    final cOptional = _COptional_CRenderedObjectInfoMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CRenderedObjectInfo();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - Projection

/**
 Проекция.

 Используется сферическая проекция Меркатора (EPSG:3857), зацикленная по долготе.
 Отображаемые данные ограничены по широте от -85.06° до 85.06°.
*/
class Projection implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CProjection_releasePtr);

  Projection._raw(this._self);
  factory Projection._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Projection._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Projection &&
    other.runtimeType == runtimeType &&
    _CProjection_cg_objectIdentifier(this._self) == _CProjection_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CProjection_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: Projection: Methods

  /**
   Вычисление точки карты в указанной точке экрана.
  
   - Note: Функция возвращает пустое значение, если указанная точка экрана за пределами проекции карты.
  */
  GeoPoint? screenToMap(
    ScreenPoint point
  )  {
    var _a1 = point._copyFromDartTo_CScreenPoint();
    _COptional_CGeoPoint res = _CProjection_screenToMap_CScreenPoint(_CProjectionMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Вычисление точки экрана, соответствующей указанной точке карты.
  
   - Note: Функция возвращает пустое значение:
   - point имеет невалидное значение
   (latitude лежит вне диапазона [-90; 90] или longitude лежит вне диапазона [-180; 180]).
   - если указанная точка карты находится выше плоскости проекции карты на экран.
   - если указанная точка карты находится слишком далеко за пределами экрана и возникает переполнение типа.
  */
  ScreenPoint? mapToScreenWithGeoPoint(
    GeoPoint point
  )  {
    var _a1 = point._copyFromDartTo_CGeoPoint();
    _COptional_CScreenPoint res = _CProjection_mapToScreenWithGeoPoint_CGeoPoint(_CProjectionMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Вычисление точки экрана, соответствующей указанной точке карты с высотой.
  
   - Note: Функция возвращает пустое значение:
   - point имеет невалидное значение
   (latitude лежит вне диапазона [-90; 90], longitude лежит вне диапазона [-180; 180] или elevation отрицателен).
   - если указанная точка карты находится выше плоскости проекции карты на экран.
   - если указанная точка карты находится слишком далеко за пределами экрана и возникает переполнение типа.
  */
  ScreenPoint? mapToScreenWithGeoPointWithElevation(
    GeoPointWithElevation point
  )  {
    var _a1 = point._copyFromDartTo_CGeoPointWithElevation();
    _COptional_CScreenPoint res = _CProjection_mapToScreenWithGeoPointWithElevation_CGeoPointWithElevation(_CProjectionMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Вычисление ближайшей точки карты к проекции указанной точки экрана.
  
   - Throws: Exception, если точка не может быть вычислена
   (например, значение x или y точки экрана слишком большое или слишком маленькое).
  */
  GeoPoint screenToMapClipped(
    ScreenPoint point
  )  {
    var _a1 = point._copyFromDartTo_CScreenPoint();
    _CGeoPoint res = _CProjection_screenToMapClipped_CScreenPoint(_CProjectionMakeDefault().._impl=_self, _a1);
    return res._toDart();
  }

  /**
   Вычисление расстояния между точками на карте, соответствующими указанным точкам на экране, в метрах.
  
   - Note: Функция возвращает пустое значение, если одна или обе указанных точки экрана находятся за пределами проекции карты.
  */
  Meter? distanceOnMap(
    ScreenPoint fromPoint,
    ScreenPoint toPoint
  )  {
    var _a1 = fromPoint._copyFromDartTo_CScreenPoint();
    var _a2 = toPoint._copyFromDartTo_CScreenPoint();
    _COptional_CMeter res = _CProjection_distanceOnMap_CScreenPoint_CScreenPoint(_CProjectionMakeDefault().._impl=_self, _a1, _a2);
    return res._toDart();
  }

  /**
   Вычисление расстояния между точками на экране, соответствующими указанным точкам на карте, в пикселях.
  
   - Note: Функция возвращает пустое значение если одна или обе точки на карте:
   - имеют невалидное значение
   (latitude лежит вне диапазона [-90; 90] или longitude лежит вне диапазона [-180; 180]).
   - находятся выше плоскости проекции карты на экран.
   - находятся слишком далеко за пределами экрана и возникает переполнение типа.
  */
  LogicalPixel? distanceOnScreen(
    GeoPoint fromGeoPoint,
    GeoPoint toGeoPoint
  )  {
    var _a1 = fromGeoPoint._copyFromDartTo_CGeoPoint();
    var _a2 = toGeoPoint._copyFromDartTo_CGeoPoint();
    _COptional_CLogicalPixel res = _CProjection_distanceOnScreen_CGeoPoint_CGeoPoint(_CProjectionMakeDefault().._impl=_self, _a1, _a2);
    return res._toDart();
  }

}

// MARK: - Projection <-> CProjection

final class _CProjection extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CProjectionBasicFunctions on _CProjection {
  void _releaseIntermediate() {
    _CProjection_release(_impl);
  }

  _CProjection _retain() {
    return _CProjection_retain(_impl);
  }
}

extension _CProjectionToDart on _CProjection {
  Projection _toDart() {
    return Projection._create(_retain()._impl);
  }
}


extension _DartToCProjection on Projection {
  _CProjection _copyFromDartTo_CProjection() {
    return (_CProjectionMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - LogicalPixel? <-> _COptional_CLogicalPixel

final class _COptional_CLogicalPixel extends ffi.Struct {
  
  external _CLogicalPixel value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CLogicalPixelBasicFunctions on _COptional_CLogicalPixel {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CLogicalPixelToDart on _COptional_CLogicalPixel {
  LogicalPixel? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CLogicalPixel on LogicalPixel? {
  _COptional_CLogicalPixel _copyFromDartTo_COptional_CLogicalPixel() {
    final cOptional = _COptional_CLogicalPixelMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CLogicalPixel();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - BaseCamera

/**
 Камера.

 Задаёт параметры проецирования карты на экран.
*/
class BaseCamera implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Проекция.
  
   Используется для получения точки экрана по точке карты и точки карты по точке экрана.
   Параметры камеры фиксируются в момент вызова.
  */
  Projection get projection {
    _CProjection res = _CBaseCamera_projection(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение текущей позиции камеры. */
  StatefulChannel<CameraPosition> get positionChannel {
    _CStatefulChannel_CCameraPosition res = _CBaseCamera_positionChannel(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение текущей позиции камеры. */
  CameraPosition get position {
    _CCameraPosition res = _CBaseCamera_position(_CBaseCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  set position(CameraPosition position) {
    var _a1 = position._copyFromDartTo_CCameraPosition();
    _CResult_CEmpty res = _CBaseCamera_setPosition_CCameraPosition(_CBaseCameraMakeDefault().._impl=_self, _a1);
    res._toDart();
    res._releaseIntermediate();
  }
  /** Получение актуальных ограничений уровня масштабирования. */
  StatefulChannel<CameraZoomRestrictions> get zoomRestrictionsChannel {
    _CStatefulChannel_CCameraZoomRestrictions res = _CBaseCamera_zoomRestrictionsChannel(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение актуальных ограничений уровня масштабирования. */
  CameraZoomRestrictions get zoomRestrictions {
    _CCameraZoomRestrictions res = _CBaseCamera_zoomRestrictions(_CBaseCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  set zoomRestrictions(CameraZoomRestrictions zoomRestrictions) {
    var _a1 = zoomRestrictions._copyFromDartTo_CCameraZoomRestrictions();
    _CResult_CEmpty res = _CBaseCamera_setZoomRestrictions_CCameraZoomRestrictions(_CBaseCameraMakeDefault().._impl=_self, _a1);
    res._toDart();
    res._releaseIntermediate();
  }
  /** Получение разрешающей способности экрана (плотность пикселей на дюйм). */
  StatefulChannel<DevicePpi> get devicePpiChannel {
    _CStatefulChannel_CDevicePpi res = _CBaseCamera_devicePpiChannel(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение разрешающей способности экрана (плотность пикселей на дюйм). */
  DevicePpi get devicePpi {
    _CDevicePpi res = _CBaseCamera_devicePpi(_CBaseCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Получение отношения DPI к базовому DPI устройства. */
  StatefulChannel<DeviceDensity> get deviceDensityChannel {
    _CStatefulChannel_CDeviceDensity res = _CBaseCamera_deviceDensityChannel(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение отношения DPI к базовому DPI устройства. */
  DeviceDensity get deviceDensity {
    _CDeviceDensity res = _CBaseCamera_deviceDensity(_CBaseCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Получение размера области просмотра. */
  StatefulChannel<ScreenSize> get sizeChannel {
    _CStatefulChannel_CScreenSize res = _CBaseCamera_sizeChannel(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение размера области просмотра. */
  ScreenSize get size {
    _CScreenSize res = _CBaseCamera_size(_CBaseCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  set size(ScreenSize size) {
    var _a1 = size._copyFromDartTo_CScreenSize();
    void res = _CBaseCamera_setSize_CScreenSize(_CBaseCameraMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Получение текущих отступов от краёв экрана. */
  StatefulChannel<Padding> get paddingChannel {
    _CStatefulChannel_CPadding res = _CBaseCamera_paddingChannel(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение текущих отступов от краёв экрана. */
  Padding get padding {
    _CPadding res = _CBaseCamera_padding(_CBaseCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  set padding(Padding padding) {
    var _a1 = padding._copyFromDartTo_CPadding();
    void res = _CBaseCamera_setPadding_CPadding(_CBaseCameraMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Точка экрана, к которой привязана позиция камеры, задаётся с учётом отступов (padding). */
  StatefulChannel<CameraPositionPoint> get positionPointChannel {
    _CStatefulChannel_CCameraPositionPoint res = _CBaseCamera_positionPointChannel(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Точка экрана, к которой привязана позиция камеры, задаётся с учётом отступов (padding). */
  CameraPositionPoint get positionPoint {
    _CCameraPositionPoint res = _CBaseCamera_positionPoint(_CBaseCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  set positionPoint(CameraPositionPoint positionPoint) {
    var _a1 = positionPoint._copyFromDartTo_CCameraPositionPoint();
    _CResult_CEmpty res = _CBaseCamera_setPositionPoint_CCameraPositionPoint(_CBaseCameraMakeDefault().._impl=_self, _a1);
    res._toDart();
    res._releaseIntermediate();
  }
  /**
   Точка взгляда относительно полного размера вьюпорта.
  
   - Returns: Значение, явно установленное функцией set_view_point.
   Если вернулся null, точка взгляда следует за точкой позиции.
  */
  CameraViewPoint? get viewPoint {
    _COptional_CCameraViewPoint res = _CBaseCamera_viewPoint(_CBaseCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  set viewPoint(CameraViewPoint? viewPoint) {
    var _a1 = viewPoint._copyFromDartTo_COptional_CCameraViewPoint();
    _CResult_CEmpty res = _CBaseCamera_setViewPoint_COptional_CCameraViewPoint(_CBaseCameraMakeDefault().._impl=_self, _a1);
    res._toDart();
    res._releaseIntermediate();
  }
  /** Область пересечения пирамиды видимости камеры и поверхности карты. */
  Geometry get visibleArea {
    _CGeometry res = _CBaseCamera_visibleArea(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Объемлющий прямоугольник видимой области карты. */
  StatefulChannel<GeoRect> get visibleRectChannel {
    _CStatefulChannel_CGeoRect res = _CBaseCamera_visibleRectChannel(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Объемлющий прямоугольник видимой области карты. */
  GeoRect get visibleRect {
    _CGeoRect res = _CBaseCamera_visibleRect(_CBaseCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  /**
   Получение текущей функции зависимости максимального угла наклона камеры от стилевого уровня масштабирования.
  
   - Returns: возвращает пустой объект, если функция не установлена.
  */
  StatefulChannel<StyleZoomToTiltRelation?> get maxTiltRestrictionChannel {
    _CStatefulChannel_COptional_CStyleZoomToTiltRelation res = _CBaseCamera_maxTiltRestrictionChannel(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение текущей функции зависимости максимального угла наклона камеры от стилевого уровня масштабирования.
  
   - Returns: возвращает пустой объект, если функция не установлена.
  */
  StyleZoomToTiltRelation? get maxTiltRestriction {
    _COptional_CStyleZoomToTiltRelation res = _CBaseCamera_maxTiltRestriction(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set maxTiltRestriction(StyleZoomToTiltRelation? maxTiltRestriction) {
    var _a1 = maxTiltRestriction._copyFromDartTo_COptional_CStyleZoomToTiltRelation();
    void res = _CBaseCamera_setMaxTiltRestriction_COptional_CStyleZoomToTiltRelation(_CBaseCameraMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /**
   Получение ограничения на область видимости.
  
   - Returns: null если ограничение не задано.
  */
  StatefulChannel<GeoRect?> get viewportRestrictionChannel {
    _CStatefulChannel_COptional_CGeoRect res = _CBaseCamera_viewportRestrictionChannel(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение ограничения на область видимости.
  
   - Returns: null если ограничение не задано.
  */
  GeoRect? get viewportRestriction {
    _COptional_CGeoRect res = _CBaseCamera_viewportRestriction(_CBaseCameraMakeDefault().._impl=_self);
    return res._toDart();
  }
  set viewportRestriction(GeoRect? viewportRestriction) {
    var _a1 = viewportRestriction._copyFromDartTo_COptional_CGeoRect();
    void res = _CBaseCamera_setViewportRestriction_COptional_CGeoRect(_CBaseCameraMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CBaseCamera_releasePtr);

  BaseCamera._raw(this._self);
  factory BaseCamera._create(ffi.Pointer<ffi.Void> self) {
    final classObject = BaseCamera._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is BaseCamera &&
    other.runtimeType == runtimeType &&
    _CBaseCamera_cg_objectIdentifier(this._self) == _CBaseCamera_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CBaseCamera_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: BaseCamera: Methods

  /** Создание копии текущей камеры. */
  BaseCamera clone()  {
    _CBaseCamera res = _CBaseCamera_clone(_CBaseCameraMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Изменение только части параметров позиции камеры.
  
   - Note: Вызов прерывает перелёт и обработку жестов,
   а также сбрасывает слежение за изменёнными параметрами,
   а при изменении координат также и слежение за стилевым уровнем масштабирования и направлением.
  */
  void changePosition(
    CameraPositionChange positionChange
  )  {
    var _a1 = positionChange._copyFromDartTo_CCameraPositionChange();
    _CResult_CEmpty res = _CBaseCamera_changePosition_CCameraPositionChange(_CBaseCameraMakeDefault().._impl=_self, _a1);
    res._toDart();
    res._releaseIntermediate();
  }

}

@internal
extension BaseCameraInternalMethods on BaseCamera {
  /** Установка разрешающей способности экрана. */
  @internal
  void setDevicePpi(
    DevicePpi devicePpi,
    DeviceDensity deviceDensity
  )  {
    var _a1 = devicePpi._copyFromDartTo_CDevicePpi();
    var _a2 = deviceDensity._copyFromDartTo_CDeviceDensity();
    void res = _CBaseCamera_setDevicePpi_CDevicePpi_CDeviceDensity(_CBaseCameraMakeDefault().._impl=_self, _a1, _a2);
    return res;
  }

}

// MARK: - BaseCamera <-> CBaseCamera

final class _CBaseCamera extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CBaseCameraBasicFunctions on _CBaseCamera {
  void _releaseIntermediate() {
    _CBaseCamera_release(_impl);
  }

  _CBaseCamera _retain() {
    return _CBaseCamera_retain(_impl);
  }
}

extension _CBaseCameraToDart on _CBaseCamera {
  BaseCamera _toDart() {
    final selector = _CBaseCamera_cg_getSelector(this);
    switch (selector) {
      case 0:
        final res = BaseCamera._create(_retain()._impl);
        return res;
      case 1:
        final res = Camera._create(_retain()._impl);
        return res;
      default: throw Exception("Unrecognized case index $selector");
    }
  }
}

extension _DartToCBaseCamera on BaseCamera {
  _CBaseCamera _copyFromDartTo_CBaseCamera() {
    return (_CBaseCameraMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<CameraPosition> <-> _CStatefulChannel_CCameraPosition

class _CStatefulChannel_CCameraPositionImpl extends StatefulChannel<CameraPosition> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<CameraPosition>>{};

  final _CStatefulChannel_CCameraPosition _channel;

  _CStatefulChannel_CCameraPositionImpl(this._channel);

  @override
  CameraPosition get value {
    return this._channel._getter();
  }

  static void valueFunction(_CCameraPosition cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<CameraPosition> listen(void onData(CameraPosition event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CCameraPosition, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<CameraPosition>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CCameraPosition extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CCameraPositionBasicFunctions on _CStatefulChannel_CCameraPosition {
  void _releaseIntermediate() {
    _CStatefulChannel_CCameraPosition_release(this);
  }

  _CStatefulChannel_CCameraPosition _retain() {
    return _CStatefulChannel_CCameraPosition_retain(this);
  }

  CameraPosition _getter() {
    final cValue = _CStatefulChannel_CCameraPositionGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CCameraPosition, ffi.Int64)> callback) {
    return _CStatefulChannel_CCameraPositionConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CCameraPositionToDart on _CStatefulChannel_CCameraPosition {
  StatefulChannel<CameraPosition> _toDart() {
    return _CStatefulChannel_CCameraPositionImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CCameraPosition on StatefulChannel<CameraPosition> {
  _CStatefulChannel_CCameraPosition _copyFromDartTo_CStatefulChannel_CCameraPosition() {
    return _CStatefulChannel_CCameraPositionMakeDefault();
  }
}
	
// MARK: - StatefulChannel<CameraZoomRestrictions> <-> _CStatefulChannel_CCameraZoomRestrictions

class _CStatefulChannel_CCameraZoomRestrictionsImpl extends StatefulChannel<CameraZoomRestrictions> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<CameraZoomRestrictions>>{};

  final _CStatefulChannel_CCameraZoomRestrictions _channel;

  _CStatefulChannel_CCameraZoomRestrictionsImpl(this._channel);

  @override
  CameraZoomRestrictions get value {
    return this._channel._getter();
  }

  static void valueFunction(_CCameraZoomRestrictions cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<CameraZoomRestrictions> listen(void onData(CameraZoomRestrictions event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CCameraZoomRestrictions, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<CameraZoomRestrictions>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CCameraZoomRestrictions extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CCameraZoomRestrictionsBasicFunctions on _CStatefulChannel_CCameraZoomRestrictions {
  void _releaseIntermediate() {
    _CStatefulChannel_CCameraZoomRestrictions_release(this);
  }

  _CStatefulChannel_CCameraZoomRestrictions _retain() {
    return _CStatefulChannel_CCameraZoomRestrictions_retain(this);
  }

  CameraZoomRestrictions _getter() {
    final cValue = _CStatefulChannel_CCameraZoomRestrictionsGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CCameraZoomRestrictions, ffi.Int64)> callback) {
    return _CStatefulChannel_CCameraZoomRestrictionsConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CCameraZoomRestrictionsToDart on _CStatefulChannel_CCameraZoomRestrictions {
  StatefulChannel<CameraZoomRestrictions> _toDart() {
    return _CStatefulChannel_CCameraZoomRestrictionsImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CCameraZoomRestrictions on StatefulChannel<CameraZoomRestrictions> {
  _CStatefulChannel_CCameraZoomRestrictions _copyFromDartTo_CStatefulChannel_CCameraZoomRestrictions() {
    return _CStatefulChannel_CCameraZoomRestrictionsMakeDefault();
  }
}
	
// MARK: - StatefulChannel<DevicePpi> <-> _CStatefulChannel_CDevicePpi

class _CStatefulChannel_CDevicePpiImpl extends StatefulChannel<DevicePpi> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<DevicePpi>>{};

  final _CStatefulChannel_CDevicePpi _channel;

  _CStatefulChannel_CDevicePpiImpl(this._channel);

  @override
  DevicePpi get value {
    return this._channel._getter();
  }

  static void valueFunction(_CDevicePpi cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<DevicePpi> listen(void onData(DevicePpi event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CDevicePpi, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<DevicePpi>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CDevicePpi extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CDevicePpiBasicFunctions on _CStatefulChannel_CDevicePpi {
  void _releaseIntermediate() {
    _CStatefulChannel_CDevicePpi_release(this);
  }

  _CStatefulChannel_CDevicePpi _retain() {
    return _CStatefulChannel_CDevicePpi_retain(this);
  }

  DevicePpi _getter() {
    final cValue = _CStatefulChannel_CDevicePpiGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CDevicePpi, ffi.Int64)> callback) {
    return _CStatefulChannel_CDevicePpiConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CDevicePpiToDart on _CStatefulChannel_CDevicePpi {
  StatefulChannel<DevicePpi> _toDart() {
    return _CStatefulChannel_CDevicePpiImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CDevicePpi on StatefulChannel<DevicePpi> {
  _CStatefulChannel_CDevicePpi _copyFromDartTo_CStatefulChannel_CDevicePpi() {
    return _CStatefulChannel_CDevicePpiMakeDefault();
  }
}
	
// MARK: - StatefulChannel<DeviceDensity> <-> _CStatefulChannel_CDeviceDensity

class _CStatefulChannel_CDeviceDensityImpl extends StatefulChannel<DeviceDensity> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<DeviceDensity>>{};

  final _CStatefulChannel_CDeviceDensity _channel;

  _CStatefulChannel_CDeviceDensityImpl(this._channel);

  @override
  DeviceDensity get value {
    return this._channel._getter();
  }

  static void valueFunction(_CDeviceDensity cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<DeviceDensity> listen(void onData(DeviceDensity event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CDeviceDensity, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<DeviceDensity>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CDeviceDensity extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CDeviceDensityBasicFunctions on _CStatefulChannel_CDeviceDensity {
  void _releaseIntermediate() {
    _CStatefulChannel_CDeviceDensity_release(this);
  }

  _CStatefulChannel_CDeviceDensity _retain() {
    return _CStatefulChannel_CDeviceDensity_retain(this);
  }

  DeviceDensity _getter() {
    final cValue = _CStatefulChannel_CDeviceDensityGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CDeviceDensity, ffi.Int64)> callback) {
    return _CStatefulChannel_CDeviceDensityConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CDeviceDensityToDart on _CStatefulChannel_CDeviceDensity {
  StatefulChannel<DeviceDensity> _toDart() {
    return _CStatefulChannel_CDeviceDensityImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CDeviceDensity on StatefulChannel<DeviceDensity> {
  _CStatefulChannel_CDeviceDensity _copyFromDartTo_CStatefulChannel_CDeviceDensity() {
    return _CStatefulChannel_CDeviceDensityMakeDefault();
  }
}
	
// MARK: - StatefulChannel<ScreenSize> <-> _CStatefulChannel_CScreenSize

class _CStatefulChannel_CScreenSizeImpl extends StatefulChannel<ScreenSize> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<ScreenSize>>{};

  final _CStatefulChannel_CScreenSize _channel;

  _CStatefulChannel_CScreenSizeImpl(this._channel);

  @override
  ScreenSize get value {
    return this._channel._getter();
  }

  static void valueFunction(_CScreenSize cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<ScreenSize> listen(void onData(ScreenSize event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CScreenSize, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<ScreenSize>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CScreenSize extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CScreenSizeBasicFunctions on _CStatefulChannel_CScreenSize {
  void _releaseIntermediate() {
    _CStatefulChannel_CScreenSize_release(this);
  }

  _CStatefulChannel_CScreenSize _retain() {
    return _CStatefulChannel_CScreenSize_retain(this);
  }

  ScreenSize _getter() {
    final cValue = _CStatefulChannel_CScreenSizeGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CScreenSize, ffi.Int64)> callback) {
    return _CStatefulChannel_CScreenSizeConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CScreenSizeToDart on _CStatefulChannel_CScreenSize {
  StatefulChannel<ScreenSize> _toDart() {
    return _CStatefulChannel_CScreenSizeImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CScreenSize on StatefulChannel<ScreenSize> {
  _CStatefulChannel_CScreenSize _copyFromDartTo_CStatefulChannel_CScreenSize() {
    return _CStatefulChannel_CScreenSizeMakeDefault();
  }
}
	
// MARK: - StatefulChannel<Padding> <-> _CStatefulChannel_CPadding

class _CStatefulChannel_CPaddingImpl extends StatefulChannel<Padding> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<Padding>>{};

  final _CStatefulChannel_CPadding _channel;

  _CStatefulChannel_CPaddingImpl(this._channel);

  @override
  Padding get value {
    return this._channel._getter();
  }

  static void valueFunction(_CPadding cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<Padding> listen(void onData(Padding event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CPadding, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<Padding>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CPadding extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CPaddingBasicFunctions on _CStatefulChannel_CPadding {
  void _releaseIntermediate() {
    _CStatefulChannel_CPadding_release(this);
  }

  _CStatefulChannel_CPadding _retain() {
    return _CStatefulChannel_CPadding_retain(this);
  }

  Padding _getter() {
    final cValue = _CStatefulChannel_CPaddingGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CPadding, ffi.Int64)> callback) {
    return _CStatefulChannel_CPaddingConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CPaddingToDart on _CStatefulChannel_CPadding {
  StatefulChannel<Padding> _toDart() {
    return _CStatefulChannel_CPaddingImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CPadding on StatefulChannel<Padding> {
  _CStatefulChannel_CPadding _copyFromDartTo_CStatefulChannel_CPadding() {
    return _CStatefulChannel_CPaddingMakeDefault();
  }
}
	
// MARK: - StatefulChannel<CameraPositionPoint> <-> _CStatefulChannel_CCameraPositionPoint

class _CStatefulChannel_CCameraPositionPointImpl extends StatefulChannel<CameraPositionPoint> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<CameraPositionPoint>>{};

  final _CStatefulChannel_CCameraPositionPoint _channel;

  _CStatefulChannel_CCameraPositionPointImpl(this._channel);

  @override
  CameraPositionPoint get value {
    return this._channel._getter();
  }

  static void valueFunction(_CCameraPositionPoint cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<CameraPositionPoint> listen(void onData(CameraPositionPoint event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CCameraPositionPoint, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<CameraPositionPoint>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CCameraPositionPoint extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CCameraPositionPointBasicFunctions on _CStatefulChannel_CCameraPositionPoint {
  void _releaseIntermediate() {
    _CStatefulChannel_CCameraPositionPoint_release(this);
  }

  _CStatefulChannel_CCameraPositionPoint _retain() {
    return _CStatefulChannel_CCameraPositionPoint_retain(this);
  }

  CameraPositionPoint _getter() {
    final cValue = _CStatefulChannel_CCameraPositionPointGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CCameraPositionPoint, ffi.Int64)> callback) {
    return _CStatefulChannel_CCameraPositionPointConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CCameraPositionPointToDart on _CStatefulChannel_CCameraPositionPoint {
  StatefulChannel<CameraPositionPoint> _toDart() {
    return _CStatefulChannel_CCameraPositionPointImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CCameraPositionPoint on StatefulChannel<CameraPositionPoint> {
  _CStatefulChannel_CCameraPositionPoint _copyFromDartTo_CStatefulChannel_CCameraPositionPoint() {
    return _CStatefulChannel_CCameraPositionPointMakeDefault();
  }
}
	
// MARK: - CameraViewPoint? <-> _COptional_CCameraViewPoint

final class _COptional_CCameraViewPoint extends ffi.Struct {
  
  external _CCameraViewPoint value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CCameraViewPointBasicFunctions on _COptional_CCameraViewPoint {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CCameraViewPointToDart on _COptional_CCameraViewPoint {
  CameraViewPoint? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CCameraViewPoint on CameraViewPoint? {
  _COptional_CCameraViewPoint _copyFromDartTo_COptional_CCameraViewPoint() {
    final cOptional = _COptional_CCameraViewPointMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CCameraViewPoint();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - StatefulChannel<GeoRect> <-> _CStatefulChannel_CGeoRect

class _CStatefulChannel_CGeoRectImpl extends StatefulChannel<GeoRect> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<GeoRect>>{};

  final _CStatefulChannel_CGeoRect _channel;

  _CStatefulChannel_CGeoRectImpl(this._channel);

  @override
  GeoRect get value {
    return this._channel._getter();
  }

  static void valueFunction(_CGeoRect cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<GeoRect> listen(void onData(GeoRect event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CGeoRect, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<GeoRect>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CGeoRect extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CGeoRectBasicFunctions on _CStatefulChannel_CGeoRect {
  void _releaseIntermediate() {
    _CStatefulChannel_CGeoRect_release(this);
  }

  _CStatefulChannel_CGeoRect _retain() {
    return _CStatefulChannel_CGeoRect_retain(this);
  }

  GeoRect _getter() {
    final cValue = _CStatefulChannel_CGeoRectGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CGeoRect, ffi.Int64)> callback) {
    return _CStatefulChannel_CGeoRectConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CGeoRectToDart on _CStatefulChannel_CGeoRect {
  StatefulChannel<GeoRect> _toDart() {
    return _CStatefulChannel_CGeoRectImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CGeoRect on StatefulChannel<GeoRect> {
  _CStatefulChannel_CGeoRect _copyFromDartTo_CStatefulChannel_CGeoRect() {
    return _CStatefulChannel_CGeoRectMakeDefault();
  }
}
	
// MARK: - StatefulChannel<StyleZoomToTiltRelation?> <-> _CStatefulChannel_COptional_CStyleZoomToTiltRelation

class _CStatefulChannel_COptional_CStyleZoomToTiltRelationImpl extends StatefulChannel<StyleZoomToTiltRelation?> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<StyleZoomToTiltRelation?>>{};

  final _CStatefulChannel_COptional_CStyleZoomToTiltRelation _channel;

  _CStatefulChannel_COptional_CStyleZoomToTiltRelationImpl(this._channel);

  @override
  StyleZoomToTiltRelation? get value {
    return this._channel._getter();
  }

  static void valueFunction(_COptional_CStyleZoomToTiltRelation cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<StyleZoomToTiltRelation?> listen(void onData(StyleZoomToTiltRelation? event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CStyleZoomToTiltRelation, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<StyleZoomToTiltRelation?>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_COptional_CStyleZoomToTiltRelation extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_COptional_CStyleZoomToTiltRelationBasicFunctions on _CStatefulChannel_COptional_CStyleZoomToTiltRelation {
  void _releaseIntermediate() {
    _CStatefulChannel_COptional_CStyleZoomToTiltRelation_release(this);
  }

  _CStatefulChannel_COptional_CStyleZoomToTiltRelation _retain() {
    return _CStatefulChannel_COptional_CStyleZoomToTiltRelation_retain(this);
  }

  StyleZoomToTiltRelation? _getter() {
    final cValue = _CStatefulChannel_COptional_CStyleZoomToTiltRelationGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_COptional_CStyleZoomToTiltRelation, ffi.Int64)> callback) {
    return _CStatefulChannel_COptional_CStyleZoomToTiltRelationConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_COptional_CStyleZoomToTiltRelationToDart on _CStatefulChannel_COptional_CStyleZoomToTiltRelation {
  StatefulChannel<StyleZoomToTiltRelation?> _toDart() {
    return _CStatefulChannel_COptional_CStyleZoomToTiltRelationImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_COptional_CStyleZoomToTiltRelation on StatefulChannel<StyleZoomToTiltRelation?> {
  _CStatefulChannel_COptional_CStyleZoomToTiltRelation _copyFromDartTo_CStatefulChannel_COptional_CStyleZoomToTiltRelation() {
    return _CStatefulChannel_COptional_CStyleZoomToTiltRelationMakeDefault();
  }
}
	
// MARK: - StyleZoomToTiltRelation? <-> _COptional_CStyleZoomToTiltRelation

final class _COptional_CStyleZoomToTiltRelation extends ffi.Struct {
  
  external _CStyleZoomToTiltRelation value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CStyleZoomToTiltRelationBasicFunctions on _COptional_CStyleZoomToTiltRelation {
  void _releaseIntermediate() {
    _COptional_CStyleZoomToTiltRelation_release(this);
  }
}

extension _COptional_CStyleZoomToTiltRelationToDart on _COptional_CStyleZoomToTiltRelation {
  StyleZoomToTiltRelation? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CStyleZoomToTiltRelation on StyleZoomToTiltRelation? {
  _COptional_CStyleZoomToTiltRelation _copyFromDartTo_COptional_CStyleZoomToTiltRelation() {
    final cOptional = _COptional_CStyleZoomToTiltRelationMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CStyleZoomToTiltRelation();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - StatefulChannel<GeoRect?> <-> _CStatefulChannel_COptional_CGeoRect

class _CStatefulChannel_COptional_CGeoRectImpl extends StatefulChannel<GeoRect?> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<GeoRect?>>{};

  final _CStatefulChannel_COptional_CGeoRect _channel;

  _CStatefulChannel_COptional_CGeoRectImpl(this._channel);

  @override
  GeoRect? get value {
    return this._channel._getter();
  }

  static void valueFunction(_COptional_CGeoRect cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<GeoRect?> listen(void onData(GeoRect? event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CGeoRect, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<GeoRect?>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_COptional_CGeoRect extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_COptional_CGeoRectBasicFunctions on _CStatefulChannel_COptional_CGeoRect {
  void _releaseIntermediate() {
    _CStatefulChannel_COptional_CGeoRect_release(this);
  }

  _CStatefulChannel_COptional_CGeoRect _retain() {
    return _CStatefulChannel_COptional_CGeoRect_retain(this);
  }

  GeoRect? _getter() {
    final cValue = _CStatefulChannel_COptional_CGeoRectGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_COptional_CGeoRect, ffi.Int64)> callback) {
    return _CStatefulChannel_COptional_CGeoRectConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_COptional_CGeoRectToDart on _CStatefulChannel_COptional_CGeoRect {
  StatefulChannel<GeoRect?> _toDart() {
    return _CStatefulChannel_COptional_CGeoRectImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_COptional_CGeoRect on StatefulChannel<GeoRect?> {
  _CStatefulChannel_COptional_CGeoRect _copyFromDartTo_CStatefulChannel_COptional_CGeoRect() {
    return _CStatefulChannel_COptional_CGeoRectMakeDefault();
  }
}
	
// MARK: - SimpleMapObject

/** Объект на карте, для которого можно задавать видимость. */
class SimpleMapObject extends MapObject implements ffi.Finalizable {
  bool get isVisible {
    bool res = _CSimpleMapObject_isVisible(_CSimpleMapObjectMakeDefault().._impl=_self);
    return res;
  }
  set isVisible(bool visible) {
    void res = _CSimpleMapObject_setVisible_bool(_CSimpleMapObjectMakeDefault().._impl=_self, visible);
    return res;
  }
  /** Получение уровня отрисовки объекта. */
  ZIndex get zIndex {
    _CZIndex res = _CSimpleMapObject_zIndex(_CSimpleMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set zIndex(ZIndex zIndex) {
    var _a1 = zIndex._copyFromDartTo_CZIndex();
    void res = _CSimpleMapObject_setZIndex_CZIndex(_CSimpleMapObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Получение привязки объекта к этажу в здании.
  
   - Returns: Идентификатор этажного плана здания, либо пустое значение.
  */
  LevelId? get levelId {
    _COptional_CLevelId res = _CSimpleMapObject_levelId(_CSimpleMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set levelId(LevelId? levelId) {
    var _a1 = levelId._copyFromDartTo_COptional_CLevelId();
    void res = _CSimpleMapObject_setLevelId_COptional_CLevelId(_CSimpleMapObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Прямоугольник минимального размера, содержащий геометрию. */
  GeoRect get bounds {
    _CGeoRect res = _CSimpleMapObject_bounds(_CSimpleMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CSimpleMapObject_releasePtr);

  SimpleMapObject._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory SimpleMapObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SimpleMapObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SimpleMapObject &&
    other.runtimeType == runtimeType &&
    _CSimpleMapObject_cg_objectIdentifier(this._self) == _CSimpleMapObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSimpleMapObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - SimpleMapObject <-> CSimpleMapObject

final class _CSimpleMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSimpleMapObjectBasicFunctions on _CSimpleMapObject {
  void _releaseIntermediate() {
    _CSimpleMapObject_release(_impl);
  }

  _CSimpleMapObject _retain() {
    return _CSimpleMapObject_retain(_impl);
  }
}

extension _CSimpleMapObjectToDart on _CSimpleMapObject {
  SimpleMapObject _toDart() {
    final selector = _CSimpleMapObject_cg_getSelector(this);
    switch (selector) {
      case 0:
        final res = SimpleMapObject._create(_retain()._impl);
        return res;
      case 1:
        final res = Marker._create(_retain()._impl);
        return res;
      case 2:
        final res = ModelMapObject._create(_retain()._impl);
        return res;
      case 3:
        final res = Circle._create(_retain()._impl);
        return res;
      case 4:
        final res = Polygon._create(_retain()._impl);
        return res;
      case 5:
        final res = Polyline._create(_retain()._impl);
        return res;
      default: throw Exception("Unrecognized case index $selector");
    }
  }
}

extension _DartToCSimpleMapObject on SimpleMapObject {
  _CSimpleMapObject _copyFromDartTo_CSimpleMapObject() {
    return (_CSimpleMapObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MapObjectManager

class MapObjectManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Переопределение видимости всех объектов, добавленных в экземпляр менеджера.
   Значение false здесь имеет приоритет над видимостью отдельного объекта.
  */
  bool get isVisible {
    bool res = _CMapObjectManager_isVisible(_CMapObjectManagerMakeDefault().._impl=_self);
    return res;
  }
  set isVisible(bool visible) {
    void res = _CMapObjectManager_setVisible_bool(_CMapObjectManagerMakeDefault().._impl=_self, visible);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CMapObjectManager_releasePtr);

  MapObjectManager._raw(this._self);
  factory MapObjectManager._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapObjectManager._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Создать IMapObjectManager.
  
   - Parameter layerId: ID слоя в стиле типа "Динамический объект".
   Создаваемые объекты будут размещены на этом слое,
   тем самым можно задать их порядок относительно других слоев.
   Если не задан, объекты размещаются поверх остальных слоев.
  */
  factory MapObjectManager(
    Map map,
    [String? layerId = null
    ]) {
    var _a0 = map._copyFromDartTo_CMap();
    var _a1 = layerId._copyFromDartTo_COptional_CString();
    _CMapObjectManager res = _CMapObjectManager_C_createWith_CMap_COptional_CString(_a0, _a1);
    _a1._releaseIntermediate();
    _a0._releaseIntermediate();
    return MapObjectManager._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapObjectManager &&
    other.runtimeType == runtimeType &&
    _CMapObjectManager_cg_objectIdentifier(this._self) == _CMapObjectManager_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapObjectManager_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CMapObjectManager: Static Methods

  /**
   Создать IMapObjectManager с кластеризацией данных. Кластеризуются только IMarker объекты.
  
   - Parameter logicalPixel: Минимально возможное расстояние на экране между точками привязки маркеров на уровнях,
   где работает кластеризация.
   - Parameter maxZoom: Уровень, начиная с которого видны все маркеры.
   - Parameter clusterRenderer: Интерфейс для задания параметров отображения кластера.
   - Parameter minZoom: Уровень, начиная с которого формируются кластеры.
   - Parameter layerId: ID слоя в стиле типа "Динамический объект".
   Создаваемые объекты будут размещены на этом слое,
   тем самым можно задать их порядок относительно других слоев.
   Если не задан, объекты размещаются поверх остальных слоев.
  */
  static MapObjectManager withClustering(
    Map map,
    LogicalPixel logicalPixel,
    Zoom maxZoom,
    SimpleClusterRenderer clusterRenderer,
    [Zoom minZoom = const Zoom(0),
    String? layerId = null
    ])  {
    var _a0 = map._copyFromDartTo_CMap();
    var _a1 = logicalPixel._copyFromDartTo_CLogicalPixel();
    var _a2 = maxZoom._copyFromDartTo_CZoom();
    var _a3 = clusterRenderer._copyFromDartTo_CSimpleClusterRenderer();
    var _a4 = minZoom._copyFromDartTo_CZoom();
    var _a5 = layerId._copyFromDartTo_COptional_CString();
    _CMapObjectManager res = _CMapObjectManager_S_withClustering_CMap_CLogicalPixel_CZoom_CSimpleClusterRenderer_CZoom_COptional_CString(_a0, _a1, _a2, _a3, _a4, _a5);
    _a5._releaseIntermediate();
    _a3._releaseIntermediate();
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Создать IMapObjectManager с генерализацией данных. Генерализуются только IMarker объекты.
  
   - Parameter logicalPixel: Минимально возможное расстояние на экране между точками привязки маркеров на уровнях,
   где работает генерализация.
   - Parameter maxZoom: Уровень, начиная с которого видны все маркеры.
   - Parameter minZoom: Уровень, начиная с которого работает генерализация.
   - Parameter layerId: ID слоя в стиле типа "Динамический объект".
   Создаваемые объекты будут размещены на этом слое,
   тем самым можно задать их порядок относительно других слоев.
   Если не задан, объекты размещаются поверх остальных слоев.
  */
  static MapObjectManager withGeneralization(
    Map map,
    LogicalPixel logicalPixel,
    Zoom maxZoom,
    [Zoom minZoom = const Zoom(0),
    String? layerId = null
    ])  {
    var _a0 = map._copyFromDartTo_CMap();
    var _a1 = logicalPixel._copyFromDartTo_CLogicalPixel();
    var _a2 = maxZoom._copyFromDartTo_CZoom();
    var _a3 = minZoom._copyFromDartTo_CZoom();
    var _a4 = layerId._copyFromDartTo_COptional_CString();
    _CMapObjectManager res = _CMapObjectManager_S_withGeneralization_CMap_CLogicalPixel_CZoom_CZoom_COptional_CString(_a0, _a1, _a2, _a3, _a4);
    _a4._releaseIntermediate();
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  // MARK: MapObjectManager: Methods

  /** Добавить объект. */
  void addObject(
    SimpleMapObject item
  )  {
    var _a1 = item._copyFromDartTo_CSimpleMapObject();
    void res = _CMapObjectManager_addObject_CSimpleMapObject(_CMapObjectManagerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Удалить объект. */
  void removeObject(
    SimpleMapObject item
  )  {
    var _a1 = item._copyFromDartTo_CSimpleMapObject();
    void res = _CMapObjectManager_removeObject_CSimpleMapObject(_CMapObjectManagerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Добавить объекты. */
  void addObjects(
    List<SimpleMapObject> objects
  )  {
    var _a1 = objects._copyFromDartTo_CArray_CSimpleMapObject();
    void res = _CMapObjectManager_addObjects_CArray_CSimpleMapObject(_CMapObjectManagerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Удалить объекты. */
  void removeObjects(
    List<SimpleMapObject> objects
  )  {
    var _a1 = objects._copyFromDartTo_CArray_CSimpleMapObject();
    void res = _CMapObjectManager_removeObjects_CArray_CSimpleMapObject(_CMapObjectManagerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  /** Удалить и добавить объекты. */
  void removeAndAddObjects(
    List<SimpleMapObject> objectsToRemove,
    List<SimpleMapObject> objectsToAdd
  )  {
    var _a1 = objectsToRemove._copyFromDartTo_CArray_CSimpleMapObject();
    var _a2 = objectsToAdd._copyFromDartTo_CArray_CSimpleMapObject();
    void res = _CMapObjectManager_removeAndAddObjects_CArray_CSimpleMapObject_CArray_CSimpleMapObject(_CMapObjectManagerMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    return res;
  }

  void removeAll()  {
    void res = _CMapObjectManager_removeAll(_CMapObjectManagerMakeDefault().._impl=_self);
    return res;
  }

  /**
   Получить список объектов, участвующих в кластеризации при переданной позиции камеры.
   В списке будут присутствовать как кластеры, так и маркеры.
  */
  List<MapObject> clusteringObjects(
    CameraPosition position
  )  {
    var _a1 = position._copyFromDartTo_CCameraPosition();
    _CArray_CMapObject res = _CMapObjectManager_clusteringObjects_CCameraPosition(_CMapObjectManagerMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - MapObjectManager <-> CMapObjectManager

final class _CMapObjectManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapObjectManagerBasicFunctions on _CMapObjectManager {
  void _releaseIntermediate() {
    _CMapObjectManager_release(_impl);
  }

  _CMapObjectManager _retain() {
    return _CMapObjectManager_retain(_impl);
  }
}

extension _CMapObjectManagerToDart on _CMapObjectManager {
  MapObjectManager _toDart() {
    return MapObjectManager._create(_retain()._impl);
  }
}


extension _DartToCMapObjectManager on MapObjectManager {
  _CMapObjectManager _copyFromDartTo_CMapObjectManager() {
    return (_CMapObjectManagerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<SimpleMapObject> <-> _CArray_CSimpleMapObject

final class _CArray_CSimpleMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CSimpleMapObjectToDart on _CArray_CSimpleMapObject {
  List<SimpleMapObject> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CSimpleMapObject on List<SimpleMapObject> {
  _CArray_CSimpleMapObject _copyFromDartTo_CArray_CSimpleMapObject() {
    final cArray = _CArray_CSimpleMapObjectmakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CSimpleMapObject();
        _CArray_CSimpleMapObjectaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CSimpleMapObjectBasicFunctions on _CArray_CSimpleMapObject {
  void _releaseIntermediate() {
    _CArray_CSimpleMapObject_release(this);
  }

  static final _listToFill = <SimpleMapObject>[];

  static void _iterate(_CSimpleMapObject item) {
    _listToFill.add(item._toDart());
  }

  List<SimpleMapObject> _fillFromC() {
    _forEach_CArray_CSimpleMapObject(this, ffi.Pointer.fromFunction<ffi.Void Function(_CSimpleMapObject)>(_iterate));
    final result = List<SimpleMapObject>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - _SimpleClusterRendererCpp

/** Класс для кастомизации внешнего вида кластера в IMapObjectManager. */
class _SimpleClusterRendererCpp extends SimpleClusterRenderer implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CSimpleClusterRendererCpp_releasePtr);

  _SimpleClusterRendererCpp._raw(this._self);
  factory _SimpleClusterRendererCpp._create(ffi.Pointer<ffi.Void> self) {
    final classObject = _SimpleClusterRendererCpp._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is _SimpleClusterRendererCpp &&
    other.runtimeType == runtimeType &&
    _CSimpleClusterRendererCpp_cg_objectIdentifier(this._self) == _CSimpleClusterRendererCpp_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSimpleClusterRendererCpp_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: _SimpleClusterRendererCpp: Methods

  /**
   Получение маркера для кластера.
  
   - Parameter cluster: Объект кластера.
   - Returns: Объект маркера кластера.
  */
  SimpleClusterOptions renderCluster(
    SimpleClusterObject cluster
  )  {
    var _a1 = cluster._copyFromDartTo_CSimpleClusterObject();
    _CSimpleClusterOptions res = _CSimpleClusterRendererCpp_renderCluster_CSimpleClusterObject(_CSimpleClusterRendererCppMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - _SimpleClusterRendererCpp <-> CSimpleClusterRendererCpp

final class _CSimpleClusterRendererCpp extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSimpleClusterRendererCppBasicFunctions on _CSimpleClusterRendererCpp {
  void _releaseIntermediate() {
    _CSimpleClusterRendererCpp_release(_impl);
  }

  _CSimpleClusterRendererCpp _retain() {
    return _CSimpleClusterRendererCpp_retain(_impl);
  }
}

extension _CSimpleClusterRendererCppToDart on _CSimpleClusterRendererCpp {
  _SimpleClusterRendererCpp _toDart() {
    return _SimpleClusterRendererCpp._create(_retain()._impl);
  }
}


extension _DartToCSimpleClusterRendererCpp on _SimpleClusterRendererCpp {
  _CSimpleClusterRendererCpp _copyFromDartTo_CSimpleClusterRendererCpp() {
    return (_CSimpleClusterRendererCppMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Image? <-> _COptional_CImage

final class _COptional_CImage extends ffi.Struct {
  
  external _CImage value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CImageBasicFunctions on _COptional_CImage {
  void _releaseIntermediate() {
    _COptional_CImage_release(this);
  }
}

extension _COptional_CImageToDart on _COptional_CImage {
  Image? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CImage on Image? {
  _COptional_CImage _copyFromDartTo_COptional_CImage() {
    final cOptional = _COptional_CImageMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CImage();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - MapDirection? <-> _COptional_CMapDirection

final class _COptional_CMapDirection extends ffi.Struct {
  
  external _CMapDirection value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CMapDirectionBasicFunctions on _COptional_CMapDirection {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CMapDirectionToDart on _COptional_CMapDirection {
  MapDirection? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CMapDirection on MapDirection? {
  _COptional_CMapDirection _copyFromDartTo_COptional_CMapDirection() {
    final cOptional = _COptional_CMapDirectionMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CMapDirection();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - TextStyle? <-> _COptional_CTextStyle

final class _COptional_CTextStyle extends ffi.Struct {
  
  external _CTextStyle value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CTextStyleBasicFunctions on _COptional_CTextStyle {
  void _releaseIntermediate() {
    _COptional_CTextStyle_release(this);
  }
}

extension _COptional_CTextStyleToDart on _COptional_CTextStyle {
  TextStyle? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CTextStyle on TextStyle? {
  _COptional_CTextStyle _copyFromDartTo_COptional_CTextStyle() {
    final cOptional = _COptional_CTextStyleMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CTextStyle();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - SimpleClusterOptions

/** Параметры маркера кластера простых (simple) объектов-маркеров. */
class SimpleClusterOptions {
  final Image? icon;
  final MapDirection? iconMapDirection;
  final Anchor anchor;
  final String? text;
  final TextStyle? textStyle;
  final Opacity iconOpacity;
  /** Целевая ширина, используемая для масштабирования. */
  final LogicalPixel iconWidth;
  final Object? userData;
  /** Уровень отрисовки объекта. */
  final ZIndex zIndex;
  /** Анимировать ли появление. */
  final bool animatedAppearance;
  /** Режим анимации. */
  final AnimationMode iconAnimationMode;

  const SimpleClusterOptions({
    required this.icon,
    this.iconMapDirection = null,
    this.anchor = const Anchor(x: 0.5, y: 0.5),
    this.text = null,
    this.textStyle = null,
    this.iconOpacity = const Opacity(1),
    this.iconWidth = const LogicalPixel(0),
    this.userData = const {},
    this.zIndex = const ZIndex(0),
    this.animatedAppearance = true,
    this.iconAnimationMode = AnimationMode.normal
  });

  SimpleClusterOptions copyWith({
    Optional<Image?>? icon,
    Optional<MapDirection?>? iconMapDirection,
    Anchor? anchor,
    Optional<String?>? text,
    Optional<TextStyle?>? textStyle,
    Opacity? iconOpacity,
    LogicalPixel? iconWidth,
    Optional<Object?>? userData,
    ZIndex? zIndex,
    bool? animatedAppearance,
    AnimationMode? iconAnimationMode
  }) {
    return SimpleClusterOptions(
      icon: icon != null ? icon.value : this.icon,
      iconMapDirection: iconMapDirection != null ? iconMapDirection.value : this.iconMapDirection,
      anchor: anchor ?? this.anchor,
      text: text != null ? text.value : this.text,
      textStyle: textStyle != null ? textStyle.value : this.textStyle,
      iconOpacity: iconOpacity ?? this.iconOpacity,
      iconWidth: iconWidth ?? this.iconWidth,
      userData: userData != null ? userData.value : this.userData,
      zIndex: zIndex ?? this.zIndex,
      animatedAppearance: animatedAppearance ?? this.animatedAppearance,
      iconAnimationMode: iconAnimationMode ?? this.iconAnimationMode
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SimpleClusterOptions &&
    other.runtimeType == runtimeType &&
    other.icon == icon &&
    other.iconMapDirection == iconMapDirection &&
    other.anchor == anchor &&
    other.text == text &&
    other.textStyle == textStyle &&
    other.iconOpacity == iconOpacity &&
    other.iconWidth == iconWidth &&
    other.userData == userData &&
    other.zIndex == zIndex &&
    other.animatedAppearance == animatedAppearance &&
    other.iconAnimationMode == iconAnimationMode;

  @override
  int get hashCode {
    return Object.hash(icon, iconMapDirection, anchor, text, textStyle, iconOpacity, iconWidth, userData, zIndex, animatedAppearance, iconAnimationMode);
  }

}
final class _CSimpleClusterOptions extends ffi.Struct {
  external _COptional_CImage icon;

  external _COptional_CMapDirection iconMapDirection;

  external _CAnchor anchor;

  external _COptional_CString text;

  external _COptional_CTextStyle textStyle;

  external _COpacity iconOpacity;

  external _CLogicalPixel iconWidth;

  external _CAny userData;

  external _CZIndex zIndex;

  @ffi.Bool()
  external bool animatedAppearance;

  external _CAnimationMode iconAnimationMode;

}
// MARK: - SimpleClusterOptions <-> _CSimpleClusterOptions

extension _CSimpleClusterOptionsToDart on _CSimpleClusterOptions {
  SimpleClusterOptions _toDart() {
    return SimpleClusterOptions(
      icon: this.icon._toDart(),
      iconMapDirection: this.iconMapDirection._toDart(),
      anchor: this.anchor._toDart(),
      text: this.text._toDart(),
      textStyle: this.textStyle._toDart(),
      iconOpacity: this.iconOpacity._toDart(),
      iconWidth: this.iconWidth._toDart(),
      userData: this.userData._toDart(),
      zIndex: this.zIndex._toDart(),
      animatedAppearance: this.animatedAppearance,
      iconAnimationMode: this.iconAnimationMode._toDart()
    );
  }
}

extension _DartTo_CSimpleClusterOptions on SimpleClusterOptions {
  _CSimpleClusterOptions _copyFromDartTo_CSimpleClusterOptions() {
    final res = _CSimpleClusterOptionsMakeDefault();
    res.icon = this.icon._copyFromDartTo_COptional_CImage();
    res.iconMapDirection = this.iconMapDirection._copyFromDartTo_COptional_CMapDirection();
    res.anchor = this.anchor._copyFromDartTo_CAnchor();
    res.text = this.text._copyFromDartTo_COptional_CString();
    res.textStyle = this.textStyle._copyFromDartTo_COptional_CTextStyle();
    res.iconOpacity = this.iconOpacity._copyFromDartTo_COpacity();
    res.iconWidth = this.iconWidth._copyFromDartTo_CLogicalPixel();
    res.userData = this.userData._copyFromDartTo_CAny();
    res.zIndex = this.zIndex._copyFromDartTo_CZIndex();
    res.animatedAppearance = this.animatedAppearance;
    res.iconAnimationMode = this.iconAnimationMode._copyFromDartTo_CAnimationMode();
    return res;
  }
}
extension _CSimpleClusterOptionsRelease on _CSimpleClusterOptions {
  void _releaseIntermediate() {
    icon._releaseIntermediate();
    text._releaseIntermediate();
    textStyle._releaseIntermediate();
    userData._releaseIntermediate();
  }
}

// MARK: - SimpleClusterObject

/** Кластер простых (simple) объектов-маркеров. */
class SimpleClusterObject extends MapObject implements ffi.Finalizable {
  /** Получение позиции кластера на карте. */
  GeoPointWithElevation get position {
    _CGeoPointWithElevation res = _CSimpleClusterObject_position(_CSimpleClusterObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  /** Получение количества маркеров в кластере. */
  int get objectCount {
    int res = _CSimpleClusterObject_objectCount(_CSimpleClusterObjectMakeDefault().._impl=_self);
    return res;
  }
  /** Получение списка маркеров в кластере. */
  List<SimpleMapObject> get objects {
    _CArray_CSimpleMapObject res = _CSimpleClusterObject_objects(_CSimpleClusterObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Получение и установка точки привязки иконки кластера. */
  Anchor get anchor {
    _CAnchor res = _CSimpleClusterObject_anchor(_CSimpleClusterObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set anchor(Anchor anchor) {
    var _a1 = anchor._copyFromDartTo_CAnchor();
    void res = _CSimpleClusterObject_setAnchor_CAnchor(_CSimpleClusterObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Получение и установка прозрачности иконки кластера. */
  Opacity get iconOpacity {
    _COpacity res = _CSimpleClusterObject_iconOpacity(_CSimpleClusterObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set iconOpacity(Opacity opacity) {
    var _a1 = opacity._copyFromDartTo_COpacity();
    void res = _CSimpleClusterObject_setIconOpacity_COpacity(_CSimpleClusterObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Получение и установка подписи кластера. */
  String get text {
    _CString res = _CSimpleClusterObject_text(_CSimpleClusterObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set text(String text) {
    var _a1 = text._copyFromDartTo_CString();
    void res = _CSimpleClusterObject_setText_CString(_CSimpleClusterObjectMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /** Получение и установка стиля подписи кластера. */
  TextStyle get textStyle {
    _CTextStyle res = _CSimpleClusterObject_textStyle(_CSimpleClusterObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set textStyle(TextStyle style) {
    var _a1 = style._copyFromDartTo_CTextStyle();
    void res = _CSimpleClusterObject_setTextStyle_CTextStyle(_CSimpleClusterObjectMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /** Получение и установка целевой ширины кластера, используемой для масштабирования. */
  LogicalPixel get iconWidth {
    _CLogicalPixel res = _CSimpleClusterObject_iconWidth(_CSimpleClusterObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set iconWidth(LogicalPixel width) {
    var _a1 = width._copyFromDartTo_CLogicalPixel();
    void res = _CSimpleClusterObject_setIconWidth_CLogicalPixel(_CSimpleClusterObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Получение и установка угла поворота кластера на карте относительно направления на север, по часовой стрелке. */
  MapDirection? get iconMapDirection {
    _COptional_CMapDirection res = _CSimpleClusterObject_iconMapDirection(_CSimpleClusterObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set iconMapDirection(MapDirection? direction) {
    var _a1 = direction._copyFromDartTo_COptional_CMapDirection();
    void res = _CSimpleClusterObject_setIconMapDirection_COptional_CMapDirection(_CSimpleClusterObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Получение и установка флага анимируемости появления кластера. */
  bool get animatedAppearance {
    bool res = _CSimpleClusterObject_animatedAppearance(_CSimpleClusterObjectMakeDefault().._impl=_self);
    return res;
  }
  set animatedAppearance(bool animatedAppearance) {
    void res = _CSimpleClusterObject_setAnimatedAppearance_bool(_CSimpleClusterObjectMakeDefault().._impl=_self, animatedAppearance);
    return res;
  }
  /** Получение и установка уровня отрисовки объекта. */
  ZIndex get zIndex {
    _CZIndex res = _CSimpleClusterObject_zIndex(_CSimpleClusterObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set zIndex(ZIndex zIndex) {
    var _a1 = zIndex._copyFromDartTo_CZIndex();
    void res = _CSimpleClusterObject_setZIndex_CZIndex(_CSimpleClusterObjectMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CSimpleClusterObject_releasePtr);

  SimpleClusterObject._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory SimpleClusterObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = SimpleClusterObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is SimpleClusterObject &&
    other.runtimeType == runtimeType &&
    _CSimpleClusterObject_cg_objectIdentifier(this._self) == _CSimpleClusterObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CSimpleClusterObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: SimpleClusterObject: Methods

  /** Установка иконки кластера. */
  void setIcon(
    Image? icon
  )  {
    var _a1 = icon._copyFromDartTo_COptional_CImage();
    void res = _CSimpleClusterObject_setIcon_COptional_CImage(_CSimpleClusterObjectMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - SimpleClusterObject <-> CSimpleClusterObject

final class _CSimpleClusterObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CSimpleClusterObjectBasicFunctions on _CSimpleClusterObject {
  void _releaseIntermediate() {
    _CSimpleClusterObject_release(_impl);
  }

  _CSimpleClusterObject _retain() {
    return _CSimpleClusterObject_retain(_impl);
  }
}

extension _CSimpleClusterObjectToDart on _CSimpleClusterObject {
  SimpleClusterObject _toDart() {
    return SimpleClusterObject._create(_retain()._impl);
  }
}


extension _DartToCSimpleClusterObject on SimpleClusterObject {
  _CSimpleClusterObject _copyFromDartTo_CSimpleClusterObject() {
    return (_CSimpleClusterObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - SimpleClusterRenderer

/** Класс для кастомизации внешнего вида кластера в IMapObjectManager. */
abstract class SimpleClusterRenderer {
  SimpleClusterOptions renderCluster(
    SimpleClusterObject cluster
  );
}

class _SimpleClusterRenderer {
  final SimpleClusterRenderer object;
  int refCounter = 1;

  _SimpleClusterRenderer(this.object);
}

final class _CSimpleClusterRenderer extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.Void> _cppValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CSimpleClusterOptions)>>, _CSimpleClusterObject)>> _renderCluster_CSimpleClusterObject;
}

extension _CSimpleClusterRendererBasicFunctions on _CSimpleClusterRenderer {
  void _releaseIntermediate() {
    _CSimpleClusterRenderer_release(this);
  }
}

int _CSimpleClusterRendererInstanceCounter = 1;
final _CSimpleClusterRendererInstanceMap = <int, _SimpleClusterRenderer>{};

extension _CSimpleClusterRendererToDart on _CSimpleClusterRenderer {
  SimpleClusterRenderer _toDart() {
    late SimpleClusterRenderer? result;
    final platformValue = this._value.cast<ffi.Int64>();
    if (platformValue.address != 0) {
      result = _CSimpleClusterRendererInstanceMap[platformValue.address]?.object;
    } else if (this._cppValue.address != 0) {
      final cppValue = _CSimpleClusterRendererCppMakeDefault().._impl = this._cppValue;
      result = cppValue._toDart();
    }
    if (result == null) {
      throw Exception("Invalid intermediate object of type _CSimpleClusterRenderer");
    }
    return result;
  }
}

extension _DartTo_CSimpleClusterRenderer on SimpleClusterRenderer {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    _CSimpleClusterRendererInstanceMap[platformValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    final platformObject = _CSimpleClusterRendererInstanceMap[platformValue.address];
    if (platformObject == null) {
      return;
    }
    platformObject.refCounter -= 1;
    if (platformObject.refCounter > 0) {
      return;
    }
    _CSimpleClusterRendererInstanceMap.remove(platformValue.address);
  }

  _CSimpleClusterRenderer _copyFromDartTo_CSimpleClusterRenderer() {
    var res = _CSimpleClusterRendererMakeDefault();
    if (this is _SimpleClusterRendererCpp) {
      final cppValue = this as _SimpleClusterRendererCpp;
      res._cppValue = cppValue._copyFromDartTo_CSimpleClusterRendererCpp()._impl;
      return res;
    }
    final instanceId = _CSimpleClusterRendererInstanceCounter;
    _CSimpleClusterRendererInstanceCounter += 1;
    _CSimpleClusterRendererInstanceMap[instanceId] = _SimpleClusterRenderer(this);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;

    final renderCluster_CSimpleClusterObjectFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CSimpleClusterOptions)>>, _CSimpleClusterObject)>.listener(renderCluster_CSimpleClusterObjectFunction);
    res._renderCluster_CSimpleClusterObject = renderCluster_CSimpleClusterObjectFunctionCallable.nativeFunction;
    return res;
  }

  static void renderCluster_CSimpleClusterObjectFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CSimpleClusterOptions)>> resultValueCallback, _CSimpleClusterObject cluster) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CSimpleClusterRenderer");
    }
    final platformObject = _CSimpleClusterRendererInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CSimpleClusterRenderer");
    }

    final clusterDart = cluster._toDart();
    final res = platformObject.object.renderCluster(clusterDart);
    cluster._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _CSimpleClusterOptions)>();
    callbackFunction(context, res._copyFromDartTo_CSimpleClusterOptions());
  }


}

// MARK: - Marker

/** Точечная отметка на карте, представляющая интерес для пользователя. */
class Marker extends SimpleMapObject implements ffi.Finalizable {
  /** Получение местоположения маркера. */
  GeoPointWithElevation get position {
    _CGeoPointWithElevation res = _CMarker_position(_CMarkerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set position(GeoPointWithElevation position) {
    var _a1 = position._copyFromDartTo_CGeoPointWithElevation();
    void res = _CMarker_setPosition_CGeoPointWithElevation(_CMarkerMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Получение иконки маркера. */
  Image? get icon {
    _COptional_CImage res = _CMarker_icon(_CMarkerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set icon(Image? icon) {
    var _a1 = icon._copyFromDartTo_COptional_CImage();
    void res = _CMarker_setIcon_COptional_CImage(_CMarkerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /** Получение точки привязки иконки маркера. */
  Anchor get anchor {
    _CAnchor res = _CMarker_anchor(_CMarkerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set anchor(Anchor anchor) {
    var _a1 = anchor._copyFromDartTo_CAnchor();
    void res = _CMarker_setAnchor_CAnchor(_CMarkerMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Получение прозрачности иконки маркера. */
  Opacity get iconOpacity {
    _COpacity res = _CMarker_iconOpacity(_CMarkerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set iconOpacity(Opacity opacity) {
    var _a1 = opacity._copyFromDartTo_COpacity();
    void res = _CMarker_setIconOpacity_COpacity(_CMarkerMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Получение подписи маркера. */
  String get text {
    _CString res = _CMarker_text(_CMarkerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set text(String text) {
    var _a1 = text._copyFromDartTo_CString();
    void res = _CMarker_setText_CString(_CMarkerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /** Получение стиля подписи маркера. */
  TextStyle get textStyle {
    _CTextStyle res = _CMarker_textStyle(_CMarkerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set textStyle(TextStyle style) {
    var _a1 = style._copyFromDartTo_CTextStyle();
    void res = _CMarker_setTextStyle_CTextStyle(_CMarkerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /** Получение флага перемещаемости маркера. */
  bool get isDraggable {
    bool res = _CMarker_isDraggable(_CMarkerMakeDefault().._impl=_self);
    return res;
  }
  set isDraggable(bool draggable) {
    void res = _CMarker_setDraggable_bool(_CMarkerMakeDefault().._impl=_self, draggable);
    return res;
  }
  /** Получение целевой ширины маркера, используемой для масштабирования. */
  LogicalPixel get iconWidth {
    _CLogicalPixel res = _CMarker_iconWidth(_CMarkerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set iconWidth(LogicalPixel width) {
    var _a1 = width._copyFromDartTo_CLogicalPixel();
    void res = _CMarker_setIconWidth_CLogicalPixel(_CMarkerMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Угол поворота маркера на карте относительно направления на север, по часовой стрелке. */
  MapDirection? get iconMapDirection {
    _COptional_CMapDirection res = _CMarker_iconMapDirection(_CMarkerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set iconMapDirection(MapDirection? direction) {
    var _a1 = direction._copyFromDartTo_COptional_CMapDirection();
    void res = _CMarker_setIconMapDirection_COptional_CMapDirection(_CMarkerMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Анимировать ли появление. */
  bool get animatedAppearance {
    bool res = _CMarker_animatedAppearance(_CMarkerMakeDefault().._impl=_self);
    return res;
  }
  set animatedAppearance(bool animatedAppearance) {
    void res = _CMarker_setAnimatedAppearance_bool(_CMarkerMakeDefault().._impl=_self, animatedAppearance);
    return res;
  }
  /** Получение режима анимации анимированного маркера. */
  AnimationMode get iconAnimationMode {
    _CAnimationMode res = _CMarker_iconAnimationMode(_CMarkerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set iconAnimationMode(AnimationMode iconAnimationMode) {
    var _a1 = iconAnimationMode._copyFromDartTo_CAnimationMode();
    void res = _CMarker_setIconAnimationMode_CAnimationMode(_CMarkerMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CMarker_releasePtr);

  Marker._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory Marker._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Marker._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory Marker(
    MarkerOptions options
  ) {
    var _a0 = options._copyFromDartTo_CMarkerOptions();
    _CResult_CMarker res = _CMarker_C_createWith_CMarkerOptions(_a0);
    _a0._releaseIntermediate();
    return Marker._create(res._toCDart()._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Marker &&
    other.runtimeType == runtimeType &&
    _CMarker_cg_objectIdentifier(this._self) == _CMarker_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMarker_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Marker <-> CMarker

final class _CMarker extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMarkerBasicFunctions on _CMarker {
  void _releaseIntermediate() {
    _CMarker_release(_impl);
  }

  _CMarker _retain() {
    return _CMarker_retain(_impl);
  }
}

extension _CMarkerToDart on _CMarker {
  Marker _toDart() {
    return Marker._create(_retain()._impl);
  }
}


extension _DartToCMarker on Marker {
  _CMarker _copyFromDartTo_CMarker() {
    return (_CMarkerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - MarkerOptions

/** Параметры маркера. */
class MarkerOptions {
  final GeoPointWithElevation position;
  final Image? icon;
  final MapDirection? iconMapDirection;
  final Anchor anchor;
  final String? text;
  final TextStyle? textStyle;
  final Opacity iconOpacity;
  final bool visible;
  final bool draggable;
  /** Целевая ширина, используемая для масштабирования. */
  final LogicalPixel iconWidth;
  final Object? userData;
  /** Уровень отрисовки объекта. */
  final ZIndex zIndex;
  /** Анимировать ли появление. */
  final bool animatedAppearance;
  /** Привязка к поэтажному плану здания. */
  final LevelId? levelId;
  /** Режим анимации. */
  final AnimationMode iconAnimationMode;

  const MarkerOptions({
    required this.position,
    required this.icon,
    this.iconMapDirection = null,
    this.anchor = const Anchor(x: 0.5, y: 0.5),
    this.text = null,
    this.textStyle = null,
    this.iconOpacity = const Opacity(1),
    this.visible = true,
    this.draggable = false,
    this.iconWidth = const LogicalPixel(0),
    this.userData = const {},
    this.zIndex = const ZIndex(0),
    this.animatedAppearance = true,
    this.levelId = null,
    this.iconAnimationMode = AnimationMode.normal
  });

  MarkerOptions copyWith({
    GeoPointWithElevation? position,
    Optional<Image?>? icon,
    Optional<MapDirection?>? iconMapDirection,
    Anchor? anchor,
    Optional<String?>? text,
    Optional<TextStyle?>? textStyle,
    Opacity? iconOpacity,
    bool? visible,
    bool? draggable,
    LogicalPixel? iconWidth,
    Optional<Object?>? userData,
    ZIndex? zIndex,
    bool? animatedAppearance,
    Optional<LevelId?>? levelId,
    AnimationMode? iconAnimationMode
  }) {
    return MarkerOptions(
      position: position ?? this.position,
      icon: icon != null ? icon.value : this.icon,
      iconMapDirection: iconMapDirection != null ? iconMapDirection.value : this.iconMapDirection,
      anchor: anchor ?? this.anchor,
      text: text != null ? text.value : this.text,
      textStyle: textStyle != null ? textStyle.value : this.textStyle,
      iconOpacity: iconOpacity ?? this.iconOpacity,
      visible: visible ?? this.visible,
      draggable: draggable ?? this.draggable,
      iconWidth: iconWidth ?? this.iconWidth,
      userData: userData != null ? userData.value : this.userData,
      zIndex: zIndex ?? this.zIndex,
      animatedAppearance: animatedAppearance ?? this.animatedAppearance,
      levelId: levelId != null ? levelId.value : this.levelId,
      iconAnimationMode: iconAnimationMode ?? this.iconAnimationMode
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MarkerOptions &&
    other.runtimeType == runtimeType &&
    other.position == position &&
    other.icon == icon &&
    other.iconMapDirection == iconMapDirection &&
    other.anchor == anchor &&
    other.text == text &&
    other.textStyle == textStyle &&
    other.iconOpacity == iconOpacity &&
    other.visible == visible &&
    other.draggable == draggable &&
    other.iconWidth == iconWidth &&
    other.userData == userData &&
    other.zIndex == zIndex &&
    other.animatedAppearance == animatedAppearance &&
    other.levelId == levelId &&
    other.iconAnimationMode == iconAnimationMode;

  @override
  int get hashCode {
    return Object.hash(position, icon, iconMapDirection, anchor, text, textStyle, iconOpacity, visible, draggable, iconWidth, userData, zIndex, animatedAppearance, levelId, iconAnimationMode);
  }

}
final class _CMarkerOptions extends ffi.Struct {
  external _CGeoPointWithElevation position;

  external _COptional_CImage icon;

  external _COptional_CMapDirection iconMapDirection;

  external _CAnchor anchor;

  external _COptional_CString text;

  external _COptional_CTextStyle textStyle;

  external _COpacity iconOpacity;

  @ffi.Bool()
  external bool visible;

  @ffi.Bool()
  external bool draggable;

  external _CLogicalPixel iconWidth;

  external _CAny userData;

  external _CZIndex zIndex;

  @ffi.Bool()
  external bool animatedAppearance;

  external _COptional_CLevelId levelId;

  external _CAnimationMode iconAnimationMode;

}
// MARK: - MarkerOptions <-> _CMarkerOptions

extension _CMarkerOptionsToDart on _CMarkerOptions {
  MarkerOptions _toDart() {
    return MarkerOptions(
      position: this.position._toDart(),
      icon: this.icon._toDart(),
      iconMapDirection: this.iconMapDirection._toDart(),
      anchor: this.anchor._toDart(),
      text: this.text._toDart(),
      textStyle: this.textStyle._toDart(),
      iconOpacity: this.iconOpacity._toDart(),
      visible: this.visible,
      draggable: this.draggable,
      iconWidth: this.iconWidth._toDart(),
      userData: this.userData._toDart(),
      zIndex: this.zIndex._toDart(),
      animatedAppearance: this.animatedAppearance,
      levelId: this.levelId._toDart(),
      iconAnimationMode: this.iconAnimationMode._toDart()
    );
  }
}

extension _DartTo_CMarkerOptions on MarkerOptions {
  _CMarkerOptions _copyFromDartTo_CMarkerOptions() {
    final res = _CMarkerOptionsMakeDefault();
    res.position = this.position._copyFromDartTo_CGeoPointWithElevation();
    res.icon = this.icon._copyFromDartTo_COptional_CImage();
    res.iconMapDirection = this.iconMapDirection._copyFromDartTo_COptional_CMapDirection();
    res.anchor = this.anchor._copyFromDartTo_CAnchor();
    res.text = this.text._copyFromDartTo_COptional_CString();
    res.textStyle = this.textStyle._copyFromDartTo_COptional_CTextStyle();
    res.iconOpacity = this.iconOpacity._copyFromDartTo_COpacity();
    res.visible = this.visible;
    res.draggable = this.draggable;
    res.iconWidth = this.iconWidth._copyFromDartTo_CLogicalPixel();
    res.userData = this.userData._copyFromDartTo_CAny();
    res.zIndex = this.zIndex._copyFromDartTo_CZIndex();
    res.animatedAppearance = this.animatedAppearance;
    res.levelId = this.levelId._copyFromDartTo_COptional_CLevelId();
    res.iconAnimationMode = this.iconAnimationMode._copyFromDartTo_CAnimationMode();
    return res;
  }
}
extension _CMarkerOptionsRelease on _CMarkerOptions {
  void _releaseIntermediate() {
    icon._releaseIntermediate();
    text._releaseIntermediate();
    textStyle._releaseIntermediate();
    userData._releaseIntermediate();
  }
}

// MARK: - Marker <-> _CResult_CMarker

final class _CResult_CMarkerImpl extends ffi.Union {
  
  external _CMarker _value;
  external _CError _error;
}

final class _CResult_CMarker extends ffi.Struct {
  external _CResult_CMarkerImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CMarkerBasicFunctions on _CResult_CMarker {
  void _releaseIntermediate() {
    _CResult_CMarker_release(this);
  }
}

extension _CResult_CMarkerToDart on _CResult_CMarker {
  Marker _toDart() {
    if (this._index == 0) {
      return this._impl._value._toDart();
    } else {
      throw this._impl._error._toDart();
    }
  }

  _CMarker _toCDart() {
    if (this._index == 0) {
      return this._impl._value;
    } else {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - _ModelDataLoaderCpp

/** Загрузчик данных модели. */
class _ModelDataLoaderCpp extends ModelDataLoader implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CModelDataLoaderCpp_releasePtr);

  _ModelDataLoaderCpp._raw(this._self);
  factory _ModelDataLoaderCpp._create(ffi.Pointer<ffi.Void> self) {
    final classObject = _ModelDataLoaderCpp._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is _ModelDataLoaderCpp &&
    other.runtimeType == runtimeType &&
    _CModelDataLoaderCpp_cg_objectIdentifier(this._self) == _CModelDataLoaderCpp_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CModelDataLoaderCpp_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: _ModelDataLoaderCpp: Methods

  ByteData load()  {
    _CData res = _CModelDataLoaderCpp_load(_CModelDataLoaderCppMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - _ModelDataLoaderCpp <-> CModelDataLoaderCpp

final class _CModelDataLoaderCpp extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CModelDataLoaderCppBasicFunctions on _CModelDataLoaderCpp {
  void _releaseIntermediate() {
    _CModelDataLoaderCpp_release(_impl);
  }

  _CModelDataLoaderCpp _retain() {
    return _CModelDataLoaderCpp_retain(_impl);
  }
}

extension _CModelDataLoaderCppToDart on _CModelDataLoaderCpp {
  _ModelDataLoaderCpp _toDart() {
    return _ModelDataLoaderCpp._create(_retain()._impl);
  }
}


extension _DartToCModelDataLoaderCpp on _ModelDataLoaderCpp {
  _CModelDataLoaderCpp _copyFromDartTo_CModelDataLoaderCpp() {
    return (_CModelDataLoaderCppMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ModelDataLoader

/** Загрузчик данных модели. */
@internal
abstract class ModelDataLoader {
  ByteData load();
}

class _ModelDataLoader {
  final ModelDataLoader object;
  int refCounter = 1;

  _ModelDataLoader(this.object);
}

final class _CModelDataLoader extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.Void> _cppValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CData)>>)>> _load;
}

extension _CModelDataLoaderBasicFunctions on _CModelDataLoader {
  void _releaseIntermediate() {
    _CModelDataLoader_release(this);
  }
}

int _CModelDataLoaderInstanceCounter = 1;
final _CModelDataLoaderInstanceMap = <int, _ModelDataLoader>{};

extension _CModelDataLoaderToDart on _CModelDataLoader {
  ModelDataLoader _toDart() {
    late ModelDataLoader? result;
    final platformValue = this._value.cast<ffi.Int64>();
    if (platformValue.address != 0) {
      result = _CModelDataLoaderInstanceMap[platformValue.address]?.object;
    } else if (this._cppValue.address != 0) {
      final cppValue = _CModelDataLoaderCppMakeDefault().._impl = this._cppValue;
      result = cppValue._toDart();
    }
    if (result == null) {
      throw Exception("Invalid intermediate object of type _CModelDataLoader");
    }
    return result;
  }
}

extension _DartTo_CModelDataLoader on ModelDataLoader {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    _CModelDataLoaderInstanceMap[platformValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    final platformObject = _CModelDataLoaderInstanceMap[platformValue.address];
    if (platformObject == null) {
      return;
    }
    platformObject.refCounter -= 1;
    if (platformObject.refCounter > 0) {
      return;
    }
    _CModelDataLoaderInstanceMap.remove(platformValue.address);
  }

  _CModelDataLoader _copyFromDartTo_CModelDataLoader() {
    var res = _CModelDataLoaderMakeDefault();
    if (this is _ModelDataLoaderCpp) {
      final cppValue = this as _ModelDataLoaderCpp;
      res._cppValue = cppValue._copyFromDartTo_CModelDataLoaderCpp()._impl;
      return res;
    }
    final instanceId = _CModelDataLoaderInstanceCounter;
    _CModelDataLoaderInstanceCounter += 1;
    _CModelDataLoaderInstanceMap[instanceId] = _ModelDataLoader(this);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;

    final loadFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CData)>>)>.listener(loadFunction);
    res._load = loadFunctionCallable.nativeFunction;
    return res;
  }

  static void loadFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CData)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CModelDataLoader");
    }
    final platformObject = _CModelDataLoaderInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CModelDataLoader");
    }

    final res = platformObject.object.load();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _CData)>();
    callbackFunction(context, res._copyFromDartTo_CData());
  }


}

// MARK: - ModelSize

/**
 Размер модели.
 Если LogicalPixel, то размер модели не будет привязан к масштабу карты и останется неизменным относительно экрана.
 Если ModelScale, то размер модели умножится на коэффициент и привяжется к масштабу карты.
*/
final class ModelSize {
  final Object? _value;
  final int _index;

  ModelSize._raw(this._value, this._index);

  ModelSize.logicalPixel(LogicalPixel value) : this._raw(value, 0);
  ModelSize.scale(ModelScale value) : this._raw(value, 1);

  bool get isLogicalPixel => this._index == 0;
  LogicalPixel? get asLogicalPixel => this.isLogicalPixel ? this._value as LogicalPixel : null;

  bool get isScale => this._index == 1;
  ModelScale? get asScale => this.isScale ? this._value as ModelScale : null;

  T match<T>({
    required T Function(LogicalPixel value) logicalPixel,
    required T Function(ModelScale value) scale,
  }) {
    return switch (this._index) {
      0 => logicalPixel(this._value as LogicalPixel),
      1 => scale(this._value as ModelScale),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "ModelSize(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ModelSize &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CModelSizeImpl extends ffi.Union {
  external _CLogicalPixel _logicalPixel;
  external _CModelScale _scale;
}

final class _CModelSize extends ffi.Struct {
  external _CModelSizeImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CModelSizeBasicFunctions on _CModelSize {
  void _releaseIntermediate() {
    _CModelSize_release(this);
  }
}
	
// MARK: - ModelSize <-> CModelSize

extension _CModelSizeToDart on _CModelSize {
  ModelSize _toDart() {
    return switch (this._index) {
      0 => ModelSize.logicalPixel(this._impl._logicalPixel._toDart()),
      1 => ModelSize.scale(this._impl._scale._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CModelSize on ModelSize {
  _CModelSize _copyFromDartTo_CModelSize() {
    var res = _CModelSizeMakeDefault();
    this.match<void>(
      logicalPixel: (LogicalPixel value) {
        res._impl._logicalPixel = value._copyFromDartTo_CLogicalPixel();
        res._index = 0;
      },
      scale: (ModelScale value) {
        res._impl._scale = value._copyFromDartTo_CModelScale();
        res._index = 1;
      },
    );
    return res;
  }
}

// MARK: - ModelMapObjectOptions

/** Параметры модели. */
class ModelMapObjectOptions {
  /** Местоположение. */
  final GeoPointWithElevation position;
  /** Данные. */
  final ModelData? data;
  /** Целевая ширина, используемая для масштабирования. */
  final ModelSize size;
  /** Угол поворота модели на карте относительно направления на север, по часовой стрелке. */
  final MapDirection? mapDirection;
  /** Прозрачность. */
  final Opacity opacity;
  /** Видимость. */
  final bool visible;
  /** Пользовательские данные. */
  final Object? userData;
  /** Привязка к поэтажному плану здания. */
  final LevelId? levelId;

  const ModelMapObjectOptions({
    required this.position,
    required this.data,
    required this.size,
    this.mapDirection = null,
    this.opacity = const Opacity(1),
    this.visible = true,
    this.userData = const {},
    this.levelId = null
  });

  ModelMapObjectOptions copyWith({
    GeoPointWithElevation? position,
    Optional<ModelData?>? data,
    ModelSize? size,
    Optional<MapDirection?>? mapDirection,
    Opacity? opacity,
    bool? visible,
    Optional<Object?>? userData,
    Optional<LevelId?>? levelId
  }) {
    return ModelMapObjectOptions(
      position: position ?? this.position,
      data: data != null ? data.value : this.data,
      size: size ?? this.size,
      mapDirection: mapDirection != null ? mapDirection.value : this.mapDirection,
      opacity: opacity ?? this.opacity,
      visible: visible ?? this.visible,
      userData: userData != null ? userData.value : this.userData,
      levelId: levelId != null ? levelId.value : this.levelId
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ModelMapObjectOptions &&
    other.runtimeType == runtimeType &&
    other.position == position &&
    other.data == data &&
    other.size == size &&
    other.mapDirection == mapDirection &&
    other.opacity == opacity &&
    other.visible == visible &&
    other.userData == userData &&
    other.levelId == levelId;

  @override
  int get hashCode {
    return Object.hash(position, data, size, mapDirection, opacity, visible, userData, levelId);
  }

}
final class _CModelMapObjectOptions extends ffi.Struct {
  external _CGeoPointWithElevation position;

  external _COptional_CModelData data;

  external _CModelSize size;

  external _COptional_CMapDirection mapDirection;

  external _COpacity opacity;

  @ffi.Bool()
  external bool visible;

  external _CAny userData;

  external _COptional_CLevelId levelId;

}
// MARK: - ModelMapObjectOptions <-> _CModelMapObjectOptions

extension _CModelMapObjectOptionsToDart on _CModelMapObjectOptions {
  ModelMapObjectOptions _toDart() {
    return ModelMapObjectOptions(
      position: this.position._toDart(),
      data: this.data._toDart(),
      size: this.size._toDart(),
      mapDirection: this.mapDirection._toDart(),
      opacity: this.opacity._toDart(),
      visible: this.visible,
      userData: this.userData._toDart(),
      levelId: this.levelId._toDart()
    );
  }
}

extension _DartTo_CModelMapObjectOptions on ModelMapObjectOptions {
  _CModelMapObjectOptions _copyFromDartTo_CModelMapObjectOptions() {
    final res = _CModelMapObjectOptionsMakeDefault();
    res.position = this.position._copyFromDartTo_CGeoPointWithElevation();
    res.data = this.data._copyFromDartTo_COptional_CModelData();
    res.size = this.size._copyFromDartTo_CModelSize();
    res.mapDirection = this.mapDirection._copyFromDartTo_COptional_CMapDirection();
    res.opacity = this.opacity._copyFromDartTo_COpacity();
    res.visible = this.visible;
    res.userData = this.userData._copyFromDartTo_CAny();
    res.levelId = this.levelId._copyFromDartTo_COptional_CLevelId();
    return res;
  }
}
extension _CModelMapObjectOptionsRelease on _CModelMapObjectOptions {
  void _releaseIntermediate() {
    data._releaseIntermediate();
    userData._releaseIntermediate();
  }
}

// MARK: - ModelMapObject

/** Модель на карте. */
class ModelMapObject extends SimpleMapObject implements ffi.Finalizable {
  /** Местоположения модели. */
  GeoPointWithElevation get position {
    _CGeoPointWithElevation res = _CModelMapObject_position(_CModelMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set position(GeoPointWithElevation position) {
    var _a1 = position._copyFromDartTo_CGeoPointWithElevation();
    void res = _CModelMapObject_setPosition_CGeoPointWithElevation(_CModelMapObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Данные модели. */
  ModelData? get modelData {
    _COptional_CModelData res = _CModelMapObject_modelData(_CModelMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set modelData(ModelData? model) {
    var _a1 = model._copyFromDartTo_COptional_CModelData();
    void res = _CModelMapObject_setModelData_COptional_CModelData(_CModelMapObjectMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  /** Прозрачность модели. */
  Opacity get opacity {
    _COpacity res = _CModelMapObject_opacity(_CModelMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set opacity(Opacity opacity) {
    var _a1 = opacity._copyFromDartTo_COpacity();
    void res = _CModelMapObject_setOpacity_COpacity(_CModelMapObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Размер модели. */
  ModelSize get size {
    _CModelSize res = _CModelMapObject_size(_CModelMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set size(ModelSize width) {
    var _a1 = width._copyFromDartTo_CModelSize();
    void res = _CModelMapObject_setSize_CModelSize(_CModelMapObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Угол поворота модели на карте относительно направления на север, по часовой стрелке. */
  MapDirection? get mapDirection {
    _COptional_CMapDirection res = _CModelMapObject_mapDirection(_CModelMapObjectMakeDefault().._impl=_self);
    return res._toDart();
  }
  set mapDirection(MapDirection? direction) {
    var _a1 = direction._copyFromDartTo_COptional_CMapDirection();
    void res = _CModelMapObject_setMapDirection_COptional_CMapDirection(_CModelMapObjectMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Настройки анимации. */
  AnimationSettings get animationSettings {
    _CAnimationSettings res = _CModelMapObject_animationSettings(_CModelMapObjectMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CModelMapObject_releasePtr);

  ModelMapObject._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory ModelMapObject._create(ffi.Pointer<ffi.Void> self) {
    final classObject = ModelMapObject._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory ModelMapObject(
    ModelMapObjectOptions options
  ) {
    var _a0 = options._copyFromDartTo_CModelMapObjectOptions();
    _CResult_CModelMapObject res = _CModelMapObject_C_createWith_CModelMapObjectOptions(_a0);
    _a0._releaseIntermediate();
    return ModelMapObject._create(res._toCDart()._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ModelMapObject &&
    other.runtimeType == runtimeType &&
    _CModelMapObject_cg_objectIdentifier(this._self) == _CModelMapObject_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CModelMapObject_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - ModelMapObject <-> CModelMapObject

final class _CModelMapObject extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CModelMapObjectBasicFunctions on _CModelMapObject {
  void _releaseIntermediate() {
    _CModelMapObject_release(_impl);
  }

  _CModelMapObject _retain() {
    return _CModelMapObject_retain(_impl);
  }
}

extension _CModelMapObjectToDart on _CModelMapObject {
  ModelMapObject _toDart() {
    return ModelMapObject._create(_retain()._impl);
  }
}


extension _DartToCModelMapObject on ModelMapObject {
  _CModelMapObject _copyFromDartTo_CModelMapObject() {
    return (_CModelMapObjectMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ModelMapObject <-> _CResult_CModelMapObject

final class _CResult_CModelMapObjectImpl extends ffi.Union {
  
  external _CModelMapObject _value;
  external _CError _error;
}

final class _CResult_CModelMapObject extends ffi.Struct {
  external _CResult_CModelMapObjectImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CModelMapObjectBasicFunctions on _CResult_CModelMapObject {
  void _releaseIntermediate() {
    _CResult_CModelMapObject_release(this);
  }
}

extension _CResult_CModelMapObjectToDart on _CResult_CModelMapObject {
  ModelMapObject _toDart() {
    if (this._index == 0) {
      return this._impl._value._toDart();
    } else {
      throw this._impl._error._toDart();
    }
  }

  _CModelMapObject _toCDart() {
    if (this._index == 0) {
      return this._impl._value;
    } else {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - createModelData

@internal
ModelData createModelData(
  Context context,
  ModelDataLoader loader
){
  var _a0 = context._copyFromDartTo_CContext();
  var _a1 = loader._copyFromDartTo_CModelDataLoader();
  _CModelData res = _CFunction_G_createModelData_With_CContext_CModelDataLoader(_a0, _a1);
  _a1._releaseIntermediate();
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - parseGeoJsonFile

List<GeometryMapObject> parseGeoJsonFile(
  String fsPath
){
  var _a0 = fsPath._copyFromDartTo_CString();
  _CArray_CGeometryMapObject res = _CFunction_G_parseGeoJsonFile_With_CString(_a0);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - parseGeoJson

List<GeometryMapObject> parseGeoJson(
  String geoJsonData
){
  var _a0 = geoJsonData._copyFromDartTo_CString();
  _CArray_CGeometryMapObject res = _CFunction_G_parseGeoJson_With_CString(_a0);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - calcPositionForGeometry

CameraPosition calcPositionForGeometry(
  BaseCamera camera,
  Geometry geometry,
  StyleZoomToTiltRelation? styleZoomToTiltRelation,
  Padding? screenArea,
  Tilt? tilt,
  Bearing? bearing,
  ScreenSize? size
){
  var _a0 = camera._copyFromDartTo_CBaseCamera();
  var _a1 = geometry._copyFromDartTo_CGeometry();
  var _a2 = styleZoomToTiltRelation._copyFromDartTo_COptional_CStyleZoomToTiltRelation();
  var _a3 = screenArea._copyFromDartTo_COptional_CPadding();
  var _a4 = tilt._copyFromDartTo_COptional_CTilt();
  var _a5 = bearing._copyFromDartTo_COptional_CBearing();
  var _a6 = size._copyFromDartTo_COptional_CScreenSize();
  _CCameraPosition res = _CFunction_G_calcPositionForGeometry_With_CBaseCamera_CGeometry_COptional_CStyleZoomToTiltRelation_COptional_CPadding_COptional_CTilt_COptional_CBearing_COptional_CScreenSize(_a0, _a1, _a2, _a3, _a4, _a5, _a6);
  _a2._releaseIntermediate();
  _a1._releaseIntermediate();
  _a0._releaseIntermediate();
  return res._toDart();
}

// MARK: - Padding? <-> _COptional_CPadding

final class _COptional_CPadding extends ffi.Struct {
  
  external _CPadding value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CPaddingBasicFunctions on _COptional_CPadding {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CPaddingToDart on _COptional_CPadding {
  Padding? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CPadding on Padding? {
  _COptional_CPadding _copyFromDartTo_COptional_CPadding() {
    final cOptional = _COptional_CPaddingMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CPadding();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - ScreenSize? <-> _COptional_CScreenSize

final class _COptional_CScreenSize extends ffi.Struct {
  
  external _CScreenSize value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CScreenSizeBasicFunctions on _COptional_CScreenSize {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CScreenSizeToDart on _COptional_CScreenSize {
  ScreenSize? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CScreenSize on ScreenSize? {
  _COptional_CScreenSize _copyFromDartTo_COptional_CScreenSize() {
    final cOptional = _COptional_CScreenSizeMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CScreenSize();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - calcPositionForObjects

CameraPosition calcPositionForObjects(
  BaseCamera camera,
  List<SimpleMapObject> objects,
  StyleZoomToTiltRelation? styleZoomToTiltRelation,
  Padding? screenArea,
  Tilt? tilt,
  Bearing? bearing,
  ScreenSize? size
){
  var _a0 = camera._copyFromDartTo_CBaseCamera();
  var _a1 = objects._copyFromDartTo_CArray_CSimpleMapObject();
  var _a2 = styleZoomToTiltRelation._copyFromDartTo_COptional_CStyleZoomToTiltRelation();
  var _a3 = screenArea._copyFromDartTo_COptional_CPadding();
  var _a4 = tilt._copyFromDartTo_COptional_CTilt();
  var _a5 = bearing._copyFromDartTo_COptional_CBearing();
  var _a6 = size._copyFromDartTo_COptional_CScreenSize();
  _CCameraPosition res = _CFunction_G_calcPositionForObjects_With_CBaseCamera_CArray_CSimpleMapObject_COptional_CStyleZoomToTiltRelation_COptional_CPadding_COptional_CTilt_COptional_CBearing_COptional_CScreenSize(_a0, _a1, _a2, _a3, _a4, _a5, _a6);
  _a2._releaseIntermediate();
  _a1._releaseIntermediate();
  _a0._releaseIntermediate();
  return res._toDart();
}

// MARK: - zoomOutToFitForGeometry

CameraPosition zoomOutToFitForGeometry(
  BaseCamera camera,
  Geometry geometry,
  [StyleZoomToTiltRelation? styleZoomToTiltRelation = null,
  ScreenSize? size = null
  ]){
  var _a0 = camera._copyFromDartTo_CBaseCamera();
  var _a1 = geometry._copyFromDartTo_CGeometry();
  var _a2 = styleZoomToTiltRelation._copyFromDartTo_COptional_CStyleZoomToTiltRelation();
  var _a3 = size._copyFromDartTo_COptional_CScreenSize();
  _CCameraPosition res = _CFunction_G_zoomOutToFitForGeometry_With_CBaseCamera_CGeometry_COptional_CStyleZoomToTiltRelation_COptional_CScreenSize(_a0, _a1, _a2, _a3);
  _a2._releaseIntermediate();
  _a1._releaseIntermediate();
  _a0._releaseIntermediate();
  return res._toDart();
}

// MARK: - zoomOutToFitForObjects

CameraPosition zoomOutToFitForObjects(
  BaseCamera camera,
  List<SimpleMapObject> objects,
  [StyleZoomToTiltRelation? styleZoomToTiltRelation = null,
  ScreenSize? size = null
  ]){
  var _a0 = camera._copyFromDartTo_CBaseCamera();
  var _a1 = objects._copyFromDartTo_CArray_CSimpleMapObject();
  var _a2 = styleZoomToTiltRelation._copyFromDartTo_COptional_CStyleZoomToTiltRelation();
  var _a3 = size._copyFromDartTo_COptional_CScreenSize();
  _CCameraPosition res = _CFunction_G_zoomOutToFitForObjects_With_CBaseCamera_CArray_CSimpleMapObject_COptional_CStyleZoomToTiltRelation_COptional_CScreenSize(_a0, _a1, _a2, _a3);
  _a2._releaseIntermediate();
  _a1._releaseIntermediate();
  _a0._releaseIntermediate();
  return res._toDart();
}

// MARK: - createImage

@internal
Image createImage(
  Context context,
  ImageLoader loader
){
  var _a0 = context._copyFromDartTo_CContext();
  var _a1 = loader._copyFromDartTo_CImageLoader();
  _CImage res = _CFunction_G_createImage_With_CContext_CImageLoader(_a0, _a1);
  _a1._releaseIntermediate();
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - createDefaultMaxTiltRestriction

/** Получаем стандартную зависимость максимального угла наклона от стилевого уровня масштабирования. */
StyleZoomToTiltRelation createDefaultMaxTiltRestriction(){
  _CStyleZoomToTiltRelation res = _CFunction_G_createDefaultMaxTiltRestriction();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - createDefaultStyleZoomToTiltRelation

/**
 Получение зависимости угла наклона камеры от стилевого уровня масштабирования
 для стандартного контроллера слежения за наклоном.
*/
StyleZoomToTiltRelation createDefaultStyleZoomToTiltRelation(){
  _CStyleZoomToTiltRelation res = _CFunction_G_createDefaultStyleZoomToTiltRelation();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - createStyleZoomToTiltRelation

/**
 Создаем зависимость угла наклона камеры от стилевого уровня масштабирования.

 - Parameter points: Точки, по которым строится зависимость.
 - Returns: зависимость угла наклона камеры от стилевого уровня масштабирования, если создать зависимость не
 удалось - бросаем исключение.
 - Note: Зависимость должна представлять собой монотонную непрерывную функцию.
 Если точками задана зависимость, не удовлетворяющая условиям, то функция бросает исключение.
 Зависимость, примерно как в 2гис, можно задать последовательностью точек [(17, 0), (19, 15), (20, 25)] в режиме карты
 и [(15, 0), (16, 34), (17, 48)] в режиме навигатора.
 Пусть нужно получить значение угла наклона камеры T для стилевого уровня масштабирования Z, такого что Z0
 <
 = Z
 <
 Z1 и
 зависимость задана точками [(Z0, T0), (Z1, T1)]. Тогда искомое значение рассчитывается по формуле
 T = T0 + k * (T1 - T0), где k = (Z - Z0) / (Z1 - Z0). Если Z
 <
 Z0, то T = T0. Если Z >= Z1, то T = T1.
*/
StyleZoomToTiltRelation createStyleZoomToTiltRelation(
  core.Map<StyleZoom, Tilt> points
){
  var _a0 = points._copyFromDartTo_CDictionary_CStyleZoom_CTilt();
  _CStyleZoomToTiltRelation res = _CFunction_G_createStyleZoomToTiltRelation_With_CDictionary_CStyleZoom_CTilt(_a0);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - core.Map<StyleZoom, Tilt> <-> _CDictionary_CStyleZoom_CTilt

final class _CDictionary_CStyleZoom_CTilt extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CDictionary_CStyleZoom_CTiltToDart on _CDictionary_CStyleZoom_CTilt {
  core.Map<StyleZoom, Tilt> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CDictionary_CStyleZoom_CTilt on core.Map<StyleZoom, Tilt> {
  _CDictionary_CStyleZoom_CTilt _copyFromDartTo_CDictionary_CStyleZoom_CTilt() {
    final cDict = _CDictionary_CStyleZoom_CTiltmakeEmpty();
    forEach((k, v) {
        final cKey = k._copyFromDartTo_CStyleZoom();
        final cValue = v._copyFromDartTo_CTilt();
        _CDictionary_CStyleZoom_CTiltaddElement(cDict, cKey, cValue);
        
        
    });
    return cDict;
  }
}

extension _CDictionary_CStyleZoom_CTiltBasicFunctions on _CDictionary_CStyleZoom_CTilt {
  void _releaseIntermediate() {
    _CDictionary_CStyleZoom_CTilt_release(this);
  }

  static final _mapToFill = <StyleZoom, Tilt>{};

  static void _iterate(_CStyleZoom key, _CTilt value) {
    _mapToFill.putIfAbsent(key._toDart(), () => value._toDart());
  }

  core.Map<StyleZoom, Tilt> _fillFromC() {
    _forEach_CDictionary_CStyleZoom_CTilt(this, ffi.Pointer.fromFunction<ffi.Void Function(_CStyleZoom, _CTilt value)>(_iterate));
    final result = core.Map<StyleZoom, Tilt>.from(_mapToFill);
    _mapToFill.clear();
    return result;
  }
}
	
// MARK: - projectionZToStyleZ

StyleZoom projectionZToStyleZ(
  Zoom projectionZ,
  Latitude latitude
){
  var _a0 = projectionZ._copyFromDartTo_CZoom();
  var _a1 = latitude._copyFromDartTo_CLatitude();
  _CStyleZoom res = _CFunction_G_projectionZToStyleZ_With_CZoom_CLatitude(_a0, _a1);
  return res._toDart();
}

// MARK: - styleZToProjectionZ

Zoom styleZToProjectionZ(
  StyleZoom styleZ,
  Latitude latitude
){
  var _a0 = styleZ._copyFromDartTo_CStyleZoom();
  var _a1 = latitude._copyFromDartTo_CLatitude();
  _CZoom res = _CFunction_G_styleZToProjectionZ_With_CStyleZoom_CLatitude(_a0, _a1);
  return res._toDart();
}

// MARK: - DashedStrokeCircleOptions

class DashedStrokeCircleOptions {
  /** Длина пунктира. */
  final LogicalPixel dashLength;
  /** Длина межпунктирного расстояния. */
  final LogicalPixel dashSpaceLength;

  const DashedStrokeCircleOptions({
    this.dashLength = const LogicalPixel(5),
    this.dashSpaceLength = const LogicalPixel(2)
  });

  DashedStrokeCircleOptions copyWith({
    LogicalPixel? dashLength,
    LogicalPixel? dashSpaceLength
  }) {
    return DashedStrokeCircleOptions(
      dashLength: dashLength ?? this.dashLength,
      dashSpaceLength: dashSpaceLength ?? this.dashSpaceLength
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DashedStrokeCircleOptions &&
    other.runtimeType == runtimeType &&
    other.dashLength == dashLength &&
    other.dashSpaceLength == dashSpaceLength;

  @override
  int get hashCode {
    return Object.hash(dashLength, dashSpaceLength);
  }

}
final class _CDashedStrokeCircleOptions extends ffi.Struct {
  external _CLogicalPixel dashLength;

  external _CLogicalPixel dashSpaceLength;

}
// MARK: - DashedStrokeCircleOptions <-> _CDashedStrokeCircleOptions

extension _CDashedStrokeCircleOptionsToDart on _CDashedStrokeCircleOptions {
  DashedStrokeCircleOptions _toDart() {
    return DashedStrokeCircleOptions(
      dashLength: this.dashLength._toDart(),
      dashSpaceLength: this.dashSpaceLength._toDart()
    );
  }
}

extension _DartTo_CDashedStrokeCircleOptions on DashedStrokeCircleOptions {
  _CDashedStrokeCircleOptions _copyFromDartTo_CDashedStrokeCircleOptions() {
    final res = _CDashedStrokeCircleOptionsMakeDefault();
    res.dashLength = this.dashLength._copyFromDartTo_CLogicalPixel();
    res.dashSpaceLength = this.dashSpaceLength._copyFromDartTo_CLogicalPixel();
    return res;
  }
}
extension _CDashedStrokeCircleOptionsRelease on _CDashedStrokeCircleOptions {
  void _releaseIntermediate() {
  }
}

// MARK: - Circle

/** Окружность. */
class Circle extends SimpleMapObject implements ffi.Finalizable {
  /** Местоположение центра окружности. */
  GeoPoint get position {
    _CGeoPoint res = _CCircle_position(_CCircleMakeDefault().._impl=_self);
    return res._toDart();
  }
  set position(GeoPoint position) {
    var _a1 = position._copyFromDartTo_CGeoPoint();
    _CResult_CEmpty res = _CCircle_setPosition_CGeoPoint(_CCircleMakeDefault().._impl=_self, _a1);
    res._toDart();
    res._releaseIntermediate();
  }
  /** Радиус окружности. */
  Meter get radius {
    _CMeter res = _CCircle_radius(_CCircleMakeDefault().._impl=_self);
    return res._toDart();
  }
  set radius(Meter radius) {
    var _a1 = radius._copyFromDartTo_CMeter();
    _CResult_CEmpty res = _CCircle_setRadius_CMeter(_CCircleMakeDefault().._impl=_self, _a1);
    res._toDart();
    res._releaseIntermediate();
  }
  /** Цвет заливки окружности. */
  Color get color {
    _CColor res = _CCircle_color(_CCircleMakeDefault().._impl=_self);
    return res._toDart();
  }
  set color(Color color) {
    var _a1 = color._copyFromDartTo_CColor();
    void res = _CCircle_setColor_CColor(_CCircleMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Ширина линии границы окружности. */
  LogicalPixel get strokeWidth {
    _CLogicalPixel res = _CCircle_strokeWidth(_CCircleMakeDefault().._impl=_self);
    return res._toDart();
  }
  set strokeWidth(LogicalPixel width) {
    var _a1 = width._copyFromDartTo_CLogicalPixel();
    void res = _CCircle_setStrokeWidth_CLogicalPixel(_CCircleMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Цвет границы окружности. */
  Color get strokeColor {
    _CColor res = _CCircle_strokeColor(_CCircleMakeDefault().._impl=_self);
    return res._toDart();
  }
  set strokeColor(Color color) {
    var _a1 = color._copyFromDartTo_CColor();
    void res = _CCircle_setStrokeColor_CColor(_CCircleMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Получение параметров пунктирной обводки
  
   - Returns: параметры пунктирной обводки или null, если обводка не является пунктирной.
  */
  DashedStrokeCircleOptions? get dashedStrokeOptions {
    _COptional_CDashedStrokeCircleOptions res = _CCircle_dashedStrokeOptions(_CCircleMakeDefault().._impl=_self);
    return res._toDart();
  }
  set dashedStrokeOptions(DashedStrokeCircleOptions? options) {
    var _a1 = options._copyFromDartTo_COptional_CDashedStrokeCircleOptions();
    void res = _CCircle_setDashedStrokeOptions_COptional_CDashedStrokeCircleOptions(_CCircleMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CCircle_releasePtr);

  Circle._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory Circle._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Circle._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory Circle(
    CircleOptions options
  ) {
    var _a0 = options._copyFromDartTo_CCircleOptions();
    _CResult_CCircle res = _CCircle_C_createWith_CCircleOptions(_a0);
    _a0._releaseIntermediate();
    return Circle._create(res._toCDart()._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Circle &&
    other.runtimeType == runtimeType &&
    _CCircle_cg_objectIdentifier(this._self) == _CCircle_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCircle_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Circle <-> CCircle

final class _CCircle extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCircleBasicFunctions on _CCircle {
  void _releaseIntermediate() {
    _CCircle_release(_impl);
  }

  _CCircle _retain() {
    return _CCircle_retain(_impl);
  }
}

extension _CCircleToDart on _CCircle {
  Circle _toDart() {
    return Circle._create(_retain()._impl);
  }
}


extension _DartToCCircle on Circle {
  _CCircle _copyFromDartTo_CCircle() {
    return (_CCircleMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - DashedStrokeCircleOptions? <-> _COptional_CDashedStrokeCircleOptions

final class _COptional_CDashedStrokeCircleOptions extends ffi.Struct {
  
  external _CDashedStrokeCircleOptions value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CDashedStrokeCircleOptionsBasicFunctions on _COptional_CDashedStrokeCircleOptions {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CDashedStrokeCircleOptionsToDart on _COptional_CDashedStrokeCircleOptions {
  DashedStrokeCircleOptions? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CDashedStrokeCircleOptions on DashedStrokeCircleOptions? {
  _COptional_CDashedStrokeCircleOptions _copyFromDartTo_COptional_CDashedStrokeCircleOptions() {
    final cOptional = _COptional_CDashedStrokeCircleOptionsMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CDashedStrokeCircleOptions();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - CircleOptions

/** Параметры для создания геометрического объекта карты типа "Окружность". */
class CircleOptions {
  /** Географическая позиция. */
  final GeoPoint position;
  /** Радиус в метрах. */
  final Meter radius;
  /** Цвет заливки. */
  final Color color;
  /** Ширина линии границы окружности. */
  final LogicalPixel strokeWidth;
  /** Цвет линии границы окружности. */
  final Color strokeColor;
  /** Параметры пунктирной границы. */
  final DashedStrokeCircleOptions? dashedStrokeOptions;
  /** Флаг видимости. */
  final bool visible;
  /** Пользовательские данные (не используются внутри SDK, нужны только для пользователя API). */
  final Object? userData;
  /** Уровень отрисовки объекта. */
  final ZIndex zIndex;
  /** Привязка к поэтажному плану здания. */
  final LevelId? levelId;

  const CircleOptions({
    required this.position,
    required this.radius,
    this.color = const Color(),
    this.strokeWidth = const LogicalPixel(0),
    this.strokeColor = const Color(),
    this.dashedStrokeOptions = null,
    this.visible = true,
    this.userData = const {},
    this.zIndex = const ZIndex(0),
    this.levelId = null
  });

  CircleOptions copyWith({
    GeoPoint? position,
    Meter? radius,
    Color? color,
    LogicalPixel? strokeWidth,
    Color? strokeColor,
    Optional<DashedStrokeCircleOptions?>? dashedStrokeOptions,
    bool? visible,
    Optional<Object?>? userData,
    ZIndex? zIndex,
    Optional<LevelId?>? levelId
  }) {
    return CircleOptions(
      position: position ?? this.position,
      radius: radius ?? this.radius,
      color: color ?? this.color,
      strokeWidth: strokeWidth ?? this.strokeWidth,
      strokeColor: strokeColor ?? this.strokeColor,
      dashedStrokeOptions: dashedStrokeOptions != null ? dashedStrokeOptions.value : this.dashedStrokeOptions,
      visible: visible ?? this.visible,
      userData: userData != null ? userData.value : this.userData,
      zIndex: zIndex ?? this.zIndex,
      levelId: levelId != null ? levelId.value : this.levelId
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CircleOptions &&
    other.runtimeType == runtimeType &&
    other.position == position &&
    other.radius == radius &&
    other.color == color &&
    other.strokeWidth == strokeWidth &&
    other.strokeColor == strokeColor &&
    other.dashedStrokeOptions == dashedStrokeOptions &&
    other.visible == visible &&
    other.userData == userData &&
    other.zIndex == zIndex &&
    other.levelId == levelId;

  @override
  int get hashCode {
    return Object.hash(position, radius, color, strokeWidth, strokeColor, dashedStrokeOptions, visible, userData, zIndex, levelId);
  }

}
final class _CCircleOptions extends ffi.Struct {
  external _CGeoPoint position;

  external _CMeter radius;

  external _CColor color;

  external _CLogicalPixel strokeWidth;

  external _CColor strokeColor;

  external _COptional_CDashedStrokeCircleOptions dashedStrokeOptions;

  @ffi.Bool()
  external bool visible;

  external _CAny userData;

  external _CZIndex zIndex;

  external _COptional_CLevelId levelId;

}
// MARK: - CircleOptions <-> _CCircleOptions

extension _CCircleOptionsToDart on _CCircleOptions {
  CircleOptions _toDart() {
    return CircleOptions(
      position: this.position._toDart(),
      radius: this.radius._toDart(),
      color: this.color._toDart(),
      strokeWidth: this.strokeWidth._toDart(),
      strokeColor: this.strokeColor._toDart(),
      dashedStrokeOptions: this.dashedStrokeOptions._toDart(),
      visible: this.visible,
      userData: this.userData._toDart(),
      zIndex: this.zIndex._toDart(),
      levelId: this.levelId._toDart()
    );
  }
}

extension _DartTo_CCircleOptions on CircleOptions {
  _CCircleOptions _copyFromDartTo_CCircleOptions() {
    final res = _CCircleOptionsMakeDefault();
    res.position = this.position._copyFromDartTo_CGeoPoint();
    res.radius = this.radius._copyFromDartTo_CMeter();
    res.color = this.color._copyFromDartTo_CColor();
    res.strokeWidth = this.strokeWidth._copyFromDartTo_CLogicalPixel();
    res.strokeColor = this.strokeColor._copyFromDartTo_CColor();
    res.dashedStrokeOptions = this.dashedStrokeOptions._copyFromDartTo_COptional_CDashedStrokeCircleOptions();
    res.visible = this.visible;
    res.userData = this.userData._copyFromDartTo_CAny();
    res.zIndex = this.zIndex._copyFromDartTo_CZIndex();
    res.levelId = this.levelId._copyFromDartTo_COptional_CLevelId();
    return res;
  }
}
extension _CCircleOptionsRelease on _CCircleOptions {
  void _releaseIntermediate() {
    userData._releaseIntermediate();
  }
}

// MARK: - Circle <-> _CResult_CCircle

final class _CResult_CCircleImpl extends ffi.Union {
  
  external _CCircle _value;
  external _CError _error;
}

final class _CResult_CCircle extends ffi.Struct {
  external _CResult_CCircleImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CCircleBasicFunctions on _CResult_CCircle {
  void _releaseIntermediate() {
    _CResult_CCircle_release(this);
  }
}

extension _CResult_CCircleToDart on _CResult_CCircle {
  Circle _toDart() {
    if (this._index == 0) {
      return this._impl._value._toDart();
    } else {
      throw this._impl._error._toDart();
    }
  }

  _CCircle _toCDart() {
    if (this._index == 0) {
      return this._impl._value;
    } else {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - Polygon

/** Полигон на карте. */
class Polygon extends SimpleMapObject implements ffi.Finalizable {
  List<List<GeoPoint>> get contours {
    _CArray_CArray_CGeoPoint res = _CPolygon_contours(_CPolygonMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set contours(List<List<GeoPoint>> contours) {
    var _a1 = contours._copyFromDartTo_CArray_CArray_CGeoPoint();
    void res = _CPolygon_setContours_CArray_CArray_CGeoPoint(_CPolygonMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  Color get color {
    _CColor res = _CPolygon_color(_CPolygonMakeDefault().._impl=_self);
    return res._toDart();
  }
  set color(Color color) {
    var _a1 = color._copyFromDartTo_CColor();
    void res = _CPolygon_setColor_CColor(_CPolygonMakeDefault().._impl=_self, _a1);
    return res;
  }
  LogicalPixel get strokeWidth {
    _CLogicalPixel res = _CPolygon_strokeWidth(_CPolygonMakeDefault().._impl=_self);
    return res._toDart();
  }
  set strokeWidth(LogicalPixel width) {
    var _a1 = width._copyFromDartTo_CLogicalPixel();
    void res = _CPolygon_setStrokeWidth_CLogicalPixel(_CPolygonMakeDefault().._impl=_self, _a1);
    return res;
  }
  Color get strokeColor {
    _CColor res = _CPolygon_strokeColor(_CPolygonMakeDefault().._impl=_self);
    return res._toDart();
  }
  set strokeColor(Color color) {
    var _a1 = color._copyFromDartTo_CColor();
    void res = _CPolygon_setStrokeColor_CColor(_CPolygonMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CPolygon_releasePtr);

  Polygon._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory Polygon._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Polygon._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Cоздание полигона на основе параметров.
  
   - Throws: Exception В случае, если один из контуров содержит меньше трех точек.
  */
  factory Polygon(
    PolygonOptions options
  ) {
    var _a0 = options._copyFromDartTo_CPolygonOptions();
    _CResult_CPolygon res = _CPolygon_C_createWith_CPolygonOptions(_a0);
    _a0._releaseIntermediate();
    return Polygon._create(res._toCDart()._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Polygon &&
    other.runtimeType == runtimeType &&
    _CPolygon_cg_objectIdentifier(this._self) == _CPolygon_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPolygon_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Polygon <-> CPolygon

final class _CPolygon extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPolygonBasicFunctions on _CPolygon {
  void _releaseIntermediate() {
    _CPolygon_release(_impl);
  }

  _CPolygon _retain() {
    return _CPolygon_retain(_impl);
  }
}

extension _CPolygonToDart on _CPolygon {
  Polygon _toDart() {
    return Polygon._create(_retain()._impl);
  }
}


extension _DartToCPolygon on Polygon {
  _CPolygon _copyFromDartTo_CPolygon() {
    return (_CPolygonMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - PolygonOptions

/** Параметры полигона. */
class PolygonOptions {
  final List<List<GeoPoint>> contours;
  final Color color;
  final LogicalPixel strokeWidth;
  final Color strokeColor;
  final bool visible;
  final Object? userData;
  /** Уровень отрисовки объекта. */
  final ZIndex zIndex;
  /** Привязка к поэтажному плану здания. */
  final LevelId? levelId;

  const PolygonOptions({
    required this.contours,
    this.color = const Color(),
    this.strokeWidth = const LogicalPixel(0),
    this.strokeColor = const Color(),
    this.visible = true,
    this.userData = const {},
    this.zIndex = const ZIndex(0),
    this.levelId = null
  });

  PolygonOptions copyWith({
    List<List<GeoPoint>>? contours,
    Color? color,
    LogicalPixel? strokeWidth,
    Color? strokeColor,
    bool? visible,
    Optional<Object?>? userData,
    ZIndex? zIndex,
    Optional<LevelId?>? levelId
  }) {
    return PolygonOptions(
      contours: contours ?? this.contours,
      color: color ?? this.color,
      strokeWidth: strokeWidth ?? this.strokeWidth,
      strokeColor: strokeColor ?? this.strokeColor,
      visible: visible ?? this.visible,
      userData: userData != null ? userData.value : this.userData,
      zIndex: zIndex ?? this.zIndex,
      levelId: levelId != null ? levelId.value : this.levelId
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PolygonOptions &&
    other.runtimeType == runtimeType &&
    other.contours == contours &&
    other.color == color &&
    other.strokeWidth == strokeWidth &&
    other.strokeColor == strokeColor &&
    other.visible == visible &&
    other.userData == userData &&
    other.zIndex == zIndex &&
    other.levelId == levelId;

  @override
  int get hashCode {
    return Object.hash(contours, color, strokeWidth, strokeColor, visible, userData, zIndex, levelId);
  }

}
final class _CPolygonOptions extends ffi.Struct {
  external _CArray_CArray_CGeoPoint contours;

  external _CColor color;

  external _CLogicalPixel strokeWidth;

  external _CColor strokeColor;

  @ffi.Bool()
  external bool visible;

  external _CAny userData;

  external _CZIndex zIndex;

  external _COptional_CLevelId levelId;

}
// MARK: - PolygonOptions <-> _CPolygonOptions

extension _CPolygonOptionsToDart on _CPolygonOptions {
  PolygonOptions _toDart() {
    return PolygonOptions(
      contours: this.contours._toDart(),
      color: this.color._toDart(),
      strokeWidth: this.strokeWidth._toDart(),
      strokeColor: this.strokeColor._toDart(),
      visible: this.visible,
      userData: this.userData._toDart(),
      zIndex: this.zIndex._toDart(),
      levelId: this.levelId._toDart()
    );
  }
}

extension _DartTo_CPolygonOptions on PolygonOptions {
  _CPolygonOptions _copyFromDartTo_CPolygonOptions() {
    final res = _CPolygonOptionsMakeDefault();
    res.contours = this.contours._copyFromDartTo_CArray_CArray_CGeoPoint();
    res.color = this.color._copyFromDartTo_CColor();
    res.strokeWidth = this.strokeWidth._copyFromDartTo_CLogicalPixel();
    res.strokeColor = this.strokeColor._copyFromDartTo_CColor();
    res.visible = this.visible;
    res.userData = this.userData._copyFromDartTo_CAny();
    res.zIndex = this.zIndex._copyFromDartTo_CZIndex();
    res.levelId = this.levelId._copyFromDartTo_COptional_CLevelId();
    return res;
  }
}
extension _CPolygonOptionsRelease on _CPolygonOptions {
  void _releaseIntermediate() {
    contours._releaseIntermediate();
    userData._releaseIntermediate();
  }
}

// MARK: - Polygon <-> _CResult_CPolygon

final class _CResult_CPolygonImpl extends ffi.Union {
  
  external _CPolygon _value;
  external _CError _error;
}

final class _CResult_CPolygon extends ffi.Struct {
  external _CResult_CPolygonImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CPolygonBasicFunctions on _CResult_CPolygon {
  void _releaseIntermediate() {
    _CResult_CPolygon_release(this);
  }
}

extension _CResult_CPolygonToDart on _CResult_CPolygon {
  Polygon _toDart() {
    if (this._index == 0) {
      return this._impl._value._toDart();
    } else {
      throw this._impl._error._toDart();
    }
  }

  _CPolygon _toCDart() {
    if (this._index == 0) {
      return this._impl._value;
    } else {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - DashedPolylineOptions

/** Параметры пунктирной полилинии. */
class DashedPolylineOptions {
  /** Длина пунктира. */
  final LogicalPixel dashLength;
  /** Длина межпунктирного расстояния. */
  final LogicalPixel dashSpaceLength;

  const DashedPolylineOptions({
    this.dashLength = const LogicalPixel(5),
    this.dashSpaceLength = const LogicalPixel(2)
  });

  DashedPolylineOptions copyWith({
    LogicalPixel? dashLength,
    LogicalPixel? dashSpaceLength
  }) {
    return DashedPolylineOptions(
      dashLength: dashLength ?? this.dashLength,
      dashSpaceLength: dashSpaceLength ?? this.dashSpaceLength
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DashedPolylineOptions &&
    other.runtimeType == runtimeType &&
    other.dashLength == dashLength &&
    other.dashSpaceLength == dashSpaceLength;

  @override
  int get hashCode {
    return Object.hash(dashLength, dashSpaceLength);
  }

}
final class _CDashedPolylineOptions extends ffi.Struct {
  external _CLogicalPixel dashLength;

  external _CLogicalPixel dashSpaceLength;

}
// MARK: - DashedPolylineOptions <-> _CDashedPolylineOptions

extension _CDashedPolylineOptionsToDart on _CDashedPolylineOptions {
  DashedPolylineOptions _toDart() {
    return DashedPolylineOptions(
      dashLength: this.dashLength._toDart(),
      dashSpaceLength: this.dashSpaceLength._toDart()
    );
  }
}

extension _DartTo_CDashedPolylineOptions on DashedPolylineOptions {
  _CDashedPolylineOptions _copyFromDartTo_CDashedPolylineOptions() {
    final res = _CDashedPolylineOptionsMakeDefault();
    res.dashLength = this.dashLength._copyFromDartTo_CLogicalPixel();
    res.dashSpaceLength = this.dashSpaceLength._copyFromDartTo_CLogicalPixel();
    return res;
  }
}
extension _CDashedPolylineOptionsRelease on _CDashedPolylineOptions {
  void _releaseIntermediate() {
  }
}

// MARK: - List<Color> <-> _CArray_CColor

final class _CArray_CColor extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CColorToDart on _CArray_CColor {
  List<Color> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CColor on List<Color> {
  _CArray_CColor _copyFromDartTo_CArray_CColor() {
    final cArray = _CArray_CColormakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CColor();
        _CArray_CColoraddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_CColorBasicFunctions on _CArray_CColor {
  void _releaseIntermediate() {
    _CArray_CColor_release(this);
  }

  static final _listToFill = <Color>[];

  static void _iterate(_CColor item) {
    _listToFill.add(item._toDart());
  }

  List<Color> _fillFromC() {
    _forEach_CArray_CColor(this, ffi.Pointer.fromFunction<ffi.Void Function(_CColor)>(_iterate));
    final result = List<Color>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - GradientPolylineOptions

/** Параметры градиентной полилинии. */
class GradientPolylineOptions {
  /** Ширина границы линии. */
  final LogicalPixel borderWidth;
  /** Ширина второй границы линии. */
  final LogicalPixel secondBorderWidth;
  /** Длина градиентной линии. */
  final LogicalPixel gradientLength;
  /** Цвет окантовки. */
  final Color borderColor;
  /** Цвет второй окантовки. */
  final Color secondBorderColor;
  /** Палитра цветов градиентной полилинии. */
  final List<Color> colors;
  /**
   Индексы цветов градиентной полилинии. Количество индексов должно быть
   на 1 меньше количества точек полилинии.
  */
  final ByteData colorIndices;

  const GradientPolylineOptions({
    this.borderWidth = const LogicalPixel(0),
    this.secondBorderWidth = const LogicalPixel(0),
    this.gradientLength = const LogicalPixel(1),
    this.borderColor = const Color(),
    this.secondBorderColor = const Color(),
    required this.colors,
    required this.colorIndices
  });

  GradientPolylineOptions copyWith({
    LogicalPixel? borderWidth,
    LogicalPixel? secondBorderWidth,
    LogicalPixel? gradientLength,
    Color? borderColor,
    Color? secondBorderColor,
    List<Color>? colors,
    ByteData? colorIndices
  }) {
    return GradientPolylineOptions(
      borderWidth: borderWidth ?? this.borderWidth,
      secondBorderWidth: secondBorderWidth ?? this.secondBorderWidth,
      gradientLength: gradientLength ?? this.gradientLength,
      borderColor: borderColor ?? this.borderColor,
      secondBorderColor: secondBorderColor ?? this.secondBorderColor,
      colors: colors ?? this.colors,
      colorIndices: colorIndices ?? this.colorIndices
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GradientPolylineOptions &&
    other.runtimeType == runtimeType &&
    other.borderWidth == borderWidth &&
    other.secondBorderWidth == secondBorderWidth &&
    other.gradientLength == gradientLength &&
    other.borderColor == borderColor &&
    other.secondBorderColor == secondBorderColor &&
    other.colors == colors &&
    other.colorIndices == colorIndices;

  @override
  int get hashCode {
    return Object.hash(borderWidth, secondBorderWidth, gradientLength, borderColor, secondBorderColor, colors, colorIndices);
  }

}
final class _CGradientPolylineOptions extends ffi.Struct {
  external _CLogicalPixel borderWidth;

  external _CLogicalPixel secondBorderWidth;

  external _CLogicalPixel gradientLength;

  external _CColor borderColor;

  external _CColor secondBorderColor;

  external _CArray_CColor colors;

  external _CData colorIndices;

}
// MARK: - GradientPolylineOptions <-> _CGradientPolylineOptions

extension _CGradientPolylineOptionsToDart on _CGradientPolylineOptions {
  GradientPolylineOptions _toDart() {
    return GradientPolylineOptions(
      borderWidth: this.borderWidth._toDart(),
      secondBorderWidth: this.secondBorderWidth._toDart(),
      gradientLength: this.gradientLength._toDart(),
      borderColor: this.borderColor._toDart(),
      secondBorderColor: this.secondBorderColor._toDart(),
      colors: this.colors._toDart(),
      colorIndices: this.colorIndices._toDart()
    );
  }
}

extension _DartTo_CGradientPolylineOptions on GradientPolylineOptions {
  _CGradientPolylineOptions _copyFromDartTo_CGradientPolylineOptions() {
    final res = _CGradientPolylineOptionsMakeDefault();
    res.borderWidth = this.borderWidth._copyFromDartTo_CLogicalPixel();
    res.secondBorderWidth = this.secondBorderWidth._copyFromDartTo_CLogicalPixel();
    res.gradientLength = this.gradientLength._copyFromDartTo_CLogicalPixel();
    res.borderColor = this.borderColor._copyFromDartTo_CColor();
    res.secondBorderColor = this.secondBorderColor._copyFromDartTo_CColor();
    res.colors = this.colors._copyFromDartTo_CArray_CColor();
    res.colorIndices = this.colorIndices._copyFromDartTo_CData();
    return res;
  }
}
extension _CGradientPolylineOptionsRelease on _CGradientPolylineOptions {
  void _releaseIntermediate() {
    colors._releaseIntermediate();
    colorIndices._releaseIntermediate();
  }
}

// MARK: - Polyline

/** Ломаная линия на карте. */
class Polyline extends SimpleMapObject implements ffi.Finalizable {
  List<GeoPoint> get points {
    _CArray_CGeoPoint res = _CPolyline_points(_CPolylineMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set points(List<GeoPoint> points) {
    var _a1 = points._copyFromDartTo_CArray_CGeoPoint();
    void res = _CPolyline_setPoints_CArray_CGeoPoint(_CPolylineMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }
  LogicalPixel get width {
    _CLogicalPixel res = _CPolyline_width(_CPolylineMakeDefault().._impl=_self);
    return res._toDart();
  }
  set width(LogicalPixel width) {
    var _a1 = width._copyFromDartTo_CLogicalPixel();
    void res = _CPolyline_setWidth_CLogicalPixel(_CPolylineMakeDefault().._impl=_self, _a1);
    return res;
  }
  Color get color {
    _CColor res = _CPolyline_color(_CPolylineMakeDefault().._impl=_self);
    return res._toDart();
  }
  set color(Color color) {
    var _a1 = color._copyFromDartTo_CColor();
    void res = _CPolyline_setColor_CColor(_CPolylineMakeDefault().._impl=_self, _a1);
    return res;
  }
  double get erasedPart {
    double res = _CPolyline_erasedPart(_CPolylineMakeDefault().._impl=_self);
    return res;
  }
  set erasedPart(double part) {
    void res = _CPolyline_setErasedPart_double(_CPolylineMakeDefault().._impl=_self, part);
    return res;
  }
  /**
   Получение параметров пунктирной полилинии.
  
   - Returns: параметры пунктира или null, если линия не является пунктирной
  */
  DashedPolylineOptions? get dashedPolylineOptions {
    _COptional_CDashedPolylineOptions res = _CPolyline_dashedPolylineOptions(_CPolylineMakeDefault().._impl=_self);
    return res._toDart();
  }
  set dashedPolylineOptions(DashedPolylineOptions? options) {
    var _a1 = options._copyFromDartTo_COptional_CDashedPolylineOptions();
    void res = _CPolyline_setDashedPolylineOptions_COptional_CDashedPolylineOptions(_CPolylineMakeDefault().._impl=_self, _a1);
    return res;
  }
  /**
   Получение параметров градиентной полилинии.
  
   - Returns: параметры градиента или null, если линия не является градиентной
  */
  GradientPolylineOptions? get gradientPolylineOptions {
    _COptional_CGradientPolylineOptions res = _CPolyline_gradientPolylineOptions(_CPolylineMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  set gradientPolylineOptions(GradientPolylineOptions? options) {
    var _a1 = options._copyFromDartTo_COptional_CGradientPolylineOptions();
    void res = _CPolyline_setGradientPolylineOptions_COptional_CGradientPolylineOptions(_CPolylineMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CPolyline_releasePtr);

  Polyline._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory Polyline._create(ffi.Pointer<ffi.Void> self) {
    final classObject = Polyline._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory Polyline(
    PolylineOptions options
  ) {
    var _a0 = options._copyFromDartTo_CPolylineOptions();
    _CResult_CPolyline res = _CPolyline_C_createWith_CPolylineOptions(_a0);
    _a0._releaseIntermediate();
    return Polyline._create(res._toCDart()._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Polyline &&
    other.runtimeType == runtimeType &&
    _CPolyline_cg_objectIdentifier(this._self) == _CPolyline_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPolyline_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - Polyline <-> CPolyline

final class _CPolyline extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPolylineBasicFunctions on _CPolyline {
  void _releaseIntermediate() {
    _CPolyline_release(_impl);
  }

  _CPolyline _retain() {
    return _CPolyline_retain(_impl);
  }
}

extension _CPolylineToDart on _CPolyline {
  Polyline _toDart() {
    return Polyline._create(_retain()._impl);
  }
}


extension _DartToCPolyline on Polyline {
  _CPolyline _copyFromDartTo_CPolyline() {
    return (_CPolylineMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - DashedPolylineOptions? <-> _COptional_CDashedPolylineOptions

final class _COptional_CDashedPolylineOptions extends ffi.Struct {
  
  external _CDashedPolylineOptions value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CDashedPolylineOptionsBasicFunctions on _COptional_CDashedPolylineOptions {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CDashedPolylineOptionsToDart on _COptional_CDashedPolylineOptions {
  DashedPolylineOptions? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CDashedPolylineOptions on DashedPolylineOptions? {
  _COptional_CDashedPolylineOptions _copyFromDartTo_COptional_CDashedPolylineOptions() {
    final cOptional = _COptional_CDashedPolylineOptionsMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CDashedPolylineOptions();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - GradientPolylineOptions? <-> _COptional_CGradientPolylineOptions

final class _COptional_CGradientPolylineOptions extends ffi.Struct {
  
  external _CGradientPolylineOptions value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CGradientPolylineOptionsBasicFunctions on _COptional_CGradientPolylineOptions {
  void _releaseIntermediate() {
    _COptional_CGradientPolylineOptions_release(this);
  }
}

extension _COptional_CGradientPolylineOptionsToDart on _COptional_CGradientPolylineOptions {
  GradientPolylineOptions? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CGradientPolylineOptions on GradientPolylineOptions? {
  _COptional_CGradientPolylineOptions _copyFromDartTo_COptional_CGradientPolylineOptions() {
    final cOptional = _COptional_CGradientPolylineOptionsMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CGradientPolylineOptions();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - PolylineOptions

/** Параметры полилинии. */
class PolylineOptions {
  /** Точки полилинии. */
  final List<GeoPoint> points;
  /** Ширина полилинии. */
  final LogicalPixel width;
  /** Основной цвет полилинии. */
  final Color color;
  /** Доля стёртой части полилинии, должна быть в диапазоне [0; 1] */
  final double erasedPart;
  /**
   Параметры пунктирной полилинии.
  
   - Note: Пунктирная градиентная линия в данный момент не поддерживается, поэтому
   если в PolylineOptions присутствуют и dashed_polyline_options, и
   gradient_polyline_options, то dashed_polyline_options будут проигнорированы
   при создании полилинии.
  */
  final DashedPolylineOptions? dashedPolylineOptions;
  /**
   Параметры градиентной полилинии.
  
   - Note: Пунктирная градиентная линия в данный момент не поддерживается, поэтому
   если в PolylineOptions присутствуют и dashed_polyline_options, и
   gradient_polyline_options, то dashed_polyline_options будут проигнорированы
   при создании полилинии.
  */
  final GradientPolylineOptions? gradientPolylineOptions;
  /** Видимость полилинии. */
  final bool visible;
  /** Пользовательские данные. */
  final Object? userData;
  /** Уровень отрисовки объекта. */
  final ZIndex zIndex;
  /** Привязка к поэтажному плану здания. */
  final LevelId? levelId;

  const PolylineOptions({
    required this.points,
    this.width = const LogicalPixel(1),
    this.color = const Color(),
    this.erasedPart = 0,
    this.dashedPolylineOptions = null,
    this.gradientPolylineOptions = null,
    this.visible = true,
    this.userData = const {},
    this.zIndex = const ZIndex(0),
    this.levelId = null
  });

  PolylineOptions copyWith({
    List<GeoPoint>? points,
    LogicalPixel? width,
    Color? color,
    double? erasedPart,
    Optional<DashedPolylineOptions?>? dashedPolylineOptions,
    Optional<GradientPolylineOptions?>? gradientPolylineOptions,
    bool? visible,
    Optional<Object?>? userData,
    ZIndex? zIndex,
    Optional<LevelId?>? levelId
  }) {
    return PolylineOptions(
      points: points ?? this.points,
      width: width ?? this.width,
      color: color ?? this.color,
      erasedPart: erasedPart ?? this.erasedPart,
      dashedPolylineOptions: dashedPolylineOptions != null ? dashedPolylineOptions.value : this.dashedPolylineOptions,
      gradientPolylineOptions: gradientPolylineOptions != null ? gradientPolylineOptions.value : this.gradientPolylineOptions,
      visible: visible ?? this.visible,
      userData: userData != null ? userData.value : this.userData,
      zIndex: zIndex ?? this.zIndex,
      levelId: levelId != null ? levelId.value : this.levelId
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PolylineOptions &&
    other.runtimeType == runtimeType &&
    other.points == points &&
    other.width == width &&
    other.color == color &&
    other.erasedPart == erasedPart &&
    other.dashedPolylineOptions == dashedPolylineOptions &&
    other.gradientPolylineOptions == gradientPolylineOptions &&
    other.visible == visible &&
    other.userData == userData &&
    other.zIndex == zIndex &&
    other.levelId == levelId;

  @override
  int get hashCode {
    return Object.hash(points, width, color, erasedPart, dashedPolylineOptions, gradientPolylineOptions, visible, userData, zIndex, levelId);
  }

}
final class _CPolylineOptions extends ffi.Struct {
  external _CArray_CGeoPoint points;

  external _CLogicalPixel width;

  external _CColor color;

  @ffi.Double()
  external double erasedPart;

  external _COptional_CDashedPolylineOptions dashedPolylineOptions;

  external _COptional_CGradientPolylineOptions gradientPolylineOptions;

  @ffi.Bool()
  external bool visible;

  external _CAny userData;

  external _CZIndex zIndex;

  external _COptional_CLevelId levelId;

}
// MARK: - PolylineOptions <-> _CPolylineOptions

extension _CPolylineOptionsToDart on _CPolylineOptions {
  PolylineOptions _toDart() {
    return PolylineOptions(
      points: this.points._toDart(),
      width: this.width._toDart(),
      color: this.color._toDart(),
      erasedPart: this.erasedPart,
      dashedPolylineOptions: this.dashedPolylineOptions._toDart(),
      gradientPolylineOptions: this.gradientPolylineOptions._toDart(),
      visible: this.visible,
      userData: this.userData._toDart(),
      zIndex: this.zIndex._toDart(),
      levelId: this.levelId._toDart()
    );
  }
}

extension _DartTo_CPolylineOptions on PolylineOptions {
  _CPolylineOptions _copyFromDartTo_CPolylineOptions() {
    final res = _CPolylineOptionsMakeDefault();
    res.points = this.points._copyFromDartTo_CArray_CGeoPoint();
    res.width = this.width._copyFromDartTo_CLogicalPixel();
    res.color = this.color._copyFromDartTo_CColor();
    res.erasedPart = this.erasedPart;
    res.dashedPolylineOptions = this.dashedPolylineOptions._copyFromDartTo_COptional_CDashedPolylineOptions();
    res.gradientPolylineOptions = this.gradientPolylineOptions._copyFromDartTo_COptional_CGradientPolylineOptions();
    res.visible = this.visible;
    res.userData = this.userData._copyFromDartTo_CAny();
    res.zIndex = this.zIndex._copyFromDartTo_CZIndex();
    res.levelId = this.levelId._copyFromDartTo_COptional_CLevelId();
    return res;
  }
}
extension _CPolylineOptionsRelease on _CPolylineOptions {
  void _releaseIntermediate() {
    points._releaseIntermediate();
    gradientPolylineOptions._releaseIntermediate();
    userData._releaseIntermediate();
  }
}

// MARK: - Polyline <-> _CResult_CPolyline

final class _CResult_CPolylineImpl extends ffi.Union {
  
  external _CPolyline _value;
  external _CError _error;
}

final class _CResult_CPolyline extends ffi.Struct {
  external _CResult_CPolylineImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CPolylineBasicFunctions on _CResult_CPolyline {
  void _releaseIntermediate() {
    _CResult_CPolyline_release(this);
  }
}

extension _CResult_CPolylineToDart on _CResult_CPolyline {
  Polyline _toDart() {
    if (this._index == 0) {
      return this._impl._value._toDart();
    } else {
      throw this._impl._error._toDart();
    }
  }

  _CPolyline _toCDart() {
    if (this._index == 0) {
      return this._impl._value;
    } else {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - CameraFollowState

/** Состояние слежения камеры за текущим местоположением пользователя. */
enum CameraFollowState {
  /** Камера не находится в режиме слежения. */
  off(0),
  /** Камера в режиме слежения за позицией. */
  followPosition(1),
  /** Камера в режиме слежения за позицией и направлением. */
  followDirection(2),
  ;

  const CameraFollowState(this.rawValue);
  final int rawValue;

  static CameraFollowState getByValue(int value) {
    return CameraFollowState.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CCameraFollowState extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CCameraFollowStateBasicFunctions on _CCameraFollowState {
  void _releaseIntermediate() {
  }
}

extension _CCameraFollowStateToDart on _CCameraFollowState {
  CameraFollowState _toDart() {
    return CameraFollowState.getByValue(this.rawValue);
  }
}

extension _DartTo_CCameraFollowState on CameraFollowState {
  _CCameraFollowState _copyFromDartTo_CCameraFollowState() {
    return _CCameraFollowStateMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - MyLocationControlModel

/**
 Модель контрола перелета к местоположению пользователя.
 Контрол состоит из кнопки, при нажатии на которую камера перелетает к местоположению пользователя.
 Если местоположение не определено, ничего не происходит.
 Методы объекта необходимо вызывать на одном потоке.
*/
class MyLocationControlModel implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  StatefulChannel<bool> get isEnabledChannel {
    _CStatefulChannel_bool res = _CMyLocationControlModel_isEnabledChannel(_CMyLocationControlModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  bool get isEnabled {
    bool res = _CMyLocationControlModel_isEnabled(_CMyLocationControlModelMakeDefault().._impl=_self);
    return res;
  }
  StatefulChannel<CameraFollowState> get followStateChannel {
    _CStatefulChannel_CCameraFollowState res = _CMyLocationControlModel_followStateChannel(_CMyLocationControlModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  CameraFollowState get followState {
    _CCameraFollowState res = _CMyLocationControlModel_followState(_CMyLocationControlModelMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CMyLocationControlModel_releasePtr);

  MyLocationControlModel._raw(this._self);
  factory MyLocationControlModel._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MyLocationControlModel._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory MyLocationControlModel(
    Map map
  ) {
    var _a0 = map._copyFromDartTo_CMap();
    _CMyLocationControlModel res = _CMyLocationControlModel_C_createWith_CMap(_a0);
    _a0._releaseIntermediate();
    return MyLocationControlModel._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MyLocationControlModel &&
    other.runtimeType == runtimeType &&
    _CMyLocationControlModel_cg_objectIdentifier(this._self) == _CMyLocationControlModel_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMyLocationControlModel_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: MyLocationControlModel: Methods

  void onClicked()  {
    void res = _CMyLocationControlModel_onClicked(_CMyLocationControlModelMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - MyLocationControlModel <-> CMyLocationControlModel

final class _CMyLocationControlModel extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMyLocationControlModelBasicFunctions on _CMyLocationControlModel {
  void _releaseIntermediate() {
    _CMyLocationControlModel_release(_impl);
  }

  _CMyLocationControlModel _retain() {
    return _CMyLocationControlModel_retain(_impl);
  }
}

extension _CMyLocationControlModelToDart on _CMyLocationControlModel {
  MyLocationControlModel _toDart() {
    return MyLocationControlModel._create(_retain()._impl);
  }
}


extension _DartToCMyLocationControlModel on MyLocationControlModel {
  _CMyLocationControlModel _copyFromDartTo_CMyLocationControlModel() {
    return (_CMyLocationControlModelMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<CameraFollowState> <-> _CStatefulChannel_CCameraFollowState

class _CStatefulChannel_CCameraFollowStateImpl extends StatefulChannel<CameraFollowState> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<CameraFollowState>>{};

  final _CStatefulChannel_CCameraFollowState _channel;

  _CStatefulChannel_CCameraFollowStateImpl(this._channel);

  @override
  CameraFollowState get value {
    return this._channel._getter();
  }

  static void valueFunction(_CCameraFollowState cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<CameraFollowState> listen(void onData(CameraFollowState event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CCameraFollowState, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<CameraFollowState>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CCameraFollowState extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CCameraFollowStateBasicFunctions on _CStatefulChannel_CCameraFollowState {
  void _releaseIntermediate() {
    _CStatefulChannel_CCameraFollowState_release(this);
  }

  _CStatefulChannel_CCameraFollowState _retain() {
    return _CStatefulChannel_CCameraFollowState_retain(this);
  }

  CameraFollowState _getter() {
    final cValue = _CStatefulChannel_CCameraFollowStateGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CCameraFollowState, ffi.Int64)> callback) {
    return _CStatefulChannel_CCameraFollowStateConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CCameraFollowStateToDart on _CStatefulChannel_CCameraFollowState {
  StatefulChannel<CameraFollowState> _toDart() {
    return _CStatefulChannel_CCameraFollowStateImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CCameraFollowState on StatefulChannel<CameraFollowState> {
  _CStatefulChannel_CCameraFollowState _copyFromDartTo_CStatefulChannel_CCameraFollowState() {
    return _CStatefulChannel_CCameraFollowStateMakeDefault();
  }
}
	
// MARK: - CompassControlModel

/**
 Модель контрола компаса.
 Контрол состоит из кнопки компаса, при нажатии на которую
 камера карты меняет угол в направлении севера.
 Если камера карты смотрит на сервер, то контрол необходимо скрывать.
 Потокобезопасно.
*/
class CompassControlModel implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  StatefulChannel<Bearing> get bearingChannel {
    _CStatefulChannel_CBearing res = _CCompassControlModel_bearingChannel(_CCompassControlModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  Bearing get bearing {
    _CBearing res = _CCompassControlModel_bearing(_CCompassControlModelMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CCompassControlModel_releasePtr);

  CompassControlModel._raw(this._self);
  factory CompassControlModel._create(ffi.Pointer<ffi.Void> self) {
    final classObject = CompassControlModel._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory CompassControlModel(
    Map map
  ) {
    var _a0 = map._copyFromDartTo_CMap();
    _CCompassControlModel res = _CCompassControlModel_C_createWith_CMap(_a0);
    _a0._releaseIntermediate();
    return CompassControlModel._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is CompassControlModel &&
    other.runtimeType == runtimeType &&
    _CCompassControlModel_cg_objectIdentifier(this._self) == _CCompassControlModel_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CCompassControlModel_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CompassControlModel: Methods

  void onClicked()  {
    void res = _CCompassControlModel_onClicked(_CCompassControlModelMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - CompassControlModel <-> CCompassControlModel

final class _CCompassControlModel extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CCompassControlModelBasicFunctions on _CCompassControlModel {
  void _releaseIntermediate() {
    _CCompassControlModel_release(_impl);
  }

  _CCompassControlModel _retain() {
    return _CCompassControlModel_retain(_impl);
  }
}

extension _CCompassControlModelToDart on _CCompassControlModel {
  CompassControlModel _toDart() {
    return CompassControlModel._create(_retain()._impl);
  }
}


extension _DartToCCompassControlModel on CompassControlModel {
  _CCompassControlModel _copyFromDartTo_CCompassControlModel() {
    return (_CCompassControlModelMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<Bearing> <-> _CStatefulChannel_CBearing

class _CStatefulChannel_CBearingImpl extends StatefulChannel<Bearing> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<Bearing>>{};

  final _CStatefulChannel_CBearing _channel;

  _CStatefulChannel_CBearingImpl(this._channel);

  @override
  Bearing get value {
    return this._channel._getter();
  }

  static void valueFunction(_CBearing cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<Bearing> listen(void onData(Bearing event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CBearing, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<Bearing>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CBearing extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CBearingBasicFunctions on _CStatefulChannel_CBearing {
  void _releaseIntermediate() {
    _CStatefulChannel_CBearing_release(this);
  }

  _CStatefulChannel_CBearing _retain() {
    return _CStatefulChannel_CBearing_retain(this);
  }

  Bearing _getter() {
    final cValue = _CStatefulChannel_CBearingGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CBearing, ffi.Int64)> callback) {
    return _CStatefulChannel_CBearingConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CBearingToDart on _CStatefulChannel_CBearing {
  StatefulChannel<Bearing> _toDart() {
    return _CStatefulChannel_CBearingImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CBearing on StatefulChannel<Bearing> {
  _CStatefulChannel_CBearing _copyFromDartTo_CStatefulChannel_CBearing() {
    return _CStatefulChannel_CBearingMakeDefault();
  }
}
	
// MARK: - ZoomControlButton

enum ZoomControlButton {
  zoomIn(0),
  zoomOut(1),
  ;

  const ZoomControlButton(this.rawValue);
  final int rawValue;

  static ZoomControlButton getByValue(int value) {
    return ZoomControlButton.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CZoomControlButton extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CZoomControlButtonBasicFunctions on _CZoomControlButton {
  void _releaseIntermediate() {
  }
}

extension _CZoomControlButtonToDart on _CZoomControlButton {
  ZoomControlButton _toDart() {
    return ZoomControlButton.getByValue(this.rawValue);
  }
}

extension _DartTo_CZoomControlButton on ZoomControlButton {
  _CZoomControlButton _copyFromDartTo_CZoomControlButton() {
    return _CZoomControlButtonMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ZoomControlModel

/**
 Модель контрола зумирования.
 Контрол состоит из кнопок +/-, при нажатии на которые меняется масштаб карты.
 При достижении допустимой границы масштаба кнопка масштабирования в этом направлении становится неактивной.
 Методы объекта необходимо вызывать на одном потоке.
*/
class ZoomControlModel implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CZoomControlModel_releasePtr);

  ZoomControlModel._raw(this._self);
  factory ZoomControlModel._create(ffi.Pointer<ffi.Void> self) {
    final classObject = ZoomControlModel._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory ZoomControlModel(
    Map map
  ) {
    var _a0 = map._copyFromDartTo_CMap();
    _CZoomControlModel res = _CZoomControlModel_C_createWith_CMap(_a0);
    _a0._releaseIntermediate();
    return ZoomControlModel._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ZoomControlModel &&
    other.runtimeType == runtimeType &&
    _CZoomControlModel_cg_objectIdentifier(this._self) == _CZoomControlModel_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CZoomControlModel_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: ZoomControlModel: Methods

  StatefulChannel<bool> isEnabled(
    ZoomControlButton button
  )  {
    var _a1 = button._copyFromDartTo_CZoomControlButton();
    _CStatefulChannel_bool res = _CZoomControlModel_isEnabled_CZoomControlButton(_CZoomControlModelMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  void setPressed(
    ZoomControlButton button,
    bool value
  )  {
    var _a1 = button._copyFromDartTo_CZoomControlButton();
    void res = _CZoomControlModel_setPressed_CZoomControlButton_bool(_CZoomControlModelMakeDefault().._impl=_self, _a1, value);
    return res;
  }

}

// MARK: - ZoomControlModel <-> CZoomControlModel

final class _CZoomControlModel extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CZoomControlModelBasicFunctions on _CZoomControlModel {
  void _releaseIntermediate() {
    _CZoomControlModel_release(_impl);
  }

  _CZoomControlModel _retain() {
    return _CZoomControlModel_retain(_impl);
  }
}

extension _CZoomControlModelToDart on _CZoomControlModel {
  ZoomControlModel _toDart() {
    return ZoomControlModel._create(_retain()._impl);
  }
}


extension _DartToCZoomControlModel on ZoomControlModel {
  _CZoomControlModel _copyFromDartTo_CZoomControlModel() {
    return (_CZoomControlModelMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - DefaultRasterUrlTemplate

class DefaultRasterUrlTemplate {
  final String urlTemplate;

  const DefaultRasterUrlTemplate(this.urlTemplate);

  DefaultRasterUrlTemplate copyWith({
    String? urlTemplate
  }) {
    return DefaultRasterUrlTemplate(
      urlTemplate ?? this.urlTemplate
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DefaultRasterUrlTemplate &&
    other.runtimeType == runtimeType &&
    other.urlTemplate == urlTemplate;

  @override
  int get hashCode {
    return urlTemplate.hashCode;
  }

}
final class _CDefaultRasterUrlTemplate extends ffi.Struct {
  external _CString urlTemplate;

}
// MARK: - DefaultRasterUrlTemplate <-> _CDefaultRasterUrlTemplate

extension _CDefaultRasterUrlTemplateToDart on _CDefaultRasterUrlTemplate {
  DefaultRasterUrlTemplate _toDart() {
    return DefaultRasterUrlTemplate(
      this.urlTemplate._toDart()
    );
  }
}

extension _DartTo_CDefaultRasterUrlTemplate on DefaultRasterUrlTemplate {
  _CDefaultRasterUrlTemplate _copyFromDartTo_CDefaultRasterUrlTemplate() {
    final res = _CDefaultRasterUrlTemplateMakeDefault();
    res.urlTemplate = this.urlTemplate._copyFromDartTo_CString();
    return res;
  }
}
extension _CDefaultRasterUrlTemplateRelease on _CDefaultRasterUrlTemplate {
  void _releaseIntermediate() {
    urlTemplate._releaseIntermediate();
  }
}

// MARK: - WmsRasterUrlTemplate

class WmsRasterUrlTemplate {
  final String urlTemplate;

  const WmsRasterUrlTemplate(this.urlTemplate);

  WmsRasterUrlTemplate copyWith({
    String? urlTemplate
  }) {
    return WmsRasterUrlTemplate(
      urlTemplate ?? this.urlTemplate
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is WmsRasterUrlTemplate &&
    other.runtimeType == runtimeType &&
    other.urlTemplate == urlTemplate;

  @override
  int get hashCode {
    return urlTemplate.hashCode;
  }

}
final class _CWmsRasterUrlTemplate extends ffi.Struct {
  external _CString urlTemplate;

}
// MARK: - WmsRasterUrlTemplate <-> _CWmsRasterUrlTemplate

extension _CWmsRasterUrlTemplateToDart on _CWmsRasterUrlTemplate {
  WmsRasterUrlTemplate _toDart() {
    return WmsRasterUrlTemplate(
      this.urlTemplate._toDart()
    );
  }
}

extension _DartTo_CWmsRasterUrlTemplate on WmsRasterUrlTemplate {
  _CWmsRasterUrlTemplate _copyFromDartTo_CWmsRasterUrlTemplate() {
    final res = _CWmsRasterUrlTemplateMakeDefault();
    res.urlTemplate = this.urlTemplate._copyFromDartTo_CString();
    return res;
  }
}
extension _CWmsRasterUrlTemplateRelease on _CWmsRasterUrlTemplate {
  void _releaseIntermediate() {
    urlTemplate._releaseIntermediate();
  }
}

// MARK: - RasterUrlTemplate

final class RasterUrlTemplate {
  final Object? _value;
  final int _index;

  RasterUrlTemplate._raw(this._value, this._index);

  RasterUrlTemplate.defaultSource(DefaultRasterUrlTemplate value) : this._raw(value, 0);
  RasterUrlTemplate.wmsSource(WmsRasterUrlTemplate value) : this._raw(value, 1);

  bool get isDefaultSource => this._index == 0;
  DefaultRasterUrlTemplate? get asDefaultSource => this.isDefaultSource ? this._value as DefaultRasterUrlTemplate : null;

  bool get isWmsSource => this._index == 1;
  WmsRasterUrlTemplate? get asWmsSource => this.isWmsSource ? this._value as WmsRasterUrlTemplate : null;

  T match<T>({
    required T Function(DefaultRasterUrlTemplate value) defaultSource,
    required T Function(WmsRasterUrlTemplate value) wmsSource,
  }) {
    return switch (this._index) {
      0 => defaultSource(this._value as DefaultRasterUrlTemplate),
      1 => wmsSource(this._value as WmsRasterUrlTemplate),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "RasterUrlTemplate(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RasterUrlTemplate &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CRasterUrlTemplateImpl extends ffi.Union {
  external _CDefaultRasterUrlTemplate _defaultSource;
  external _CWmsRasterUrlTemplate _wmsSource;
}

final class _CRasterUrlTemplate extends ffi.Struct {
  external _CRasterUrlTemplateImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CRasterUrlTemplateBasicFunctions on _CRasterUrlTemplate {
  void _releaseIntermediate() {
    _CRasterUrlTemplate_release(this);
  }
}
	
// MARK: - RasterUrlTemplate <-> CRasterUrlTemplate

extension _CRasterUrlTemplateToDart on _CRasterUrlTemplate {
  RasterUrlTemplate _toDart() {
    return switch (this._index) {
      0 => RasterUrlTemplate.defaultSource(this._impl._defaultSource._toDart()),
      1 => RasterUrlTemplate.wmsSource(this._impl._wmsSource._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CRasterUrlTemplate on RasterUrlTemplate {
  _CRasterUrlTemplate _copyFromDartTo_CRasterUrlTemplate() {
    var res = _CRasterUrlTemplateMakeDefault();
    this.match<void>(
      defaultSource: (DefaultRasterUrlTemplate value) {
        res._impl._defaultSource = value._copyFromDartTo_CDefaultRasterUrlTemplate();
        res._index = 0;
      },
      wmsSource: (WmsRasterUrlTemplate value) {
        res._impl._wmsSource = value._copyFromDartTo_CWmsRasterUrlTemplate();
        res._index = 1;
      },
    );
    return res;
  }
}

// MARK: - RasterTileSource

/** Источник, получающий растровые тайлы. */
class RasterTileSource extends Source implements ffi.Finalizable {
  static final _finalizer = ffi.NativeFinalizer(_CRasterTileSource_releasePtr);

  RasterTileSource._raw(ffi.Pointer<ffi.Void> p) : super._raw(p);
  factory RasterTileSource._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RasterTileSource._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Создание источника, получающего растровые тайлы.
  
   - Parameter context: контекст.
   - Parameter sublayerName: имя, которое будет использовано при генерации объектов.
   Это имя должно быть указано в стилях в условии filter слоя типа raster для атрибута db_sublayer.
   Пример: ["match", ["get", "db_sublayer"], ["NAME"], true, false]
   Подробнее см. спецификацию: https://docs.2gis.com/ru/mapgl/stylespecification
   - Parameter sourceTemplate: Шаблон для запроса тайлов.
  */
  factory RasterTileSource(
    Context context,
    String sublayerName,
    RasterUrlTemplate sourceTemplate
  ) {
    var _a0 = context._copyFromDartTo_CContext();
    var _a1 = sublayerName._copyFromDartTo_CString();
    var _a2 = sourceTemplate._copyFromDartTo_CRasterUrlTemplate();
    _CRasterTileSource res = _CRasterTileSource_C_createWith_CContext_CString_CRasterUrlTemplate(_a0, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    _a0._releaseIntermediate();
    return RasterTileSource._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RasterTileSource &&
    other.runtimeType == runtimeType &&
    _CRasterTileSource_cg_objectIdentifier(this._self) == _CRasterTileSource_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRasterTileSource_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RasterTileSource: Methods

  /** Установка значения прозрачности растрового тайла. */
  void setOpacity(
    Opacity opacity
  )  {
    var _a1 = opacity._copyFromDartTo_COpacity();
    void res = _CRasterTileSource_setOpacity_COpacity(_CRasterTileSourceMakeDefault().._impl=_self, _a1);
    return res;
  }

}

// MARK: - RasterTileSource <-> CRasterTileSource

final class _CRasterTileSource extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRasterTileSourceBasicFunctions on _CRasterTileSource {
  void _releaseIntermediate() {
    _CRasterTileSource_release(_impl);
  }

  _CRasterTileSource _retain() {
    return _CRasterTileSource_retain(_impl);
  }
}

extension _CRasterTileSourceToDart on _CRasterTileSource {
  RasterTileSource _toDart() {
    return RasterTileSource._create(_retain()._impl);
  }
}


extension _DartToCRasterTileSource on RasterTileSource {
  _CRasterTileSource _copyFromDartTo_CRasterTileSource() {
    return (_CRasterTileSourceMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - ParkingControlModel

/**
 Модель контрола парковок.

 - Note: Этот интерфейс является потокобезопасным.
*/
class ParkingControlModel implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /**
   Состояние элемента управления видимостью парковок.
   true, если парковки видны.
  */
  StatefulChannel<bool> get isEnabledChannel {
    _CStatefulChannel_bool res = _CParkingControlModel_isEnabledChannel(_CParkingControlModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Состояние элемента управления видимостью парковок.
   true, если парковки видны.
  */
  bool get isEnabled {
    bool res = _CParkingControlModel_isEnabled(_CParkingControlModelMakeDefault().._impl=_self);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CParkingControlModel_releasePtr);

  ParkingControlModel._raw(this._self);
  factory ParkingControlModel._create(ffi.Pointer<ffi.Void> self) {
    final classObject = ParkingControlModel._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Функция создания модели элемента управления парковками.
  
   - Parameter map: карта.
   - Returns: Модель элемента управления видимостью парковок для карты.
  */
  factory ParkingControlModel(
    Map map
  ) {
    var _a0 = map._copyFromDartTo_CMap();
    _CParkingControlModel res = _CParkingControlModel_C_createWith_CMap(_a0);
    _a0._releaseIntermediate();
    return ParkingControlModel._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ParkingControlModel &&
    other.runtimeType == runtimeType &&
    _CParkingControlModel_cg_objectIdentifier(this._self) == _CParkingControlModel_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CParkingControlModel_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: ParkingControlModel: Methods

  /**
   Действие при нажатии на контрол.
   Переключает видимость парковок на карте.
  */
  void toggleParkingsVisibility()  {
    void res = _CParkingControlModel_toggleParkingsVisibility(_CParkingControlModelMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - ParkingControlModel <-> CParkingControlModel

final class _CParkingControlModel extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CParkingControlModelBasicFunctions on _CParkingControlModel {
  void _releaseIntermediate() {
    _CParkingControlModel_release(_impl);
  }

  _CParkingControlModel _retain() {
    return _CParkingControlModel_retain(_impl);
  }
}

extension _CParkingControlModelToDart on _CParkingControlModel {
  ParkingControlModel _toDart() {
    return ParkingControlModel._create(_retain()._impl);
  }
}


extension _DartToCParkingControlModel on ParkingControlModel {
  _CParkingControlModel _copyFromDartTo_CParkingControlModel() {
    return (_CParkingControlModelMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - PackedMapState

/** Сериализованное состояние карты. */
class PackedMapState implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Получение состояния отображения пробок на карте. */
  bool get showTraffic {
    bool res = _CPackedMapState_showTraffic(_CPackedMapStateMakeDefault().._impl=_self);
    return res;
  }
  set showTraffic(bool showTraffic) {
    void res = _CPackedMapState_setShowTraffic_bool(_CPackedMapStateMakeDefault().._impl=_self, showTraffic);
    return res;
  }
  /** Получение позиции камеры. */
  CameraPosition get cameraPosition {
    _CCameraPosition res = _CPackedMapState_cameraPosition(_CPackedMapStateMakeDefault().._impl=_self);
    return res._toDart();
  }
  set cameraPosition(CameraPosition position) {
    var _a1 = position._copyFromDartTo_CCameraPosition();
    void res = _CPackedMapState_setCameraPosition_CCameraPosition(_CPackedMapStateMakeDefault().._impl=_self, _a1);
    return res;
  }
  /** Получения режима слежения камеры. */
  CameraBehaviour get cameraBehaviour {
    _CCameraBehaviour res = _CPackedMapState_cameraBehaviour(_CPackedMapStateMakeDefault().._impl=_self);
    return res._toDart();
  }
  set cameraBehaviour(CameraBehaviour behaviour) {
    var _a1 = behaviour._copyFromDartTo_CCameraBehaviour();
    void res = _CPackedMapState_setCameraBehaviour_CCameraBehaviour(_CPackedMapStateMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CPackedMapState_releasePtr);

  PackedMapState._raw(this._self);
  factory PackedMapState._create(ffi.Pointer<ffi.Void> self) {
    final classObject = PackedMapState._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is PackedMapState &&
    other.runtimeType == runtimeType &&
    _CPackedMapState_cg_objectIdentifier(this._self) == _CPackedMapState_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPackedMapState_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CPackedMapState: Static Methods

  /**
   Получение состояния карты.
  
   - Parameter position: Позиция камеры.
   - Parameter showTraffic: Состояние отображения пробок на карте.
   - Parameter behaviour: Режим слежения камеры.
   - Returns: Сериализованное состояние карты.
  */
  static PackedMapState of(
    CameraPosition position,
    bool showTraffic,
    CameraBehaviour behaviour
  )  {
    var _a0 = position._copyFromDartTo_CCameraPosition();
    var _a2 = behaviour._copyFromDartTo_CCameraBehaviour();
    _CPackedMapState res = _CPackedMapState_S_of_CCameraPosition_bool_CCameraBehaviour(_a0, showTraffic, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Получение состояния карты.
  
   - Parameter data: Состояние карты в виде последовательности байтов.
   - Throws: Exception десериализуется неподдерживаемая версия или битые данные.
   - Returns: Сериализованное состояние карты.
  */
  static PackedMapState fromBytes(
    ByteData data
  )  {
    var _a0 = data._copyFromDartTo_CData();
    _CResult_CPackedMapState res = _CPackedMapState_S_fromBytes_CData(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Получение состояния карты.
  
   - Parameter map: Карта, состояние которой необходимо получить.
   - Returns: Сериализованное состояние карты.
  */
  static PackedMapState fromMap(
    Map map
  )  {
    var _a0 = map._copyFromDartTo_CMap();
    _CPackedMapState res = _CPackedMapState_S_fromMap_CMap(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  // MARK: PackedMapState: Methods

  /** Представление состояния карты в виде последовательности байтов. */
  ByteData toBytes()  {
    _CData res = _CPackedMapState_toBytes(_CPackedMapStateMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - PackedMapState <-> CPackedMapState

final class _CPackedMapState extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPackedMapStateBasicFunctions on _CPackedMapState {
  void _releaseIntermediate() {
    _CPackedMapState_release(_impl);
  }

  _CPackedMapState _retain() {
    return _CPackedMapState_retain(_impl);
  }
}

extension _CPackedMapStateToDart on _CPackedMapState {
  PackedMapState _toDart() {
    return PackedMapState._create(_retain()._impl);
  }
}


extension _DartToCPackedMapState on PackedMapState {
  _CPackedMapState _copyFromDartTo_CPackedMapState() {
    return (_CPackedMapStateMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - PackedMapState <-> _CResult_CPackedMapState

final class _CResult_CPackedMapStateImpl extends ffi.Union {
  
  external _CPackedMapState _value;
  external _CError _error;
}

final class _CResult_CPackedMapState extends ffi.Struct {
  external _CResult_CPackedMapStateImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CResult_CPackedMapStateBasicFunctions on _CResult_CPackedMapState {
  void _releaseIntermediate() {
    _CResult_CPackedMapState_release(this);
  }
}

extension _CResult_CPackedMapStateToDart on _CResult_CPackedMapState {
  PackedMapState _toDart() {
    if (this._index == 0) {
      return this._impl._value._toDart();
    } else {
      throw this._impl._error._toDart();
    }
  }

  _CPackedMapState _toCDart() {
    if (this._index == 0) {
      return this._impl._value;
    } else {
      throw this._impl._error._toDart();
    }
  }
}
	
// MARK: - Fps

/** Frames per second, частота кадров. */
class Fps {
  final int value;

  const Fps([this.value = 0]);

  Fps copyWith({
    int? value
  }) {
    return Fps(
      value ?? this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is Fps &&
    other.runtimeType == runtimeType &&
    other.value == value;

  @override
  int get hashCode {
    return value.hashCode;
  }

}
final class _CFps extends ffi.Struct {
  @ffi.Uint32()
  external int value;

}
// MARK: - Fps <-> _CFps

extension _CFpsToDart on _CFps {
  Fps _toDart() {
    return Fps(
      this.value
    );
  }
}

extension _DartTo_CFps on Fps {
  _CFps _copyFromDartTo_CFps() {
    final res = _CFpsMakeDefault();
    res.value = this.value;
    return res;
  }
}
extension _CFpsRelease on _CFps {
  void _releaseIntermediate() {
  }
}

// MARK: - MapSurfaceProvider

/** Передача нативной поверхности от платформы для рендеринга карты. */
@internal
class MapSurfaceProvider implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Идентификатор нативной поверхности. */
  int get id {
    int res = _CMapSurfaceProvider_id(_CMapSurfaceProviderMakeDefault().._impl=_self);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CMapSurfaceProvider_releasePtr);

  MapSurfaceProvider._raw(this._self);
  factory MapSurfaceProvider._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapSurfaceProvider._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapSurfaceProvider &&
    other.runtimeType == runtimeType &&
    _CMapSurfaceProvider_cg_objectIdentifier(this._self) == _CMapSurfaceProvider_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapSurfaceProvider_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CMapSurfaceProvider: Static Methods

  static MapSurfaceProvider create(
    Map map
  )  {
    var _a0 = map._copyFromDartTo_CMap();
    _CMapSurfaceProvider res = _CMapSurfaceProvider_S_create_CMap(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  // MARK: MapSurfaceProvider: Methods

  /**
   Установить внеэкранную поверхность.
  
   Может использоваться для получения результата рендеринга в виде изображения.
   Можно вызывать лишь с render-потока.
  */
  void setOffscreenSurface(
    ScreenSize size
  )  {
    var _a1 = size._copyFromDartTo_CScreenSize();
    void res = _CMapSurfaceProvider_setOffscreenSurface_CScreenSize(_CMapSurfaceProviderMakeDefault().._impl=_self, _a1);
    return res;
  }

  /**
   Удалить С++-представление поверхности.
  
   Может надолго заблокировать вызывающий поток, так как дожидается завершения рендеринга.
  */
  void destroySurface()  {
    void res = _CMapSurfaceProvider_destroySurface(_CMapSurfaceProviderMakeDefault().._impl=_self);
    return res;
  }

  /** Асинхронно удалить С++-представление поверхности. */
  CancelableOperation<bool> destroySurfaceAsync()  {
    _CFuture_bool res = _CMapSurfaceProvider_destroySurfaceAsync(_CMapSurfaceProviderMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Изменить размер поверхности. */
  void resizeSurface(
    ScreenSize size
  )  {
    var _a1 = size._copyFromDartTo_CScreenSize();
    void res = _CMapSurfaceProvider_resizeSurface_CScreenSize(_CMapSurfaceProviderMakeDefault().._impl=_self, _a1);
    return res;
  }

  /** Установить активна ли поверхность (приложение не свернуто, не в спящем режиме). */
  void setActive(
    bool active
  )  {
    void res = _CMapSurfaceProvider_setActive_bool(_CMapSurfaceProviderMakeDefault().._impl=_self, active);
    return res;
  }

}

// MARK: - MapSurfaceProvider <-> CMapSurfaceProvider

final class _CMapSurfaceProvider extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapSurfaceProviderBasicFunctions on _CMapSurfaceProvider {
  void _releaseIntermediate() {
    _CMapSurfaceProvider_release(_impl);
  }

  _CMapSurfaceProvider _retain() {
    return _CMapSurfaceProvider_retain(_impl);
  }
}

extension _CMapSurfaceProviderToDart on _CMapSurfaceProvider {
  MapSurfaceProvider _toDart() {
    return MapSurfaceProvider._create(_retain()._impl);
  }
}


extension _DartToCMapSurfaceProvider on MapSurfaceProvider {
  _CMapSurfaceProvider _copyFromDartTo_CMapSurfaceProvider() {
    return (_CMapSurfaceProviderMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CancelableOperation<bool> <-> _CFuture_bool

final class _CFuture_bool extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_bool_Cancellable {
  final Completer<bool> completer;
  final _CFuture_bool _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(ffi.Bool, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_bool_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_boolBasicFunctions on _CFuture_bool {
  void _releaseIntermediate() {
    _CFuture_bool_release(this);
  }

  _CFuture_bool _retain() {
    return _CFuture_bool_retain(this);
  }
}

extension _CFuture_boolToDart on _CFuture_bool {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_bool_Cancellable>{};

  static void valueFunction(bool cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue);
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<bool> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<bool>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Bool, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_boolReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_bool_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_bool on CancelableOperation<bool> {
  _CFuture_bool _copyFromDartTo_CFuture_bool() {
    return _CFuture_boolMakeDefault();
  }
}
	
// MARK: - MapRenderer

/** Создание этого объекта приводит к началу рисования карты. */
@internal
class MapRenderer implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  Fps? get maxFps {
    _COptional_CFps res = _CMapRenderer_maxFps(_CMapRendererMakeDefault().._impl=_self);
    return res._toDart();
  }
  Fps? get powerSavingMaxFps {
    _COptional_CFps res = _CMapRenderer_powerSavingMaxFps(_CMapRendererMakeDefault().._impl=_self);
    return res._toDart();
  }
  StatefulChannel<Fps> get fpsChannel {
    _CStatefulChannel_CFps res = _CMapRenderer_fpsChannel(_CMapRendererMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  Fps get fps {
    _CFps res = _CMapRenderer_fps(_CMapRendererMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CMapRenderer_releasePtr);

  MapRenderer._raw(this._self);
  factory MapRenderer._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapRenderer._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapRenderer &&
    other.runtimeType == runtimeType &&
    _CMapRenderer_cg_objectIdentifier(this._self) == _CMapRenderer_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapRenderer_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CMapRenderer: Static Methods

  static MapRenderer create(
    Map map
  )  {
    var _a0 = map._copyFromDartTo_CMap();
    _CMapRenderer res = _CMapRenderer_S_create_CMap(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  // MARK: MapRenderer: Methods

  void setMaxFps(
    Fps? maxFps,
    Fps? powerSavingMaxFps
  )  {
    var _a1 = maxFps._copyFromDartTo_COptional_CFps();
    var _a2 = powerSavingMaxFps._copyFromDartTo_COptional_CFps();
    void res = _CMapRenderer_setMaxFps_COptional_CFps_COptional_CFps(_CMapRendererMakeDefault().._impl=_self, _a1, _a2);
    return res;
  }

  CancelableOperation<bool> waitForLoading()  {
    _CFuture_bool res = _CMapRenderer_waitForLoading(_CMapRendererMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  CancelableOperation<bool> waitForRendering()  {
    _CFuture_bool res = _CMapRenderer_waitForRendering(_CMapRendererMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  CancelableOperation<ImageData> takeSnapshot(
    Alignment copyrightAlign
  )  {
    var _a1 = copyrightAlign._copyFromDartTo_CAlignment();
    _CFuture_CImageData res = _CMapRenderer_takeSnapshot_CAlignment(_CMapRendererMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - MapRenderer <-> CMapRenderer

final class _CMapRenderer extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapRendererBasicFunctions on _CMapRenderer {
  void _releaseIntermediate() {
    _CMapRenderer_release(_impl);
  }

  _CMapRenderer _retain() {
    return _CMapRenderer_retain(_impl);
  }
}

extension _CMapRendererToDart on _CMapRenderer {
  MapRenderer _toDart() {
    return MapRenderer._create(_retain()._impl);
  }
}


extension _DartToCMapRenderer on MapRenderer {
  _CMapRenderer _copyFromDartTo_CMapRenderer() {
    return (_CMapRendererMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Fps? <-> _COptional_CFps

final class _COptional_CFps extends ffi.Struct {
  
  external _CFps value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CFpsBasicFunctions on _COptional_CFps {
  void _releaseIntermediate() {
    
  }
}

extension _COptional_CFpsToDart on _COptional_CFps {
  Fps? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CFps on Fps? {
  _COptional_CFps _copyFromDartTo_COptional_CFps() {
    final cOptional = _COptional_CFpsMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CFps();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - StatefulChannel<Fps> <-> _CStatefulChannel_CFps

class _CStatefulChannel_CFpsImpl extends StatefulChannel<Fps> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<Fps>>{};

  final _CStatefulChannel_CFps _channel;

  _CStatefulChannel_CFpsImpl(this._channel);

  @override
  Fps get value {
    return this._channel._getter();
  }

  static void valueFunction(_CFps cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<Fps> listen(void onData(Fps event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CFps, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<Fps>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CFps extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CFpsBasicFunctions on _CStatefulChannel_CFps {
  void _releaseIntermediate() {
    _CStatefulChannel_CFps_release(this);
  }

  _CStatefulChannel_CFps _retain() {
    return _CStatefulChannel_CFps_retain(this);
  }

  Fps _getter() {
    final cValue = _CStatefulChannel_CFpsGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CFps, ffi.Int64)> callback) {
    return _CStatefulChannel_CFpsConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CFpsToDart on _CStatefulChannel_CFps {
  StatefulChannel<Fps> _toDart() {
    return _CStatefulChannel_CFpsImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CFps on StatefulChannel<Fps> {
  _CStatefulChannel_CFps _copyFromDartTo_CStatefulChannel_CFps() {
    return _CStatefulChannel_CFpsMakeDefault();
  }
}
	
// MARK: - CancelableOperation<ImageData> <-> _CFuture_CImageData

final class _CFuture_CImageData extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CImageData_Cancellable {
  final Completer<ImageData> completer;
  final _CFuture_CImageData _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CImageData, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CImageData_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CImageDataBasicFunctions on _CFuture_CImageData {
  void _releaseIntermediate() {
    _CFuture_CImageData_release(this);
  }

  _CFuture_CImageData _retain() {
    return _CFuture_CImageData_retain(this);
  }
}

extension _CFuture_CImageDataToDart on _CFuture_CImageData {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CImageData_Cancellable>{};

  static void valueFunction(_CImageData cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<ImageData> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<ImageData>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CImageData, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CImageDataReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CImageData_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CImageData on CancelableOperation<ImageData> {
  _CFuture_CImageData _copyFromDartTo_CFuture_CImageData() {
    return _CFuture_CImageDataMakeDefault();
  }
}
	
// MARK: - MapBuilder

@internal
class MapBuilder implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CMapBuilder_releasePtr);

  MapBuilder._raw(this._self);
  factory MapBuilder._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapBuilder._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory MapBuilder() {
    _CMapBuilder res = _CMapBuilder_C_create();
    return MapBuilder._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapBuilder &&
    other.runtimeType == runtimeType &&
    _CMapBuilder_cg_objectIdentifier(this._self) == _CMapBuilder_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapBuilder_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: MapBuilder: Methods

  MapBuilder setSize(
    ScreenSize size
  )  {
    var _a1 = size._copyFromDartTo_CScreenSize();
    _CMapBuilder res = _CMapBuilder_setSize_CScreenSize(_CMapBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setDevicePpi(
    DevicePpi devicePpi,
    DeviceDensity deviceDensity
  )  {
    var _a1 = devicePpi._copyFromDartTo_CDevicePpi();
    var _a2 = deviceDensity._copyFromDartTo_CDeviceDensity();
    _CMapBuilder res = _CMapBuilder_setDevicePpi_CDevicePpi_CDeviceDensity(_CMapBuilderMakeDefault().._impl=_self, _a1, _a2);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setFontIconSizeMultiplier(
    double fontIconSizeMultiplier
  )  {
    _CMapBuilder res = _CMapBuilder_setFontIconSizeMultiplier_float(_CMapBuilderMakeDefault().._impl=_self, fontIconSizeMultiplier);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setSystemFontIconSizeMultiplier(
    double fontIconSizeMultiplier
  )  {
    _CMapBuilder res = _CMapBuilder_setSystemFontIconSizeMultiplier_float(_CMapBuilderMakeDefault().._impl=_self, fontIconSizeMultiplier);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setStyle(
    Style style
  )  {
    var _a1 = style._copyFromDartTo_CStyle();
    _CMapBuilder res = _CMapBuilder_setStyle_CStyle(_CMapBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setStyleFromFile(
    Context context,
    File file
  )  {
    var _a1 = context._copyFromDartTo_CContext();
    var _a2 = file._copyFromDartTo_CFile();
    _CMapBuilder res = _CMapBuilder_setStyleFromFile_CContext_CFile(_CMapBuilderMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setPosition(
    CameraPosition position
  )  {
    var _a1 = position._copyFromDartTo_CCameraPosition();
    _CMapBuilder res = _CMapBuilder_setPosition_CCameraPosition(_CMapBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setZoomRestrictions(
    CameraZoomRestrictions zoomRestrictions
  )  {
    var _a1 = zoomRestrictions._copyFromDartTo_CCameraZoomRestrictions();
    _CMapBuilder res = _CMapBuilder_setZoomRestrictions_CCameraZoomRestrictions(_CMapBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setPositionPoint(
    CameraPositionPoint positionPoint
  )  {
    var _a1 = positionPoint._copyFromDartTo_CCameraPositionPoint();
    _CMapBuilder res = _CMapBuilder_setPositionPoint_CCameraPositionPoint(_CMapBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setBehaviour(
    CameraBehaviour behaviour
  )  {
    var _a1 = behaviour._copyFromDartTo_CCameraBehaviour();
    _CMapBuilder res = _CMapBuilder_setBehaviour_CCameraBehaviour(_CMapBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setFollowController(
    FollowController followController
  )  {
    var _a1 = followController._copyFromDartTo_CFollowController();
    _CMapBuilder res = _CMapBuilder_setFollowController_CFollowController(_CMapBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setAttribute(
    String name,
    AttributeValue value
  )  {
    var _a1 = name._copyFromDartTo_CString();
    var _a2 = value._copyFromDartTo_CAttributeValue();
    _CMapBuilder res = _CMapBuilder_setAttribute_CString_CAttributeValue(_CMapBuilderMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setAttributes(
    core.Map<String, AttributeValue> values
  )  {
    var _a1 = values._copyFromDartTo_CDictionary_CString_CAttributeValue();
    _CMapBuilder res = _CMapBuilder_setAttributes_CDictionary_CString_CAttributeValue(_CMapBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setBackgroundColor(
    Color color
  )  {
    var _a1 = color._copyFromDartTo_CColor();
    _CMapBuilder res = _CMapBuilder_setBackgroundColor_CColor(_CMapBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setVisibilityState(
    MapVisibilityState state
  )  {
    var _a1 = state._copyFromDartTo_CMapVisibilityState();
    _CMapBuilder res = _CMapBuilder_setVisibilityState_CMapVisibilityState(_CMapBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder setGraphicsPreset(
    GraphicsPreset graphicPreset
  )  {
    var _a1 = graphicPreset._copyFromDartTo_CGraphicsPreset();
    _CMapBuilder res = _CMapBuilder_setGraphicsPreset_CGraphicsPreset(_CMapBuilderMakeDefault().._impl=_self, _a1);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  MapBuilder addSource(
    Source source
  )  {
    var _a1 = source._copyFromDartTo_CSource();
    _CMapBuilder res = _CMapBuilder_addSource_CSource(_CMapBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  CancelableOperation<Map> createMap(
    Context context
  )  {
    var _a1 = context._copyFromDartTo_CContext();
    _CFuture_CMap res = _CMapBuilder_createMap_CContext(_CMapBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - MapBuilder <-> CMapBuilder

final class _CMapBuilder extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapBuilderBasicFunctions on _CMapBuilder {
  void _releaseIntermediate() {
    _CMapBuilder_release(_impl);
  }

  _CMapBuilder _retain() {
    return _CMapBuilder_retain(_impl);
  }
}

extension _CMapBuilderToDart on _CMapBuilder {
  MapBuilder _toDart() {
    return MapBuilder._create(_retain()._impl);
  }
}


extension _DartToCMapBuilder on MapBuilder {
  _CMapBuilder _copyFromDartTo_CMapBuilder() {
    return (_CMapBuilderMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CancelableOperation<Map> <-> _CFuture_CMap

final class _CFuture_CMap extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CMap_Cancellable {
  final Completer<Map> completer;
  final _CFuture_CMap _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CMap, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CMap_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CMapBasicFunctions on _CFuture_CMap {
  void _releaseIntermediate() {
    _CFuture_CMap_release(this);
  }

  _CFuture_CMap _retain() {
    return _CFuture_CMap_retain(this);
  }
}

extension _CFuture_CMapToDart on _CFuture_CMap {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CMap_Cancellable>{};

  static void valueFunction(_CMap cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<Map> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<Map>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CMap, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CMapReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CMap_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CMap on CancelableOperation<Map> {
  _CFuture_CMap _copyFromDartTo_CFuture_CMap() {
    return _CFuture_CMapMakeDefault();
  }
}
	
// MARK: - StyleBuilder

/** Конструктор стилей. */
class StyleBuilder implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CStyleBuilder_releasePtr);

  StyleBuilder._raw(this._self);
  factory StyleBuilder._create(ffi.Pointer<ffi.Void> self) {
    final classObject = StyleBuilder._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory StyleBuilder(
    Context context
  ) {
    var _a0 = context._copyFromDartTo_CContext();
    _CStyleBuilder res = _CStyleBuilder_C_createWith_CContext(_a0);
    _a0._releaseIntermediate();
    return StyleBuilder._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is StyleBuilder &&
    other.runtimeType == runtimeType &&
    _CStyleBuilder_cg_objectIdentifier(this._self) == _CStyleBuilder_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CStyleBuilder_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: StyleBuilder: Methods

  StyleBuilder setStyleAttribute(
    String name,
    AttributeValue value
  )  {
    var _a1 = name._copyFromDartTo_CString();
    var _a2 = value._copyFromDartTo_CAttributeValue();
    _CStyleBuilder res = _CStyleBuilder_setStyleAttribute_CString_CAttributeValue(_CStyleBuilderMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Получение предустановленного стиля. */
  CancelableOperation<Style> getDefaultStyle()  {
    _CFuture_CStyle res = _CStyleBuilder_getDefaultStyle(_CStyleBuilderMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /** Загрузка пользовательского стиля. */
  CancelableOperation<Style> loadStyle(
    File file
  )  {
    var _a1 = file._copyFromDartTo_CFile();
    _CFuture_CStyle res = _CStyleBuilder_loadStyle_CFile(_CStyleBuilderMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - StyleBuilder <-> CStyleBuilder

final class _CStyleBuilder extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStyleBuilderBasicFunctions on _CStyleBuilder {
  void _releaseIntermediate() {
    _CStyleBuilder_release(_impl);
  }

  _CStyleBuilder _retain() {
    return _CStyleBuilder_retain(_impl);
  }
}

extension _CStyleBuilderToDart on _CStyleBuilder {
  StyleBuilder _toDart() {
    return StyleBuilder._create(_retain()._impl);
  }
}


extension _DartToCStyleBuilder on StyleBuilder {
  _CStyleBuilder _copyFromDartTo_CStyleBuilder() {
    return (_CStyleBuilderMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CancelableOperation<Style> <-> _CFuture_CStyle

final class _CFuture_CStyle extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CStyle_Cancellable {
  final Completer<Style> completer;
  final _CFuture_CStyle _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CStyle, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CStyle_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CStyleBasicFunctions on _CFuture_CStyle {
  void _releaseIntermediate() {
    _CFuture_CStyle_release(this);
  }

  _CFuture_CStyle _retain() {
    return _CFuture_CStyle_retain(this);
  }
}

extension _CFuture_CStyleToDart on _CFuture_CStyle {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CStyle_Cancellable>{};

  static void valueFunction(_CStyle cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<Style> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<Style>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CStyle, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CStyleReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CStyle_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CStyle on CancelableOperation<Style> {
  _CFuture_CStyle _copyFromDartTo_CFuture_CStyle() {
    return _CFuture_CStyleMakeDefault();
  }
}
	
// MARK: - RotationCenter

/** Задает правило обработки событий вращения карты. */
enum RotationCenter {
  /** Вращать относительно геометрического центра множества точек постановки пальцев. */
  eventCenter(0),
  /** Вращать относительно точки позиции карты. */
  mapPosition(1),
  /**
   Вращать относительно геопозиции.
   Геопозиция устанавливается через метод set_target_geo_point.
   Если геопозиция не указана, то вращение производится относительно точки позиции карты.
  */
  geoPosition(2),
  ;

  const RotationCenter(this.rawValue);
  final int rawValue;

  static RotationCenter getByValue(int value) {
    return RotationCenter.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CRotationCenter extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CRotationCenterBasicFunctions on _CRotationCenter {
  void _releaseIntermediate() {
  }
}

extension _CRotationCenterToDart on _CRotationCenter {
  RotationCenter _toDart() {
    return RotationCenter.getByValue(this.rawValue);
  }
}

extension _DartTo_CRotationCenter on RotationCenter {
  _CRotationCenter _copyFromDartTo_CRotationCenter() {
    return _CRotationCenterMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ScalingCenter

/** Задает правило обработки событий масштабирования карты. */
enum ScalingCenter {
  /** Масштабировать относительно геометрического центра множества точек постановки пальцев. */
  eventCenter(0),
  /** Масштабировать относительно точки позиции карты. */
  mapPosition(1),
  /**
   Масштабировать относительно геопозиции.
   Геопозиция устанавливается через метод set_target_geo_point.
   Если геопозиция не указана, то масштабирование производится относительно точки позиции карты.
  */
  geoPosition(2),
  ;

  const ScalingCenter(this.rawValue);
  final int rawValue;

  static ScalingCenter getByValue(int value) {
    return ScalingCenter.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CScalingCenter extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CScalingCenterBasicFunctions on _CScalingCenter {
  void _releaseIntermediate() {
  }
}

extension _CScalingCenterToDart on _CScalingCenter {
  ScalingCenter _toDart() {
    return ScalingCenter.getByValue(this.rawValue);
  }
}

extension _DartTo_CScalingCenter on ScalingCenter {
  _CScalingCenter _copyFromDartTo_CScalingCenter() {
    return _CScalingCenterMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - EventsProcessingSettings

class EventsProcessingSettings {
  /** Точка, относительно которой производится вращение карты. */
  final RotationCenter rotationCenter;
  /** Точка, относительно которой производится масштабирование карты. */
  final ScalingCenter scalingCenter;

  const EventsProcessingSettings({
    required this.rotationCenter,
    required this.scalingCenter
  });

  EventsProcessingSettings copyWith({
    RotationCenter? rotationCenter,
    ScalingCenter? scalingCenter
  }) {
    return EventsProcessingSettings(
      rotationCenter: rotationCenter ?? this.rotationCenter,
      scalingCenter: scalingCenter ?? this.scalingCenter
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is EventsProcessingSettings &&
    other.runtimeType == runtimeType &&
    other.rotationCenter == rotationCenter &&
    other.scalingCenter == scalingCenter;

  @override
  int get hashCode {
    return Object.hash(rotationCenter, scalingCenter);
  }

}
final class _CEventsProcessingSettings extends ffi.Struct {
  external _CRotationCenter rotationCenter;

  external _CScalingCenter scalingCenter;

}
// MARK: - EventsProcessingSettings <-> _CEventsProcessingSettings

extension _CEventsProcessingSettingsToDart on _CEventsProcessingSettings {
  EventsProcessingSettings _toDart() {
    return EventsProcessingSettings(
      rotationCenter: this.rotationCenter._toDart(),
      scalingCenter: this.scalingCenter._toDart()
    );
  }
}

extension _DartTo_CEventsProcessingSettings on EventsProcessingSettings {
  _CEventsProcessingSettings _copyFromDartTo_CEventsProcessingSettings() {
    final res = _CEventsProcessingSettingsMakeDefault();
    res.rotationCenter = this.rotationCenter._copyFromDartTo_CRotationCenter();
    res.scalingCenter = this.scalingCenter._copyFromDartTo_CScalingCenter();
    return res;
  }
}
extension _CEventsProcessingSettingsRelease on _CEventsProcessingSettings {
  void _releaseIntermediate() {
  }
}

// MARK: - DragBeginData

/** Данные о начале перетаскивания: точка старта перемещения и перемещаемый объект. */
class DragBeginData {
  final ScreenPoint point;
  final RenderedObject item;

  const DragBeginData({
    required this.point,
    required this.item
  });

  DragBeginData copyWith({
    ScreenPoint? point,
    RenderedObject? item
  }) {
    return DragBeginData(
      point: point ?? this.point,
      item: item ?? this.item
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is DragBeginData &&
    other.runtimeType == runtimeType &&
    other.point == point &&
    other.item == item;

  @override
  int get hashCode {
    return Object.hash(point, item);
  }

}
final class _CDragBeginData extends ffi.Struct {
  external _CScreenPoint point;

  external _CRenderedObject item;

}
// MARK: - DragBeginData <-> _CDragBeginData

extension _CDragBeginDataToDart on _CDragBeginData {
  DragBeginData _toDart() {
    return DragBeginData(
      point: this.point._toDart(),
      item: this.item._toDart()
    );
  }
}

extension _DartTo_CDragBeginData on DragBeginData {
  _CDragBeginData _copyFromDartTo_CDragBeginData() {
    final res = _CDragBeginDataMakeDefault();
    res.point = this.point._copyFromDartTo_CScreenPoint();
    res.item = this.item._copyFromDartTo_CRenderedObject();
    return res;
  }
}
extension _CDragBeginDataRelease on _CDragBeginData {
  void _releaseIntermediate() {
    item._releaseIntermediate();
  }
}

// MARK: - Gesture

enum Gesture {
  shift(1),
  scaling(2),
  rotation(4),
  multiTouchShift(8),
  tilt(16),
  ;

  const Gesture(this.rawValue);
  final int rawValue;

  static Gesture getByValue(int value) {
    return Gesture.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CGesture extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CGestureBasicFunctions on _CGesture {
  void _releaseIntermediate() {
  }
}

extension _CGestureToDart on _CGesture {
  Gesture _toDart() {
    return Gesture.getByValue(this.rawValue);
  }
}

extension _DartTo_CGesture on Gesture {
  _CGesture _copyFromDartTo_CGesture() {
    return _CGestureMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - ScalingSettings

class ScalingSettings {
  /**
   Порог коэффицента масштабирования, по достижению которого начнёт отправляться событие масштабирования.
   Используется, если вращение неактивно. Множитель должен выйти за пределы
   (1 / scale_ratio_threshold, scale_ratio_threshold).
  */
  final double scaleRatioThreshold;
  /**
   Порог коэффицента масштабирования, по достижению которого начнёт отправляться сообщения масштабирования.
   Используется, если вращение активно. Множитель должен выйти за пределы
   (1 / scale_ratio_threshold_in_rotation, scale_ratio_threshold_in_rotation).
  */
  final double scaleRatioThresholdInRotation;

  const ScalingSettings({
    required this.scaleRatioThreshold,
    required this.scaleRatioThresholdInRotation
  });

  ScalingSettings copyWith({
    double? scaleRatioThreshold,
    double? scaleRatioThresholdInRotation
  }) {
    return ScalingSettings(
      scaleRatioThreshold: scaleRatioThreshold ?? this.scaleRatioThreshold,
      scaleRatioThresholdInRotation: scaleRatioThresholdInRotation ?? this.scaleRatioThresholdInRotation
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is ScalingSettings &&
    other.runtimeType == runtimeType &&
    other.scaleRatioThreshold == scaleRatioThreshold &&
    other.scaleRatioThresholdInRotation == scaleRatioThresholdInRotation;

  @override
  int get hashCode {
    return Object.hash(scaleRatioThreshold, scaleRatioThresholdInRotation);
  }

}
final class _CScalingSettings extends ffi.Struct {
  @ffi.Float()
  external double scaleRatioThreshold;

  @ffi.Float()
  external double scaleRatioThresholdInRotation;

}
// MARK: - ScalingSettings <-> _CScalingSettings

extension _CScalingSettingsToDart on _CScalingSettings {
  ScalingSettings _toDart() {
    return ScalingSettings(
      scaleRatioThreshold: this.scaleRatioThreshold,
      scaleRatioThresholdInRotation: this.scaleRatioThresholdInRotation
    );
  }
}

extension _DartTo_CScalingSettings on ScalingSettings {
  _CScalingSettings _copyFromDartTo_CScalingSettings() {
    final res = _CScalingSettingsMakeDefault();
    res.scaleRatioThreshold = this.scaleRatioThreshold;
    res.scaleRatioThresholdInRotation = this.scaleRatioThresholdInRotation;
    return res;
  }
}
extension _CScalingSettingsRelease on _CScalingSettings {
  void _releaseIntermediate() {
  }
}

// MARK: - RotationSettings

/** Настройки обработки вращения карты. */
class RotationSettings {
  /**
   Порог изменения угла, в градусах, по достижению которого начнёт отправлять сообщения вращения.
   Используется, если масштабирование неактивно.
  */
  final double angleDiffDeg;
  /**
   Порог среднего радиального сдвига точек, в миллиметрах, по достижению которого начнёт отправлять
   сообщения вращения. Используется, если масштабирование неактивно.
  */
  final double distanceDiffMm;
  /**
   Порог изменения угла, в градусах, по достижению которого начнёт отправлять сообщения вращения.
   Используется, если масштабирование активно.
  */
  final double angleDiffInScalingDeg;
  /**
   Порог среднего радиального сдвига точек, в миллиметрах, по достижению которого начнёт отправлять
   сообщения вращения. Используется, если масштабирование активно.
  */
  final double distanceDiffInScalingMm;

  const RotationSettings({
    required this.angleDiffDeg,
    required this.distanceDiffMm,
    required this.angleDiffInScalingDeg,
    required this.distanceDiffInScalingMm
  });

  RotationSettings copyWith({
    double? angleDiffDeg,
    double? distanceDiffMm,
    double? angleDiffInScalingDeg,
    double? distanceDiffInScalingMm
  }) {
    return RotationSettings(
      angleDiffDeg: angleDiffDeg ?? this.angleDiffDeg,
      distanceDiffMm: distanceDiffMm ?? this.distanceDiffMm,
      angleDiffInScalingDeg: angleDiffInScalingDeg ?? this.angleDiffInScalingDeg,
      distanceDiffInScalingMm: distanceDiffInScalingMm ?? this.distanceDiffInScalingMm
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RotationSettings &&
    other.runtimeType == runtimeType &&
    other.angleDiffDeg == angleDiffDeg &&
    other.distanceDiffMm == distanceDiffMm &&
    other.angleDiffInScalingDeg == angleDiffInScalingDeg &&
    other.distanceDiffInScalingMm == distanceDiffInScalingMm;

  @override
  int get hashCode {
    return Object.hash(angleDiffDeg, distanceDiffMm, angleDiffInScalingDeg, distanceDiffInScalingMm);
  }

}
final class _CRotationSettings extends ffi.Struct {
  @ffi.Float()
  external double angleDiffDeg;

  @ffi.Float()
  external double distanceDiffMm;

  @ffi.Float()
  external double angleDiffInScalingDeg;

  @ffi.Float()
  external double distanceDiffInScalingMm;

}
// MARK: - RotationSettings <-> _CRotationSettings

extension _CRotationSettingsToDart on _CRotationSettings {
  RotationSettings _toDart() {
    return RotationSettings(
      angleDiffDeg: this.angleDiffDeg,
      distanceDiffMm: this.distanceDiffMm,
      angleDiffInScalingDeg: this.angleDiffInScalingDeg,
      distanceDiffInScalingMm: this.distanceDiffInScalingMm
    );
  }
}

extension _DartTo_CRotationSettings on RotationSettings {
  _CRotationSettings _copyFromDartTo_CRotationSettings() {
    final res = _CRotationSettingsMakeDefault();
    res.angleDiffDeg = this.angleDiffDeg;
    res.distanceDiffMm = this.distanceDiffMm;
    res.angleDiffInScalingDeg = this.angleDiffInScalingDeg;
    res.distanceDiffInScalingMm = this.distanceDiffInScalingMm;
    return res;
  }
}
extension _CRotationSettingsRelease on _CRotationSettings {
  void _releaseIntermediate() {
  }
}

// MARK: - MultiTouchShiftSettings

/** Настройки обработки сдвига при касании несколькими пальцами. */
class MultiTouchShiftSettings {
  /**
   Порог сдвига взвешенного среднего точек постановки пальцев, в миллиметрах, по достижению которого начинают
   генерироваться события смещения несколькими пальцами
  */
  final double thresholdMm;

  const MultiTouchShiftSettings(this.thresholdMm);

  MultiTouchShiftSettings copyWith({
    double? thresholdMm
  }) {
    return MultiTouchShiftSettings(
      thresholdMm ?? this.thresholdMm
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MultiTouchShiftSettings &&
    other.runtimeType == runtimeType &&
    other.thresholdMm == thresholdMm;

  @override
  int get hashCode {
    return thresholdMm.hashCode;
  }

}
final class _CMultiTouchShiftSettings extends ffi.Struct {
  @ffi.Float()
  external double thresholdMm;

}
// MARK: - MultiTouchShiftSettings <-> _CMultiTouchShiftSettings

extension _CMultiTouchShiftSettingsToDart on _CMultiTouchShiftSettings {
  MultiTouchShiftSettings _toDart() {
    return MultiTouchShiftSettings(
      this.thresholdMm
    );
  }
}

extension _DartTo_CMultiTouchShiftSettings on MultiTouchShiftSettings {
  _CMultiTouchShiftSettings _copyFromDartTo_CMultiTouchShiftSettings() {
    final res = _CMultiTouchShiftSettingsMakeDefault();
    res.thresholdMm = this.thresholdMm;
    return res;
  }
}
extension _CMultiTouchShiftSettingsRelease on _CMultiTouchShiftSettings {
  void _releaseIntermediate() {
  }
}

// MARK: - TiltSettings

class TiltSettings {
  /**
   Расстояние, в мм, на которое нужно сдвинуть пальцы по экрану, чтобы изменить угол наклона камеры на 1 градус.
   Отрицательное значение прведет к инверсии направления. значение 0 недопустимо.
  */
  final double lenOnDegreeMm;
  /**
   Максимальный допустимый угол отклонения линии постановки пальцев от горизонта для вертикального свайпа.
   В градусах.
  */
  final double horizontalSwerveDeg;
  /** Максимально допустимый угол отклонения направления свайпа от вертикальной линии. Измеряется в градусах */
  final double verticalSwerveDeg;
  /** Порог сдвига взвешенного среднего точек в миллиметрах. Если сдвиг не превысит порог, то событие не отправляется. */
  final double thresholdMm;
  /**
   Максимально допустимый угол между векторами, до достижения которого они считаются сонаправленными во время
   распознавания жеста наклона.
  */
  final double maxParallelsDeviationDeg;

  const TiltSettings({
    required this.lenOnDegreeMm,
    required this.horizontalSwerveDeg,
    required this.verticalSwerveDeg,
    required this.thresholdMm,
    required this.maxParallelsDeviationDeg
  });

  TiltSettings copyWith({
    double? lenOnDegreeMm,
    double? horizontalSwerveDeg,
    double? verticalSwerveDeg,
    double? thresholdMm,
    double? maxParallelsDeviationDeg
  }) {
    return TiltSettings(
      lenOnDegreeMm: lenOnDegreeMm ?? this.lenOnDegreeMm,
      horizontalSwerveDeg: horizontalSwerveDeg ?? this.horizontalSwerveDeg,
      verticalSwerveDeg: verticalSwerveDeg ?? this.verticalSwerveDeg,
      thresholdMm: thresholdMm ?? this.thresholdMm,
      maxParallelsDeviationDeg: maxParallelsDeviationDeg ?? this.maxParallelsDeviationDeg
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TiltSettings &&
    other.runtimeType == runtimeType &&
    other.lenOnDegreeMm == lenOnDegreeMm &&
    other.horizontalSwerveDeg == horizontalSwerveDeg &&
    other.verticalSwerveDeg == verticalSwerveDeg &&
    other.thresholdMm == thresholdMm &&
    other.maxParallelsDeviationDeg == maxParallelsDeviationDeg;

  @override
  int get hashCode {
    return Object.hash(lenOnDegreeMm, horizontalSwerveDeg, verticalSwerveDeg, thresholdMm, maxParallelsDeviationDeg);
  }

}
final class _CTiltSettings extends ffi.Struct {
  @ffi.Float()
  external double lenOnDegreeMm;

  @ffi.Float()
  external double horizontalSwerveDeg;

  @ffi.Float()
  external double verticalSwerveDeg;

  @ffi.Float()
  external double thresholdMm;

  @ffi.Float()
  external double maxParallelsDeviationDeg;

}
// MARK: - TiltSettings <-> _CTiltSettings

extension _CTiltSettingsToDart on _CTiltSettings {
  TiltSettings _toDart() {
    return TiltSettings(
      lenOnDegreeMm: this.lenOnDegreeMm,
      horizontalSwerveDeg: this.horizontalSwerveDeg,
      verticalSwerveDeg: this.verticalSwerveDeg,
      thresholdMm: this.thresholdMm,
      maxParallelsDeviationDeg: this.maxParallelsDeviationDeg
    );
  }
}

extension _DartTo_CTiltSettings on TiltSettings {
  _CTiltSettings _copyFromDartTo_CTiltSettings() {
    final res = _CTiltSettingsMakeDefault();
    res.lenOnDegreeMm = this.lenOnDegreeMm;
    res.horizontalSwerveDeg = this.horizontalSwerveDeg;
    res.verticalSwerveDeg = this.verticalSwerveDeg;
    res.thresholdMm = this.thresholdMm;
    res.maxParallelsDeviationDeg = this.maxParallelsDeviationDeg;
    return res;
  }
}
extension _CTiltSettingsRelease on _CTiltSettings {
  void _releaseIntermediate() {
  }
}

// MARK: - GestureManager

/** Класс для управления обработкой жестов. */
class GestureManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  GestureEnumSet get enabledGestures {
    _COptionSet_CGesture res = _CGestureManager_enabledGestures(_CGestureManagerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set enabledGestures(GestureEnumSet flags) {
    var _a1 = flags._copyFromDartTo_COptionSet_CGesture();
    void res = _CGestureManager_setEnabledGestures_COptionSet_CGesture(_CGestureManagerMakeDefault().._impl=_self, _a1);
    return res;
  }
  ScalingSettings get scalingSettings {
    _CScalingSettings res = _CGestureManager_scalingSettings(_CGestureManagerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set scalingSettings(ScalingSettings settings) {
    var _a1 = settings._copyFromDartTo_CScalingSettings();
    void res = _CGestureManager_setScalingSettings_CScalingSettings(_CGestureManagerMakeDefault().._impl=_self, _a1);
    return res;
  }
  RotationSettings get rotationSettings {
    _CRotationSettings res = _CGestureManager_rotationSettings(_CGestureManagerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set rotationSettings(RotationSettings settings) {
    var _a1 = settings._copyFromDartTo_CRotationSettings();
    void res = _CGestureManager_setRotationSettings_CRotationSettings(_CGestureManagerMakeDefault().._impl=_self, _a1);
    return res;
  }
  MultiTouchShiftSettings get multitouchShiftSettings {
    _CMultiTouchShiftSettings res = _CGestureManager_multitouchShiftSettings(_CGestureManagerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set multitouchShiftSettings(MultiTouchShiftSettings settings) {
    var _a1 = settings._copyFromDartTo_CMultiTouchShiftSettings();
    void res = _CGestureManager_setMultitouchShiftSettings_CMultiTouchShiftSettings(_CGestureManagerMakeDefault().._impl=_self, _a1);
    return res;
  }
  TiltSettings get tiltSettings {
    _CTiltSettings res = _CGestureManager_tiltSettings(_CGestureManagerMakeDefault().._impl=_self);
    return res._toDart();
  }
  set tiltSettings(TiltSettings settings) {
    var _a1 = settings._copyFromDartTo_CTiltSettings();
    void res = _CGestureManager_setTiltSettings_CTiltSettings(_CGestureManagerMakeDefault().._impl=_self, _a1);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CGestureManager_releasePtr);

  GestureManager._raw(this._self);
  factory GestureManager._create(ffi.Pointer<ffi.Void> self) {
    final classObject = GestureManager._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is GestureManager &&
    other.runtimeType == runtimeType &&
    _CGestureManager_cg_objectIdentifier(this._self) == _CGestureManager_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CGestureManager_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: GestureManager: Methods

  void enableGesture(
    Gesture gesture
  )  {
    var _a1 = gesture._copyFromDartTo_CGesture();
    void res = _CGestureManager_enableGesture_CGesture(_CGestureManagerMakeDefault().._impl=_self, _a1);
    return res;
  }

  void disableGesture(
    Gesture gesture
  )  {
    var _a1 = gesture._copyFromDartTo_CGesture();
    void res = _CGestureManager_disableGesture_CGesture(_CGestureManagerMakeDefault().._impl=_self, _a1);
    return res;
  }

  bool gestureEnabled(
    Gesture gesture
  )  {
    var _a1 = gesture._copyFromDartTo_CGesture();
    bool res = _CGestureManager_gestureEnabled_CGesture(_CGestureManagerMakeDefault().._impl=_self, _a1);
    return res;
  }

  /**
   Настройка точки, относительно которой происходит масштабирование и поворот.
  
   - Parameter settings: настройки обработки событий.
   - Note: при вызове функции происходит пересоздание инструментов распознавания жестов.
  */
  void setSettingsAboutMapPositionPoint(
    EventsProcessingSettings settings
  )  {
    var _a1 = settings._copyFromDartTo_CEventsProcessingSettings();
    void res = _CGestureManager_setSettingsAboutMapPositionPoint_CEventsProcessingSettings(_CGestureManagerMakeDefault().._impl=_self, _a1);
    return res;
  }

  /** Установка геопозиции, относительно которой происходит масштабирование и поворот. */
  void setTargetGeoPoint(
    GeoPoint? geoPoint
  )  {
    var _a1 = geoPoint._copyFromDartTo_COptional_CGeoPoint();
    void res = _CGestureManager_setTargetGeoPoint_COptional_CGeoPoint(_CGestureManagerMakeDefault().._impl=_self, _a1);
    return res;
  }

  /**
   Установка списка правил исключения одновременного срабатывания нескольких жестов.
  
   - Note: К переданному списку правил добавляются правила по умолчанию, которые не позволяют жесту управления наклоном
   срабатывать одновременно с другими жестами.
   Каждое правило представляет собой перечень жестов, которые не могут срабатывать одновременно
   Например, если в правиле указать жесты Scaling и Rotation то эти жесты не будут работать одновременно
   В случае одновременного выполнения жестов из правила, сработает жест с большим приоритетом
   Порядок приоритета жестов (по убыванию): (Shift ->) Tilt -> Scaling -> Rotation -> MultiTouchShift
  */
  void setMutuallyExclusiveGestures(
    List<GestureEnumSet> rules
  )  {
    var _a1 = rules._copyFromDartTo_CArray_COptionSet_CGesture();
    void res = _CGestureManager_setMutuallyExclusiveGestures_CArray_COptionSet_CGesture(_CGestureManagerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - GestureManager <-> CGestureManager

final class _CGestureManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CGestureManagerBasicFunctions on _CGestureManager {
  void _releaseIntermediate() {
    _CGestureManager_release(_impl);
  }

  _CGestureManager _retain() {
    return _CGestureManager_retain(_impl);
  }
}

extension _CGestureManagerToDart on _CGestureManager {
  GestureManager _toDart() {
    return GestureManager._create(_retain()._impl);
  }
}


extension _DartToCGestureManager on GestureManager {
  _CGestureManager _copyFromDartTo_CGestureManager() {
    return (_CGestureManagerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - GestureEnumSet

class GestureEnumSet extends EnumSet<Gesture> {
  GestureEnumSet() : super();

  factory GestureEnumSet.fromRawValue(int rawValue) {
    GestureEnumSet enumSet = GestureEnumSet();
    enumSet.rawValue = rawValue;
    return enumSet;
  }

  factory GestureEnumSet.of(Iterable<Gesture> elements) {
    GestureEnumSet enumSet = GestureEnumSet();
    enumSet.addAll(elements);
    return enumSet;
  }

  factory GestureEnumSet.all() {
    GestureEnumSet enumSet = GestureEnumSet();
    enumSet.addAll(Gesture.values);
    return enumSet;
  }

  @override
  bool contains(Gesture value) =>
      (this.rawValue & value.rawValue) == value.rawValue;

  @override
  bool containsAllFromEnumSet(EnumSet<Gesture> other) =>
      (this.rawValue & other.rawValue) == this.rawValue;

  @override
  bool add(Gesture value) {
    if (this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue | value.rawValue;
    return true;
  }

  @override
  void addAllFromEnumSet(EnumSet<Gesture> other) =>
      this.rawValue = this.rawValue | other.rawValue;

  @override
  bool remove(Gesture value) {
    if (!this.contains(value)) {
      return false;
    }
    this.rawValue = this.rawValue & ~value.rawValue;
    return true;
  }

  @override
  void removeAllFromEnumSet(EnumSet<Gesture> other) =>
      this.rawValue = this.rawValue & ~other.rawValue;

  @override
  EnumSet<Gesture> intersection(EnumSet<Gesture> other) =>
      GestureEnumSet.fromRawValue(this.rawValue & other.rawValue);

  @override
  EnumSet<Gesture> union(EnumSet<Gesture> other) =>
      GestureEnumSet.fromRawValue(this.rawValue | other.rawValue);

  @override
  EnumSet<Gesture> difference(EnumSet<Gesture> other) =>
      GestureEnumSet.fromRawValue(this.rawValue & ~other.rawValue);

  @override
  Set<Gesture> toSet() {
    Set<Gesture> result = {};
    Gesture.values.forEach((element) {
      if (this.contains(element)) {
        result.add(element);
      }
    });
    return result;
  }

  @override
  String toString() {
    List<String> validOptionNames = [];
    Gesture.values.forEach((element) {
      if (this.contains(element)) {
        validOptionNames.add(element.name);
      }
    });

    return "${this.runtimeType}: ${validOptionNames.join(', ')}";
  }
}

final class _COptionSet_CGesture extends ffi.Struct {
  @ffi.Uint32()
  external int _rawValue;
}

extension _COptionSet_CGestureBasicFunctions on _COptionSet_CGesture {
  void _releaseIntermediate() {
  }
}

extension _COptionSet_CGestureToDart on _COptionSet_CGesture {
  GestureEnumSet _toDart() {
    return GestureEnumSet.fromRawValue(this._rawValue);
  }
}

extension _DartTo_COptionSet_CGesture on GestureEnumSet {
  _COptionSet_CGesture _copyFromDartTo_COptionSet_CGesture() {
    return _COptionSet_CGestureMakeDefault().._rawValue = this.rawValue;
  }
}
	
// MARK: - List<GestureEnumSet> <-> _CArray_COptionSet_CGesture

final class _CArray_COptionSet_CGesture extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_COptionSet_CGestureToDart on _CArray_COptionSet_CGesture {
  List<GestureEnumSet> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_COptionSet_CGesture on List<GestureEnumSet> {
  _CArray_COptionSet_CGesture _copyFromDartTo_CArray_COptionSet_CGesture() {
    final cArray = _CArray_COptionSet_CGesturemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_COptionSet_CGesture();
        _CArray_COptionSet_CGestureaddElement(cArray, cItem);
        
    });
    return cArray;
  }
}

extension _CArray_COptionSet_CGestureBasicFunctions on _CArray_COptionSet_CGesture {
  void _releaseIntermediate() {
    _CArray_COptionSet_CGesture_release(this);
  }

  static final _listToFill = <GestureEnumSet>[];

  static void _iterate(_COptionSet_CGesture item) {
    _listToFill.add(item._toDart());
  }

  List<GestureEnumSet> _fillFromC() {
    _forEach_CArray_COptionSet_CGesture(this, ffi.Pointer.fromFunction<ffi.Void Function(_COptionSet_CGesture)>(_iterate));
    final result = List<GestureEnumSet>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - TouchPointState

enum TouchPointState {
  pressed(0),
  released(1),
  moved(2),
  endThisEnum(3),
  ;

  const TouchPointState(this.rawValue);
  final int rawValue;

  static TouchPointState getByValue(int value) {
    return TouchPointState.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CTouchPointState extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CTouchPointStateBasicFunctions on _CTouchPointState {
  void _releaseIntermediate() {
  }
}

extension _CTouchPointStateToDart on _CTouchPointState {
  TouchPointState _toDart() {
    return TouchPointState.getByValue(this.rawValue);
  }
}

extension _DartTo_CTouchPointState on TouchPointState {
  _CTouchPointState _copyFromDartTo_CTouchPointState() {
    return _CTouchPointStateMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - MapGestureRecognizer

/**
 Принимает информацию о нажатиях и преобразует их в жесты карты.
 Обработка происходит в два этапа:
 * Добавляется несколько точек - add_touch_point
 * Точки обрабатываются - process_touch_event
*/
@internal
class MapGestureRecognizer implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  Channel<DragBeginData> get dragBegin {
    _CChannel_CDragBeginData res = _CMapGestureRecognizer_dragBegin(_CMapGestureRecognizerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  Channel<bool> get dragEnd {
    _CChannel_bool res = _CMapGestureRecognizer_dragEnd(_CMapGestureRecognizerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  Channel<ScreenPoint> get dragMove {
    _CChannel_CScreenPoint res = _CMapGestureRecognizer_dragMove(_CMapGestureRecognizerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  Channel<ScreenPoint> get tap {
    _CChannel_CScreenPoint res = _CMapGestureRecognizer_tap(_CMapGestureRecognizerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  Channel<ScreenPoint> get longTouch {
    _CChannel_CScreenPoint res = _CMapGestureRecognizer_longTouch(_CMapGestureRecognizerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  GestureManager? get gestureManager {
    _COptional_CGestureManager res = _CMapGestureRecognizer_gestureManager(_CMapGestureRecognizerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CMapGestureRecognizer_releasePtr);

  MapGestureRecognizer._raw(this._self);
  factory MapGestureRecognizer._create(ffi.Pointer<ffi.Void> self) {
    final classObject = MapGestureRecognizer._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is MapGestureRecognizer &&
    other.runtimeType == runtimeType &&
    _CMapGestureRecognizer_cg_objectIdentifier(this._self) == _CMapGestureRecognizer_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CMapGestureRecognizer_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: CMapGestureRecognizer: Static Methods

  static MapGestureRecognizer create(
    Map map
  )  {
    var _a0 = map._copyFromDartTo_CMap();
    _CMapGestureRecognizer res = _CMapGestureRecognizer_S_create_CMap(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  // MARK: MapGestureRecognizer: Methods

  void addTouchPoint(
    ScreenPoint point,
    TouchPointState state,
    int id
  )  {
    var _a1 = point._copyFromDartTo_CScreenPoint();
    var _a2 = state._copyFromDartTo_CTouchPointState();
    void res = _CMapGestureRecognizer_addTouchPoint_CScreenPoint_CTouchPointState_uint64_t(_CMapGestureRecognizerMakeDefault().._impl=_self, _a1, _a2, id);
    return res;
  }

  bool processTouchEvent(
    Duration timestamp
  )  {
    var _a1 = timestamp._copyFromDartTo_CTimeInterval();
    bool res = _CMapGestureRecognizer_processTouchEvent_CTimeInterval(_CMapGestureRecognizerMakeDefault().._impl=_self, _a1);
    return res;
  }

  void cancel()  {
    void res = _CMapGestureRecognizer_cancel(_CMapGestureRecognizerMakeDefault().._impl=_self);
    return res;
  }

  void onDevicePpiChanged(
    DevicePpi devicePpi
  )  {
    var _a1 = devicePpi._copyFromDartTo_CDevicePpi();
    void res = _CMapGestureRecognizer_onDevicePpiChanged_CDevicePpi(_CMapGestureRecognizerMakeDefault().._impl=_self, _a1);
    return res;
  }

}

// MARK: - MapGestureRecognizer <-> CMapGestureRecognizer

final class _CMapGestureRecognizer extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CMapGestureRecognizerBasicFunctions on _CMapGestureRecognizer {
  void _releaseIntermediate() {
    _CMapGestureRecognizer_release(_impl);
  }

  _CMapGestureRecognizer _retain() {
    return _CMapGestureRecognizer_retain(_impl);
  }
}

extension _CMapGestureRecognizerToDart on _CMapGestureRecognizer {
  MapGestureRecognizer _toDart() {
    return MapGestureRecognizer._create(_retain()._impl);
  }
}


extension _DartToCMapGestureRecognizer on MapGestureRecognizer {
  _CMapGestureRecognizer _copyFromDartTo_CMapGestureRecognizer() {
    return (_CMapGestureRecognizerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - Channel<DragBeginData> <-> _CChannel_CDragBeginData

class _CChannel_CDragBeginDataImpl extends Channel<DragBeginData> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<DragBeginData>>{};

  final _CChannel_CDragBeginData _channel;

  _CChannel_CDragBeginDataImpl(this._channel);

  static void valueFunction(_CDragBeginData cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<DragBeginData> listen(void onData(DragBeginData event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CDragBeginData, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<DragBeginData>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CChannel_CDragBeginData extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CChannel_CDragBeginDataBasicFunctions on _CChannel_CDragBeginData {
  void _releaseIntermediate() {
    _CChannel_CDragBeginData_release(this);
  }

  _CChannel_CDragBeginData _retain() {
    return _CChannel_CDragBeginData_retain(this);
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CDragBeginData, ffi.Int64)> callback) {
    return _CChannel_CDragBeginDataConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CChannel_CDragBeginDataToDart on _CChannel_CDragBeginData {
  Channel<DragBeginData> _toDart() {
    return _CChannel_CDragBeginDataImpl(this._retain());
  }
}

extension _DartTo_CChannel_CDragBeginData on Channel<DragBeginData> {
  _CChannel_CDragBeginData _copyFromDartTo_CChannel_CDragBeginData() {
    return _CChannel_CDragBeginDataMakeDefault();
  }
}
	
// MARK: - Channel<ScreenPoint> <-> _CChannel_CScreenPoint

class _CChannel_CScreenPointImpl extends Channel<ScreenPoint> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<ScreenPoint>>{};

  final _CChannel_CScreenPoint _channel;

  _CChannel_CScreenPointImpl(this._channel);

  static void valueFunction(_CScreenPoint cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<ScreenPoint> listen(void onData(ScreenPoint event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CScreenPoint, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<ScreenPoint>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CChannel_CScreenPoint extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CChannel_CScreenPointBasicFunctions on _CChannel_CScreenPoint {
  void _releaseIntermediate() {
    _CChannel_CScreenPoint_release(this);
  }

  _CChannel_CScreenPoint _retain() {
    return _CChannel_CScreenPoint_retain(this);
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CScreenPoint, ffi.Int64)> callback) {
    return _CChannel_CScreenPointConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CChannel_CScreenPointToDart on _CChannel_CScreenPoint {
  Channel<ScreenPoint> _toDart() {
    return _CChannel_CScreenPointImpl(this._retain());
  }
}

extension _DartTo_CChannel_CScreenPoint on Channel<ScreenPoint> {
  _CChannel_CScreenPoint _copyFromDartTo_CChannel_CScreenPoint() {
    return _CChannel_CScreenPointMakeDefault();
  }
}
	
// MARK: - GestureManager? <-> _COptional_CGestureManager

final class _COptional_CGestureManager extends ffi.Struct {
  
  external _CGestureManager value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CGestureManagerBasicFunctions on _COptional_CGestureManager {
  void _releaseIntermediate() {
    _COptional_CGestureManager_release(this);
  }
}

extension _COptional_CGestureManagerToDart on _COptional_CGestureManager {
  GestureManager? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CGestureManager on GestureManager? {
  _COptional_CGestureManager _copyFromDartTo_COptional_CGestureManager() {
    final cOptional = _COptional_CGestureManagerMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CGestureManager();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - ApplicationState

/** Состояние приложения, использующего SDK */
@internal
enum ApplicationState {
  /**
   Приложение может быть в любой момент быть выгружено (закрыто) системой.
  
   Следует прекратить работу и сохранить данные для возобновления обработки после восстановления.
  */
  suspended(0),
  /**
   Приложение свёрнуто/скрыто, не виден UI.
  
   - Todo: удалить. Это состояние необходимо получать из видимости Viewport.
  */
  hidden(1),
  /**
   Приложение частично или полностью перекрыто другими приложениями.
  
   - Todo: удалить. Это состояние необходимо получать из видимости Viewport.
  */
  inactive(2),
  /** Приложение активно */
  active(3),
  ;

  const ApplicationState(this.rawValue);
  final int rawValue;

  static ApplicationState getByValue(int value) {
    return ApplicationState.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CApplicationState extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CApplicationStateBasicFunctions on _CApplicationState {
  void _releaseIntermediate() {
  }
}

extension _CApplicationStateToDart on _CApplicationState {
  ApplicationState _toDart() {
    return ApplicationState.getByValue(this.rawValue);
  }
}

extension _DartTo_CApplicationState on ApplicationState {
  _CApplicationState _copyFromDartTo_CApplicationState() {
    return _CApplicationStateMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - HttpCacheManager

/** Интерфейс управления HTTP-кешем. */
class HttpCacheManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Текущий размер HTTP-кеша */
  int get currentSize {
    int res = _CHttpCacheManager_getCurrentSize(_CHttpCacheManagerMakeDefault().._impl=_self);
    return res;
  }
  /** Максимальный размер HTTP-кеша */
  int get maxSize {
    int res = _CHttpCacheManager_getMaxSize(_CHttpCacheManagerMakeDefault().._impl=_self);
    return res;
  }
  set maxSize(int size) {
    void res = _CHttpCacheManager_setMaxSize_uint64_t(_CHttpCacheManagerMakeDefault().._impl=_self, size);
    return res;
  }

  static final _finalizer = ffi.NativeFinalizer(_CHttpCacheManager_releasePtr);

  HttpCacheManager._raw(this._self);
  factory HttpCacheManager._create(ffi.Pointer<ffi.Void> self) {
    final classObject = HttpCacheManager._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is HttpCacheManager &&
    other.runtimeType == runtimeType &&
    _CHttpCacheManager_cg_objectIdentifier(this._self) == _CHttpCacheManager_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CHttpCacheManager_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: HttpCacheManager: Methods

  /** Очистка содержимого HTTP-кеша. */
  void clear()  {
    void res = _CHttpCacheManager_clear(_CHttpCacheManagerMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - HttpCacheManager <-> CHttpCacheManager

final class _CHttpCacheManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CHttpCacheManagerBasicFunctions on _CHttpCacheManager {
  void _releaseIntermediate() {
    _CHttpCacheManager_release(_impl);
  }

  _CHttpCacheManager _retain() {
    return _CHttpCacheManager_retain(_impl);
  }
}

extension _CHttpCacheManagerToDart on _CHttpCacheManager {
  HttpCacheManager _toDart() {
    return HttpCacheManager._create(_retain()._impl);
  }
}


extension _DartToCHttpCacheManager on HttpCacheManager {
  _CHttpCacheManager _copyFromDartTo_CHttpCacheManager() {
    return (_CHttpCacheManagerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - LocaleChangeNotifier

@internal
class LocaleChangeNotifier implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CLocaleChangeNotifier_releasePtr);

  LocaleChangeNotifier._raw(this._self);
  factory LocaleChangeNotifier._create(ffi.Pointer<ffi.Void> self) {
    final classObject = LocaleChangeNotifier._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LocaleChangeNotifier &&
    other.runtimeType == runtimeType &&
    _CLocaleChangeNotifier_cg_objectIdentifier(this._self) == _CLocaleChangeNotifier_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CLocaleChangeNotifier_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: LocaleChangeNotifier: Methods

  void changed(
    List<Locale> locales
  )  {
    var _a1 = locales._copyFromDartTo_CArray_CLocale();
    void res = _CLocaleChangeNotifier_changed_CArray_CLocale(_CLocaleChangeNotifierMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - LocaleChangeNotifier <-> CLocaleChangeNotifier

final class _CLocaleChangeNotifier extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CLocaleChangeNotifierBasicFunctions on _CLocaleChangeNotifier {
  void _releaseIntermediate() {
    _CLocaleChangeNotifier_release(_impl);
  }

  _CLocaleChangeNotifier _retain() {
    return _CLocaleChangeNotifier_retain(_impl);
  }
}

extension _CLocaleChangeNotifierToDart on _CLocaleChangeNotifier {
  LocaleChangeNotifier _toDart() {
    return LocaleChangeNotifier._create(_retain()._impl);
  }
}


extension _DartToCLocaleChangeNotifier on LocaleChangeNotifier {
  _CLocaleChangeNotifier _copyFromDartTo_CLocaleChangeNotifier() {
    return (_CLocaleChangeNotifierMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - List<Locale> <-> _CArray_CLocale

final class _CArray_CLocale extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CArray_CLocaleToDart on _CArray_CLocale {
  List<Locale> _toDart() {
    return _fillFromC();
  }
}

extension _DartTo_CArray_CLocale on List<Locale> {
  _CArray_CLocale _copyFromDartTo_CArray_CLocale() {
    final cArray = _CArray_CLocalemakeEmpty();
    forEach((item) {
        final cItem = item._copyFromDartTo_CLocale();
        _CArray_CLocaleaddElement(cArray, cItem);
        cItem._releaseIntermediate();
    });
    return cArray;
  }
}

extension _CArray_CLocaleBasicFunctions on _CArray_CLocale {
  void _releaseIntermediate() {
    _CArray_CLocale_release(this);
  }

  static final _listToFill = <Locale>[];

  static void _iterate(_CLocale item) {
    _listToFill.add(item._toDart());
  }

  List<Locale> _fillFromC() {
    _forEach_CArray_CLocale(this, ffi.Pointer.fromFunction<ffi.Void Function(_CLocale)>(_iterate));
    final result = List<Locale>.from(_listToFill);
    _listToFill.clear();
    return result;
  }
}
	
// MARK: - LocaleManager

/** Менеджер региональных настроек приложения. */
class LocaleManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Локали приложения, если заданы, иначе - локали, заданные пользователем в ОС. */
  StatefulChannel<List<Locale>> get localesChannel {
    _CStatefulChannel_CArray_CLocale res = _CLocaleManager_localesChannel(_CLocaleManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Локали приложения, если заданы, иначе - локали, заданные пользователем в ОС. */
  List<Locale> get locales {
    _CArray_CLocale res = _CLocaleManager_locales(_CLocaleManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение локалей, предоставляемых ОС.
  
   Локали ОС в порядке, заданном пользователем (в порядке от более приоритетной
   к менее приоритетной).
  */
  StatefulChannel<List<Locale>> get systemLocalesChannel {
    _CStatefulChannel_CArray_CLocale res = _CLocaleManager_systemLocalesChannel(_CLocaleManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /**
   Получение локалей, предоставляемых ОС.
  
   Локали ОС в порядке, заданном пользователем (в порядке от более приоритетной
   к менее приоритетной).
  */
  List<Locale> get systemLocales {
    _CArray_CLocale res = _CLocaleManager_systemLocales(_CLocaleManagerMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  static final _finalizer = ffi.NativeFinalizer(_CLocaleManager_releasePtr);

  LocaleManager._raw(this._self);
  factory LocaleManager._create(ffi.Pointer<ffi.Void> self) {
    final classObject = LocaleManager._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LocaleManager &&
    other.runtimeType == runtimeType &&
    _CLocaleManager_cg_objectIdentifier(this._self) == _CLocaleManager_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CLocaleManager_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: LocaleManager: Methods

  /** Установка списка локалей приложения */
  void overrideLocales(
    List<Locale> locales
  )  {
    var _a1 = locales._copyFromDartTo_CArray_CLocale();
    void res = _CLocaleManager_overrideLocales_CArray_CLocale(_CLocaleManagerMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - LocaleManager <-> CLocaleManager

final class _CLocaleManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CLocaleManagerBasicFunctions on _CLocaleManager {
  void _releaseIntermediate() {
    _CLocaleManager_release(_impl);
  }

  _CLocaleManager _retain() {
    return _CLocaleManager_retain(_impl);
  }
}

extension _CLocaleManagerToDart on _CLocaleManager {
  LocaleManager _toDart() {
    return LocaleManager._create(_retain()._impl);
  }
}


extension _DartToCLocaleManager on LocaleManager {
  _CLocaleManager _copyFromDartTo_CLocaleManager() {
    return (_CLocaleManagerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<List<Locale>> <-> _CStatefulChannel_CArray_CLocale

class _CStatefulChannel_CArray_CLocaleImpl extends StatefulChannel<List<Locale>> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<List<Locale>>>{};

  final _CStatefulChannel_CArray_CLocale _channel;

  _CStatefulChannel_CArray_CLocaleImpl(this._channel);

  @override
  List<Locale> get value {
    return this._channel._getter();
  }

  static void valueFunction(_CArray_CLocale cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    cValue._releaseIntermediate();
  }

  @override
  StreamSubscription<List<Locale>> listen(void onData(List<Locale> event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CArray_CLocale, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<List<Locale>>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CArray_CLocale extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CArray_CLocaleBasicFunctions on _CStatefulChannel_CArray_CLocale {
  void _releaseIntermediate() {
    _CStatefulChannel_CArray_CLocale_release(this);
  }

  _CStatefulChannel_CArray_CLocale _retain() {
    return _CStatefulChannel_CArray_CLocale_retain(this);
  }

  List<Locale> _getter() {
    final cValue = _CStatefulChannel_CArray_CLocaleGetCurrentValue(this);
    final res = cValue._toDart();
    cValue._releaseIntermediate();
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CArray_CLocale, ffi.Int64)> callback) {
    return _CStatefulChannel_CArray_CLocaleConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CArray_CLocaleToDart on _CStatefulChannel_CArray_CLocale {
  StatefulChannel<List<Locale>> _toDart() {
    return _CStatefulChannel_CArray_CLocaleImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CArray_CLocale on StatefulChannel<List<Locale>> {
  _CStatefulChannel_CArray_CLocale _copyFromDartTo_CStatefulChannel_CArray_CLocale() {
    return _CStatefulChannel_CArray_CLocaleMakeDefault();
  }
}
	
// MARK: - _PlatformLocaleManagerCpp

/** Класс для платформенной реализации LocaleManager. */
class _PlatformLocaleManagerCpp extends PlatformLocaleManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CPlatformLocaleManagerCpp_releasePtr);

  _PlatformLocaleManagerCpp._raw(this._self);
  factory _PlatformLocaleManagerCpp._create(ffi.Pointer<ffi.Void> self) {
    final classObject = _PlatformLocaleManagerCpp._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is _PlatformLocaleManagerCpp &&
    other.runtimeType == runtimeType &&
    _CPlatformLocaleManagerCpp_cg_objectIdentifier(this._self) == _CPlatformLocaleManagerCpp_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CPlatformLocaleManagerCpp_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: _PlatformLocaleManagerCpp: Methods

  List<Locale> locales()  {
    _CArray_CLocale res = _CPlatformLocaleManagerCpp_locales(_CPlatformLocaleManagerCppMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  void setLocalesChangeNotifier(
    LocaleChangeNotifier notifier
  )  {
    var _a1 = notifier._copyFromDartTo_CLocaleChangeNotifier();
    void res = _CPlatformLocaleManagerCpp_setLocalesChangeNotifier_CLocaleChangeNotifier(_CPlatformLocaleManagerCppMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  List<Locale> systemLocales()  {
    _CArray_CLocale res = _CPlatformLocaleManagerCpp_systemLocales(_CPlatformLocaleManagerCppMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  void setSystemLocalesChangeNotifier(
    LocaleChangeNotifier notifier
  )  {
    var _a1 = notifier._copyFromDartTo_CLocaleChangeNotifier();
    void res = _CPlatformLocaleManagerCpp_setSystemLocalesChangeNotifier_CLocaleChangeNotifier(_CPlatformLocaleManagerCppMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

  void overrideLocales(
    List<Locale> locales
  )  {
    var _a1 = locales._copyFromDartTo_CArray_CLocale();
    void res = _CPlatformLocaleManagerCpp_overrideLocales_CArray_CLocale(_CPlatformLocaleManagerCppMakeDefault().._impl=_self, _a1);
    _a1._releaseIntermediate();
    return res;
  }

}

// MARK: - _PlatformLocaleManagerCpp <-> CPlatformLocaleManagerCpp

final class _CPlatformLocaleManagerCpp extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CPlatformLocaleManagerCppBasicFunctions on _CPlatformLocaleManagerCpp {
  void _releaseIntermediate() {
    _CPlatformLocaleManagerCpp_release(_impl);
  }

  _CPlatformLocaleManagerCpp _retain() {
    return _CPlatformLocaleManagerCpp_retain(_impl);
  }
}

extension _CPlatformLocaleManagerCppToDart on _CPlatformLocaleManagerCpp {
  _PlatformLocaleManagerCpp _toDart() {
    return _PlatformLocaleManagerCpp._create(_retain()._impl);
  }
}


extension _DartToCPlatformLocaleManagerCpp on _PlatformLocaleManagerCpp {
  _CPlatformLocaleManagerCpp _copyFromDartTo_CPlatformLocaleManagerCpp() {
    return (_CPlatformLocaleManagerCppMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - PlatformLocaleManager

/** Класс для платформенной реализации LocaleManager. */
@internal
abstract class PlatformLocaleManager {
  List<Locale> locales();
  void setLocalesChangeNotifier(
    LocaleChangeNotifier notifier
  );
  List<Locale> systemLocales();
  void setSystemLocalesChangeNotifier(
    LocaleChangeNotifier notifier
  );
  void overrideLocales(
    List<Locale> locales
  );
}

class _PlatformLocaleManager {
  final PlatformLocaleManager object;
  int refCounter = 1;

  _PlatformLocaleManager(this.object);
}

final class _CPlatformLocaleManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _value;
  external ffi.Pointer<ffi.Void> _cppValue;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _retain;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> _release;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CArray_CLocale)>>)>> _locales;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _CLocaleChangeNotifier)>> _setLocalesChangeNotifier_CLocaleChangeNotifier;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CArray_CLocale)>>)>> _systemLocales;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _CLocaleChangeNotifier)>> _setSystemLocalesChangeNotifier_CLocaleChangeNotifier;
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _CArray_CLocale)>> _overrideLocales_CArray_CLocale;
}

extension _CPlatformLocaleManagerBasicFunctions on _CPlatformLocaleManager {
  void _releaseIntermediate() {
    _CPlatformLocaleManager_release(this);
  }
}

int _CPlatformLocaleManagerInstanceCounter = 1;
final _CPlatformLocaleManagerInstanceMap = <int, _PlatformLocaleManager>{};

extension _CPlatformLocaleManagerToDart on _CPlatformLocaleManager {
  PlatformLocaleManager _toDart() {
    late PlatformLocaleManager? result;
    final platformValue = this._value.cast<ffi.Int64>();
    if (platformValue.address != 0) {
      result = _CPlatformLocaleManagerInstanceMap[platformValue.address]?.object;
    } else if (this._cppValue.address != 0) {
      final cppValue = _CPlatformLocaleManagerCppMakeDefault().._impl = this._cppValue;
      result = cppValue._toDart();
    }
    if (result == null) {
      throw Exception("Invalid intermediate object of type _CPlatformLocaleManager");
    }
    return result;
  }
}

extension _DartTo_CPlatformLocaleManager on PlatformLocaleManager {
  static void retainFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    _CPlatformLocaleManagerInstanceMap[platformValue.address]?.refCounter += 1;
  }

  static void releaseFunction(ffi.Pointer<ffi.Void> value) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      return;
    }
    final platformObject = _CPlatformLocaleManagerInstanceMap[platformValue.address];
    if (platformObject == null) {
      return;
    }
    platformObject.refCounter -= 1;
    if (platformObject.refCounter > 0) {
      return;
    }
    _CPlatformLocaleManagerInstanceMap.remove(platformValue.address);
  }

  _CPlatformLocaleManager _copyFromDartTo_CPlatformLocaleManager() {
    var res = _CPlatformLocaleManagerMakeDefault();
    if (this is _PlatformLocaleManagerCpp) {
      final cppValue = this as _PlatformLocaleManagerCpp;
      res._cppValue = cppValue._copyFromDartTo_CPlatformLocaleManagerCpp()._impl;
      return res;
    }
    final instanceId = _CPlatformLocaleManagerInstanceCounter;
    _CPlatformLocaleManagerInstanceCounter += 1;
    _CPlatformLocaleManagerInstanceMap[instanceId] = _PlatformLocaleManager(this);
    res._value = ffi.Pointer.fromAddress(instanceId);
    final retainFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(retainFunction);
    //final releaseFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>)>.listener(releaseFunction);
    res._retain = retainFunctionCallable.nativeFunction;
    //res._release = releaseFunctionCallable.nativeFunction;

    final localesFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CArray_CLocale)>>)>.listener(localesFunction);
    res._locales = localesFunctionCallable.nativeFunction;
    final setLocalesChangeNotifier_CLocaleChangeNotifierFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _CLocaleChangeNotifier)>.listener(setLocalesChangeNotifier_CLocaleChangeNotifierFunction);
    res._setLocalesChangeNotifier_CLocaleChangeNotifier = setLocalesChangeNotifier_CLocaleChangeNotifierFunctionCallable.nativeFunction;
    final systemLocalesFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CArray_CLocale)>>)>.listener(systemLocalesFunction);
    res._systemLocales = systemLocalesFunctionCallable.nativeFunction;
    final setSystemLocalesChangeNotifier_CLocaleChangeNotifierFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _CLocaleChangeNotifier)>.listener(setSystemLocalesChangeNotifier_CLocaleChangeNotifierFunction);
    res._setSystemLocalesChangeNotifier_CLocaleChangeNotifier = setSystemLocalesChangeNotifier_CLocaleChangeNotifierFunctionCallable.nativeFunction;
    final overrideLocales_CArray_CLocaleFunctionCallable = ffi.NativeCallable<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>, _CArray_CLocale)>.listener(overrideLocales_CArray_CLocaleFunction);
    res._overrideLocales_CArray_CLocale = overrideLocales_CArray_CLocaleFunctionCallable.nativeFunction;
    return res;
  }

  static void localesFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CArray_CLocale)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CPlatformLocaleManager");
    }
    final platformObject = _CPlatformLocaleManagerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CPlatformLocaleManager");
    }

    final res = platformObject.object.locales();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _CArray_CLocale)>();
    callbackFunction(context, res._copyFromDartTo_CArray_CLocale());
  }

  static void setLocalesChangeNotifier_CLocaleChangeNotifierFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> resultValueCallback, _CLocaleChangeNotifier notifier) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CPlatformLocaleManager");
    }
    final platformObject = _CPlatformLocaleManagerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CPlatformLocaleManager");
    }

    final notifierDart = notifier._toDart();
    platformObject.object.setLocalesChangeNotifier(notifierDart);
    notifier._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
    callbackFunction(context);
  }

  static void systemLocalesFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, _CArray_CLocale)>> resultValueCallback) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CPlatformLocaleManager");
    }
    final platformObject = _CPlatformLocaleManagerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CPlatformLocaleManager");
    }

    final res = platformObject.object.systemLocales();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>, _CArray_CLocale)>();
    callbackFunction(context, res._copyFromDartTo_CArray_CLocale());
  }

  static void setSystemLocalesChangeNotifier_CLocaleChangeNotifierFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> resultValueCallback, _CLocaleChangeNotifier notifier) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CPlatformLocaleManager");
    }
    final platformObject = _CPlatformLocaleManagerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CPlatformLocaleManager");
    }

    final notifierDart = notifier._toDart();
    platformObject.object.setSystemLocalesChangeNotifier(notifierDart);
    notifier._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
    callbackFunction(context);
  }

  static void overrideLocales_CArray_CLocaleFunction(ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> resultValueCallback, _CArray_CLocale locales) {
    final platformValue = value.cast<ffi.Int64>();
    if (platformValue.address == 0) {
      throw Exception("Invalid object of type _CPlatformLocaleManager");
    }
    final platformObject = _CPlatformLocaleManagerInstanceMap[platformValue.address];
    if (platformObject == null) {
      throw Exception("Invalid object of type _CPlatformLocaleManager");
    }

    final localesDart = locales._toDart();
    platformObject.object.overrideLocales(localesDart);
    locales._releaseIntermediate();
    final callbackFunction = resultValueCallback.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
    callbackFunction(context);
  }


}

// MARK: - getHttpCacheManager

/** Интерфейс управления HTTP-кешем. Null, если HTTP кэш не используется. */
HttpCacheManager? getHttpCacheManager(
  Context context
){
  var _a0 = context._copyFromDartTo_CContext();
  _COptional_CHttpCacheManager res = _CFunction_G_getHttpCacheManager_With_CContext(_a0);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - HttpCacheManager? <-> _COptional_CHttpCacheManager

final class _COptional_CHttpCacheManager extends ffi.Struct {
  
  external _CHttpCacheManager value;
  @ffi.Bool()
  external bool hasValue;
}

extension _COptional_CHttpCacheManagerBasicFunctions on _COptional_CHttpCacheManager {
  void _releaseIntermediate() {
    _COptional_CHttpCacheManager_release(this);
  }
}

extension _COptional_CHttpCacheManagerToDart on _COptional_CHttpCacheManager {
  HttpCacheManager? _toDart() {
    if (!this.hasValue) {
      return null;
    }
    return this.value._toDart();
  }
}

extension _DartTo_COptional_CHttpCacheManager on HttpCacheManager? {
  _COptional_CHttpCacheManager _copyFromDartTo_COptional_CHttpCacheManager() {
    final cOptional = _COptional_CHttpCacheManagerMakeDefault();
    if (this != null) {
      cOptional.value = this!._copyFromDartTo_CHttpCacheManager();
      cOptional.hasValue = true;
    } else {
      cOptional.hasValue = false;
    }
    return cOptional;
  }
}
// MARK: - getLocaleManager

/** Интерфейс управления локалями приложения. */
LocaleManager getLocaleManager(
  Context context
){
  var _a0 = context._copyFromDartTo_CContext();
  _CLocaleManager res = _CFunction_G_getLocaleManager_With_CContext(_a0);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - toLocaleManager

@internal
LocaleManager toLocaleManager(
  PlatformLocaleManager platformLocaleManager
){
  var _a0 = platformLocaleManager._copyFromDartTo_CPlatformLocaleManager();
  _CLocaleManager res = _CFunction_G_toLocaleManager_With_CPlatformLocaleManager(_a0);
  _a0._releaseIntermediate();
  final t = res._toDart();
  res._releaseIntermediate();
  return t;
}

// MARK: - Locale

extension LocaleToLocalePosix on Locale {
  String toLocalePosix()  {
    var _a0 = this._copyFromDartTo_CLocale();
    _CString res = _CFunction_G_toLocalePosix_With_CLocale(_a0);
    _a0._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}
// MARK: - LocationService

/** Класс для работы с установленным при инициализации SDK источником. */
class LocationService implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CLocationService_releasePtr);

  LocationService._raw(this._self);
  factory LocationService._create(ffi.Pointer<ffi.Void> self) {
    final classObject = LocationService._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory LocationService(
    Context context
  ) {
    var _a0 = context._copyFromDartTo_CContext();
    _CLocationService res = _CLocationService_C_createWith_CContext(_a0);
    _a0._releaseIntermediate();
    return LocationService._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is LocationService &&
    other.runtimeType == runtimeType &&
    _CLocationService_cg_objectIdentifier(this._self) == _CLocationService_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CLocationService_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: LocationService: Methods

  /**
   Канал, который оповещает об изменении геопозиции.
  
   - Note: Возвращаемая в канале геопозиция может быть недостоверной.
   - Note: Если API платформы не предоставляет аналогичный по функциональности метод,
   то в канале всегда будет null.
  */
  StatefulChannel<Location?> lastLocation()  {
    _CStatefulChannel_COptional_CLocation res = _CLocationService_lastLocation(_CLocationServiceMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Метод необходимо вызвать после получения разрешений на использование геопозиции.
  
   - Note: Этот метод актуален только для источника геопозиции по умолчанию.
  */
  void onPermissionGranted()  {
    void res = _CLocationService_onPermissionGranted(_CLocationServiceMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - LocationService <-> CLocationService

final class _CLocationService extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CLocationServiceBasicFunctions on _CLocationService {
  void _releaseIntermediate() {
    _CLocationService_release(_impl);
  }

  _CLocationService _retain() {
    return _CLocationService_retain(_impl);
  }
}

extension _CLocationServiceToDart on _CLocationService {
  LocationService _toDart() {
    return LocationService._create(_retain()._impl);
  }
}


extension _DartToCLocationService on LocationService {
  _CLocationService _copyFromDartTo_CLocationService() {
    return (_CLocationServiceMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<Location?> <-> _CStatefulChannel_COptional_CLocation

class _CStatefulChannel_COptional_CLocationImpl extends StatefulChannel<Location?> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<Location?>>{};

  final _CStatefulChannel_COptional_CLocation _channel;

  _CStatefulChannel_COptional_CLocationImpl(this._channel);

  @override
  Location? get value {
    return this._channel._getter();
  }

  static void valueFunction(_COptional_CLocation cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<Location?> listen(void onData(Location? event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_COptional_CLocation, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<Location?>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_COptional_CLocation extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_COptional_CLocationBasicFunctions on _CStatefulChannel_COptional_CLocation {
  void _releaseIntermediate() {
    _CStatefulChannel_COptional_CLocation_release(this);
  }

  _CStatefulChannel_COptional_CLocation _retain() {
    return _CStatefulChannel_COptional_CLocation_retain(this);
  }

  Location? _getter() {
    final cValue = _CStatefulChannel_COptional_CLocationGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_COptional_CLocation, ffi.Int64)> callback) {
    return _CStatefulChannel_COptional_CLocationConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_COptional_CLocationToDart on _CStatefulChannel_COptional_CLocation {
  StatefulChannel<Location?> _toDart() {
    return _CStatefulChannel_COptional_CLocationImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_COptional_CLocation on StatefulChannel<Location?> {
  _CStatefulChannel_COptional_CLocation _copyFromDartTo_CStatefulChannel_COptional_CLocation() {
    return _CStatefulChannel_COptional_CLocationMakeDefault();
  }
}
	
// MARK: - AddEventError

/** Тип ошибки добавления дорожного события. */
enum AddEventError {
  /** Сетевая ошибка. */
  networkError(0),
  /** Попытка добавить событие вне проектов 2ГИС. */
  territoryNotSupported(1),
  /**
   Неизвестна текущая позиция пользователя.
   Дорожные события разрешается добавлять только с известной позицией.
  */
  unknownUserLocation(2),
  /** Пользователь находится слишком далеко от места добавляемого события. */
  userLocationTooFarFromEvent(3),
  /** Попытка добавить анонимное событие на территории, где требуется обязательная авторизация пользователей. */
  notAuthorized(4),
  /** Пользователь отказался от сбора и отправки персональных данных. */
  noPersonalDataCollectionConsent(5),
  /** Пользователь заблокирован. */
  userBlocked(6),
  /** Пользователь слишком часто создаёт события. */
  tooManyRequests(7),
  ;

  const AddEventError(this.rawValue);
  final int rawValue;

  static AddEventError getByValue(int value) {
    return AddEventError.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CAddEventError extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CAddEventErrorBasicFunctions on _CAddEventError {
  void _releaseIntermediate() {
  }
}

extension _CAddEventErrorToDart on _CAddEventError {
  AddEventError _toDart() {
    return AddEventError.getByValue(this.rawValue);
  }
}

extension _DartTo_CAddEventError on AddEventError {
  _CAddEventError _copyFromDartTo_CAddEventError() {
    return _CAddEventErrorMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - AddEventResult

/** Результат добавления события (объект события или ошибка). */
final class AddEventResult {
  final Object? _value;
  final int _index;

  AddEventResult._raw(this._value, this._index);

  AddEventResult.event(RoadEvent value) : this._raw(value, 0);
  AddEventResult.error(AddEventError value) : this._raw(value, 1);

  bool get isEvent => this._index == 0;
  RoadEvent? get asEvent => this.isEvent ? this._value as RoadEvent : null;

  bool get isError => this._index == 1;
  AddEventError? get asError => this.isError ? this._value as AddEventError : null;

  T match<T>({
    required T Function(RoadEvent value) event,
    required T Function(AddEventError value) error,
  }) {
    return switch (this._index) {
      0 => event(this._value as RoadEvent),
      1 => error(this._value as AddEventError),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }

  @override
  String toString() => "AddEventResult(${this._value})";

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is AddEventResult &&
    other.runtimeType == runtimeType &&
    other._value == this._value && other._index == this._index;

  @override
  int get hashCode => Object.hash(this._index, this._value);
}

final class _CAddEventResultImpl extends ffi.Union {
  external _CRoadEvent _event;
  external _CAddEventError _error;
}

final class _CAddEventResult extends ffi.Struct {
  external _CAddEventResultImpl _impl;
  @ffi.Uint8()
  external int _index;
}

extension _CAddEventResultBasicFunctions on _CAddEventResult {
  void _releaseIntermediate() {
    _CAddEventResult_release(this);
  }
}
	
// MARK: - AddEventResult <-> CAddEventResult

extension _CAddEventResultToDart on _CAddEventResult {
  AddEventResult _toDart() {
    return switch (this._index) {
      0 => AddEventResult.event(this._impl._event._toDart()),
      1 => AddEventResult.error(this._impl._error._toDart()),
      _ => throw NativeException("Unrecognized case index ${this._index}")
    };
  }
}

extension _DartTo_CAddEventResult on AddEventResult {
  _CAddEventResult _copyFromDartTo_CAddEventResult() {
    var res = _CAddEventResultMakeDefault();
    this.match<void>(
      event: (RoadEvent value) {
        res._impl._event = value._copyFromDartTo_CRoadEvent();
        res._index = 0;
      },
      error: (AddEventError value) {
        res._impl._error = value._copyFromDartTo_CAddEventError();
        res._index = 1;
      },
    );
    return res;
  }
}

// MARK: - RoadEventManager

/** Объект для создания транспортных событий. */
class RoadEventManager implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  static final _finalizer = ffi.NativeFinalizer(_CRoadEventManager_releasePtr);

  RoadEventManager._raw(this._self);
  factory RoadEventManager._create(ffi.Pointer<ffi.Void> self) {
    final classObject = RoadEventManager._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /** Получение объекта для создания дорожных событий. */
  factory RoadEventManager(
    Context context
  ) {
    var _a0 = context._copyFromDartTo_CContext();
    _CRoadEventManager res = _CRoadEventManager_C_createWith_CContext(_a0);
    _a0._releaseIntermediate();
    return RoadEventManager._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is RoadEventManager &&
    other.runtimeType == runtimeType &&
    _CRoadEventManager_cg_objectIdentifier(this._self) == _CRoadEventManager_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CRoadEventManager_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: RoadEventManager: Methods

  /**
   Создание события "ДТП".
  
   - Parameter location: Местоположение события.
   - Parameter lanes: Полосы дороги, затрагиваемые событием.
   - Parameter description: Пользовательское описание события.
  */
  CancelableOperation<AddEventResult> createAccident(
    GeoPoint location,
    LaneEnumSet lanes,
    String description
  )  {
    var _a1 = location._copyFromDartTo_CGeoPoint();
    var _a2 = lanes._copyFromDartTo_COptionSet_CLane();
    var _a3 = description._copyFromDartTo_CString();
    _CFuture_CAddEventResult res = _CRoadEventManager_createAccident_CGeoPoint_COptionSet_CLane_CString(_CRoadEventManagerMakeDefault().._impl=_self, _a1, _a2, _a3);
    _a3._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Создание события "Камера".
  
   - Parameter location: Местоположение события.
   - Parameter description: Пользовательское описание события.
  */
  CancelableOperation<AddEventResult> createCamera(
    GeoPoint location,
    String description
  )  {
    var _a1 = location._copyFromDartTo_CGeoPoint();
    var _a2 = description._copyFromDartTo_CString();
    _CFuture_CAddEventResult res = _CRoadEventManager_createCamera_CGeoPoint_CString(_CRoadEventManagerMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Создание события "Перекрытие дорожного движения".
  
   - Parameter location: Местоположение события.
   - Parameter description: Пользовательское описание события.
  */
  CancelableOperation<AddEventResult> createRoadRestriction(
    GeoPoint location,
    String description
  )  {
    var _a1 = location._copyFromDartTo_CGeoPoint();
    var _a2 = description._copyFromDartTo_CString();
    _CFuture_CAddEventResult res = _CRoadEventManager_createRoadRestriction_CGeoPoint_CString(_CRoadEventManagerMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Создание события "Комментарий".
  
   - Parameter location: Местоположение события.
   - Parameter description: Пользовательское описание события.
  */
  CancelableOperation<AddEventResult> createComment(
    GeoPoint location,
    String description
  )  {
    var _a1 = location._copyFromDartTo_CGeoPoint();
    var _a2 = description._copyFromDartTo_CString();
    _CFuture_CAddEventResult res = _CRoadEventManager_createComment_CGeoPoint_CString(_CRoadEventManagerMakeDefault().._impl=_self, _a1, _a2);
    _a2._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Создание события "Другое".
  
   - Parameter location: Местоположение события.
   - Parameter lanes: Полосы дороги, затрагиваемые событием.
   - Parameter description: Пользовательское описание события.
  */
  CancelableOperation<AddEventResult> createOther(
    GeoPoint location,
    LaneEnumSet lanes,
    String description
  )  {
    var _a1 = location._copyFromDartTo_CGeoPoint();
    var _a2 = lanes._copyFromDartTo_COptionSet_CLane();
    var _a3 = description._copyFromDartTo_CString();
    _CFuture_CAddEventResult res = _CRoadEventManager_createOther_CGeoPoint_COptionSet_CLane_CString(_CRoadEventManagerMakeDefault().._impl=_self, _a1, _a2, _a3);
    _a3._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

  /**
   Создание события "Дорожные работы".
  
   - Parameter location: Местоположение события.
   - Parameter lanes: Полосы дороги, затрагиваемые событием.
   - Parameter description: Пользовательское описание события.
  */
  CancelableOperation<AddEventResult> createRoadWorks(
    GeoPoint location,
    LaneEnumSet lanes,
    String description
  )  {
    var _a1 = location._copyFromDartTo_CGeoPoint();
    var _a2 = lanes._copyFromDartTo_COptionSet_CLane();
    var _a3 = description._copyFromDartTo_CString();
    _CFuture_CAddEventResult res = _CRoadEventManager_createRoadWorks_CGeoPoint_COptionSet_CLane_CString(_CRoadEventManagerMakeDefault().._impl=_self, _a1, _a2, _a3);
    _a3._releaseIntermediate();
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }

}

// MARK: - RoadEventManager <-> CRoadEventManager

final class _CRoadEventManager extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CRoadEventManagerBasicFunctions on _CRoadEventManager {
  void _releaseIntermediate() {
    _CRoadEventManager_release(_impl);
  }

  _CRoadEventManager _retain() {
    return _CRoadEventManager_retain(_impl);
  }
}

extension _CRoadEventManagerToDart on _CRoadEventManager {
  RoadEventManager _toDart() {
    return RoadEventManager._create(_retain()._impl);
  }
}


extension _DartToCRoadEventManager on RoadEventManager {
  _CRoadEventManager _copyFromDartTo_CRoadEventManager() {
    return (_CRoadEventManagerMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - CancelableOperation<AddEventResult> <-> _CFuture_CAddEventResult

final class _CFuture_CAddEventResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

class _CFuture_CAddEventResult_Cancellable {
  final Completer<AddEventResult> completer;
  final _CFuture_CAddEventResult _futureInstance;
  final _CCancellable _cancellable;
  final ffi.NativeCallable<ffi.Void Function(_CAddEventResult, ffi.Int64)> valueFunctionCallable;
  final ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)> failureCallable;

  _CFuture_CAddEventResult_Cancellable(
    this.completer,
    this._futureInstance,
    this._cancellable,
    this.valueFunctionCallable,
    this.failureCallable
  );

  void cancel() {
    this._cancellable._cancel();
    this._futureInstance._releaseIntermediate();
    this.valueFunctionCallable.close();
    this.failureCallable.close();
  }
}

extension _CFuture_CAddEventResultBasicFunctions on _CFuture_CAddEventResult {
  void _releaseIntermediate() {
    _CFuture_CAddEventResult_release(this);
  }

  _CFuture_CAddEventResult _retain() {
    return _CFuture_CAddEventResult_retain(this);
  }
}

extension _CFuture_CAddEventResultToDart on _CFuture_CAddEventResult {
  static int instanceCounter = 0;
  static final instanceMap = <int, _CFuture_CAddEventResult_Cancellable>{};

  static void valueFunction(_CAddEventResult cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.complete(cValue._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cValue._releaseIntermediate();
  }

  static void failure(_CError cError, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.completer.completeError(cError._toDart());
      instance.cancel();
      instanceMap.remove(instanceId);
    }
    cError._releaseIntermediate();
  }

  CancelableOperation<AddEventResult> _toDart() {
    final futureInstance = this._retain();
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final completer = new Completer<AddEventResult>();
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CAddEventResult, ffi.Int64)>.listener(valueFunction);
    final failureCallable = ffi.NativeCallable<ffi.Void Function(_CError, ffi.Int64)>.listener(failure);
    final cCancel = _CFuture_CAddEventResultReceive(
      futureInstance,
      instanceId,
      valueFunctionCallable.nativeFunction,
      failureCallable.nativeFunction
    );
    final cancellable = cCancel._retain();
    instanceMap[instanceId] = _CFuture_CAddEventResult_Cancellable(
      completer,
      futureInstance,
      cancellable,
      valueFunctionCallable,
      failureCallable
    );
    cCancel._releaseIntermediate();
    return CancelableOperation.fromFuture(
      completer.future,
      onCancel: () {
        instanceMap[instanceId]?.cancel();
        instanceMap.remove(instanceId);
      },
    );
  }
}

extension _DartTo_CFuture_CAddEventResult on CancelableOperation<AddEventResult> {
  _CFuture_CAddEventResult _copyFromDartTo_CFuture_CAddEventResult() {
    return _CFuture_CAddEventResultMakeDefault();
  }
}
	
// MARK: - TrafficScoreState

/** Актуальность балла пробок. */
enum TrafficScoreState {
  /** Значение неизвестно, будет запрошено позднее. Начальное состояние. */
  pending(0),
  /** Значение актуально. */
  valid(1),
  /**
   Значение устарело. Состояние достигается, если данные не удалось
   обновить в течение определённого времени.
  */
  expired(2),
  ;

  const TrafficScoreState(this.rawValue);
  final int rawValue;

  static TrafficScoreState getByValue(int value) {
    return TrafficScoreState.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CTrafficScoreState extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CTrafficScoreStateBasicFunctions on _CTrafficScoreState {
  void _releaseIntermediate() {
  }
}

extension _CTrafficScoreStateToDart on _CTrafficScoreState {
  TrafficScoreState _toDart() {
    return TrafficScoreState.getByValue(this.rawValue);
  }
}

extension _DartTo_CTrafficScoreState on TrafficScoreState {
  _CTrafficScoreState _copyFromDartTo_CTrafficScoreState() {
    return _CTrafficScoreStateMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - TrafficScore

/** Оценка пробок. */
class TrafficScore {
  /** Актуальность значения. */
  final TrafficScoreState state;
  /**
   Значение в баллах. Как правило, значения находятся в диапазоне от 1 до 10.
   Пустое значение, если информация ещё не получена, либо уже устарела,
   либо недоступна для заданного местоположения.
  */
  final int? value;

  const TrafficScore({
    this.state = TrafficScoreState.pending,
    required this.value
  });

  TrafficScore copyWith({
    TrafficScoreState? state,
    Optional<int?>? value
  }) {
    return TrafficScore(
      state: state ?? this.state,
      value: value != null ? value.value : this.value
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TrafficScore &&
    other.runtimeType == runtimeType &&
    other.state == state &&
    other.value == value;

  @override
  int get hashCode {
    return Object.hash(state, value);
  }

}
final class _CTrafficScore extends ffi.Struct {
  external _CTrafficScoreState state;

  external _COptional_uint32_t value;

}
// MARK: - TrafficScore <-> _CTrafficScore

extension _CTrafficScoreToDart on _CTrafficScore {
  TrafficScore _toDart() {
    return TrafficScore(
      state: this.state._toDart(),
      value: this.value._toDart()
    );
  }
}

extension _DartTo_CTrafficScore on TrafficScore {
  _CTrafficScore _copyFromDartTo_CTrafficScore() {
    final res = _CTrafficScoreMakeDefault();
    res.state = this.state._copyFromDartTo_CTrafficScoreState();
    res.value = this.value._copyFromDartTo_COptional_uint32_t();
    return res;
  }
}
extension _CTrafficScoreRelease on _CTrafficScore {
  void _releaseIntermediate() {
  }
}

// MARK: - TrafficScoreProvider

/**
 Подписка на обновления информации о величине пробок.

 - Note: Этот интерфейс является потокобезопасным.
*/
class TrafficScoreProvider implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Текущее состояние пробок и их балл. */
  StatefulChannel<TrafficScore> get scoreChannel {
    _CStatefulChannel_CTrafficScore res = _CTrafficScoreProvider_scoreChannel(_CTrafficScoreProviderMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Текущее состояние пробок и их балл. */
  TrafficScore get score {
    _CTrafficScore res = _CTrafficScoreProvider_score(_CTrafficScoreProviderMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CTrafficScoreProvider_releasePtr);

  TrafficScoreProvider._raw(this._self);
  factory TrafficScoreProvider._create(ffi.Pointer<ffi.Void> self) {
    final classObject = TrafficScoreProvider._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  factory TrafficScoreProvider(
    Map map
  ) {
    var _a0 = map._copyFromDartTo_CMap();
    _CTrafficScoreProvider res = _CTrafficScoreProvider_C_createWith_CMap(_a0);
    _a0._releaseIntermediate();
    return TrafficScoreProvider._create(res._impl);
  }

  factory TrafficScoreProvider.fromGeoPoint(
    Context context,
    GeoPoint point
  ) {
    var _a0 = context._copyFromDartTo_CContext();
    var _a1 = point._copyFromDartTo_CGeoPoint();
    _CTrafficScoreProvider res = _CTrafficScoreProvider_C_createWith_CContext_CGeoPoint(_a0, _a1);
    _a0._releaseIntermediate();
    return TrafficScoreProvider._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TrafficScoreProvider &&
    other.runtimeType == runtimeType &&
    _CTrafficScoreProvider_cg_objectIdentifier(this._self) == _CTrafficScoreProvider_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CTrafficScoreProvider_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

}

// MARK: - TrafficScoreProvider <-> CTrafficScoreProvider

final class _CTrafficScoreProvider extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CTrafficScoreProviderBasicFunctions on _CTrafficScoreProvider {
  void _releaseIntermediate() {
    _CTrafficScoreProvider_release(_impl);
  }

  _CTrafficScoreProvider _retain() {
    return _CTrafficScoreProvider_retain(_impl);
  }
}

extension _CTrafficScoreProviderToDart on _CTrafficScoreProvider {
  TrafficScoreProvider _toDart() {
    return TrafficScoreProvider._create(_retain()._impl);
  }
}


extension _DartToCTrafficScoreProvider on TrafficScoreProvider {
  _CTrafficScoreProvider _copyFromDartTo_CTrafficScoreProvider() {
    return (_CTrafficScoreProviderMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<TrafficScore> <-> _CStatefulChannel_CTrafficScore

class _CStatefulChannel_CTrafficScoreImpl extends StatefulChannel<TrafficScore> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<TrafficScore>>{};

  final _CStatefulChannel_CTrafficScore _channel;

  _CStatefulChannel_CTrafficScoreImpl(this._channel);

  @override
  TrafficScore get value {
    return this._channel._getter();
  }

  static void valueFunction(_CTrafficScore cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<TrafficScore> listen(void onData(TrafficScore event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CTrafficScore, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<TrafficScore>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CTrafficScore extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CTrafficScoreBasicFunctions on _CStatefulChannel_CTrafficScore {
  void _releaseIntermediate() {
    _CStatefulChannel_CTrafficScore_release(this);
  }

  _CStatefulChannel_CTrafficScore _retain() {
    return _CStatefulChannel_CTrafficScore_retain(this);
  }

  TrafficScore _getter() {
    final cValue = _CStatefulChannel_CTrafficScoreGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CTrafficScore, ffi.Int64)> callback) {
    return _CStatefulChannel_CTrafficScoreConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CTrafficScoreToDart on _CStatefulChannel_CTrafficScore {
  StatefulChannel<TrafficScore> _toDart() {
    return _CStatefulChannel_CTrafficScoreImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CTrafficScore on StatefulChannel<TrafficScore> {
  _CStatefulChannel_CTrafficScore _copyFromDartTo_CStatefulChannel_CTrafficScore() {
    return _CStatefulChannel_CTrafficScoreMakeDefault();
  }
}
	
// MARK: - TrafficControlStatus

/** Статус элемента управления видимостью пробок. */
enum TrafficControlStatus {
  /**
   Контрол скрыт.
   Возникает, когда в регионе отсутствует информация о пробках.
  */
  hidden(0),
  /**
   Контрол в активном состоянии.
   Возникает, когда данные о пробках в актуальном состоянии,
   и на карте присутствует слой пробок.
  */
  enabled(1),
  /**
   Контрол в неактивном состоянии.
   Возникает, когда на карте отсутствует слой пробок.
  */
  disabled(2),
  /**
   Индикатор загрузки.
   Возникает, когда данные о пробках в неактуальном состоянии,
   и на карте присутствует слой пробок.
  */
  loading(3),
  ;

  const TrafficControlStatus(this.rawValue);
  final int rawValue;

  static TrafficControlStatus getByValue(int value) {
    return TrafficControlStatus.values.firstWhere((x) => x.rawValue == value);
  }
}


final class _CTrafficControlStatus extends ffi.Struct {
  @ffi.Uint32()
  external int rawValue;
}

extension _CTrafficControlStatusBasicFunctions on _CTrafficControlStatus {
  void _releaseIntermediate() {
  }
}

extension _CTrafficControlStatusToDart on _CTrafficControlStatus {
  TrafficControlStatus _toDart() {
    return TrafficControlStatus.getByValue(this.rawValue);
  }
}

extension _DartTo_CTrafficControlStatus on TrafficControlStatus {
  _CTrafficControlStatus _copyFromDartTo_CTrafficControlStatus() {
    return _CTrafficControlStatusMakeDefault()..rawValue = this.rawValue;
  }
}
	
// MARK: - TrafficControlState

/** Состояние элемента управления видимостью пробок. */
class TrafficControlState {
  /** Статус, в зависимости от которого меняется внешний вид элемента управления. */
  final TrafficControlStatus status;
  /**
   Балл пробок.
   Отображается в виде надписи на контроле.
   Если отсутствует, отображается иконка-заглушка.
  */
  final int? score;

  const TrafficControlState({
    this.status = TrafficControlStatus.hidden,
    required this.score
  });

  TrafficControlState copyWith({
    TrafficControlStatus? status,
    Optional<int?>? score
  }) {
    return TrafficControlState(
      status: status ?? this.status,
      score: score != null ? score.value : this.score
    );
  }
  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TrafficControlState &&
    other.runtimeType == runtimeType &&
    other.status == status &&
    other.score == score;

  @override
  int get hashCode {
    return Object.hash(status, score);
  }

}
final class _CTrafficControlState extends ffi.Struct {
  external _CTrafficControlStatus status;

  external _COptional_uint32_t score;

}
// MARK: - TrafficControlState <-> _CTrafficControlState

extension _CTrafficControlStateToDart on _CTrafficControlState {
  TrafficControlState _toDart() {
    return TrafficControlState(
      status: this.status._toDart(),
      score: this.score._toDart()
    );
  }
}

extension _DartTo_CTrafficControlState on TrafficControlState {
  _CTrafficControlState _copyFromDartTo_CTrafficControlState() {
    final res = _CTrafficControlStateMakeDefault();
    res.status = this.status._copyFromDartTo_CTrafficControlStatus();
    res.score = this.score._copyFromDartTo_COptional_uint32_t();
    return res;
  }
}
extension _CTrafficControlStateRelease on _CTrafficControlState {
  void _releaseIntermediate() {
  }
}

// MARK: - TrafficControlModel

/**
 Модель контрола пробок.

 - Note: Этот интерфейс является потокобезопасным.
*/
class TrafficControlModel implements ffi.Finalizable {
  final ffi.Pointer<ffi.Void> _self;

  /** Состояние элемента управления видимостью пробок. */
  StatefulChannel<TrafficControlState> get stateChannel {
    _CStatefulChannel_CTrafficControlState res = _CTrafficControlModel_stateChannel(_CTrafficControlModelMakeDefault().._impl=_self);
    final t = res._toDart();
    res._releaseIntermediate();
    return t;
  }
  /** Состояние элемента управления видимостью пробок. */
  TrafficControlState get state {
    _CTrafficControlState res = _CTrafficControlModel_state(_CTrafficControlModelMakeDefault().._impl=_self);
    return res._toDart();
  }

  static final _finalizer = ffi.NativeFinalizer(_CTrafficControlModel_releasePtr);

  TrafficControlModel._raw(this._self);
  factory TrafficControlModel._create(ffi.Pointer<ffi.Void> self) {
    final classObject = TrafficControlModel._raw(self);
    _finalizer.attach(classObject, self, detach: classObject, externalSize: 10000);
    return classObject;
  }

  /**
   Функция создания модели элемента управления пробками.
  
   - Parameter map: карта.
   - Returns: Модель элемента управления видимостью пробок для карты.
  */
  factory TrafficControlModel(
    Map map
  ) {
    var _a0 = map._copyFromDartTo_CMap();
    _CTrafficControlModel res = _CTrafficControlModel_C_createWith_CMap(_a0);
    _a0._releaseIntermediate();
    return TrafficControlModel._create(res._impl);
  }

  @override
  bool operator ==(Object other) =>
    identical(this, other) || other is TrafficControlModel &&
    other.runtimeType == runtimeType &&
    _CTrafficControlModel_cg_objectIdentifier(this._self) == _CTrafficControlModel_cg_objectIdentifier(other._self);

  @override
  int get hashCode {
    final identifier = _CTrafficControlModel_cg_objectIdentifier(this._self);
    return identifier.hashCode;
  }

  // MARK: TrafficControlModel: Methods

  /**
   Действие при нажатии на контрол.
   Переключает видимость пробок на карте.
  */
  void onClicked()  {
    void res = _CTrafficControlModel_onClicked(_CTrafficControlModelMakeDefault().._impl=_self);
    return res;
  }

}

// MARK: - TrafficControlModel <-> CTrafficControlModel

final class _CTrafficControlModel extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CTrafficControlModelBasicFunctions on _CTrafficControlModel {
  void _releaseIntermediate() {
    _CTrafficControlModel_release(_impl);
  }

  _CTrafficControlModel _retain() {
    return _CTrafficControlModel_retain(_impl);
  }
}

extension _CTrafficControlModelToDart on _CTrafficControlModel {
  TrafficControlModel _toDart() {
    return TrafficControlModel._create(_retain()._impl);
  }
}


extension _DartToCTrafficControlModel on TrafficControlModel {
  _CTrafficControlModel _copyFromDartTo_CTrafficControlModel() {
    return (_CTrafficControlModelMakeDefault().._impl=_self)._retain();
  }
}
// MARK: - StatefulChannel<TrafficControlState> <-> _CStatefulChannel_CTrafficControlState

class _CStatefulChannel_CTrafficControlStateImpl extends StatefulChannel<TrafficControlState> {
  static int instanceCounter = 0;
  static final instanceMap = <int, StreamController<TrafficControlState>>{};

  final _CStatefulChannel_CTrafficControlState _channel;

  _CStatefulChannel_CTrafficControlStateImpl(this._channel);

  @override
  TrafficControlState get value {
    return this._channel._getter();
  }

  static void valueFunction(_CTrafficControlState cValue, int instanceId) {
    final instance = instanceMap[instanceId];
    if (instance != null) {
      instance.add(cValue._toDart());
    }
    
  }

  @override
  StreamSubscription<TrafficControlState> listen(void onData(TrafficControlState event)?,
      {Function? onError, void onDone()?, bool? cancelOnError}) {
    final instanceId = instanceCounter;
    instanceCounter += 1;
    final valueFunctionCallable = ffi.NativeCallable<ffi.Void Function(_CTrafficControlState, ffi.Int64)>.listener(valueFunction);
    final cCancel = this._channel._connect(instanceId, valueFunctionCallable);
    final cancellable = cCancel._retain();
    cCancel._releaseIntermediate();
    final streamController = new StreamController<TrafficControlState>(
      onCancel: () {
        cancellable._cancel();
        instanceMap.remove(instanceId);
      },
    );
    instanceMap[instanceId] = streamController;
    return streamController.stream.listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError
    );
  }
}

final class _CStatefulChannel_CTrafficControlState extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _impl;
}

extension _CStatefulChannel_CTrafficControlStateBasicFunctions on _CStatefulChannel_CTrafficControlState {
  void _releaseIntermediate() {
    _CStatefulChannel_CTrafficControlState_release(this);
  }

  _CStatefulChannel_CTrafficControlState _retain() {
    return _CStatefulChannel_CTrafficControlState_retain(this);
  }

  TrafficControlState _getter() {
    final cValue = _CStatefulChannel_CTrafficControlStateGetCurrentValue(this);
    final res = cValue._toDart();
    
    return res;
  }

  _CCancellable _connect(int instanceId,
      ffi.NativeCallable<ffi.Void Function(_CTrafficControlState, ffi.Int64)> callback) {
    return _CStatefulChannel_CTrafficControlStateConnect(this, instanceId, callback.nativeFunction);
  }
}

extension _CStatefulChannel_CTrafficControlStateToDart on _CStatefulChannel_CTrafficControlState {
  StatefulChannel<TrafficControlState> _toDart() {
    return _CStatefulChannel_CTrafficControlStateImpl(this._retain());
  }
}

extension _DartTo_CStatefulChannel_CTrafficControlState on StatefulChannel<TrafficControlState> {
  _CStatefulChannel_CTrafficControlState _copyFromDartTo_CStatefulChannel_CTrafficControlState() {
    return _CStatefulChannel_CTrafficControlStateMakeDefault();
  }
}
	
// MARK: Private functions and pointers


late final _CBuildingIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBuildingId Function()>>('CBuildingIdMakeDefault');
late final _CBuildingIdMakeDefault = _CBuildingIdMakeDefaultPtr.asFunction<_CBuildingId Function()>();


late final _CDayTimeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDayTime Function()>>('CDayTimeMakeDefault');
late final _CDayTimeMakeDefault = _CDayTimeMakeDefaultPtr.asFunction<_CDayTime Function()>();


late final _CDgisObjectIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDgisObjectId Function()>>('CDgisObjectIdMakeDefault');
late final _CDgisObjectIdMakeDefault = _CDgisObjectIdMakeDefaultPtr.asFunction<_CDgisObjectId Function()>();


late final _CContext_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CContext_cg_objectIdentifier');
late final _CContext_cg_objectIdentifier = _CContext_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CContext_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CContext_release');
late final _CContext_release = _CContext_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CContext_retainPtr = _lookup<ffi.NativeFunction<_CContext Function(ffi.Pointer<ffi.Void>)>>('CContext_retain');
late final _CContext_retain = _CContext_retainPtr.asFunction<_CContext Function(ffi.Pointer<ffi.Void>)>();
late final _CContextMakeDefaultPtr = _lookup<ffi.NativeFunction<_CContext Function()>>('CContextMakeDefault');
late final _CContextMakeDefault = _CContextMakeDefaultPtr.asFunction<_CContext Function()>();


late final _CSystemMemoryManager_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSystemMemoryManager_cg_objectIdentifier');
late final _CSystemMemoryManager_cg_objectIdentifier = _CSystemMemoryManager_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSystemMemoryManager_reduceMemoryUsagePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSystemMemoryManager)>>('CSystemMemoryManager_reduceMemoryUsage');
late final _CSystemMemoryManager_reduceMemoryUsage = _CSystemMemoryManager_reduceMemoryUsagePtr.asFunction<void Function(_CSystemMemoryManager)>();

late final _CSystemMemoryManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSystemMemoryManager_release');
late final _CSystemMemoryManager_release = _CSystemMemoryManager_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSystemMemoryManager_retainPtr = _lookup<ffi.NativeFunction<_CSystemMemoryManager Function(ffi.Pointer<ffi.Void>)>>('CSystemMemoryManager_retain');
late final _CSystemMemoryManager_retain = _CSystemMemoryManager_retainPtr.asFunction<_CSystemMemoryManager Function(ffi.Pointer<ffi.Void>)>();
late final _CSystemMemoryManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSystemMemoryManager Function()>>('CSystemMemoryManagerMakeDefault');
late final _CSystemMemoryManagerMakeDefault = _CSystemMemoryManagerMakeDefaultPtr.asFunction<_CSystemMemoryManager Function()>();


late final _CLevelIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLevelId Function()>>('CLevelIdMakeDefault');
late final _CLevelIdMakeDefault = _CLevelIdMakeDefaultPtr.asFunction<_CLevelId Function()>();


late final _CStringCreateWithDataPtr = _lookup<ffi.NativeFunction<_CString Function(ffi.Size size, ffi.Pointer<ffi_package.Utf8>)>>('CString_createWithData');
late final _CStringCreateWithDataPrivate = _CStringCreateWithDataPtr.asFunction<_CString Function(int, ffi.Pointer<ffi_package.Utf8>)>();
late final _GetSizeWith_CStringPtr = _lookup<ffi.NativeFunction<ffi.Size Function(_CString)>>('CString_getSize');
late final _GetSizeWith_CString = _GetSizeWith_CStringPtr.asFunction<int Function(_CString)>();
late final _GetDataWith_CStringPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi_package.Utf8> Function(_CString)>>('CString_getData');
late final _GetDataWith_CString = _GetDataWith_CStringPtr.asFunction<ffi.Pointer<ffi_package.Utf8> Function(_CString)>();
late final _CString_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CString)>>('CString_release');
late final _CString_release = _CString_releasePtr.asFunction<void Function(_CString)>();

late final _CLevelInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLevelInfo Function()>>('CLevelInfoMakeDefault');
late final _CLevelInfoMakeDefault = _CLevelInfoMakeDefaultPtr.asFunction<_CLevelInfo Function()>();


late final _CMeterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMeter Function()>>('CMeterMakeDefault');
late final _CMeterMakeDefault = _CMeterMakeDefaultPtr.asFunction<_CMeter Function()>();


late final _CPersonalDataCollectionConsentMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPersonalDataCollectionConsent Function()>>('CPersonalDataCollectionConsentMakeDefault');
late final _CPersonalDataCollectionConsentMakeDefault = _CPersonalDataCollectionConsentMakeDefaultPtr.asFunction<_CPersonalDataCollectionConsent Function()>();

late final _CScreenSizeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScreenSize Function()>>('CScreenSizeMakeDefault');
late final _CScreenSizeMakeDefault = _CScreenSizeMakeDefaultPtr.asFunction<_CScreenSize Function()>();


late final _CWeekDayMakeDefaultPtr = _lookup<ffi.NativeFunction<_CWeekDay Function()>>('CWeekDayMakeDefault');
late final _CWeekDayMakeDefault = _CWeekDayMakeDefaultPtr.asFunction<_CWeekDay Function()>();

late final _CWeekTimeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CWeekTime Function()>>('CWeekTimeMakeDefault');
late final _CWeekTimeMakeDefault = _CWeekTimeMakeDefaultPtr.asFunction<_CWeekTime Function()>();


late final _CWeekTimeIntervalMakeDefaultPtr = _lookup<ffi.NativeFunction<_CWeekTimeInterval Function()>>('CWeekTimeIntervalMakeDefault');
late final _CWeekTimeIntervalMakeDefault = _CWeekTimeIntervalMakeDefaultPtr.asFunction<_CWeekTimeInterval Function()>();

late final _CFunction_G_getSystemMemoryManager_With_CContextPtr = _lookup<ffi.NativeFunction<_CSystemMemoryManager Function(_CContext)>>('CFunction_G_getSystemMemoryManager_With_CContext');
late final _CFunction_G_getSystemMemoryManager_With_CContext = _CFunction_G_getSystemMemoryManager_With_CContextPtr.asFunction<_CSystemMemoryManager Function(_CContext)>();
late final _CFunction_G_makeSystemContext_With_CKeySource_CHttpOptions_CLogOptions_CPersonalDataCollectionConsent_CVendorConfig_COptional_CLocationProvider_COptional_CHeadingProviderPtr = _lookup<ffi.NativeFunction<_CContext Function(_CKeySource, _CHttpOptions, _CLogOptions, _CPersonalDataCollectionConsent, _CVendorConfig, _COptional_CLocationProvider, _COptional_CHeadingProvider)>>('CFunction_G_makeSystemContext_With_CKeySource_CHttpOptions_CLogOptions_CPersonalDataCollectionConsent_CVendorConfig_COptional_CLocationProvider_COptional_CHeadingProvider');
late final _CFunction_G_makeSystemContext_With_CKeySource_CHttpOptions_CLogOptions_CPersonalDataCollectionConsent_CVendorConfig_COptional_CLocationProvider_COptional_CHeadingProvider = _CFunction_G_makeSystemContext_With_CKeySource_CHttpOptions_CLogOptions_CPersonalDataCollectionConsent_CVendorConfig_COptional_CLocationProvider_COptional_CHeadingProviderPtr.asFunction<_CContext Function(_CKeySource, _CHttpOptions, _CLogOptions, _CPersonalDataCollectionConsent, _CVendorConfig, _COptional_CLocationProvider, _COptional_CHeadingProvider)>();

late final _CKeyFromAssetMakeDefaultPtr = _lookup<ffi.NativeFunction<_CKeyFromAsset Function()>>('CKeyFromAssetMakeDefault');
late final _CKeyFromAssetMakeDefault = _CKeyFromAssetMakeDefaultPtr.asFunction<_CKeyFromAsset Function()>();


late final _CKeyFromFileMakeDefaultPtr = _lookup<ffi.NativeFunction<_CKeyFromFile Function()>>('CKeyFromFileMakeDefault');
late final _CKeyFromFileMakeDefault = _CKeyFromFileMakeDefaultPtr.asFunction<_CKeyFromFile Function()>();


late final _CKeyFromStringMakeDefaultPtr = _lookup<ffi.NativeFunction<_CKeyFromString Function()>>('CKeyFromStringMakeDefault');
late final _CKeyFromStringMakeDefault = _CKeyFromStringMakeDefaultPtr.asFunction<_CKeyFromString Function()>();


late final _CKeySource_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CKeySource)>>('CKeySource_release');
late final _CKeySource_release = _CKeySource_releasePtr.asFunction<void Function(_CKeySource)>();
late final _CKeySourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CKeySource Function()>>('CKeySourceMakeDefault');
late final _CKeySourceMakeDefault = _CKeySourceMakeDefaultPtr.asFunction<_CKeySource Function()>();

late final _CTimeIntervalMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTimeInterval Function()>>('CTimeIntervalMakeDefault');
late final _CTimeIntervalMakeDefault = _CTimeIntervalMakeDefaultPtr.asFunction<_CTimeInterval Function()>();

late final _COptional_CStringMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CString Function()>>('COptional_CStringMakeDefault');
late final _COptional_CStringMakeDefault = _COptional_CStringMakeDefaultPtr.asFunction<_COptional_CString Function()>();

late final _COptional_CString_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CString)>>('COptional_CString_release');
late final _COptional_CString_release = _COptional_CString_releasePtr.asFunction<void Function(_COptional_CString)>();

late final _COptional_uint64_tMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_uint64_t Function()>>('COptional_uint64_tMakeDefault');
late final _COptional_uint64_tMakeDefault = _COptional_uint64_tMakeDefaultPtr.asFunction<_COptional_uint64_t Function()>();

late final _CHttpOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CHttpOptions Function()>>('CHttpOptionsMakeDefault');
late final _CHttpOptionsMakeDefault = _CHttpOptionsMakeDefaultPtr.asFunction<_CHttpOptions Function()>();


late final _CLogLevelMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLogLevel Function()>>('CLogLevelMakeDefault');
late final _CLogLevelMakeDefault = _CLogLevelMakeDefaultPtr.asFunction<_CLogLevel Function()>();

late final _CLogSinkMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLogSink Function()>>('CLogSinkMakeDefault');
late final _CLogSinkMakeDefault = _CLogSinkMakeDefaultPtr.asFunction<_CLogSink Function()>();
late final _CLogSink_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CLogSink)>>('CLogSink_release');
late final _CLogSink_release = _CLogSink_releasePtr.asFunction<void Function(_CLogSink)>();

late final _COptional_CLogSinkMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CLogSink Function()>>('COptional_CLogSinkMakeDefault');
late final _COptional_CLogSinkMakeDefault = _COptional_CLogSinkMakeDefaultPtr.asFunction<_COptional_CLogSink Function()>();

late final _COptional_CLogSink_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CLogSink)>>('COptional_CLogSink_release');
late final _COptional_CLogSink_release = _COptional_CLogSink_releasePtr.asFunction<void Function(_COptional_CLogSink)>();

late final _CLogOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLogOptions Function()>>('CLogOptionsMakeDefault');
late final _CLogOptionsMakeDefault = _CLogOptionsMakeDefaultPtr.asFunction<_CLogOptions Function()>();


late final _CLogSinkCpp_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CLogSinkCpp_cg_objectIdentifier');
late final _CLogSinkCpp_cg_objectIdentifier = _CLogSinkCpp_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CLogSinkCpp_write_CLogMessagePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CLogSinkCpp, _CLogMessage)>>('CLogSinkCpp_write_CLogMessage');
late final _CLogSinkCpp_write_CLogMessage = _CLogSinkCpp_write_CLogMessagePtr.asFunction<void Function(_CLogSinkCpp, _CLogMessage)>();

late final _CLogSinkCpp_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CLogSinkCpp_release');
late final _CLogSinkCpp_release = _CLogSinkCpp_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CLogSinkCpp_retainPtr = _lookup<ffi.NativeFunction<_CLogSinkCpp Function(ffi.Pointer<ffi.Void>)>>('CLogSinkCpp_retain');
late final _CLogSinkCpp_retain = _CLogSinkCpp_retainPtr.asFunction<_CLogSinkCpp Function(ffi.Pointer<ffi.Void>)>();
late final _CLogSinkCppMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLogSinkCpp Function()>>('CLogSinkCppMakeDefault');
late final _CLogSinkCppMakeDefault = _CLogSinkCppMakeDefaultPtr.asFunction<_CLogSinkCpp Function()>();


late final _CLogMessageMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLogMessage Function()>>('CLogMessageMakeDefault');
late final _CLogMessageMakeDefault = _CLogMessageMakeDefaultPtr.asFunction<_CLogMessage Function()>();


late final _CVendorConfigFromAssetMakeDefaultPtr = _lookup<ffi.NativeFunction<_CVendorConfigFromAsset Function()>>('CVendorConfigFromAssetMakeDefault');
late final _CVendorConfigFromAssetMakeDefault = _CVendorConfigFromAssetMakeDefaultPtr.asFunction<_CVendorConfigFromAsset Function()>();


late final _CVendorConfigFromFileMakeDefaultPtr = _lookup<ffi.NativeFunction<_CVendorConfigFromFile Function()>>('CVendorConfigFromFileMakeDefault');
late final _CVendorConfigFromFileMakeDefault = _CVendorConfigFromFileMakeDefaultPtr.asFunction<_CVendorConfigFromFile Function()>();


late final _CVendorConfigFromStringMakeDefaultPtr = _lookup<ffi.NativeFunction<_CVendorConfigFromString Function()>>('CVendorConfigFromStringMakeDefault');
late final _CVendorConfigFromStringMakeDefault = _CVendorConfigFromStringMakeDefaultPtr.asFunction<_CVendorConfigFromString Function()>();


late final _CVendorConfig_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CVendorConfig)>>('CVendorConfig_release');
late final _CVendorConfig_release = _CVendorConfig_releasePtr.asFunction<void Function(_CVendorConfig)>();
late final _CVendorConfigMakeDefaultPtr = _lookup<ffi.NativeFunction<_CVendorConfig Function()>>('CVendorConfigMakeDefault');
late final _CVendorConfigMakeDefault = _CVendorConfigMakeDefaultPtr.asFunction<_CVendorConfig Function()>();

late final _CDesiredAccuracyMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDesiredAccuracy Function()>>('CDesiredAccuracyMakeDefault');
late final _CDesiredAccuracyMakeDefault = _CDesiredAccuracyMakeDefaultPtr.asFunction<_CDesiredAccuracy Function()>();

late final _CLocationProviderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocationProvider Function()>>('CLocationProviderMakeDefault');
late final _CLocationProviderMakeDefault = _CLocationProviderMakeDefaultPtr.asFunction<_CLocationProvider Function()>();
late final _CLocationProvider_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CLocationProvider)>>('CLocationProvider_release');
late final _CLocationProvider_release = _CLocationProvider_releasePtr.asFunction<void Function(_CLocationProvider)>();

late final _COptional_CLocationProviderMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CLocationProvider Function()>>('COptional_CLocationProviderMakeDefault');
late final _COptional_CLocationProviderMakeDefault = _COptional_CLocationProviderMakeDefaultPtr.asFunction<_COptional_CLocationProvider Function()>();

late final _COptional_CLocationProvider_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CLocationProvider)>>('COptional_CLocationProvider_release');
late final _COptional_CLocationProvider_release = _COptional_CLocationProvider_releasePtr.asFunction<void Function(_COptional_CLocationProvider)>();

late final _CLocationProviderCpp_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CLocationProviderCpp_cg_objectIdentifier');
late final _CLocationProviderCpp_cg_objectIdentifier = _CLocationProviderCpp_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CLocationProviderCpp_lastLocationPtr = _lookup<ffi.NativeFunction<_COptional_CLocation Function(_CLocationProviderCpp)>>('CLocationProviderCpp_lastLocation');
late final _CLocationProviderCpp_lastLocation = _CLocationProviderCpp_lastLocationPtr.asFunction<_COptional_CLocation Function(_CLocationProviderCpp)>();
late final _CLocationProviderCpp_setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifierPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CLocationProviderCpp, _COptional_CLocationNotifier, _COptional_CLocationAvailableNotifier)>>('CLocationProviderCpp_setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifier');
late final _CLocationProviderCpp_setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifier = _CLocationProviderCpp_setNotifiers_COptional_CLocationNotifier_COptional_CLocationAvailableNotifierPtr.asFunction<void Function(_CLocationProviderCpp, _COptional_CLocationNotifier, _COptional_CLocationAvailableNotifier)>();
late final _CLocationProviderCpp_setDesiredAccuracy_CDesiredAccuracyPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CLocationProviderCpp, _CDesiredAccuracy)>>('CLocationProviderCpp_setDesiredAccuracy_CDesiredAccuracy');
late final _CLocationProviderCpp_setDesiredAccuracy_CDesiredAccuracy = _CLocationProviderCpp_setDesiredAccuracy_CDesiredAccuracyPtr.asFunction<void Function(_CLocationProviderCpp, _CDesiredAccuracy)>();

late final _CLocationProviderCpp_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CLocationProviderCpp_release');
late final _CLocationProviderCpp_release = _CLocationProviderCpp_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CLocationProviderCpp_retainPtr = _lookup<ffi.NativeFunction<_CLocationProviderCpp Function(ffi.Pointer<ffi.Void>)>>('CLocationProviderCpp_retain');
late final _CLocationProviderCpp_retain = _CLocationProviderCpp_retainPtr.asFunction<_CLocationProviderCpp Function(ffi.Pointer<ffi.Void>)>();
late final _CLocationProviderCppMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocationProviderCpp Function()>>('CLocationProviderCppMakeDefault');
late final _CLocationProviderCppMakeDefault = _CLocationProviderCppMakeDefaultPtr.asFunction<_CLocationProviderCpp Function()>();


late final _CLatitudeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLatitude Function()>>('CLatitudeMakeDefault');
late final _CLatitudeMakeDefault = _CLatitudeMakeDefaultPtr.asFunction<_CLatitude Function()>();


late final _CLongitudeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLongitude Function()>>('CLongitudeMakeDefault');
late final _CLongitudeMakeDefault = _CLongitudeMakeDefaultPtr.asFunction<_CLongitude Function()>();


late final _CGeoPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGeoPoint Function()>>('CGeoPointMakeDefault');
late final _CGeoPointMakeDefault = _CGeoPointMakeDefaultPtr.asFunction<_CGeoPoint Function()>();


late final _CLocationCoordinatesMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocationCoordinates Function()>>('CLocationCoordinatesMakeDefault');
late final _CLocationCoordinatesMakeDefault = _CLocationCoordinatesMakeDefaultPtr.asFunction<_CLocationCoordinates Function()>();


late final _COptional_doubleMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_double Function()>>('COptional_doubleMakeDefault');
late final _COptional_doubleMakeDefault = _COptional_doubleMakeDefaultPtr.asFunction<_COptional_double Function()>();

late final _CLocationFuzzyDoubleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocationFuzzyDouble Function()>>('CLocationFuzzyDoubleMakeDefault');
late final _CLocationFuzzyDoubleMakeDefault = _CLocationFuzzyDoubleMakeDefaultPtr.asFunction<_CLocationFuzzyDouble Function()>();


late final _COptional_CLocationFuzzyDoubleMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CLocationFuzzyDouble Function()>>('COptional_CLocationFuzzyDoubleMakeDefault');
late final _COptional_CLocationFuzzyDoubleMakeDefault = _COptional_CLocationFuzzyDoubleMakeDefaultPtr.asFunction<_COptional_CLocationFuzzyDouble Function()>();

late final _CBearingMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBearing Function()>>('CBearingMakeDefault');
late final _CBearingMakeDefault = _CBearingMakeDefaultPtr.asFunction<_CBearing Function()>();


late final _COptional_CBearingMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CBearing Function()>>('COptional_CBearingMakeDefault');
late final _COptional_CBearingMakeDefault = _COptional_CBearingMakeDefaultPtr.asFunction<_COptional_CBearing Function()>();

late final _CLocationCourseMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocationCourse Function()>>('CLocationCourseMakeDefault');
late final _CLocationCourseMakeDefault = _CLocationCourseMakeDefaultPtr.asFunction<_CLocationCourse Function()>();


late final _COptional_CLocationCourseMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CLocationCourse Function()>>('COptional_CLocationCourseMakeDefault');
late final _COptional_CLocationCourseMakeDefault = _COptional_CLocationCourseMakeDefaultPtr.asFunction<_COptional_CLocationCourse Function()>();

late final _CLocationMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocation Function()>>('CLocationMakeDefault');
late final _CLocationMakeDefault = _CLocationMakeDefaultPtr.asFunction<_CLocation Function()>();


late final _COptional_CLocationMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CLocation Function()>>('COptional_CLocationMakeDefault');
late final _COptional_CLocationMakeDefault = _COptional_CLocationMakeDefaultPtr.asFunction<_COptional_CLocation Function()>();

late final _CLocationNotifier_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CLocationNotifier_cg_objectIdentifier');
late final _CLocationNotifier_cg_objectIdentifier = _CLocationNotifier_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CLocationNotifier_send_CArray_CLocationPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CLocationNotifier, _CArray_CLocation)>>('CLocationNotifier_send_CArray_CLocation');
late final _CLocationNotifier_send_CArray_CLocation = _CLocationNotifier_send_CArray_CLocationPtr.asFunction<void Function(_CLocationNotifier, _CArray_CLocation)>();

late final _CLocationNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CLocationNotifier_release');
late final _CLocationNotifier_release = _CLocationNotifier_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CLocationNotifier_retainPtr = _lookup<ffi.NativeFunction<_CLocationNotifier Function(ffi.Pointer<ffi.Void>)>>('CLocationNotifier_retain');
late final _CLocationNotifier_retain = _CLocationNotifier_retainPtr.asFunction<_CLocationNotifier Function(ffi.Pointer<ffi.Void>)>();
late final _CLocationNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocationNotifier Function()>>('CLocationNotifierMakeDefault');
late final _CLocationNotifierMakeDefault = _CLocationNotifierMakeDefaultPtr.asFunction<_CLocationNotifier Function()>();


late final _COptional_CLocationNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CLocationNotifier Function()>>('COptional_CLocationNotifierMakeDefault');
late final _COptional_CLocationNotifierMakeDefault = _COptional_CLocationNotifierMakeDefaultPtr.asFunction<_COptional_CLocationNotifier Function()>();

late final _COptional_CLocationNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CLocationNotifier)>>('COptional_CLocationNotifier_release');
late final _COptional_CLocationNotifier_release = _COptional_CLocationNotifier_releasePtr.asFunction<void Function(_COptional_CLocationNotifier)>();

late final _CArray_CLocationmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CLocation Function()>>('CArray_CLocation_makeEmpty');
late final _CArray_CLocationmakeEmpty = _CArray_CLocationmakeEmptyPtr.asFunction<_CArray_CLocation Function()>();
late final _CArray_CLocationaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CLocation, _CLocation)>>('CArray_CLocation_addElement');
late final _CArray_CLocationaddElement = _CArray_CLocationaddElementPtr.asFunction<void Function(_CArray_CLocation, _CLocation)>();
late final _forEach_CArray_CLocationPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CLocation, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLocation)>>)
>>('CArray_CLocation_forEachWithFunctionPointer');
late final _forEach_CArray_CLocation = _forEach_CArray_CLocationPtr.asFunction<
  void Function(_CArray_CLocation, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLocation)
>>)>();
late final _CArray_CLocation_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CLocation)>>('CArray_CLocation_release');
late final _CArray_CLocation_release = _CArray_CLocation_releasePtr.asFunction<void Function(_CArray_CLocation)>();

late final _CLocationAvailableNotifier_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CLocationAvailableNotifier_cg_objectIdentifier');
late final _CLocationAvailableNotifier_cg_objectIdentifier = _CLocationAvailableNotifier_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CLocationAvailableNotifier_send_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CLocationAvailableNotifier, ffi.Bool)>>('CLocationAvailableNotifier_send_bool');
late final _CLocationAvailableNotifier_send_bool = _CLocationAvailableNotifier_send_boolPtr.asFunction<void Function(_CLocationAvailableNotifier, bool)>();

late final _CLocationAvailableNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CLocationAvailableNotifier_release');
late final _CLocationAvailableNotifier_release = _CLocationAvailableNotifier_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CLocationAvailableNotifier_retainPtr = _lookup<ffi.NativeFunction<_CLocationAvailableNotifier Function(ffi.Pointer<ffi.Void>)>>('CLocationAvailableNotifier_retain');
late final _CLocationAvailableNotifier_retain = _CLocationAvailableNotifier_retainPtr.asFunction<_CLocationAvailableNotifier Function(ffi.Pointer<ffi.Void>)>();
late final _CLocationAvailableNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocationAvailableNotifier Function()>>('CLocationAvailableNotifierMakeDefault');
late final _CLocationAvailableNotifierMakeDefault = _CLocationAvailableNotifierMakeDefaultPtr.asFunction<_CLocationAvailableNotifier Function()>();


late final _COptional_CLocationAvailableNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CLocationAvailableNotifier Function()>>('COptional_CLocationAvailableNotifierMakeDefault');
late final _COptional_CLocationAvailableNotifierMakeDefault = _COptional_CLocationAvailableNotifierMakeDefaultPtr.asFunction<_COptional_CLocationAvailableNotifier Function()>();

late final _COptional_CLocationAvailableNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CLocationAvailableNotifier)>>('COptional_CLocationAvailableNotifier_release');
late final _COptional_CLocationAvailableNotifier_release = _COptional_CLocationAvailableNotifier_releasePtr.asFunction<void Function(_COptional_CLocationAvailableNotifier)>();

late final _CHeadingProviderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CHeadingProvider Function()>>('CHeadingProviderMakeDefault');
late final _CHeadingProviderMakeDefault = _CHeadingProviderMakeDefaultPtr.asFunction<_CHeadingProvider Function()>();
late final _CHeadingProvider_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CHeadingProvider)>>('CHeadingProvider_release');
late final _CHeadingProvider_release = _CHeadingProvider_releasePtr.asFunction<void Function(_CHeadingProvider)>();

late final _COptional_CHeadingProviderMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CHeadingProvider Function()>>('COptional_CHeadingProviderMakeDefault');
late final _COptional_CHeadingProviderMakeDefault = _COptional_CHeadingProviderMakeDefaultPtr.asFunction<_COptional_CHeadingProvider Function()>();

late final _COptional_CHeadingProvider_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CHeadingProvider)>>('COptional_CHeadingProvider_release');
late final _COptional_CHeadingProvider_release = _COptional_CHeadingProvider_releasePtr.asFunction<void Function(_COptional_CHeadingProvider)>();

late final _CHeadingProviderCpp_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CHeadingProviderCpp_cg_objectIdentifier');
late final _CHeadingProviderCpp_cg_objectIdentifier = _CHeadingProviderCpp_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CHeadingProviderCpp_setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifierPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CHeadingProviderCpp, _COptional_CHeadingNotifier, _COptional_CHeadingAvailableNotifier)>>('CHeadingProviderCpp_setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifier');
late final _CHeadingProviderCpp_setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifier = _CHeadingProviderCpp_setNotifiers_COptional_CHeadingNotifier_COptional_CHeadingAvailableNotifierPtr.asFunction<void Function(_CHeadingProviderCpp, _COptional_CHeadingNotifier, _COptional_CHeadingAvailableNotifier)>();

late final _CHeadingProviderCpp_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CHeadingProviderCpp_release');
late final _CHeadingProviderCpp_release = _CHeadingProviderCpp_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CHeadingProviderCpp_retainPtr = _lookup<ffi.NativeFunction<_CHeadingProviderCpp Function(ffi.Pointer<ffi.Void>)>>('CHeadingProviderCpp_retain');
late final _CHeadingProviderCpp_retain = _CHeadingProviderCpp_retainPtr.asFunction<_CHeadingProviderCpp Function(ffi.Pointer<ffi.Void>)>();
late final _CHeadingProviderCppMakeDefaultPtr = _lookup<ffi.NativeFunction<_CHeadingProviderCpp Function()>>('CHeadingProviderCppMakeDefault');
late final _CHeadingProviderCppMakeDefault = _CHeadingProviderCppMakeDefaultPtr.asFunction<_CHeadingProviderCpp Function()>();


late final _CHeadingNotifier_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CHeadingNotifier_cg_objectIdentifier');
late final _CHeadingNotifier_cg_objectIdentifier = _CHeadingNotifier_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CHeadingNotifier_send_CPlatformHeadingPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CHeadingNotifier, _CPlatformHeading)>>('CHeadingNotifier_send_CPlatformHeading');
late final _CHeadingNotifier_send_CPlatformHeading = _CHeadingNotifier_send_CPlatformHeadingPtr.asFunction<void Function(_CHeadingNotifier, _CPlatformHeading)>();

late final _CHeadingNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CHeadingNotifier_release');
late final _CHeadingNotifier_release = _CHeadingNotifier_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CHeadingNotifier_retainPtr = _lookup<ffi.NativeFunction<_CHeadingNotifier Function(ffi.Pointer<ffi.Void>)>>('CHeadingNotifier_retain');
late final _CHeadingNotifier_retain = _CHeadingNotifier_retainPtr.asFunction<_CHeadingNotifier Function(ffi.Pointer<ffi.Void>)>();
late final _CHeadingNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_CHeadingNotifier Function()>>('CHeadingNotifierMakeDefault');
late final _CHeadingNotifierMakeDefault = _CHeadingNotifierMakeDefaultPtr.asFunction<_CHeadingNotifier Function()>();


late final _COptional_CHeadingNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CHeadingNotifier Function()>>('COptional_CHeadingNotifierMakeDefault');
late final _COptional_CHeadingNotifierMakeDefault = _COptional_CHeadingNotifierMakeDefaultPtr.asFunction<_COptional_CHeadingNotifier Function()>();

late final _COptional_CHeadingNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CHeadingNotifier)>>('COptional_CHeadingNotifier_release');
late final _COptional_CHeadingNotifier_release = _COptional_CHeadingNotifier_releasePtr.asFunction<void Function(_COptional_CHeadingNotifier)>();

late final _CPlatformHeadingMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPlatformHeading Function()>>('CPlatformHeadingMakeDefault');
late final _CPlatformHeadingMakeDefault = _CPlatformHeadingMakeDefaultPtr.asFunction<_CPlatformHeading Function()>();


late final _CHeadingAvailableNotifier_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CHeadingAvailableNotifier_cg_objectIdentifier');
late final _CHeadingAvailableNotifier_cg_objectIdentifier = _CHeadingAvailableNotifier_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CHeadingAvailableNotifier_send_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CHeadingAvailableNotifier, ffi.Bool)>>('CHeadingAvailableNotifier_send_bool');
late final _CHeadingAvailableNotifier_send_bool = _CHeadingAvailableNotifier_send_boolPtr.asFunction<void Function(_CHeadingAvailableNotifier, bool)>();

late final _CHeadingAvailableNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CHeadingAvailableNotifier_release');
late final _CHeadingAvailableNotifier_release = _CHeadingAvailableNotifier_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CHeadingAvailableNotifier_retainPtr = _lookup<ffi.NativeFunction<_CHeadingAvailableNotifier Function(ffi.Pointer<ffi.Void>)>>('CHeadingAvailableNotifier_retain');
late final _CHeadingAvailableNotifier_retain = _CHeadingAvailableNotifier_retainPtr.asFunction<_CHeadingAvailableNotifier Function(ffi.Pointer<ffi.Void>)>();
late final _CHeadingAvailableNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_CHeadingAvailableNotifier Function()>>('CHeadingAvailableNotifierMakeDefault');
late final _CHeadingAvailableNotifierMakeDefault = _CHeadingAvailableNotifierMakeDefaultPtr.asFunction<_CHeadingAvailableNotifier Function()>();


late final _COptional_CHeadingAvailableNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CHeadingAvailableNotifier Function()>>('COptional_CHeadingAvailableNotifierMakeDefault');
late final _COptional_CHeadingAvailableNotifierMakeDefault = _COptional_CHeadingAvailableNotifierMakeDefaultPtr.asFunction<_COptional_CHeadingAvailableNotifier Function()>();

late final _COptional_CHeadingAvailableNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CHeadingAvailableNotifier)>>('COptional_CHeadingAvailableNotifier_release');
late final _COptional_CHeadingAvailableNotifier_release = _COptional_CHeadingAvailableNotifier_releasePtr.asFunction<void Function(_COptional_CHeadingAvailableNotifier)>();

late final _CFile_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CFile_cg_objectIdentifier');
late final _CFile_cg_objectIdentifier = _CFile_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CFile_S_fromString_CStringPtr = _lookup<ffi.NativeFunction<_CFile Function(_CString)>>('CFile_S_fromString_CString');
late final _CFile_S_fromString_CString = _CFile_S_fromString_CStringPtr.asFunction<_CFile Function(_CString)>();
late final _CFile_S_fromAsset_CContext_CStringPtr = _lookup<ffi.NativeFunction<_CFile Function(_CContext, _CString)>>('CFile_S_fromAsset_CContext_CString');
late final _CFile_S_fromAsset_CContext_CString = _CFile_S_fromAsset_CContext_CStringPtr.asFunction<_CFile Function(_CContext, _CString)>();
late final _CFile_C_createWith_CStringPtr = _lookup<ffi.NativeFunction<_CFile Function(_CString)>>('CFile_C_createWith_CString');
late final _CFile_C_createWith_CString = _CFile_C_createWith_CStringPtr.asFunction<_CFile Function(_CString)>();

late final _CFile_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CFile_release');
late final _CFile_release = _CFile_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CFile_retainPtr = _lookup<ffi.NativeFunction<_CFile Function(ffi.Pointer<ffi.Void>)>>('CFile_retain');
late final _CFile_retain = _CFile_retainPtr.asFunction<_CFile Function(ffi.Pointer<ffi.Void>)>();
late final _CFileMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFile Function()>>('CFileMakeDefault');
late final _CFileMakeDefault = _CFileMakeDefaultPtr.asFunction<_CFile Function()>();


late final _CGeoRectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGeoRect Function()>>('CGeoRectMakeDefault');
late final _CGeoRectMakeDefault = _CGeoRectMakeDefaultPtr.asFunction<_CGeoRect Function()>();

late final _CFunction_G_calculateBearing_With_CGeoPoint_CGeoPointPtr = _lookup<ffi.NativeFunction<_CBearing Function(_CGeoPoint, _CGeoPoint)>>('CFunction_G_calculateBearing_With_CGeoPoint_CGeoPoint');
late final _CFunction_G_calculateBearing_With_CGeoPoint_CGeoPoint = _CFunction_G_calculateBearing_With_CGeoPoint_CGeoPointPtr.asFunction<_CBearing Function(_CGeoPoint, _CGeoPoint)>();
late final _CFunction_G_calculateDistance_With_CGeoPoint_CGeoPointPtr = _lookup<ffi.NativeFunction<ffi.Double Function(_CGeoPoint, _CGeoPoint)>>('CFunction_G_calculateDistance_With_CGeoPoint_CGeoPoint');
late final _CFunction_G_calculateDistance_With_CGeoPoint_CGeoPoint = _CFunction_G_calculateDistance_With_CGeoPoint_CGeoPointPtr.asFunction<double Function(_CGeoPoint, _CGeoPoint)>();
late final _CFunction_G_move_With_CGeoPoint_CBearing_doublePtr = _lookup<ffi.NativeFunction<_CGeoPoint Function(_CGeoPoint, _CBearing, ffi.Double)>>('CFunction_G_move_With_CGeoPoint_CBearing_double');
late final _CFunction_G_move_With_CGeoPoint_CBearing_double = _CFunction_G_move_With_CGeoPoint_CBearing_doublePtr.asFunction<_CGeoPoint Function(_CGeoPoint, _CBearing, double)>();
late final _CFunction_G_isGeoPointValid_With_CGeoPointPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CGeoPoint)>>('CFunction_G_isGeoPointValid_With_CGeoPoint');
late final _CFunction_G_isGeoPointValid_With_CGeoPoint = _CFunction_G_isGeoPointValid_With_CGeoPointPtr.asFunction<bool Function(_CGeoPoint)>();
late final _CFunction_G_isGeoRectValid_With_CGeoRectPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CGeoRect)>>('CFunction_G_isGeoRectValid_With_CGeoRect');
late final _CFunction_G_isGeoRectValid_With_CGeoRect = _CFunction_G_isGeoRectValid_With_CGeoRectPtr.asFunction<bool Function(_CGeoRect)>();
late final _CFunction_G_containsPoint_With_CGeoRect_CGeoPointPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CGeoRect, _CGeoPoint)>>('CFunction_G_containsPoint_With_CGeoRect_CGeoPoint');
late final _CFunction_G_containsPoint_With_CGeoRect_CGeoPoint = _CFunction_G_containsPoint_With_CGeoRect_CGeoPointPtr.asFunction<bool Function(_CGeoRect, _CGeoPoint)>();
late final _CFunction_G_containsRect_With_CGeoRect_CGeoRectPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CGeoRect, _CGeoRect)>>('CFunction_G_containsRect_With_CGeoRect_CGeoRect');
late final _CFunction_G_containsRect_With_CGeoRect_CGeoRect = _CFunction_G_containsRect_With_CGeoRect_CGeoRectPtr.asFunction<bool Function(_CGeoRect, _CGeoRect)>();
late final _CFunction_G_expandPoint_With_CGeoRect_CGeoPointPtr = _lookup<ffi.NativeFunction<_CGeoRect Function(_CGeoRect, _CGeoPoint)>>('CFunction_G_expandPoint_With_CGeoRect_CGeoPoint');
late final _CFunction_G_expandPoint_With_CGeoRect_CGeoPoint = _CFunction_G_expandPoint_With_CGeoRect_CGeoPointPtr.asFunction<_CGeoRect Function(_CGeoRect, _CGeoPoint)>();
late final _CFunction_G_expandRect_With_CGeoRect_CGeoRectPtr = _lookup<ffi.NativeFunction<_CGeoRect Function(_CGeoRect, _CGeoRect)>>('CFunction_G_expandRect_With_CGeoRect_CGeoRect');
late final _CFunction_G_expandRect_With_CGeoRect_CGeoRect = _CFunction_G_expandRect_With_CGeoRect_CGeoRectPtr.asFunction<_CGeoRect Function(_CGeoRect, _CGeoRect)>();
late final _CFunction_G_isDegenerate_With_CGeoRectPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CGeoRect)>>('CFunction_G_isDegenerate_With_CGeoRect');
late final _CFunction_G_isDegenerate_With_CGeoRect = _CFunction_G_isDegenerate_With_CGeoRectPtr.asFunction<bool Function(_CGeoRect)>();
late final _CFunction_G_intersects_With_CGeoRect_CGeoRectPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CGeoRect, _CGeoRect)>>('CFunction_G_intersects_With_CGeoRect_CGeoRect');
late final _CFunction_G_intersects_With_CGeoRect_CGeoRect = _CFunction_G_intersects_With_CGeoRect_CGeoRectPtr.asFunction<bool Function(_CGeoRect, _CGeoRect)>();

late final _CApartmentRangeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CApartmentRange Function()>>('CApartmentRangeMakeDefault');
late final _CApartmentRangeMakeDefault = _CApartmentRangeMakeDefaultPtr.asFunction<_CApartmentRange Function()>();


late final _CAttributeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAttribute Function()>>('CAttributeMakeDefault');
late final _CAttributeMakeDefault = _CAttributeMakeDefaultPtr.asFunction<_CAttribute Function()>();


late final _CPurposeCodeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPurposeCode Function()>>('CPurposeCodeMakeDefault');
late final _CPurposeCodeMakeDefault = _CPurposeCodeMakeDefaultPtr.asFunction<_CPurposeCode Function()>();


late final _CArray_CLevelInfomakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CLevelInfo Function()>>('CArray_CLevelInfo_makeEmpty');
late final _CArray_CLevelInfomakeEmpty = _CArray_CLevelInfomakeEmptyPtr.asFunction<_CArray_CLevelInfo Function()>();
late final _CArray_CLevelInfoaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CLevelInfo, _CLevelInfo)>>('CArray_CLevelInfo_addElement');
late final _CArray_CLevelInfoaddElement = _CArray_CLevelInfoaddElementPtr.asFunction<void Function(_CArray_CLevelInfo, _CLevelInfo)>();
late final _forEach_CArray_CLevelInfoPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CLevelInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLevelInfo)>>)
>>('CArray_CLevelInfo_forEachWithFunctionPointer');
late final _forEach_CArray_CLevelInfo = _forEach_CArray_CLevelInfoPtr.asFunction<
  void Function(_CArray_CLevelInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLevelInfo)
>>)>();
late final _CArray_CLevelInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CLevelInfo)>>('CArray_CLevelInfo_release');
late final _CArray_CLevelInfo_release = _CArray_CLevelInfo_releasePtr.asFunction<void Function(_CArray_CLevelInfo)>();

late final _CBuildingLevelsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBuildingLevels Function()>>('CBuildingLevelsMakeDefault');
late final _CBuildingLevelsMakeDefault = _CBuildingLevelsMakeDefaultPtr.asFunction<_CBuildingLevels Function()>();


late final _COptional_CPurposeCodeMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CPurposeCode Function()>>('COptional_CPurposeCodeMakeDefault');
late final _COptional_CPurposeCodeMakeDefault = _COptional_CPurposeCodeMakeDefaultPtr.asFunction<_COptional_CPurposeCode Function()>();

late final _COptional_CBuildingLevelsMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CBuildingLevels Function()>>('COptional_CBuildingLevelsMakeDefault');
late final _COptional_CBuildingLevelsMakeDefault = _COptional_CBuildingLevelsMakeDefaultPtr.asFunction<_COptional_CBuildingLevels Function()>();

late final _COptional_CBuildingLevels_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CBuildingLevels)>>('COptional_CBuildingLevels_release');
late final _COptional_CBuildingLevels_release = _COptional_CBuildingLevels_releasePtr.asFunction<void Function(_COptional_CBuildingLevels)>();

late final _COptional_CBuildingIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CBuildingId Function()>>('COptional_CBuildingIdMakeDefault');
late final _COptional_CBuildingIdMakeDefault = _COptional_CBuildingIdMakeDefaultPtr.asFunction<_COptional_CBuildingId Function()>();

late final _CBuildingInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBuildingInfo Function()>>('CBuildingInfoMakeDefault');
late final _CBuildingInfoMakeDefault = _CBuildingInfoMakeDefaultPtr.asFunction<_CBuildingInfo Function()>();


late final _CContactInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CContactInfo Function()>>('CContactInfoMakeDefault');
late final _CContactInfoMakeDefault = _CContactInfoMakeDefaultPtr.asFunction<_CContactInfo Function()>();


late final _CIsOpenNowMakeDefaultPtr = _lookup<ffi.NativeFunction<_CIsOpenNow Function()>>('CIsOpenNowMakeDefault');
late final _CIsOpenNowMakeDefault = _CIsOpenNowMakeDefaultPtr.asFunction<_CIsOpenNow Function()>();


late final _CWorkTimeFilter_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CWorkTimeFilter)>>('CWorkTimeFilter_release');
late final _CWorkTimeFilter_release = _CWorkTimeFilter_releasePtr.asFunction<void Function(_CWorkTimeFilter)>();
late final _CWorkTimeFilterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CWorkTimeFilter Function()>>('CWorkTimeFilterMakeDefault');
late final _CWorkTimeFilterMakeDefault = _CWorkTimeFilterMakeDefaultPtr.asFunction<_CWorkTimeFilter Function()>();

late final _COptional_boolMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_bool Function()>>('COptional_boolMakeDefault');
late final _COptional_boolMakeDefault = _COptional_boolMakeDefaultPtr.asFunction<_COptional_bool Function()>();

late final _CFlagFilterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFlagFilter Function()>>('CFlagFilterMakeDefault');
late final _CFlagFilterMakeDefault = _CFlagFilterMakeDefaultPtr.asFunction<_CFlagFilter Function()>();


late final _CRangeFilterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRangeFilter Function()>>('CRangeFilterMakeDefault');
late final _CRangeFilterMakeDefault = _CRangeFilterMakeDefaultPtr.asFunction<_CRangeFilter Function()>();


late final _CSortingFilterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSortingFilter Function()>>('CSortingFilterMakeDefault');
late final _CSortingFilterMakeDefault = _CSortingFilterMakeDefaultPtr.asFunction<_CSortingFilter Function()>();


late final _CDynamicFilter_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CDynamicFilter)>>('CDynamicFilter_release');
late final _CDynamicFilter_release = _CDynamicFilter_releasePtr.asFunction<void Function(_CDynamicFilter)>();
late final _CDynamicFilterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDynamicFilter Function()>>('CDynamicFilterMakeDefault');
late final _CDynamicFilterMakeDefault = _CDynamicFilterMakeDefaultPtr.asFunction<_CDynamicFilter Function()>();

late final _COptional_CWorkTimeFilterMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CWorkTimeFilter Function()>>('COptional_CWorkTimeFilterMakeDefault');
late final _COptional_CWorkTimeFilterMakeDefault = _COptional_CWorkTimeFilterMakeDefaultPtr.asFunction<_COptional_CWorkTimeFilter Function()>();

late final _CArray_CDynamicFiltermakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CDynamicFilter Function()>>('CArray_CDynamicFilter_makeEmpty');
late final _CArray_CDynamicFiltermakeEmpty = _CArray_CDynamicFiltermakeEmptyPtr.asFunction<_CArray_CDynamicFilter Function()>();
late final _CArray_CDynamicFilteraddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CDynamicFilter, _CDynamicFilter)>>('CArray_CDynamicFilter_addElement');
late final _CArray_CDynamicFilteraddElement = _CArray_CDynamicFilteraddElementPtr.asFunction<void Function(_CArray_CDynamicFilter, _CDynamicFilter)>();
late final _forEach_CArray_CDynamicFilterPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CDynamicFilter, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDynamicFilter)>>)
>>('CArray_CDynamicFilter_forEachWithFunctionPointer');
late final _forEach_CArray_CDynamicFilter = _forEach_CArray_CDynamicFilterPtr.asFunction<
  void Function(_CArray_CDynamicFilter, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDynamicFilter)
>>)>();
late final _CArray_CDynamicFilter_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CDynamicFilter)>>('CArray_CDynamicFilter_release');
late final _CArray_CDynamicFilter_release = _CArray_CDynamicFilter_releasePtr.asFunction<void Function(_CArray_CDynamicFilter)>();

late final _CDirectoryFilterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDirectoryFilter Function()>>('CDirectoryFilterMakeDefault');
late final _CDirectoryFilterMakeDefault = _CDirectoryFilterMakeDefaultPtr.asFunction<_CDirectoryFilter Function()>();


late final _CArray_CGeoPointmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CGeoPoint Function()>>('CArray_CGeoPoint_makeEmpty');
late final _CArray_CGeoPointmakeEmpty = _CArray_CGeoPointmakeEmptyPtr.asFunction<_CArray_CGeoPoint Function()>();
late final _CArray_CGeoPointaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CGeoPoint, _CGeoPoint)>>('CArray_CGeoPoint_addElement');
late final _CArray_CGeoPointaddElement = _CArray_CGeoPointaddElementPtr.asFunction<void Function(_CArray_CGeoPoint, _CGeoPoint)>();
late final _forEach_CArray_CGeoPointPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CGeoPoint, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeoPoint)>>)
>>('CArray_CGeoPoint_forEachWithFunctionPointer');
late final _forEach_CArray_CGeoPoint = _forEach_CArray_CGeoPointPtr.asFunction<
  void Function(_CArray_CGeoPoint, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeoPoint)
>>)>();
late final _CArray_CGeoPoint_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CGeoPoint)>>('CArray_CGeoPoint_release');
late final _CArray_CGeoPoint_release = _CArray_CGeoPoint_releasePtr.asFunction<void Function(_CArray_CGeoPoint)>();

late final _CArray_CArray_CGeoPointmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CArray_CGeoPoint Function()>>('CArray_CArray_CGeoPoint_makeEmpty');
late final _CArray_CArray_CGeoPointmakeEmpty = _CArray_CArray_CGeoPointmakeEmptyPtr.asFunction<_CArray_CArray_CGeoPoint Function()>();
late final _CArray_CArray_CGeoPointaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CArray_CGeoPoint, _CArray_CGeoPoint)>>('CArray_CArray_CGeoPoint_addElement');
late final _CArray_CArray_CGeoPointaddElement = _CArray_CArray_CGeoPointaddElementPtr.asFunction<void Function(_CArray_CArray_CGeoPoint, _CArray_CGeoPoint)>();
late final _forEach_CArray_CArray_CGeoPointPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CArray_CGeoPoint, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CGeoPoint)>>)
>>('CArray_CArray_CGeoPoint_forEachWithFunctionPointer');
late final _forEach_CArray_CArray_CGeoPoint = _forEach_CArray_CArray_CGeoPointPtr.asFunction<
  void Function(_CArray_CArray_CGeoPoint, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CGeoPoint)
>>)>();
late final _CArray_CArray_CGeoPoint_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CArray_CGeoPoint)>>('CArray_CArray_CGeoPoint_release');
late final _CArray_CArray_CGeoPoint_release = _CArray_CArray_CGeoPoint_releasePtr.asFunction<void Function(_CArray_CArray_CGeoPoint)>();

late final _CEntranceGeometryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CEntranceGeometry Function()>>('CEntranceGeometryMakeDefault');
late final _CEntranceGeometryMakeDefault = _CEntranceGeometryMakeDefaultPtr.asFunction<_CEntranceGeometry Function()>();


late final _CArray_CApartmentRangemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CApartmentRange Function()>>('CArray_CApartmentRange_makeEmpty');
late final _CArray_CApartmentRangemakeEmpty = _CArray_CApartmentRangemakeEmptyPtr.asFunction<_CArray_CApartmentRange Function()>();
late final _CArray_CApartmentRangeaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CApartmentRange, _CApartmentRange)>>('CArray_CApartmentRange_addElement');
late final _CArray_CApartmentRangeaddElement = _CArray_CApartmentRangeaddElementPtr.asFunction<void Function(_CArray_CApartmentRange, _CApartmentRange)>();
late final _forEach_CArray_CApartmentRangePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CApartmentRange, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CApartmentRange)>>)
>>('CArray_CApartmentRange_forEachWithFunctionPointer');
late final _forEach_CArray_CApartmentRange = _forEach_CArray_CApartmentRangePtr.asFunction<
  void Function(_CArray_CApartmentRange, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CApartmentRange)
>>)>();
late final _CArray_CApartmentRange_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CApartmentRange)>>('CArray_CApartmentRange_release');
late final _CArray_CApartmentRange_release = _CArray_CApartmentRange_releasePtr.asFunction<void Function(_CArray_CApartmentRange)>();

late final _COptional_CEntranceGeometryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CEntranceGeometry Function()>>('COptional_CEntranceGeometryMakeDefault');
late final _COptional_CEntranceGeometryMakeDefault = _COptional_CEntranceGeometryMakeDefaultPtr.asFunction<_COptional_CEntranceGeometry Function()>();

late final _COptional_CEntranceGeometry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CEntranceGeometry)>>('COptional_CEntranceGeometry_release');
late final _COptional_CEntranceGeometry_release = _COptional_CEntranceGeometry_releasePtr.asFunction<void Function(_COptional_CEntranceGeometry)>();

late final _CEntranceInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CEntranceInfo Function()>>('CEntranceInfoMakeDefault');
late final _CEntranceInfoMakeDefault = _CEntranceInfoMakeDefaultPtr.asFunction<_CEntranceInfo Function()>();


late final _CFilterTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFilterType Function()>>('CFilterTypeMakeDefault');
late final _CFilterTypeMakeDefault = _CFilterTypeMakeDefaultPtr.asFunction<_CFilterType Function()>();

late final _CFloorInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFloorInfo Function()>>('CFloorInfoMakeDefault');
late final _CFloorInfoMakeDefault = _CFloorInfoMakeDefaultPtr.asFunction<_CFloorInfo Function()>();


late final _CFormattedAddressMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFormattedAddress Function()>>('CFormattedAddressMakeDefault');
late final _CFormattedAddressMakeDefault = _CFormattedAddressMakeDefaultPtr.asFunction<_CFormattedAddress Function()>();


late final _CFormattingTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFormattingType Function()>>('CFormattingTypeMakeDefault');
late final _CFormattingTypeMakeDefault = _CFormattingTypeMakeDefaultPtr.asFunction<_CFormattingType Function()>();

late final _CObjectTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CObjectType Function()>>('CObjectTypeMakeDefault');
late final _CObjectTypeMakeDefault = _CObjectTypeMakeDefaultPtr.asFunction<_CObjectType Function()>();

late final _CGroupItemMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGroupItem Function()>>('CGroupItemMakeDefault');
late final _CGroupItemMakeDefault = _CGroupItemMakeDefaultPtr.asFunction<_CGroupItem Function()>();


late final _CAggregateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAggregate Function()>>('CAggregateMakeDefault');
late final _CAggregateMakeDefault = _CAggregateMakeDefaultPtr.asFunction<_CAggregate Function()>();


late final _CStatusTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatusType Function()>>('CStatusTypeMakeDefault');
late final _CStatusTypeMakeDefault = _CStatusTypeMakeDefaultPtr.asFunction<_CStatusType Function()>();

late final _CConnectorMakeDefaultPtr = _lookup<ffi.NativeFunction<_CConnector Function()>>('CConnectorMakeDefault');
late final _CConnectorMakeDefault = _CConnectorMakeDefaultPtr.asFunction<_CConnector Function()>();


late final _CArray_CConnectormakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CConnector Function()>>('CArray_CConnector_makeEmpty');
late final _CArray_CConnectormakeEmpty = _CArray_CConnectormakeEmptyPtr.asFunction<_CArray_CConnector Function()>();
late final _CArray_CConnectoraddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CConnector, _CConnector)>>('CArray_CConnector_addElement');
late final _CArray_CConnectoraddElement = _CArray_CConnectoraddElementPtr.asFunction<void Function(_CArray_CConnector, _CConnector)>();
late final _forEach_CArray_CConnectorPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CConnector, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CConnector)>>)
>>('CArray_CConnector_forEachWithFunctionPointer');
late final _forEach_CArray_CConnector = _forEach_CArray_CConnectorPtr.asFunction<
  void Function(_CArray_CConnector, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CConnector)
>>)>();
late final _CArray_CConnector_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CConnector)>>('CArray_CConnector_release');
late final _CArray_CConnector_release = _CArray_CConnector_releasePtr.asFunction<void Function(_CArray_CConnector)>();

late final _CChargingStationMakeDefaultPtr = _lookup<ffi.NativeFunction<_CChargingStation Function()>>('CChargingStationMakeDefault');
late final _CChargingStationMakeDefault = _CChargingStationMakeDefaultPtr.asFunction<_CChargingStation Function()>();


late final _CRubricIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRubricId Function()>>('CRubricIdMakeDefault');
late final _CRubricIdMakeDefault = _CRubricIdMakeDefaultPtr.asFunction<_CRubricId Function()>();

late final _CItemMarkerInfo_objectIdPtr = _lookup<ffi.NativeFunction<_COptional_CDgisObjectId Function(_CItemMarkerInfo)>>('CItemMarkerInfo_objectId');
late final _CItemMarkerInfo_objectId = _CItemMarkerInfo_objectIdPtr.asFunction<_COptional_CDgisObjectId Function(_CItemMarkerInfo)>();
late final _CItemMarkerInfo_geoPointPtr = _lookup<ffi.NativeFunction<_CGeoPointWithElevation Function(_CItemMarkerInfo)>>('CItemMarkerInfo_geoPoint');
late final _CItemMarkerInfo_geoPoint = _CItemMarkerInfo_geoPointPtr.asFunction<_CGeoPointWithElevation Function(_CItemMarkerInfo)>();
late final _CItemMarkerInfo_floorInfoPtr = _lookup<ffi.NativeFunction<_COptional_CFloorInfo Function(_CItemMarkerInfo)>>('CItemMarkerInfo_floorInfo');
late final _CItemMarkerInfo_floorInfo = _CItemMarkerInfo_floorInfoPtr.asFunction<_COptional_CFloorInfo Function(_CItemMarkerInfo)>();
late final _CItemMarkerInfo_titlePtr = _lookup<ffi.NativeFunction<_COptional_CString Function(_CItemMarkerInfo)>>('CItemMarkerInfo_title');
late final _CItemMarkerInfo_title = _CItemMarkerInfo_titlePtr.asFunction<_COptional_CString Function(_CItemMarkerInfo)>();
late final _CItemMarkerInfo_rubricIdsPtr = _lookup<ffi.NativeFunction<_CArray_CRubricId Function(_CItemMarkerInfo)>>('CItemMarkerInfo_rubricIds');
late final _CItemMarkerInfo_rubricIds = _CItemMarkerInfo_rubricIdsPtr.asFunction<_CArray_CRubricId Function(_CItemMarkerInfo)>();

late final _CItemMarkerInfo_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CItemMarkerInfo_cg_objectIdentifier');
late final _CItemMarkerInfo_cg_objectIdentifier = _CItemMarkerInfo_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CItemMarkerInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CItemMarkerInfo_release');
late final _CItemMarkerInfo_release = _CItemMarkerInfo_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CItemMarkerInfo_retainPtr = _lookup<ffi.NativeFunction<_CItemMarkerInfo Function(ffi.Pointer<ffi.Void>)>>('CItemMarkerInfo_retain');
late final _CItemMarkerInfo_retain = _CItemMarkerInfo_retainPtr.asFunction<_CItemMarkerInfo Function(ffi.Pointer<ffi.Void>)>();
late final _CItemMarkerInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CItemMarkerInfo Function()>>('CItemMarkerInfoMakeDefault');
late final _CItemMarkerInfoMakeDefault = _CItemMarkerInfoMakeDefaultPtr.asFunction<_CItemMarkerInfo Function()>();


late final _COptional_CDgisObjectIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CDgisObjectId Function()>>('COptional_CDgisObjectIdMakeDefault');
late final _COptional_CDgisObjectIdMakeDefault = _COptional_CDgisObjectIdMakeDefaultPtr.asFunction<_COptional_CDgisObjectId Function()>();

late final _CElevationMakeDefaultPtr = _lookup<ffi.NativeFunction<_CElevation Function()>>('CElevationMakeDefault');
late final _CElevationMakeDefault = _CElevationMakeDefaultPtr.asFunction<_CElevation Function()>();


late final _CGeoPointWithElevationMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGeoPointWithElevation Function()>>('CGeoPointWithElevationMakeDefault');
late final _CGeoPointWithElevationMakeDefault = _CGeoPointWithElevationMakeDefaultPtr.asFunction<_CGeoPointWithElevation Function()>();


late final _COptional_CFloorInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CFloorInfo Function()>>('COptional_CFloorInfoMakeDefault');
late final _COptional_CFloorInfoMakeDefault = _COptional_CFloorInfoMakeDefaultPtr.asFunction<_COptional_CFloorInfo Function()>();

late final _CArray_CRubricIdmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CRubricId Function()>>('CArray_CRubricId_makeEmpty');
late final _CArray_CRubricIdmakeEmpty = _CArray_CRubricIdmakeEmptyPtr.asFunction<_CArray_CRubricId Function()>();
late final _CArray_CRubricIdaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRubricId, _CRubricId)>>('CArray_CRubricId_addElement');
late final _CArray_CRubricIdaddElement = _CArray_CRubricIdaddElementPtr.asFunction<void Function(_CArray_CRubricId, _CRubricId)>();
late final _forEach_CArray_CRubricIdPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CRubricId, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRubricId)>>)
>>('CArray_CRubricId_forEachWithFunctionPointer');
late final _forEach_CArray_CRubricId = _forEach_CArray_CRubricIdPtr.asFunction<
  void Function(_CArray_CRubricId, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRubricId)
>>)>();
late final _CArray_CRubricId_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRubricId)>>('CArray_CRubricId_release');
late final _CArray_CRubricId_release = _CArray_CRubricId_releasePtr.asFunction<void Function(_CArray_CRubricId)>();

late final _CArray_CArray_CWeekTimeIntervalmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CArray_CWeekTimeInterval Function()>>('CArray_CArray_CWeekTimeInterval_makeEmpty');
late final _CArray_CArray_CWeekTimeIntervalmakeEmpty = _CArray_CArray_CWeekTimeIntervalmakeEmptyPtr.asFunction<_CArray_CArray_CWeekTimeInterval Function()>();
late final _CArray_CArray_CWeekTimeIntervaladdElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CArray_CWeekTimeInterval, _CArray_CWeekTimeInterval)>>('CArray_CArray_CWeekTimeInterval_addElement');
late final _CArray_CArray_CWeekTimeIntervaladdElement = _CArray_CArray_CWeekTimeIntervaladdElementPtr.asFunction<void Function(_CArray_CArray_CWeekTimeInterval, _CArray_CWeekTimeInterval)>();
late final _forEach_CArray_CArray_CWeekTimeIntervalPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CArray_CWeekTimeInterval, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CWeekTimeInterval)>>)
>>('CArray_CArray_CWeekTimeInterval_forEachWithFunctionPointer');
late final _forEach_CArray_CArray_CWeekTimeInterval = _forEach_CArray_CArray_CWeekTimeIntervalPtr.asFunction<
  void Function(_CArray_CArray_CWeekTimeInterval, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CWeekTimeInterval)
>>)>();
late final _CArray_CArray_CWeekTimeInterval_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CArray_CWeekTimeInterval)>>('CArray_CArray_CWeekTimeInterval_release');
late final _CArray_CArray_CWeekTimeInterval_release = _CArray_CArray_CWeekTimeInterval_releasePtr.asFunction<void Function(_CArray_CArray_CWeekTimeInterval)>();

late final _COpeningHoursMakeDefaultPtr = _lookup<ffi.NativeFunction<_COpeningHours Function()>>('COpeningHoursMakeDefault');
late final _COpeningHoursMakeDefault = _COpeningHoursMakeDefaultPtr.asFunction<_COpeningHours Function()>();


late final _CArray_CWeekTimeIntervalmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CWeekTimeInterval Function()>>('CArray_CWeekTimeInterval_makeEmpty');
late final _CArray_CWeekTimeIntervalmakeEmpty = _CArray_CWeekTimeIntervalmakeEmptyPtr.asFunction<_CArray_CWeekTimeInterval Function()>();
late final _CArray_CWeekTimeIntervaladdElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CWeekTimeInterval, _CWeekTimeInterval)>>('CArray_CWeekTimeInterval_addElement');
late final _CArray_CWeekTimeIntervaladdElement = _CArray_CWeekTimeIntervaladdElementPtr.asFunction<void Function(_CArray_CWeekTimeInterval, _CWeekTimeInterval)>();
late final _forEach_CArray_CWeekTimeIntervalPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CWeekTimeInterval, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CWeekTimeInterval)>>)
>>('CArray_CWeekTimeInterval_forEachWithFunctionPointer');
late final _forEach_CArray_CWeekTimeInterval = _forEach_CArray_CWeekTimeIntervalPtr.asFunction<
  void Function(_CArray_CWeekTimeInterval, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CWeekTimeInterval)
>>)>();
late final _CArray_CWeekTimeInterval_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CWeekTimeInterval)>>('CArray_CWeekTimeInterval_release');
late final _CArray_CWeekTimeInterval_release = _CArray_CWeekTimeInterval_releasePtr.asFunction<void Function(_CArray_CWeekTimeInterval)>();

late final _COrgIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_COrgId Function()>>('COrgIdMakeDefault');
late final _COrgIdMakeDefault = _COrgIdMakeDefaultPtr.asFunction<_COrgId Function()>();


late final _COrgInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_COrgInfo Function()>>('COrgInfoMakeDefault');
late final _COrgInfoMakeDefault = _COrgInfoMakeDefaultPtr.asFunction<_COrgInfo Function()>();


late final _CParkingAccessMakeDefaultPtr = _lookup<ffi.NativeFunction<_CParkingAccess Function()>>('CParkingAccessMakeDefault');
late final _CParkingAccessMakeDefault = _CParkingAccessMakeDefaultPtr.asFunction<_CParkingAccess Function()>();

late final _CSpecialSpaceTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSpecialSpaceType Function()>>('CSpecialSpaceTypeMakeDefault');
late final _CSpecialSpaceTypeMakeDefault = _CSpecialSpaceTypeMakeDefaultPtr.asFunction<_CSpecialSpaceType Function()>();

late final _CSpecialSpaceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSpecialSpace Function()>>('CSpecialSpaceMakeDefault');
late final _CSpecialSpaceMakeDefault = _CSpecialSpaceMakeDefaultPtr.asFunction<_CSpecialSpace Function()>();


late final _CArray_CSpecialSpacemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CSpecialSpace Function()>>('CArray_CSpecialSpace_makeEmpty');
late final _CArray_CSpecialSpacemakeEmpty = _CArray_CSpecialSpacemakeEmptyPtr.asFunction<_CArray_CSpecialSpace Function()>();
late final _CArray_CSpecialSpaceaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSpecialSpace, _CSpecialSpace)>>('CArray_CSpecialSpace_addElement');
late final _CArray_CSpecialSpaceaddElement = _CArray_CSpecialSpaceaddElementPtr.asFunction<void Function(_CArray_CSpecialSpace, _CSpecialSpace)>();
late final _forEach_CArray_CSpecialSpacePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CSpecialSpace, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSpecialSpace)>>)
>>('CArray_CSpecialSpace_forEachWithFunctionPointer');
late final _forEach_CArray_CSpecialSpace = _forEach_CArray_CSpecialSpacePtr.asFunction<
  void Function(_CArray_CSpecialSpace, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSpecialSpace)
>>)>();
late final _CArray_CSpecialSpace_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSpecialSpace)>>('CArray_CSpecialSpace_release');
late final _CArray_CSpecialSpace_release = _CArray_CSpecialSpace_releasePtr.asFunction<void Function(_CArray_CSpecialSpace)>();

late final _CParkingCapacityMakeDefaultPtr = _lookup<ffi.NativeFunction<_CParkingCapacity Function()>>('CParkingCapacityMakeDefault');
late final _CParkingCapacityMakeDefault = _CParkingCapacityMakeDefaultPtr.asFunction<_CParkingCapacity Function()>();


late final _CParkingTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CParkingType Function()>>('CParkingTypeMakeDefault');
late final _CParkingTypeMakeDefault = _CParkingTypeMakeDefaultPtr.asFunction<_CParkingType Function()>();

late final _CParkingPurposeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CParkingPurpose Function()>>('CParkingPurposeMakeDefault');
late final _CParkingPurposeMakeDefault = _CParkingPurposeMakeDefaultPtr.asFunction<_CParkingPurpose Function()>();

late final _CParkingPavingTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CParkingPavingType Function()>>('CParkingPavingTypeMakeDefault');
late final _CParkingPavingTypeMakeDefault = _CParkingPavingTypeMakeDefaultPtr.asFunction<_CParkingPavingType Function()>();

late final _COptional_CParkingTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CParkingType Function()>>('COptional_CParkingTypeMakeDefault');
late final _COptional_CParkingTypeMakeDefault = _COptional_CParkingTypeMakeDefaultPtr.asFunction<_COptional_CParkingType Function()>();

late final _COptional_CParkingPavingTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CParkingPavingType Function()>>('COptional_CParkingPavingTypeMakeDefault');
late final _COptional_CParkingPavingTypeMakeDefault = _COptional_CParkingPavingTypeMakeDefaultPtr.asFunction<_COptional_CParkingPavingType Function()>();

late final _COptional_uint16_tMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_uint16_t Function()>>('COptional_uint16_tMakeDefault');
late final _COptional_uint16_tMakeDefault = _COptional_uint16_tMakeDefaultPtr.asFunction<_COptional_uint16_t Function()>();

late final _COptional_CParkingCapacityMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CParkingCapacity Function()>>('COptional_CParkingCapacityMakeDefault');
late final _COptional_CParkingCapacityMakeDefault = _COptional_CParkingCapacityMakeDefaultPtr.asFunction<_COptional_CParkingCapacity Function()>();

late final _COptional_CParkingCapacity_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CParkingCapacity)>>('COptional_CParkingCapacity_release');
late final _COptional_CParkingCapacity_release = _COptional_CParkingCapacity_releasePtr.asFunction<void Function(_COptional_CParkingCapacity)>();

late final _CParkingInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CParkingInfo Function()>>('CParkingInfoMakeDefault');
late final _CParkingInfoMakeDefault = _CParkingInfoMakeDefaultPtr.asFunction<_CParkingInfo Function()>();


late final _CReviewsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CReviews Function()>>('CReviewsMakeDefault');
late final _CReviewsMakeDefault = _CReviewsMakeDefaultPtr.asFunction<_CReviews Function()>();


late final _CSearchResultTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchResultType Function()>>('CSearchResultTypeMakeDefault');
late final _CSearchResultTypeMakeDefault = _CSearchResultTypeMakeDefaultPtr.asFunction<_CSearchResultType Function()>();

late final _CSortingTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSortingType Function()>>('CSortingTypeMakeDefault');
late final _CSortingTypeMakeDefault = _CSortingTypeMakeDefaultPtr.asFunction<_CSortingType Function()>();

late final _CTradeLicenseMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTradeLicense Function()>>('CTradeLicenseMakeDefault');
late final _CTradeLicenseMakeDefault = _CTradeLicenseMakeDefaultPtr.asFunction<_CTradeLicense Function()>();


late final _CUIMarkerInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CUIMarkerInfo Function()>>('CUIMarkerInfoMakeDefault');
late final _CUIMarkerInfoMakeDefault = _CUIMarkerInfoMakeDefaultPtr.asFunction<_CUIMarkerInfo Function()>();


late final _CWorkStatusMakeDefaultPtr = _lookup<ffi.NativeFunction<_CWorkStatus Function()>>('CWorkStatusMakeDefault');
late final _CWorkStatusMakeDefault = _CWorkStatusMakeDefaultPtr.asFunction<_CWorkStatus Function()>();


late final _CAddressAdmDivMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAddressAdmDiv Function()>>('CAddressAdmDivMakeDefault');
late final _CAddressAdmDivMakeDefault = _CAddressAdmDivMakeDefaultPtr.asFunction<_CAddressAdmDiv Function()>();


late final _CAddressStreetMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAddressStreet Function()>>('CAddressStreetMakeDefault');
late final _CAddressStreetMakeDefault = _CAddressStreetMakeDefaultPtr.asFunction<_CAddressStreet Function()>();


late final _CAddressNumberMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAddressNumber Function()>>('CAddressNumberMakeDefault');
late final _CAddressNumberMakeDefault = _CAddressNumberMakeDefaultPtr.asFunction<_CAddressNumber Function()>();


late final _CAddressLocationMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAddressLocation Function()>>('CAddressLocationMakeDefault');
late final _CAddressLocationMakeDefault = _CAddressLocationMakeDefaultPtr.asFunction<_CAddressLocation Function()>();


late final _CAddressComponent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAddressComponent)>>('CAddressComponent_release');
late final _CAddressComponent_release = _CAddressComponent_releasePtr.asFunction<void Function(_CAddressComponent)>();
late final _CAddressComponentMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAddressComponent Function()>>('CAddressComponentMakeDefault');
late final _CAddressComponentMakeDefault = _CAddressComponentMakeDefaultPtr.asFunction<_CAddressComponent Function()>();

late final _CArray_CAddressAdmDivmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CAddressAdmDiv Function()>>('CArray_CAddressAdmDiv_makeEmpty');
late final _CArray_CAddressAdmDivmakeEmpty = _CArray_CAddressAdmDivmakeEmptyPtr.asFunction<_CArray_CAddressAdmDiv Function()>();
late final _CArray_CAddressAdmDivaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CAddressAdmDiv, _CAddressAdmDiv)>>('CArray_CAddressAdmDiv_addElement');
late final _CArray_CAddressAdmDivaddElement = _CArray_CAddressAdmDivaddElementPtr.asFunction<void Function(_CArray_CAddressAdmDiv, _CAddressAdmDiv)>();
late final _forEach_CArray_CAddressAdmDivPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CAddressAdmDiv, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CAddressAdmDiv)>>)
>>('CArray_CAddressAdmDiv_forEachWithFunctionPointer');
late final _forEach_CArray_CAddressAdmDiv = _forEach_CArray_CAddressAdmDivPtr.asFunction<
  void Function(_CArray_CAddressAdmDiv, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CAddressAdmDiv)
>>)>();
late final _CArray_CAddressAdmDiv_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CAddressAdmDiv)>>('CArray_CAddressAdmDiv_release');
late final _CArray_CAddressAdmDiv_release = _CArray_CAddressAdmDiv_releasePtr.asFunction<void Function(_CArray_CAddressAdmDiv)>();

late final _CArray_CAddressComponentmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CAddressComponent Function()>>('CArray_CAddressComponent_makeEmpty');
late final _CArray_CAddressComponentmakeEmpty = _CArray_CAddressComponentmakeEmptyPtr.asFunction<_CArray_CAddressComponent Function()>();
late final _CArray_CAddressComponentaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CAddressComponent, _CAddressComponent)>>('CArray_CAddressComponent_addElement');
late final _CArray_CAddressComponentaddElement = _CArray_CAddressComponentaddElementPtr.asFunction<void Function(_CArray_CAddressComponent, _CAddressComponent)>();
late final _forEach_CArray_CAddressComponentPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CAddressComponent, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CAddressComponent)>>)
>>('CArray_CAddressComponent_forEachWithFunctionPointer');
late final _forEach_CArray_CAddressComponent = _forEach_CArray_CAddressComponentPtr.asFunction<
  void Function(_CArray_CAddressComponent, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CAddressComponent)
>>)>();
late final _CArray_CAddressComponent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CAddressComponent)>>('CArray_CAddressComponent_release');
late final _CArray_CAddressComponent_release = _CArray_CAddressComponent_releasePtr.asFunction<void Function(_CArray_CAddressComponent)>();

late final _CAddressMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAddress Function()>>('CAddressMakeDefault');
late final _CAddressMakeDefault = _CAddressMakeDefaultPtr.asFunction<_CAddress Function()>();

late final _CDirectoryObject_typesPtr = _lookup<ffi.NativeFunction<_CArray_CObjectType Function(_CDirectoryObject)>>('CDirectoryObject_types');
late final _CDirectoryObject_types = _CDirectoryObject_typesPtr.asFunction<_CArray_CObjectType Function(_CDirectoryObject)>();
late final _CDirectoryObject_titlePtr = _lookup<ffi.NativeFunction<_CString Function(_CDirectoryObject)>>('CDirectoryObject_title');
late final _CDirectoryObject_title = _CDirectoryObject_titlePtr.asFunction<_CString Function(_CDirectoryObject)>();
late final _CDirectoryObject_titleAdditionPtr = _lookup<ffi.NativeFunction<_CString Function(_CDirectoryObject)>>('CDirectoryObject_titleAddition');
late final _CDirectoryObject_titleAddition = _CDirectoryObject_titleAdditionPtr.asFunction<_CString Function(_CDirectoryObject)>();
late final _CDirectoryObject_subtitlePtr = _lookup<ffi.NativeFunction<_CString Function(_CDirectoryObject)>>('CDirectoryObject_subtitle');
late final _CDirectoryObject_subtitle = _CDirectoryObject_subtitlePtr.asFunction<_CString Function(_CDirectoryObject)>();
late final _CDirectoryObject_descriptionPtr = _lookup<ffi.NativeFunction<_CString Function(_CDirectoryObject)>>('CDirectoryObject_description');
late final _CDirectoryObject_description = _CDirectoryObject_descriptionPtr.asFunction<_CString Function(_CDirectoryObject)>();
late final _CDirectoryObject_idPtr = _lookup<ffi.NativeFunction<_COptional_CDgisObjectId Function(_CDirectoryObject)>>('CDirectoryObject_id');
late final _CDirectoryObject_id = _CDirectoryObject_idPtr.asFunction<_COptional_CDgisObjectId Function(_CDirectoryObject)>();
late final _CDirectoryObject_markerPositionPtr = _lookup<ffi.NativeFunction<_COptional_CGeoPointWithElevation Function(_CDirectoryObject)>>('CDirectoryObject_markerPosition');
late final _CDirectoryObject_markerPosition = _CDirectoryObject_markerPositionPtr.asFunction<_COptional_CGeoPointWithElevation Function(_CDirectoryObject)>();
late final _CDirectoryObject_addressPtr = _lookup<ffi.NativeFunction<_COptional_CAddress Function(_CDirectoryObject)>>('CDirectoryObject_address');
late final _CDirectoryObject_address = _CDirectoryObject_addressPtr.asFunction<_COptional_CAddress Function(_CDirectoryObject)>();
late final _CDirectoryObject_attributesPtr = _lookup<ffi.NativeFunction<_CArray_CAttribute Function(_CDirectoryObject)>>('CDirectoryObject_attributes');
late final _CDirectoryObject_attributes = _CDirectoryObject_attributesPtr.asFunction<_CArray_CAttribute Function(_CDirectoryObject)>();
late final _CDirectoryObject_contextAttributesPtr = _lookup<ffi.NativeFunction<_CArray_CAttribute Function(_CDirectoryObject)>>('CDirectoryObject_contextAttributes');
late final _CDirectoryObject_contextAttributes = _CDirectoryObject_contextAttributesPtr.asFunction<_CArray_CAttribute Function(_CDirectoryObject)>();
late final _CDirectoryObject_timeZoneOffsetPtr = _lookup<ffi.NativeFunction<_COptional_CTimeInterval Function(_CDirectoryObject)>>('CDirectoryObject_timeZoneOffset');
late final _CDirectoryObject_timeZoneOffset = _CDirectoryObject_timeZoneOffsetPtr.asFunction<_COptional_CTimeInterval Function(_CDirectoryObject)>();
late final _CDirectoryObject_openingHoursPtr = _lookup<ffi.NativeFunction<_COptional_COpeningHours Function(_CDirectoryObject)>>('CDirectoryObject_openingHours');
late final _CDirectoryObject_openingHours = _CDirectoryObject_openingHoursPtr.asFunction<_COptional_COpeningHours Function(_CDirectoryObject)>();
late final _CDirectoryObject_contactInfosPtr = _lookup<ffi.NativeFunction<_CArray_CContactInfo Function(_CDirectoryObject)>>('CDirectoryObject_contactInfos');
late final _CDirectoryObject_contactInfos = _CDirectoryObject_contactInfosPtr.asFunction<_CArray_CContactInfo Function(_CDirectoryObject)>();
late final _CDirectoryObject_reviewsPtr = _lookup<ffi.NativeFunction<_COptional_CReviews Function(_CDirectoryObject)>>('CDirectoryObject_reviews');
late final _CDirectoryObject_reviews = _CDirectoryObject_reviewsPtr.asFunction<_COptional_CReviews Function(_CDirectoryObject)>();
late final _CDirectoryObject_parkingInfoPtr = _lookup<ffi.NativeFunction<_COptional_CParkingInfo Function(_CDirectoryObject)>>('CDirectoryObject_parkingInfo');
late final _CDirectoryObject_parkingInfo = _CDirectoryObject_parkingInfoPtr.asFunction<_COptional_CParkingInfo Function(_CDirectoryObject)>();
late final _CDirectoryObject_workStatusPtr = _lookup<ffi.NativeFunction<_COptional_CWorkStatus Function(_CDirectoryObject)>>('CDirectoryObject_workStatus');
late final _CDirectoryObject_workStatus = _CDirectoryObject_workStatusPtr.asFunction<_COptional_CWorkStatus Function(_CDirectoryObject)>();
late final _CDirectoryObject_levelIdPtr = _lookup<ffi.NativeFunction<_COptional_CLevelId Function(_CDirectoryObject)>>('CDirectoryObject_levelId');
late final _CDirectoryObject_levelId = _CDirectoryObject_levelIdPtr.asFunction<_COptional_CLevelId Function(_CDirectoryObject)>();
late final _CDirectoryObject_buildingLevelsPtr = _lookup<ffi.NativeFunction<_COptional_CBuildingLevels Function(_CDirectoryObject)>>('CDirectoryObject_buildingLevels');
late final _CDirectoryObject_buildingLevels = _CDirectoryObject_buildingLevelsPtr.asFunction<_COptional_CBuildingLevels Function(_CDirectoryObject)>();
late final _CDirectoryObject_entrancesPtr = _lookup<ffi.NativeFunction<_CArray_CEntranceInfo Function(_CDirectoryObject)>>('CDirectoryObject_entrances');
late final _CDirectoryObject_entrances = _CDirectoryObject_entrancesPtr.asFunction<_CArray_CEntranceInfo Function(_CDirectoryObject)>();
late final _CDirectoryObject_tradeLicensePtr = _lookup<ffi.NativeFunction<_COptional_CTradeLicense Function(_CDirectoryObject)>>('CDirectoryObject_tradeLicense');
late final _CDirectoryObject_tradeLicense = _CDirectoryObject_tradeLicensePtr.asFunction<_COptional_CTradeLicense Function(_CDirectoryObject)>();
late final _CDirectoryObject_buildingInfoPtr = _lookup<ffi.NativeFunction<_CBuildingInfo Function(_CDirectoryObject)>>('CDirectoryObject_buildingInfo');
late final _CDirectoryObject_buildingInfo = _CDirectoryObject_buildingInfoPtr.asFunction<_CBuildingInfo Function(_CDirectoryObject)>();
late final _CDirectoryObject_chargingStationPtr = _lookup<ffi.NativeFunction<_COptional_CChargingStation Function(_CDirectoryObject)>>('CDirectoryObject_chargingStation');
late final _CDirectoryObject_chargingStation = _CDirectoryObject_chargingStationPtr.asFunction<_COptional_CChargingStation Function(_CDirectoryObject)>();
late final _CDirectoryObject_rubricIdsPtr = _lookup<ffi.NativeFunction<_CArray_CRubricId Function(_CDirectoryObject)>>('CDirectoryObject_rubricIds');
late final _CDirectoryObject_rubricIds = _CDirectoryObject_rubricIdsPtr.asFunction<_CArray_CRubricId Function(_CDirectoryObject)>();
late final _CDirectoryObject_orgInfoPtr = _lookup<ffi.NativeFunction<_COptional_COrgInfo Function(_CDirectoryObject)>>('CDirectoryObject_orgInfo');
late final _CDirectoryObject_orgInfo = _CDirectoryObject_orgInfoPtr.asFunction<_COptional_COrgInfo Function(_CDirectoryObject)>();
late final _CDirectoryObject_groupPtr = _lookup<ffi.NativeFunction<_CArray_CGroupItem Function(_CDirectoryObject)>>('CDirectoryObject_group');
late final _CDirectoryObject_group = _CDirectoryObject_groupPtr.asFunction<_CArray_CGroupItem Function(_CDirectoryObject)>();

late final _CDirectoryObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CDirectoryObject_cg_objectIdentifier');
late final _CDirectoryObject_cg_objectIdentifier = _CDirectoryObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CDirectoryObject_formattedAddress_CFormattingTypePtr = _lookup<ffi.NativeFunction<_COptional_CFormattedAddress Function(_CDirectoryObject, _CFormattingType)>>('CDirectoryObject_formattedAddress_CFormattingType');
late final _CDirectoryObject_formattedAddress_CFormattingType = _CDirectoryObject_formattedAddress_CFormattingTypePtr.asFunction<_COptional_CFormattedAddress Function(_CDirectoryObject, _CFormattingType)>();

late final _CDirectoryObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CDirectoryObject_release');
late final _CDirectoryObject_release = _CDirectoryObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectoryObject_retainPtr = _lookup<ffi.NativeFunction<_CDirectoryObject Function(ffi.Pointer<ffi.Void>)>>('CDirectoryObject_retain');
late final _CDirectoryObject_retain = _CDirectoryObject_retainPtr.asFunction<_CDirectoryObject Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectoryObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDirectoryObject Function()>>('CDirectoryObjectMakeDefault');
late final _CDirectoryObjectMakeDefault = _CDirectoryObjectMakeDefaultPtr.asFunction<_CDirectoryObject Function()>();


late final _CArray_CObjectTypemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CObjectType Function()>>('CArray_CObjectType_makeEmpty');
late final _CArray_CObjectTypemakeEmpty = _CArray_CObjectTypemakeEmptyPtr.asFunction<_CArray_CObjectType Function()>();
late final _CArray_CObjectTypeaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CObjectType, _CObjectType)>>('CArray_CObjectType_addElement');
late final _CArray_CObjectTypeaddElement = _CArray_CObjectTypeaddElementPtr.asFunction<void Function(_CArray_CObjectType, _CObjectType)>();
late final _forEach_CArray_CObjectTypePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CObjectType, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CObjectType)>>)
>>('CArray_CObjectType_forEachWithFunctionPointer');
late final _forEach_CArray_CObjectType = _forEach_CArray_CObjectTypePtr.asFunction<
  void Function(_CArray_CObjectType, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CObjectType)
>>)>();
late final _CArray_CObjectType_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CObjectType)>>('CArray_CObjectType_release');
late final _CArray_CObjectType_release = _CArray_CObjectType_releasePtr.asFunction<void Function(_CArray_CObjectType)>();

late final _COptional_CGeoPointWithElevationMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CGeoPointWithElevation Function()>>('COptional_CGeoPointWithElevationMakeDefault');
late final _COptional_CGeoPointWithElevationMakeDefault = _COptional_CGeoPointWithElevationMakeDefaultPtr.asFunction<_COptional_CGeoPointWithElevation Function()>();

late final _COptional_CAddressMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CAddress Function()>>('COptional_CAddressMakeDefault');
late final _COptional_CAddressMakeDefault = _COptional_CAddressMakeDefaultPtr.asFunction<_COptional_CAddress Function()>();

late final _COptional_CAddress_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CAddress)>>('COptional_CAddress_release');
late final _COptional_CAddress_release = _COptional_CAddress_releasePtr.asFunction<void Function(_COptional_CAddress)>();

late final _CArray_CAttributemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CAttribute Function()>>('CArray_CAttribute_makeEmpty');
late final _CArray_CAttributemakeEmpty = _CArray_CAttributemakeEmptyPtr.asFunction<_CArray_CAttribute Function()>();
late final _CArray_CAttributeaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CAttribute, _CAttribute)>>('CArray_CAttribute_addElement');
late final _CArray_CAttributeaddElement = _CArray_CAttributeaddElementPtr.asFunction<void Function(_CArray_CAttribute, _CAttribute)>();
late final _forEach_CArray_CAttributePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CAttribute, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CAttribute)>>)
>>('CArray_CAttribute_forEachWithFunctionPointer');
late final _forEach_CArray_CAttribute = _forEach_CArray_CAttributePtr.asFunction<
  void Function(_CArray_CAttribute, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CAttribute)
>>)>();
late final _CArray_CAttribute_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CAttribute)>>('CArray_CAttribute_release');
late final _CArray_CAttribute_release = _CArray_CAttribute_releasePtr.asFunction<void Function(_CArray_CAttribute)>();

late final _COptional_CFormattedAddressMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CFormattedAddress Function()>>('COptional_CFormattedAddressMakeDefault');
late final _COptional_CFormattedAddressMakeDefault = _COptional_CFormattedAddressMakeDefaultPtr.asFunction<_COptional_CFormattedAddress Function()>();

late final _COptional_CFormattedAddress_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CFormattedAddress)>>('COptional_CFormattedAddress_release');
late final _COptional_CFormattedAddress_release = _COptional_CFormattedAddress_releasePtr.asFunction<void Function(_COptional_CFormattedAddress)>();

late final _COptional_CTimeIntervalMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CTimeInterval Function()>>('COptional_CTimeIntervalMakeDefault');
late final _COptional_CTimeIntervalMakeDefault = _COptional_CTimeIntervalMakeDefaultPtr.asFunction<_COptional_CTimeInterval Function()>();

late final _COptional_COpeningHoursMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_COpeningHours Function()>>('COptional_COpeningHoursMakeDefault');
late final _COptional_COpeningHoursMakeDefault = _COptional_COpeningHoursMakeDefaultPtr.asFunction<_COptional_COpeningHours Function()>();

late final _COptional_COpeningHours_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_COpeningHours)>>('COptional_COpeningHours_release');
late final _COptional_COpeningHours_release = _COptional_COpeningHours_releasePtr.asFunction<void Function(_COptional_COpeningHours)>();

late final _CArray_CContactInfomakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CContactInfo Function()>>('CArray_CContactInfo_makeEmpty');
late final _CArray_CContactInfomakeEmpty = _CArray_CContactInfomakeEmptyPtr.asFunction<_CArray_CContactInfo Function()>();
late final _CArray_CContactInfoaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CContactInfo, _CContactInfo)>>('CArray_CContactInfo_addElement');
late final _CArray_CContactInfoaddElement = _CArray_CContactInfoaddElementPtr.asFunction<void Function(_CArray_CContactInfo, _CContactInfo)>();
late final _forEach_CArray_CContactInfoPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CContactInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CContactInfo)>>)
>>('CArray_CContactInfo_forEachWithFunctionPointer');
late final _forEach_CArray_CContactInfo = _forEach_CArray_CContactInfoPtr.asFunction<
  void Function(_CArray_CContactInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CContactInfo)
>>)>();
late final _CArray_CContactInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CContactInfo)>>('CArray_CContactInfo_release');
late final _CArray_CContactInfo_release = _CArray_CContactInfo_releasePtr.asFunction<void Function(_CArray_CContactInfo)>();

late final _COptional_CReviewsMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CReviews Function()>>('COptional_CReviewsMakeDefault');
late final _COptional_CReviewsMakeDefault = _COptional_CReviewsMakeDefaultPtr.asFunction<_COptional_CReviews Function()>();

late final _COptional_CParkingInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CParkingInfo Function()>>('COptional_CParkingInfoMakeDefault');
late final _COptional_CParkingInfoMakeDefault = _COptional_CParkingInfoMakeDefaultPtr.asFunction<_COptional_CParkingInfo Function()>();

late final _COptional_CParkingInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CParkingInfo)>>('COptional_CParkingInfo_release');
late final _COptional_CParkingInfo_release = _COptional_CParkingInfo_releasePtr.asFunction<void Function(_COptional_CParkingInfo)>();

late final _COptional_CWorkStatusMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CWorkStatus Function()>>('COptional_CWorkStatusMakeDefault');
late final _COptional_CWorkStatusMakeDefault = _COptional_CWorkStatusMakeDefaultPtr.asFunction<_COptional_CWorkStatus Function()>();

late final _COptional_CWorkStatus_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CWorkStatus)>>('COptional_CWorkStatus_release');
late final _COptional_CWorkStatus_release = _COptional_CWorkStatus_releasePtr.asFunction<void Function(_COptional_CWorkStatus)>();

late final _COptional_CLevelIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CLevelId Function()>>('COptional_CLevelIdMakeDefault');
late final _COptional_CLevelIdMakeDefault = _COptional_CLevelIdMakeDefaultPtr.asFunction<_COptional_CLevelId Function()>();

late final _CArray_CEntranceInfomakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CEntranceInfo Function()>>('CArray_CEntranceInfo_makeEmpty');
late final _CArray_CEntranceInfomakeEmpty = _CArray_CEntranceInfomakeEmptyPtr.asFunction<_CArray_CEntranceInfo Function()>();
late final _CArray_CEntranceInfoaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CEntranceInfo, _CEntranceInfo)>>('CArray_CEntranceInfo_addElement');
late final _CArray_CEntranceInfoaddElement = _CArray_CEntranceInfoaddElementPtr.asFunction<void Function(_CArray_CEntranceInfo, _CEntranceInfo)>();
late final _forEach_CArray_CEntranceInfoPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CEntranceInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CEntranceInfo)>>)
>>('CArray_CEntranceInfo_forEachWithFunctionPointer');
late final _forEach_CArray_CEntranceInfo = _forEach_CArray_CEntranceInfoPtr.asFunction<
  void Function(_CArray_CEntranceInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CEntranceInfo)
>>)>();
late final _CArray_CEntranceInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CEntranceInfo)>>('CArray_CEntranceInfo_release');
late final _CArray_CEntranceInfo_release = _CArray_CEntranceInfo_releasePtr.asFunction<void Function(_CArray_CEntranceInfo)>();

late final _COptional_CTradeLicenseMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CTradeLicense Function()>>('COptional_CTradeLicenseMakeDefault');
late final _COptional_CTradeLicenseMakeDefault = _COptional_CTradeLicenseMakeDefaultPtr.asFunction<_COptional_CTradeLicense Function()>();

late final _COptional_CTradeLicense_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CTradeLicense)>>('COptional_CTradeLicense_release');
late final _COptional_CTradeLicense_release = _COptional_CTradeLicense_releasePtr.asFunction<void Function(_COptional_CTradeLicense)>();

late final _COptional_CChargingStationMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CChargingStation Function()>>('COptional_CChargingStationMakeDefault');
late final _COptional_CChargingStationMakeDefault = _COptional_CChargingStationMakeDefaultPtr.asFunction<_COptional_CChargingStation Function()>();

late final _COptional_CChargingStation_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CChargingStation)>>('COptional_CChargingStation_release');
late final _COptional_CChargingStation_release = _COptional_CChargingStation_releasePtr.asFunction<void Function(_COptional_CChargingStation)>();

late final _COptional_COrgInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_COrgInfo Function()>>('COptional_COrgInfoMakeDefault');
late final _COptional_COrgInfoMakeDefault = _COptional_COrgInfoMakeDefaultPtr.asFunction<_COptional_COrgInfo Function()>();

late final _COptional_COrgInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_COrgInfo)>>('COptional_COrgInfo_release');
late final _COptional_COrgInfo_release = _COptional_COrgInfo_releasePtr.asFunction<void Function(_COptional_COrgInfo)>();

late final _CArray_CGroupItemmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CGroupItem Function()>>('CArray_CGroupItem_makeEmpty');
late final _CArray_CGroupItemmakeEmpty = _CArray_CGroupItemmakeEmptyPtr.asFunction<_CArray_CGroupItem Function()>();
late final _CArray_CGroupItemaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CGroupItem, _CGroupItem)>>('CArray_CGroupItem_addElement');
late final _CArray_CGroupItemaddElement = _CArray_CGroupItemaddElementPtr.asFunction<void Function(_CArray_CGroupItem, _CGroupItem)>();
late final _forEach_CArray_CGroupItemPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CGroupItem, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGroupItem)>>)
>>('CArray_CGroupItem_forEachWithFunctionPointer');
late final _forEach_CArray_CGroupItem = _forEach_CArray_CGroupItemPtr.asFunction<
  void Function(_CArray_CGroupItem, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGroupItem)
>>)>();
late final _CArray_CGroupItem_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CGroupItem)>>('CArray_CGroupItem_release');
late final _CArray_CGroupItem_release = _CArray_CGroupItem_releasePtr.asFunction<void Function(_CArray_CGroupItem)>();
late final _CPage_itemsPtr = _lookup<ffi.NativeFunction<_CArray_CDirectoryObject Function(_CPage)>>('CPage_items');
late final _CPage_items = _CPage_itemsPtr.asFunction<_CArray_CDirectoryObject Function(_CPage)>();

late final _CPage_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPage_cg_objectIdentifier');
late final _CPage_cg_objectIdentifier = _CPage_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPage_fetchPrevPagePtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CPage Function(_CPage)>>('CPage_fetchPrevPage');
late final _CPage_fetchPrevPage = _CPage_fetchPrevPagePtr.asFunction<_CFuture_COptional_CPage Function(_CPage)>();
late final _CPage_fetchNextPagePtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CPage Function(_CPage)>>('CPage_fetchNextPage');
late final _CPage_fetchNextPage = _CPage_fetchNextPagePtr.asFunction<_CFuture_COptional_CPage Function(_CPage)>();

late final _CPage_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPage_release');
late final _CPage_release = _CPage_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPage_retainPtr = _lookup<ffi.NativeFunction<_CPage Function(ffi.Pointer<ffi.Void>)>>('CPage_retain');
late final _CPage_retain = _CPage_retainPtr.asFunction<_CPage Function(ffi.Pointer<ffi.Void>)>();
late final _CPageMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPage Function()>>('CPageMakeDefault');
late final _CPageMakeDefault = _CPageMakeDefaultPtr.asFunction<_CPage Function()>();


late final _CArray_CDirectoryObjectmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CDirectoryObject Function()>>('CArray_CDirectoryObject_makeEmpty');
late final _CArray_CDirectoryObjectmakeEmpty = _CArray_CDirectoryObjectmakeEmptyPtr.asFunction<_CArray_CDirectoryObject Function()>();
late final _CArray_CDirectoryObjectaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CDirectoryObject, _CDirectoryObject)>>('CArray_CDirectoryObject_addElement');
late final _CArray_CDirectoryObjectaddElement = _CArray_CDirectoryObjectaddElementPtr.asFunction<void Function(_CArray_CDirectoryObject, _CDirectoryObject)>();
late final _forEach_CArray_CDirectoryObjectPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CDirectoryObject, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDirectoryObject)>>)
>>('CArray_CDirectoryObject_forEachWithFunctionPointer');
late final _forEach_CArray_CDirectoryObject = _forEach_CArray_CDirectoryObjectPtr.asFunction<
  void Function(_CArray_CDirectoryObject, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDirectoryObject)
>>)>();
late final _CArray_CDirectoryObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CDirectoryObject)>>('CArray_CDirectoryObject_release');
late final _CArray_CDirectoryObject_release = _CArray_CDirectoryObject_releasePtr.asFunction<void Function(_CArray_CDirectoryObject)>();

late final _CFuture_COptional_CPageMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CPage Function()>>('CFuture_COptional_CPageMakeDefault');
late final _CFuture_COptional_CPageMakeDefault = _CFuture_COptional_CPageMakeDefaultPtr.asFunction<_CFuture_COptional_CPage Function()>();
late final _CFuture_COptional_CPage_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_COptional_CPage)>>('CFuture_COptional_CPage_release');
late final _CFuture_COptional_CPage_release = _CFuture_COptional_CPage_releasePtr.asFunction<void Function(_CFuture_COptional_CPage)>();
late final _CFuture_COptional_CPage_retainPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CPage Function(_CFuture_COptional_CPage)>>('CFuture_COptional_CPage_retain');
late final _CFuture_COptional_CPage_retain = _CFuture_COptional_CPage_retainPtr.asFunction<_CFuture_COptional_CPage Function(_CFuture_COptional_CPage)>();
late final _CFuture_COptional_CPageReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_COptional_CPage,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CPage, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_COptional_CPage_receive');
late final _CFuture_COptional_CPageReceive = _CFuture_COptional_CPageReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_COptional_CPage,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CPage, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _COptional_CPageMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CPage Function()>>('COptional_CPageMakeDefault');
late final _COptional_CPageMakeDefault = _COptional_CPageMakeDefaultPtr.asFunction<_COptional_CPage Function()>();

late final _COptional_CPage_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CPage)>>('COptional_CPage_release');
late final _COptional_CPage_release = _COptional_CPage_releasePtr.asFunction<void Function(_COptional_CPage)>();

late final _CCancellableMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCancellable Function()>>('CCancellableMakeDefault');
late final _CCancellableMakeDefault = _CCancellableMakeDefaultPtr.asFunction<_CCancellable Function()>();
late final _CCancellable_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCancellable)>>('CCancellable_release');
late final _CCancellable_release = _CCancellable_releasePtr.asFunction<void Function(_CCancellable)>();
late final _CCancellable_retainPtr = _lookup<ffi.NativeFunction<_CCancellable Function(_CCancellable)>>('CCancellable_retain');
late final _CCancellable_retain = _CCancellable_retainPtr.asFunction<_CCancellable Function(_CCancellable)>();
late final _CCancellableCancelPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCancellable)>>('CCancellable_cancel');
late final _CCancellableCancel = _CCancellableCancelPtr.asFunction<void Function(_CCancellable)>();

late final _CErrorCreateWithDescriptionPtr = _lookup<ffi.NativeFunction<_CError Function(ffi.Pointer<ffi_package.Utf8>)>>('CError_createWithDescription');
late final _CErrorCreateWithDescription = _CErrorCreateWithDescriptionPtr.asFunction<_CError Function(ffi.Pointer<ffi_package.Utf8>)>();
late final _CErrorMakeDefaultPtr = _lookup<ffi.NativeFunction<_CError Function()>>('CErrorMakeDefault');
late final _CErrorMakeDefault = _CErrorMakeDefaultPtr.asFunction<_CError Function()>();
late final _CError_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CError)>>('CError_release');
late final _CError_release = _CError_releasePtr.asFunction<void Function(_CError)>();
late final _CErrorGetDescriptionPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi_package.Utf8> Function(_CError)>>('CError_getDescription');
late final _CErrorGetDescription = _CErrorGetDescriptionPtr.asFunction<ffi.Pointer<ffi_package.Utf8> Function(_CError)>();

late final _CWidgetTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CWidgetType Function()>>('CWidgetTypeMakeDefault');
late final _CWidgetTypeMakeDefault = _CWidgetTypeMakeDefaultPtr.asFunction<_CWidgetType Function()>();
late final _CWidget_typePtr = _lookup<ffi.NativeFunction<_CWidgetType Function(_CWidget)>>('CWidget_type');
late final _CWidget_type = _CWidget_typePtr.asFunction<_CWidgetType Function(_CWidget)>();
late final _CWidget_captionPtr = _lookup<ffi.NativeFunction<_COptional_CString Function(_CWidget)>>('CWidget_caption');
late final _CWidget_caption = _CWidget_captionPtr.asFunction<_COptional_CString Function(_CWidget)>();
late final _CWidget_filtersPtr = _lookup<ffi.NativeFunction<_CArray_CDynamicFilter Function(_CWidget)>>('CWidget_filters');
late final _CWidget_filters = _CWidget_filtersPtr.asFunction<_CArray_CDynamicFilter Function(_CWidget)>();

late final _CWidget_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CWidget_cg_objectIdentifier');
late final _CWidget_cg_objectIdentifier = _CWidget_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CWidget_cg_getSelectorPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CWidget)>>('CWidget_cg_getSelector');
late final _CWidget_cg_getSelector = _CWidget_cg_getSelectorPtr.asFunction<int Function(_CWidget)>();

late final _CWidget_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CWidget_release');
late final _CWidget_release = _CWidget_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CWidget_retainPtr = _lookup<ffi.NativeFunction<_CWidget Function(ffi.Pointer<ffi.Void>)>>('CWidget_retain');
late final _CWidget_retain = _CWidget_retainPtr.asFunction<_CWidget Function(ffi.Pointer<ffi.Void>)>();
late final _CWidgetMakeDefaultPtr = _lookup<ffi.NativeFunction<_CWidget Function()>>('CWidgetMakeDefault');
late final _CWidgetMakeDefault = _CWidgetMakeDefaultPtr.asFunction<_CWidget Function()>();

late final _CCheckbox_filterTypePtr = _lookup<ffi.NativeFunction<_CFilterType Function(_CCheckbox)>>('CCheckbox_filterType');
late final _CCheckbox_filterType = _CCheckbox_filterTypePtr.asFunction<_CFilterType Function(_CCheckbox)>();
late final _CCheckbox_checkedTextPtr = _lookup<ffi.NativeFunction<_COptional_CString Function(_CCheckbox)>>('CCheckbox_checkedText');
late final _CCheckbox_checkedText = _CCheckbox_checkedTextPtr.asFunction<_COptional_CString Function(_CCheckbox)>();
late final _CCheckbox_uncheckedTextPtr = _lookup<ffi.NativeFunction<_COptional_CString Function(_CCheckbox)>>('CCheckbox_uncheckedText');
late final _CCheckbox_uncheckedText = _CCheckbox_uncheckedTextPtr.asFunction<_COptional_CString Function(_CCheckbox)>();
late final _CCheckbox_valuesPtr = _lookup<ffi.NativeFunction<_CArray_CString Function(_CCheckbox)>>('CCheckbox_values');
late final _CCheckbox_values = _CCheckbox_valuesPtr.asFunction<_CArray_CString Function(_CCheckbox)>();
late final _CCheckbox_isCheckedPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CCheckbox)>>('CCheckbox_isChecked');
late final _CCheckbox_isChecked = _CCheckbox_isCheckedPtr.asFunction<bool Function(_CCheckbox)>();
late final _CCheckbox_setChecked_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCheckbox, ffi.Bool)>>('CCheckbox_setChecked_bool');
late final _CCheckbox_setChecked_bool = _CCheckbox_setChecked_boolPtr.asFunction<void Function(_CCheckbox, bool)>();

late final _CCheckbox_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCheckbox_cg_objectIdentifier');
late final _CCheckbox_cg_objectIdentifier = _CCheckbox_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CCheckbox_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCheckbox_release');
late final _CCheckbox_release = _CCheckbox_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCheckbox_retainPtr = _lookup<ffi.NativeFunction<_CCheckbox Function(ffi.Pointer<ffi.Void>)>>('CCheckbox_retain');
late final _CCheckbox_retain = _CCheckbox_retainPtr.asFunction<_CCheckbox Function(ffi.Pointer<ffi.Void>)>();
late final _CCheckboxMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCheckbox Function()>>('CCheckboxMakeDefault');
late final _CCheckboxMakeDefault = _CCheckboxMakeDefaultPtr.asFunction<_CCheckbox Function()>();


late final _CArray_CStringmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CString Function()>>('CArray_CString_makeEmpty');
late final _CArray_CStringmakeEmpty = _CArray_CStringmakeEmptyPtr.asFunction<_CArray_CString Function()>();
late final _CArray_CStringaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CString, _CString)>>('CArray_CString_addElement');
late final _CArray_CStringaddElement = _CArray_CStringaddElementPtr.asFunction<void Function(_CArray_CString, _CString)>();
late final _forEach_CArray_CStringPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CString, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CString)>>)
>>('CArray_CString_forEachWithFunctionPointer');
late final _forEach_CArray_CString = _forEach_CArray_CStringPtr.asFunction<
  void Function(_CArray_CString, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CString)
>>)>();
late final _CArray_CString_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CString)>>('CArray_CString_release');
late final _CArray_CString_release = _CArray_CString_releasePtr.asFunction<void Function(_CArray_CString)>();

late final _CCheckableItemTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCheckableItemType Function()>>('CCheckableItemTypeMakeDefault');
late final _CCheckableItemTypeMakeDefault = _CCheckableItemTypeMakeDefaultPtr.asFunction<_CCheckableItemType Function()>();
late final _CCheckableItem_typePtr = _lookup<ffi.NativeFunction<_CCheckableItemType Function(_CCheckableItem)>>('CCheckableItem_type');
late final _CCheckableItem_type = _CCheckableItem_typePtr.asFunction<_CCheckableItemType Function(_CCheckableItem)>();
late final _CCheckableItem_filterTypePtr = _lookup<ffi.NativeFunction<_CFilterType Function(_CCheckableItem)>>('CCheckableItem_filterType');
late final _CCheckableItem_filterType = _CCheckableItem_filterTypePtr.asFunction<_CFilterType Function(_CCheckableItem)>();

late final _CCheckableItem_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCheckableItem_cg_objectIdentifier');
late final _CCheckableItem_cg_objectIdentifier = _CCheckableItem_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CCheckableItem_cg_getSelectorPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CCheckableItem)>>('CCheckableItem_cg_getSelector');
late final _CCheckableItem_cg_getSelector = _CCheckableItem_cg_getSelectorPtr.asFunction<int Function(_CCheckableItem)>();

late final _CCheckableItem_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCheckableItem_release');
late final _CCheckableItem_release = _CCheckableItem_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCheckableItem_retainPtr = _lookup<ffi.NativeFunction<_CCheckableItem Function(ffi.Pointer<ffi.Void>)>>('CCheckableItem_retain');
late final _CCheckableItem_retain = _CCheckableItem_retainPtr.asFunction<_CCheckableItem Function(ffi.Pointer<ffi.Void>)>();
late final _CCheckableItemMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCheckableItem Function()>>('CCheckableItemMakeDefault');
late final _CCheckableItemMakeDefault = _CCheckableItemMakeDefaultPtr.asFunction<_CCheckableItem Function()>();

late final _CCheckableGroupedItem_textPtr = _lookup<ffi.NativeFunction<_CString Function(_CCheckableGroupedItem)>>('CCheckableGroupedItem_text');
late final _CCheckableGroupedItem_text = _CCheckableGroupedItem_textPtr.asFunction<_CString Function(_CCheckableGroupedItem)>();
late final _CCheckableGroupedItem_valuesPtr = _lookup<ffi.NativeFunction<_CArray_CString Function(_CCheckableGroupedItem)>>('CCheckableGroupedItem_values');
late final _CCheckableGroupedItem_values = _CCheckableGroupedItem_valuesPtr.asFunction<_CArray_CString Function(_CCheckableGroupedItem)>();
late final _CCheckableGroupedItem_isCheckedPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CCheckableGroupedItem)>>('CCheckableGroupedItem_isChecked');
late final _CCheckableGroupedItem_isChecked = _CCheckableGroupedItem_isCheckedPtr.asFunction<bool Function(_CCheckableGroupedItem)>();
late final _CCheckableGroupedItem_setChecked_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCheckableGroupedItem, ffi.Bool)>>('CCheckableGroupedItem_setChecked_bool');
late final _CCheckableGroupedItem_setChecked_bool = _CCheckableGroupedItem_setChecked_boolPtr.asFunction<void Function(_CCheckableGroupedItem, bool)>();

late final _CCheckableGroupedItem_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCheckableGroupedItem_cg_objectIdentifier');
late final _CCheckableGroupedItem_cg_objectIdentifier = _CCheckableGroupedItem_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CCheckableGroupedItem_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCheckableGroupedItem_release');
late final _CCheckableGroupedItem_release = _CCheckableGroupedItem_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCheckableGroupedItem_retainPtr = _lookup<ffi.NativeFunction<_CCheckableGroupedItem Function(ffi.Pointer<ffi.Void>)>>('CCheckableGroupedItem_retain');
late final _CCheckableGroupedItem_retain = _CCheckableGroupedItem_retainPtr.asFunction<_CCheckableGroupedItem Function(ffi.Pointer<ffi.Void>)>();
late final _CCheckableGroupedItemMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCheckableGroupedItem Function()>>('CCheckableGroupedItemMakeDefault');
late final _CCheckableGroupedItemMakeDefault = _CCheckableGroupedItemMakeDefaultPtr.asFunction<_CCheckableGroupedItem Function()>();

late final _CCheckableItemsGroup_itemsPtr = _lookup<ffi.NativeFunction<_CArray_CCheckableItem Function(_CCheckableItemsGroup)>>('CCheckableItemsGroup_items');
late final _CCheckableItemsGroup_items = _CCheckableItemsGroup_itemsPtr.asFunction<_CArray_CCheckableItem Function(_CCheckableItemsGroup)>();

late final _CCheckableItemsGroup_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCheckableItemsGroup_cg_objectIdentifier');
late final _CCheckableItemsGroup_cg_objectIdentifier = _CCheckableItemsGroup_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CCheckableItemsGroup_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCheckableItemsGroup_release');
late final _CCheckableItemsGroup_release = _CCheckableItemsGroup_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCheckableItemsGroup_retainPtr = _lookup<ffi.NativeFunction<_CCheckableItemsGroup Function(ffi.Pointer<ffi.Void>)>>('CCheckableItemsGroup_retain');
late final _CCheckableItemsGroup_retain = _CCheckableItemsGroup_retainPtr.asFunction<_CCheckableItemsGroup Function(ffi.Pointer<ffi.Void>)>();
late final _CCheckableItemsGroupMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCheckableItemsGroup Function()>>('CCheckableItemsGroupMakeDefault');
late final _CCheckableItemsGroupMakeDefault = _CCheckableItemsGroupMakeDefaultPtr.asFunction<_CCheckableItemsGroup Function()>();


late final _CArray_CCheckableItemmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CCheckableItem Function()>>('CArray_CCheckableItem_makeEmpty');
late final _CArray_CCheckableItemmakeEmpty = _CArray_CCheckableItemmakeEmptyPtr.asFunction<_CArray_CCheckableItem Function()>();
late final _CArray_CCheckableItemaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CCheckableItem, _CCheckableItem)>>('CArray_CCheckableItem_addElement');
late final _CArray_CCheckableItemaddElement = _CArray_CCheckableItemaddElementPtr.asFunction<void Function(_CArray_CCheckableItem, _CCheckableItem)>();
late final _forEach_CArray_CCheckableItemPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CCheckableItem, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCheckableItem)>>)
>>('CArray_CCheckableItem_forEachWithFunctionPointer');
late final _forEach_CArray_CCheckableItem = _forEach_CArray_CCheckableItemPtr.asFunction<
  void Function(_CArray_CCheckableItem, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCheckableItem)
>>)>();
late final _CArray_CCheckableItem_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CCheckableItem)>>('CArray_CCheckableItem_release');
late final _CArray_CCheckableItem_release = _CArray_CCheckableItem_releasePtr.asFunction<void Function(_CArray_CCheckableItem)>();
late final _CSimpleCheckableItem_textPtr = _lookup<ffi.NativeFunction<_CString Function(_CSimpleCheckableItem)>>('CSimpleCheckableItem_text');
late final _CSimpleCheckableItem_text = _CSimpleCheckableItem_textPtr.asFunction<_CString Function(_CSimpleCheckableItem)>();
late final _CSimpleCheckableItem_valuesPtr = _lookup<ffi.NativeFunction<_CArray_CString Function(_CSimpleCheckableItem)>>('CSimpleCheckableItem_values');
late final _CSimpleCheckableItem_values = _CSimpleCheckableItem_valuesPtr.asFunction<_CArray_CString Function(_CSimpleCheckableItem)>();
late final _CSimpleCheckableItem_isCheckedPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CSimpleCheckableItem)>>('CSimpleCheckableItem_isChecked');
late final _CSimpleCheckableItem_isChecked = _CSimpleCheckableItem_isCheckedPtr.asFunction<bool Function(_CSimpleCheckableItem)>();
late final _CSimpleCheckableItem_setChecked_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleCheckableItem, ffi.Bool)>>('CSimpleCheckableItem_setChecked_bool');
late final _CSimpleCheckableItem_setChecked_bool = _CSimpleCheckableItem_setChecked_boolPtr.asFunction<void Function(_CSimpleCheckableItem, bool)>();

late final _CSimpleCheckableItem_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSimpleCheckableItem_cg_objectIdentifier');
late final _CSimpleCheckableItem_cg_objectIdentifier = _CSimpleCheckableItem_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CSimpleCheckableItem_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSimpleCheckableItem_release');
late final _CSimpleCheckableItem_release = _CSimpleCheckableItem_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSimpleCheckableItem_retainPtr = _lookup<ffi.NativeFunction<_CSimpleCheckableItem Function(ffi.Pointer<ffi.Void>)>>('CSimpleCheckableItem_retain');
late final _CSimpleCheckableItem_retain = _CSimpleCheckableItem_retainPtr.asFunction<_CSimpleCheckableItem Function(ffi.Pointer<ffi.Void>)>();
late final _CSimpleCheckableItemMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSimpleCheckableItem Function()>>('CSimpleCheckableItemMakeDefault');
late final _CSimpleCheckableItemMakeDefault = _CSimpleCheckableItemMakeDefaultPtr.asFunction<_CSimpleCheckableItem Function()>();

late final _CGroupCheckableItem_itemsPtr = _lookup<ffi.NativeFunction<_CArray_CCheckableGroupedItem Function(_CGroupCheckableItem)>>('CGroupCheckableItem_items');
late final _CGroupCheckableItem_items = _CGroupCheckableItem_itemsPtr.asFunction<_CArray_CCheckableGroupedItem Function(_CGroupCheckableItem)>();

late final _CGroupCheckableItem_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CGroupCheckableItem_cg_objectIdentifier');
late final _CGroupCheckableItem_cg_objectIdentifier = _CGroupCheckableItem_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CGroupCheckableItem_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CGroupCheckableItem_release');
late final _CGroupCheckableItem_release = _CGroupCheckableItem_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CGroupCheckableItem_retainPtr = _lookup<ffi.NativeFunction<_CGroupCheckableItem Function(ffi.Pointer<ffi.Void>)>>('CGroupCheckableItem_retain');
late final _CGroupCheckableItem_retain = _CGroupCheckableItem_retainPtr.asFunction<_CGroupCheckableItem Function(ffi.Pointer<ffi.Void>)>();
late final _CGroupCheckableItemMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGroupCheckableItem Function()>>('CGroupCheckableItemMakeDefault');
late final _CGroupCheckableItemMakeDefault = _CGroupCheckableItemMakeDefaultPtr.asFunction<_CGroupCheckableItem Function()>();


late final _CArray_CCheckableGroupedItemmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CCheckableGroupedItem Function()>>('CArray_CCheckableGroupedItem_makeEmpty');
late final _CArray_CCheckableGroupedItemmakeEmpty = _CArray_CCheckableGroupedItemmakeEmptyPtr.asFunction<_CArray_CCheckableGroupedItem Function()>();
late final _CArray_CCheckableGroupedItemaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CCheckableGroupedItem, _CCheckableGroupedItem)>>('CArray_CCheckableGroupedItem_addElement');
late final _CArray_CCheckableGroupedItemaddElement = _CArray_CCheckableGroupedItemaddElementPtr.asFunction<void Function(_CArray_CCheckableGroupedItem, _CCheckableGroupedItem)>();
late final _forEach_CArray_CCheckableGroupedItemPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CCheckableGroupedItem, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCheckableGroupedItem)>>)
>>('CArray_CCheckableGroupedItem_forEachWithFunctionPointer');
late final _forEach_CArray_CCheckableGroupedItem = _forEach_CArray_CCheckableGroupedItemPtr.asFunction<
  void Function(_CArray_CCheckableGroupedItem, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCheckableGroupedItem)
>>)>();
late final _CArray_CCheckableGroupedItem_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CCheckableGroupedItem)>>('CArray_CCheckableGroupedItem_release');
late final _CArray_CCheckableGroupedItem_release = _CArray_CCheckableGroupedItem_releasePtr.asFunction<void Function(_CArray_CCheckableGroupedItem)>();

late final _CBordersMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBorders Function()>>('CBordersMakeDefault');
late final _CBordersMakeDefault = _CBordersMakeDefaultPtr.asFunction<_CBorders Function()>();


late final _COrderedValueMakeDefaultPtr = _lookup<ffi.NativeFunction<_COrderedValue Function()>>('COrderedValueMakeDefault');
late final _COrderedValueMakeDefault = _COrderedValueMakeDefaultPtr.asFunction<_COrderedValue Function()>();


late final _CArray_COrderedValuemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_COrderedValue Function()>>('CArray_COrderedValue_makeEmpty');
late final _CArray_COrderedValuemakeEmpty = _CArray_COrderedValuemakeEmptyPtr.asFunction<_CArray_COrderedValue Function()>();
late final _CArray_COrderedValueaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_COrderedValue, _COrderedValue)>>('CArray_COrderedValue_addElement');
late final _CArray_COrderedValueaddElement = _CArray_COrderedValueaddElementPtr.asFunction<void Function(_CArray_COrderedValue, _COrderedValue)>();
late final _forEach_CArray_COrderedValuePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_COrderedValue, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COrderedValue)>>)
>>('CArray_COrderedValue_forEachWithFunctionPointer');
late final _forEach_CArray_COrderedValue = _forEach_CArray_COrderedValuePtr.asFunction<
  void Function(_CArray_COrderedValue, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COrderedValue)
>>)>();
late final _CArray_COrderedValue_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_COrderedValue)>>('CArray_COrderedValue_release');
late final _CArray_COrderedValue_release = _CArray_COrderedValue_releasePtr.asFunction<void Function(_CArray_COrderedValue)>();

late final _COrderedValuesMakeDefaultPtr = _lookup<ffi.NativeFunction<_COrderedValues Function()>>('COrderedValuesMakeDefault');
late final _COrderedValuesMakeDefault = _COrderedValuesMakeDefaultPtr.asFunction<_COrderedValues Function()>();


late final _CRange_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRange)>>('CRange_release');
late final _CRange_release = _CRange_releasePtr.asFunction<void Function(_CRange)>();
late final _CRangeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRange Function()>>('CRangeMakeDefault');
late final _CRangeMakeDefault = _CRangeMakeDefaultPtr.asFunction<_CRange Function()>();
late final _CRangeWidget_rangePtr = _lookup<ffi.NativeFunction<_CRange Function(_CRangeWidget)>>('CRangeWidget_range');
late final _CRangeWidget_range = _CRangeWidget_rangePtr.asFunction<_CRange Function(_CRangeWidget)>();

late final _CRangeWidget_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRangeWidget_cg_objectIdentifier');
late final _CRangeWidget_cg_objectIdentifier = _CRangeWidget_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRangeWidget_setValues_double_doublePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRangeWidget, ffi.Double, ffi.Double)>>('CRangeWidget_setValues_double_double');
late final _CRangeWidget_setValues_double_double = _CRangeWidget_setValues_double_doublePtr.asFunction<void Function(_CRangeWidget, double, double)>();

late final _CRangeWidget_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRangeWidget_release');
late final _CRangeWidget_release = _CRangeWidget_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRangeWidget_retainPtr = _lookup<ffi.NativeFunction<_CRangeWidget Function(ffi.Pointer<ffi.Void>)>>('CRangeWidget_retain');
late final _CRangeWidget_retain = _CRangeWidget_retainPtr.asFunction<_CRangeWidget Function(ffi.Pointer<ffi.Void>)>();
late final _CRangeWidgetMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRangeWidget Function()>>('CRangeWidgetMakeDefault');
late final _CRangeWidgetMakeDefault = _CRangeWidgetMakeDefaultPtr.asFunction<_CRangeWidget Function()>();

late final _CSearchResult_firstPagePtr = _lookup<ffi.NativeFunction<_COptional_CPage Function(_CSearchResult)>>('CSearchResult_firstPage');
late final _CSearchResult_firstPage = _CSearchResult_firstPagePtr.asFunction<_COptional_CPage Function(_CSearchResult)>();
late final _CSearchResult_representativeAreaPtr = _lookup<ffi.NativeFunction<_COptional_CGeometry Function(_CSearchResult)>>('CSearchResult_representativeArea');
late final _CSearchResult_representativeArea = _CSearchResult_representativeAreaPtr.asFunction<_COptional_CGeometry Function(_CSearchResult)>();
late final _CSearchResult_itemMarkerInfosPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CArray_CItemMarkerInfo Function(_CSearchResult)>>('CSearchResult_itemMarkerInfos');
late final _CSearchResult_itemMarkerInfos = _CSearchResult_itemMarkerInfosPtr.asFunction<_CFuture_COptional_CArray_CItemMarkerInfo Function(_CSearchResult)>();
late final _CSearchResult_searchResultTypePtr = _lookup<ffi.NativeFunction<_CSearchResultType Function(_CSearchResult)>>('CSearchResult_searchResultType');
late final _CSearchResult_searchResultType = _CSearchResult_searchResultTypePtr.asFunction<_CSearchResultType Function(_CSearchResult)>();
late final _CSearchResult_dynamicFiltersPtr = _lookup<ffi.NativeFunction<_CArray_CDynamicFilter Function(_CSearchResult)>>('CSearchResult_dynamicFilters');
late final _CSearchResult_dynamicFilters = _CSearchResult_dynamicFiltersPtr.asFunction<_CArray_CDynamicFilter Function(_CSearchResult)>();
late final _CSearchResult_actionWidgetsPtr = _lookup<ffi.NativeFunction<_CArray_CWidget Function(_CSearchResult)>>('CSearchResult_actionWidgets');
late final _CSearchResult_actionWidgets = _CSearchResult_actionWidgetsPtr.asFunction<_CArray_CWidget Function(_CSearchResult)>();
late final _CSearchResult_mainWidgetsPtr = _lookup<ffi.NativeFunction<_CArray_CWidget Function(_CSearchResult)>>('CSearchResult_mainWidgets');
late final _CSearchResult_mainWidgets = _CSearchResult_mainWidgetsPtr.asFunction<_CArray_CWidget Function(_CSearchResult)>();
late final _CSearchResult_autoUseFirstResultPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CSearchResult)>>('CSearchResult_autoUseFirstResult');
late final _CSearchResult_autoUseFirstResult = _CSearchResult_autoUseFirstResultPtr.asFunction<bool Function(_CSearchResult)>();

late final _CSearchResult_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSearchResult_cg_objectIdentifier');
late final _CSearchResult_cg_objectIdentifier = _CSearchResult_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSearchResult_markerTitles_CArray_CDgisObjectIdPtr = _lookup<ffi.NativeFunction<_CArray_CFuture_CArray_CUIMarkerInfo Function(_CSearchResult, _CArray_CDgisObjectId)>>('CSearchResult_markerTitles_CArray_CDgisObjectId');
late final _CSearchResult_markerTitles_CArray_CDgisObjectId = _CSearchResult_markerTitles_CArray_CDgisObjectIdPtr.asFunction<_CArray_CFuture_CArray_CUIMarkerInfo Function(_CSearchResult, _CArray_CDgisObjectId)>();

late final _CSearchResult_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSearchResult_release');
late final _CSearchResult_release = _CSearchResult_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchResult_retainPtr = _lookup<ffi.NativeFunction<_CSearchResult Function(ffi.Pointer<ffi.Void>)>>('CSearchResult_retain');
late final _CSearchResult_retain = _CSearchResult_retainPtr.asFunction<_CSearchResult Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchResult Function()>>('CSearchResultMakeDefault');
late final _CSearchResultMakeDefault = _CSearchResultMakeDefaultPtr.asFunction<_CSearchResult Function()>();


late final _CGeometryKindMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGeometryKind Function()>>('CGeometryKindMakeDefault');
late final _CGeometryKindMakeDefault = _CGeometryKindMakeDefaultPtr.asFunction<_CGeometryKind Function()>();
late final _CGeometry_kindPtr = _lookup<ffi.NativeFunction<_CGeometryKind Function(_CGeometry)>>('CGeometry_kind');
late final _CGeometry_kind = _CGeometry_kindPtr.asFunction<_CGeometryKind Function(_CGeometry)>();
late final _CGeometry_boundsPtr = _lookup<ffi.NativeFunction<_CGeoRect Function(_CGeometry)>>('CGeometry_bounds');
late final _CGeometry_bounds = _CGeometry_boundsPtr.asFunction<_CGeoRect Function(_CGeometry)>();
late final _CGeometry_minPointPtr = _lookup<ffi.NativeFunction<_CGeoPoint Function(_CGeometry)>>('CGeometry_minPoint');
late final _CGeometry_minPoint = _CGeometry_minPointPtr.asFunction<_CGeoPoint Function(_CGeometry)>();
late final _CGeometry_maxPointPtr = _lookup<ffi.NativeFunction<_CGeoPoint Function(_CGeometry)>>('CGeometry_maxPoint');
late final _CGeometry_maxPoint = _CGeometry_maxPointPtr.asFunction<_CGeoPoint Function(_CGeometry)>();

late final _CGeometry_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CGeometry_cg_objectIdentifier');
late final _CGeometry_cg_objectIdentifier = _CGeometry_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CGeometry_intersects_CGeometryPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CGeometry, _CGeometry)>>('CGeometry_intersects_CGeometry');
late final _CGeometry_intersects_CGeometry = _CGeometry_intersects_CGeometryPtr.asFunction<bool Function(_CGeometry, _CGeometry)>();
late final _CGeometry_cg_getSelectorPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CGeometry)>>('CGeometry_cg_getSelector');
late final _CGeometry_cg_getSelector = _CGeometry_cg_getSelectorPtr.asFunction<int Function(_CGeometry)>();

late final _CGeometry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CGeometry_release');
late final _CGeometry_release = _CGeometry_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CGeometry_retainPtr = _lookup<ffi.NativeFunction<_CGeometry Function(ffi.Pointer<ffi.Void>)>>('CGeometry_retain');
late final _CGeometry_retain = _CGeometry_retainPtr.asFunction<_CGeometry Function(ffi.Pointer<ffi.Void>)>();
late final _CGeometryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGeometry Function()>>('CGeometryMakeDefault');
late final _CGeometryMakeDefault = _CGeometryMakeDefaultPtr.asFunction<_CGeometry Function()>();


late final _COptional_CGeometryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CGeometry Function()>>('COptional_CGeometryMakeDefault');
late final _COptional_CGeometryMakeDefault = _COptional_CGeometryMakeDefaultPtr.asFunction<_COptional_CGeometry Function()>();

late final _COptional_CGeometry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CGeometry)>>('COptional_CGeometry_release');
late final _COptional_CGeometry_release = _COptional_CGeometry_releasePtr.asFunction<void Function(_COptional_CGeometry)>();

late final _CFuture_COptional_CArray_CItemMarkerInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CArray_CItemMarkerInfo Function()>>('CFuture_COptional_CArray_CItemMarkerInfoMakeDefault');
late final _CFuture_COptional_CArray_CItemMarkerInfoMakeDefault = _CFuture_COptional_CArray_CItemMarkerInfoMakeDefaultPtr.asFunction<_CFuture_COptional_CArray_CItemMarkerInfo Function()>();
late final _CFuture_COptional_CArray_CItemMarkerInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_COptional_CArray_CItemMarkerInfo)>>('CFuture_COptional_CArray_CItemMarkerInfo_release');
late final _CFuture_COptional_CArray_CItemMarkerInfo_release = _CFuture_COptional_CArray_CItemMarkerInfo_releasePtr.asFunction<void Function(_CFuture_COptional_CArray_CItemMarkerInfo)>();
late final _CFuture_COptional_CArray_CItemMarkerInfo_retainPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CArray_CItemMarkerInfo Function(_CFuture_COptional_CArray_CItemMarkerInfo)>>('CFuture_COptional_CArray_CItemMarkerInfo_retain');
late final _CFuture_COptional_CArray_CItemMarkerInfo_retain = _CFuture_COptional_CArray_CItemMarkerInfo_retainPtr.asFunction<_CFuture_COptional_CArray_CItemMarkerInfo Function(_CFuture_COptional_CArray_CItemMarkerInfo)>();
late final _CFuture_COptional_CArray_CItemMarkerInfoReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_COptional_CArray_CItemMarkerInfo,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CArray_CItemMarkerInfo, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_COptional_CArray_CItemMarkerInfo_receive');
late final _CFuture_COptional_CArray_CItemMarkerInfoReceive = _CFuture_COptional_CArray_CItemMarkerInfoReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_COptional_CArray_CItemMarkerInfo,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CArray_CItemMarkerInfo, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CArray_CItemMarkerInfomakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CItemMarkerInfo Function()>>('CArray_CItemMarkerInfo_makeEmpty');
late final _CArray_CItemMarkerInfomakeEmpty = _CArray_CItemMarkerInfomakeEmptyPtr.asFunction<_CArray_CItemMarkerInfo Function()>();
late final _CArray_CItemMarkerInfoaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CItemMarkerInfo, _CItemMarkerInfo)>>('CArray_CItemMarkerInfo_addElement');
late final _CArray_CItemMarkerInfoaddElement = _CArray_CItemMarkerInfoaddElementPtr.asFunction<void Function(_CArray_CItemMarkerInfo, _CItemMarkerInfo)>();
late final _forEach_CArray_CItemMarkerInfoPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CItemMarkerInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CItemMarkerInfo)>>)
>>('CArray_CItemMarkerInfo_forEachWithFunctionPointer');
late final _forEach_CArray_CItemMarkerInfo = _forEach_CArray_CItemMarkerInfoPtr.asFunction<
  void Function(_CArray_CItemMarkerInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CItemMarkerInfo)
>>)>();
late final _CArray_CItemMarkerInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CItemMarkerInfo)>>('CArray_CItemMarkerInfo_release');
late final _CArray_CItemMarkerInfo_release = _CArray_CItemMarkerInfo_releasePtr.asFunction<void Function(_CArray_CItemMarkerInfo)>();

late final _COptional_CArray_CItemMarkerInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CArray_CItemMarkerInfo Function()>>('COptional_CArray_CItemMarkerInfoMakeDefault');
late final _COptional_CArray_CItemMarkerInfoMakeDefault = _COptional_CArray_CItemMarkerInfoMakeDefaultPtr.asFunction<_COptional_CArray_CItemMarkerInfo Function()>();

late final _COptional_CArray_CItemMarkerInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CArray_CItemMarkerInfo)>>('COptional_CArray_CItemMarkerInfo_release');
late final _COptional_CArray_CItemMarkerInfo_release = _COptional_CArray_CItemMarkerInfo_releasePtr.asFunction<void Function(_COptional_CArray_CItemMarkerInfo)>();

late final _CArray_CFuture_CArray_CUIMarkerInfomakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CFuture_CArray_CUIMarkerInfo Function()>>('CArray_CFuture_CArray_CUIMarkerInfo_makeEmpty');
late final _CArray_CFuture_CArray_CUIMarkerInfomakeEmpty = _CArray_CFuture_CArray_CUIMarkerInfomakeEmptyPtr.asFunction<_CArray_CFuture_CArray_CUIMarkerInfo Function()>();
late final _CArray_CFuture_CArray_CUIMarkerInfoaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CFuture_CArray_CUIMarkerInfo, _CFuture_CArray_CUIMarkerInfo)>>('CArray_CFuture_CArray_CUIMarkerInfo_addElement');
late final _CArray_CFuture_CArray_CUIMarkerInfoaddElement = _CArray_CFuture_CArray_CUIMarkerInfoaddElementPtr.asFunction<void Function(_CArray_CFuture_CArray_CUIMarkerInfo, _CFuture_CArray_CUIMarkerInfo)>();
late final _forEach_CArray_CFuture_CArray_CUIMarkerInfoPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CFuture_CArray_CUIMarkerInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CFuture_CArray_CUIMarkerInfo)>>)
>>('CArray_CFuture_CArray_CUIMarkerInfo_forEachWithFunctionPointer');
late final _forEach_CArray_CFuture_CArray_CUIMarkerInfo = _forEach_CArray_CFuture_CArray_CUIMarkerInfoPtr.asFunction<
  void Function(_CArray_CFuture_CArray_CUIMarkerInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CFuture_CArray_CUIMarkerInfo)
>>)>();
late final _CArray_CFuture_CArray_CUIMarkerInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CFuture_CArray_CUIMarkerInfo)>>('CArray_CFuture_CArray_CUIMarkerInfo_release');
late final _CArray_CFuture_CArray_CUIMarkerInfo_release = _CArray_CFuture_CArray_CUIMarkerInfo_releasePtr.asFunction<void Function(_CArray_CFuture_CArray_CUIMarkerInfo)>();

late final _CFuture_CArray_CUIMarkerInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CUIMarkerInfo Function()>>('CFuture_CArray_CUIMarkerInfoMakeDefault');
late final _CFuture_CArray_CUIMarkerInfoMakeDefault = _CFuture_CArray_CUIMarkerInfoMakeDefaultPtr.asFunction<_CFuture_CArray_CUIMarkerInfo Function()>();
late final _CFuture_CArray_CUIMarkerInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CArray_CUIMarkerInfo)>>('CFuture_CArray_CUIMarkerInfo_release');
late final _CFuture_CArray_CUIMarkerInfo_release = _CFuture_CArray_CUIMarkerInfo_releasePtr.asFunction<void Function(_CFuture_CArray_CUIMarkerInfo)>();
late final _CFuture_CArray_CUIMarkerInfo_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CUIMarkerInfo Function(_CFuture_CArray_CUIMarkerInfo)>>('CFuture_CArray_CUIMarkerInfo_retain');
late final _CFuture_CArray_CUIMarkerInfo_retain = _CFuture_CArray_CUIMarkerInfo_retainPtr.asFunction<_CFuture_CArray_CUIMarkerInfo Function(_CFuture_CArray_CUIMarkerInfo)>();
late final _CFuture_CArray_CUIMarkerInfoReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CArray_CUIMarkerInfo,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CUIMarkerInfo, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CArray_CUIMarkerInfo_receive');
late final _CFuture_CArray_CUIMarkerInfoReceive = _CFuture_CArray_CUIMarkerInfoReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CArray_CUIMarkerInfo,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CUIMarkerInfo, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CArray_CUIMarkerInfomakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CUIMarkerInfo Function()>>('CArray_CUIMarkerInfo_makeEmpty');
late final _CArray_CUIMarkerInfomakeEmpty = _CArray_CUIMarkerInfomakeEmptyPtr.asFunction<_CArray_CUIMarkerInfo Function()>();
late final _CArray_CUIMarkerInfoaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CUIMarkerInfo, _CUIMarkerInfo)>>('CArray_CUIMarkerInfo_addElement');
late final _CArray_CUIMarkerInfoaddElement = _CArray_CUIMarkerInfoaddElementPtr.asFunction<void Function(_CArray_CUIMarkerInfo, _CUIMarkerInfo)>();
late final _forEach_CArray_CUIMarkerInfoPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CUIMarkerInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CUIMarkerInfo)>>)
>>('CArray_CUIMarkerInfo_forEachWithFunctionPointer');
late final _forEach_CArray_CUIMarkerInfo = _forEach_CArray_CUIMarkerInfoPtr.asFunction<
  void Function(_CArray_CUIMarkerInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CUIMarkerInfo)
>>)>();
late final _CArray_CUIMarkerInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CUIMarkerInfo)>>('CArray_CUIMarkerInfo_release');
late final _CArray_CUIMarkerInfo_release = _CArray_CUIMarkerInfo_releasePtr.asFunction<void Function(_CArray_CUIMarkerInfo)>();

late final _CArray_CDgisObjectIdmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CDgisObjectId Function()>>('CArray_CDgisObjectId_makeEmpty');
late final _CArray_CDgisObjectIdmakeEmpty = _CArray_CDgisObjectIdmakeEmptyPtr.asFunction<_CArray_CDgisObjectId Function()>();
late final _CArray_CDgisObjectIdaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CDgisObjectId, _CDgisObjectId)>>('CArray_CDgisObjectId_addElement');
late final _CArray_CDgisObjectIdaddElement = _CArray_CDgisObjectIdaddElementPtr.asFunction<void Function(_CArray_CDgisObjectId, _CDgisObjectId)>();
late final _forEach_CArray_CDgisObjectIdPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CDgisObjectId, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDgisObjectId)>>)
>>('CArray_CDgisObjectId_forEachWithFunctionPointer');
late final _forEach_CArray_CDgisObjectId = _forEach_CArray_CDgisObjectIdPtr.asFunction<
  void Function(_CArray_CDgisObjectId, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDgisObjectId)
>>)>();
late final _CArray_CDgisObjectId_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CDgisObjectId)>>('CArray_CDgisObjectId_release');
late final _CArray_CDgisObjectId_release = _CArray_CDgisObjectId_releasePtr.asFunction<void Function(_CArray_CDgisObjectId)>();

late final _CArray_CWidgetmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CWidget Function()>>('CArray_CWidget_makeEmpty');
late final _CArray_CWidgetmakeEmpty = _CArray_CWidgetmakeEmptyPtr.asFunction<_CArray_CWidget Function()>();
late final _CArray_CWidgetaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CWidget, _CWidget)>>('CArray_CWidget_addElement');
late final _CArray_CWidgetaddElement = _CArray_CWidgetaddElementPtr.asFunction<void Function(_CArray_CWidget, _CWidget)>();
late final _forEach_CArray_CWidgetPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CWidget, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CWidget)>>)
>>('CArray_CWidget_forEachWithFunctionPointer');
late final _forEach_CArray_CWidget = _forEach_CArray_CWidgetPtr.asFunction<
  void Function(_CArray_CWidget, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CWidget)
>>)>();
late final _CArray_CWidget_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CWidget)>>('CArray_CWidget_release');
late final _CArray_CWidget_release = _CArray_CWidget_releasePtr.asFunction<void Function(_CArray_CWidget)>();

late final _CSearchQuery_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSearchQuery_cg_objectIdentifier');
late final _CSearchQuery_cg_objectIdentifier = _CSearchQuery_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CSearchQuery_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSearchQuery_release');
late final _CSearchQuery_release = _CSearchQuery_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchQuery_retainPtr = _lookup<ffi.NativeFunction<_CSearchQuery Function(ffi.Pointer<ffi.Void>)>>('CSearchQuery_retain');
late final _CSearchQuery_retain = _CSearchQuery_retainPtr.asFunction<_CSearchQuery Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchQueryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchQuery Function()>>('CSearchQueryMakeDefault');
late final _CSearchQueryMakeDefault = _CSearchQueryMakeDefaultPtr.asFunction<_CSearchQuery Function()>();

late final _CSuggestObjectHandler_itemPtr = _lookup<ffi.NativeFunction<_CDirectoryObject Function(_CSuggestObjectHandler)>>('CSuggestObjectHandler_item');
late final _CSuggestObjectHandler_item = _CSuggestObjectHandler_itemPtr.asFunction<_CDirectoryObject Function(_CSuggestObjectHandler)>();

late final _CSuggestObjectHandler_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSuggestObjectHandler_cg_objectIdentifier');
late final _CSuggestObjectHandler_cg_objectIdentifier = _CSuggestObjectHandler_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CSuggestObjectHandler_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSuggestObjectHandler_release');
late final _CSuggestObjectHandler_release = _CSuggestObjectHandler_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSuggestObjectHandler_retainPtr = _lookup<ffi.NativeFunction<_CSuggestObjectHandler Function(ffi.Pointer<ffi.Void>)>>('CSuggestObjectHandler_retain');
late final _CSuggestObjectHandler_retain = _CSuggestObjectHandler_retainPtr.asFunction<_CSuggestObjectHandler Function(ffi.Pointer<ffi.Void>)>();
late final _CSuggestObjectHandlerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSuggestObjectHandler Function()>>('CSuggestObjectHandlerMakeDefault');
late final _CSuggestObjectHandlerMakeDefault = _CSuggestObjectHandlerMakeDefaultPtr.asFunction<_CSuggestObjectHandler Function()>();

late final _CPerformSearchHandler_searchQueryPtr = _lookup<ffi.NativeFunction<_CSearchQuery Function(_CPerformSearchHandler)>>('CPerformSearchHandler_searchQuery');
late final _CPerformSearchHandler_searchQuery = _CPerformSearchHandler_searchQueryPtr.asFunction<_CSearchQuery Function(_CPerformSearchHandler)>();

late final _CPerformSearchHandler_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPerformSearchHandler_cg_objectIdentifier');
late final _CPerformSearchHandler_cg_objectIdentifier = _CPerformSearchHandler_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CPerformSearchHandler_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPerformSearchHandler_release');
late final _CPerformSearchHandler_release = _CPerformSearchHandler_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPerformSearchHandler_retainPtr = _lookup<ffi.NativeFunction<_CPerformSearchHandler Function(ffi.Pointer<ffi.Void>)>>('CPerformSearchHandler_retain');
late final _CPerformSearchHandler_retain = _CPerformSearchHandler_retainPtr.asFunction<_CPerformSearchHandler Function(ffi.Pointer<ffi.Void>)>();
late final _CPerformSearchHandlerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPerformSearchHandler Function()>>('CPerformSearchHandlerMakeDefault');
late final _CPerformSearchHandlerMakeDefault = _CPerformSearchHandlerMakeDefaultPtr.asFunction<_CPerformSearchHandler Function()>();

late final _CIncompleteTextHandler_queryTextPtr = _lookup<ffi.NativeFunction<_CString Function(_CIncompleteTextHandler)>>('CIncompleteTextHandler_queryText');
late final _CIncompleteTextHandler_queryText = _CIncompleteTextHandler_queryTextPtr.asFunction<_CString Function(_CIncompleteTextHandler)>();

late final _CIncompleteTextHandler_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CIncompleteTextHandler_cg_objectIdentifier');
late final _CIncompleteTextHandler_cg_objectIdentifier = _CIncompleteTextHandler_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CIncompleteTextHandler_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CIncompleteTextHandler_release');
late final _CIncompleteTextHandler_release = _CIncompleteTextHandler_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CIncompleteTextHandler_retainPtr = _lookup<ffi.NativeFunction<_CIncompleteTextHandler Function(ffi.Pointer<ffi.Void>)>>('CIncompleteTextHandler_retain');
late final _CIncompleteTextHandler_retain = _CIncompleteTextHandler_retainPtr.asFunction<_CIncompleteTextHandler Function(ffi.Pointer<ffi.Void>)>();
late final _CIncompleteTextHandlerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CIncompleteTextHandler Function()>>('CIncompleteTextHandlerMakeDefault');
late final _CIncompleteTextHandlerMakeDefault = _CIncompleteTextHandlerMakeDefaultPtr.asFunction<_CIncompleteTextHandler Function()>();


late final _COptional_CSuggestObjectHandlerMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CSuggestObjectHandler Function()>>('COptional_CSuggestObjectHandlerMakeDefault');
late final _COptional_CSuggestObjectHandlerMakeDefault = _COptional_CSuggestObjectHandlerMakeDefaultPtr.asFunction<_COptional_CSuggestObjectHandler Function()>();

late final _COptional_CSuggestObjectHandler_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CSuggestObjectHandler)>>('COptional_CSuggestObjectHandler_release');
late final _COptional_CSuggestObjectHandler_release = _COptional_CSuggestObjectHandler_releasePtr.asFunction<void Function(_COptional_CSuggestObjectHandler)>();

late final _COptional_CPerformSearchHandlerMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CPerformSearchHandler Function()>>('COptional_CPerformSearchHandlerMakeDefault');
late final _COptional_CPerformSearchHandlerMakeDefault = _COptional_CPerformSearchHandlerMakeDefaultPtr.asFunction<_COptional_CPerformSearchHandler Function()>();

late final _COptional_CPerformSearchHandler_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CPerformSearchHandler)>>('COptional_CPerformSearchHandler_release');
late final _COptional_CPerformSearchHandler_release = _COptional_CPerformSearchHandler_releasePtr.asFunction<void Function(_COptional_CPerformSearchHandler)>();

late final _COptional_CIncompleteTextHandlerMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CIncompleteTextHandler Function()>>('COptional_CIncompleteTextHandlerMakeDefault');
late final _COptional_CIncompleteTextHandlerMakeDefault = _COptional_CIncompleteTextHandlerMakeDefaultPtr.asFunction<_COptional_CIncompleteTextHandler Function()>();

late final _COptional_CIncompleteTextHandler_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CIncompleteTextHandler)>>('COptional_CIncompleteTextHandler_release');
late final _COptional_CIncompleteTextHandler_release = _COptional_CIncompleteTextHandler_releasePtr.asFunction<void Function(_COptional_CIncompleteTextHandler)>();

late final _CSuggestHandler_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSuggestHandler)>>('CSuggestHandler_release');
late final _CSuggestHandler_release = _CSuggestHandler_releasePtr.asFunction<void Function(_CSuggestHandler)>();
late final _CSuggestHandlerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSuggestHandler Function()>>('CSuggestHandlerMakeDefault');
late final _CSuggestHandlerMakeDefault = _CSuggestHandlerMakeDefaultPtr.asFunction<_CSuggestHandler Function()>();

late final _CMarkedUpTextSpanMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMarkedUpTextSpan Function()>>('CMarkedUpTextSpanMakeDefault');
late final _CMarkedUpTextSpanMakeDefault = _CMarkedUpTextSpanMakeDefaultPtr.asFunction<_CMarkedUpTextSpan Function()>();


late final _CArray_CMarkedUpTextSpanmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CMarkedUpTextSpan Function()>>('CArray_CMarkedUpTextSpan_makeEmpty');
late final _CArray_CMarkedUpTextSpanmakeEmpty = _CArray_CMarkedUpTextSpanmakeEmptyPtr.asFunction<_CArray_CMarkedUpTextSpan Function()>();
late final _CArray_CMarkedUpTextSpanaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CMarkedUpTextSpan, _CMarkedUpTextSpan)>>('CArray_CMarkedUpTextSpan_addElement');
late final _CArray_CMarkedUpTextSpanaddElement = _CArray_CMarkedUpTextSpanaddElementPtr.asFunction<void Function(_CArray_CMarkedUpTextSpan, _CMarkedUpTextSpan)>();
late final _forEach_CArray_CMarkedUpTextSpanPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CMarkedUpTextSpan, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMarkedUpTextSpan)>>)
>>('CArray_CMarkedUpTextSpan_forEachWithFunctionPointer');
late final _forEach_CArray_CMarkedUpTextSpan = _forEach_CArray_CMarkedUpTextSpanPtr.asFunction<
  void Function(_CArray_CMarkedUpTextSpan, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMarkedUpTextSpan)
>>)>();
late final _CArray_CMarkedUpTextSpan_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CMarkedUpTextSpan)>>('CArray_CMarkedUpTextSpan_release');
late final _CArray_CMarkedUpTextSpan_release = _CArray_CMarkedUpTextSpan_releasePtr.asFunction<void Function(_CArray_CMarkedUpTextSpan)>();

late final _CMarkedUpTextMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMarkedUpText Function()>>('CMarkedUpTextMakeDefault');
late final _CMarkedUpTextMakeDefault = _CMarkedUpTextMakeDefaultPtr.asFunction<_CMarkedUpText Function()>();


late final _CSuggestedTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSuggestedType Function()>>('CSuggestedTypeMakeDefault');
late final _CSuggestedTypeMakeDefault = _CSuggestedTypeMakeDefaultPtr.asFunction<_CSuggestedType Function()>();

late final _CSuggestorTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSuggestorType Function()>>('CSuggestorTypeMakeDefault');
late final _CSuggestorTypeMakeDefault = _CSuggestorTypeMakeDefaultPtr.asFunction<_CSuggestorType Function()>();
late final _CSuggest_handlerPtr = _lookup<ffi.NativeFunction<_CSuggestHandler Function(_CSuggest)>>('CSuggest_handler');
late final _CSuggest_handler = _CSuggest_handlerPtr.asFunction<_CSuggestHandler Function(_CSuggest)>();
late final _CSuggest_suggestedTypePtr = _lookup<ffi.NativeFunction<_CSuggestedType Function(_CSuggest)>>('CSuggest_suggestedType');
late final _CSuggest_suggestedType = _CSuggest_suggestedTypePtr.asFunction<_CSuggestedType Function(_CSuggest)>();
late final _CSuggest_titlePtr = _lookup<ffi.NativeFunction<_CMarkedUpText Function(_CSuggest)>>('CSuggest_title');
late final _CSuggest_title = _CSuggest_titlePtr.asFunction<_CMarkedUpText Function(_CSuggest)>();
late final _CSuggest_subtitlePtr = _lookup<ffi.NativeFunction<_CMarkedUpText Function(_CSuggest)>>('CSuggest_subtitle');
late final _CSuggest_subtitle = _CSuggest_subtitlePtr.asFunction<_CMarkedUpText Function(_CSuggest)>();

late final _CSuggest_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSuggest_cg_objectIdentifier');
late final _CSuggest_cg_objectIdentifier = _CSuggest_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CSuggest_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSuggest_release');
late final _CSuggest_release = _CSuggest_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSuggest_retainPtr = _lookup<ffi.NativeFunction<_CSuggest Function(ffi.Pointer<ffi.Void>)>>('CSuggest_retain');
late final _CSuggest_retain = _CSuggest_retainPtr.asFunction<_CSuggest Function(ffi.Pointer<ffi.Void>)>();
late final _CSuggestMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSuggest Function()>>('CSuggestMakeDefault');
late final _CSuggestMakeDefault = _CSuggestMakeDefaultPtr.asFunction<_CSuggest Function()>();

late final _CSuggestResult_suggestsPtr = _lookup<ffi.NativeFunction<_CArray_CSuggest Function(_CSuggestResult)>>('CSuggestResult_suggests');
late final _CSuggestResult_suggests = _CSuggestResult_suggestsPtr.asFunction<_CArray_CSuggest Function(_CSuggestResult)>();

late final _CSuggestResult_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSuggestResult_cg_objectIdentifier');
late final _CSuggestResult_cg_objectIdentifier = _CSuggestResult_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CSuggestResult_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSuggestResult_release');
late final _CSuggestResult_release = _CSuggestResult_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSuggestResult_retainPtr = _lookup<ffi.NativeFunction<_CSuggestResult Function(ffi.Pointer<ffi.Void>)>>('CSuggestResult_retain');
late final _CSuggestResult_retain = _CSuggestResult_retainPtr.asFunction<_CSuggestResult Function(ffi.Pointer<ffi.Void>)>();
late final _CSuggestResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSuggestResult Function()>>('CSuggestResultMakeDefault');
late final _CSuggestResultMakeDefault = _CSuggestResultMakeDefaultPtr.asFunction<_CSuggestResult Function()>();


late final _CArray_CSuggestmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CSuggest Function()>>('CArray_CSuggest_makeEmpty');
late final _CArray_CSuggestmakeEmpty = _CArray_CSuggestmakeEmptyPtr.asFunction<_CArray_CSuggest Function()>();
late final _CArray_CSuggestaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSuggest, _CSuggest)>>('CArray_CSuggest_addElement');
late final _CArray_CSuggestaddElement = _CArray_CSuggestaddElementPtr.asFunction<void Function(_CArray_CSuggest, _CSuggest)>();
late final _forEach_CArray_CSuggestPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CSuggest, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSuggest)>>)
>>('CArray_CSuggest_forEachWithFunctionPointer');
late final _forEach_CArray_CSuggest = _forEach_CArray_CSuggestPtr.asFunction<
  void Function(_CArray_CSuggest, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSuggest)
>>)>();
late final _CArray_CSuggest_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSuggest)>>('CArray_CSuggest_release');
late final _CArray_CSuggest_release = _CArray_CSuggest_releasePtr.asFunction<void Function(_CArray_CSuggest)>();

late final _CSuggestQuery_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSuggestQuery_cg_objectIdentifier');
late final _CSuggestQuery_cg_objectIdentifier = _CSuggestQuery_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CSuggestQuery_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSuggestQuery_release');
late final _CSuggestQuery_release = _CSuggestQuery_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSuggestQuery_retainPtr = _lookup<ffi.NativeFunction<_CSuggestQuery Function(ffi.Pointer<ffi.Void>)>>('CSuggestQuery_retain');
late final _CSuggestQuery_retain = _CSuggestQuery_retainPtr.asFunction<_CSuggestQuery Function(ffi.Pointer<ffi.Void>)>();
late final _CSuggestQueryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSuggestQuery Function()>>('CSuggestQueryMakeDefault');
late final _CSuggestQueryMakeDefault = _CSuggestQueryMakeDefaultPtr.asFunction<_CSuggestQuery Function()>();


late final _CSearchManager_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSearchManager_cg_objectIdentifier');
late final _CSearchManager_cg_objectIdentifier = _CSearchManager_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSearchManager_S_createOnlineManager_CContextPtr = _lookup<ffi.NativeFunction<_CResult_CSearchManager Function(_CContext)>>('CSearchManager_S_createOnlineManager_CContext');
late final _CSearchManager_S_createOnlineManager_CContext = _CSearchManager_S_createOnlineManager_CContextPtr.asFunction<_CResult_CSearchManager Function(_CContext)>();
late final _CSearchManager_suggest_CSuggestQueryPtr = _lookup<ffi.NativeFunction<_CFuture_CSuggestResult Function(_CSearchManager, _CSuggestQuery)>>('CSearchManager_suggest_CSuggestQuery');
late final _CSearchManager_suggest_CSuggestQuery = _CSearchManager_suggest_CSuggestQueryPtr.asFunction<_CFuture_CSuggestResult Function(_CSearchManager, _CSuggestQuery)>();
late final _CSearchManager_search_CSearchQueryPtr = _lookup<ffi.NativeFunction<_CFuture_CSearchResult Function(_CSearchManager, _CSearchQuery)>>('CSearchManager_search_CSearchQuery');
late final _CSearchManager_search_CSearchQuery = _CSearchManager_search_CSearchQueryPtr.asFunction<_CFuture_CSearchResult Function(_CSearchManager, _CSearchQuery)>();
late final _CSearchManager_searchById_CStringPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CDirectoryObject Function(_CSearchManager, _CString)>>('CSearchManager_searchById_CString');
late final _CSearchManager_searchById_CString = _CSearchManager_searchById_CStringPtr.asFunction<_CFuture_COptional_CDirectoryObject Function(_CSearchManager, _CString)>();
late final _CSearchManager_searchByDirectoryObjectId_CDgisObjectIdPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CDirectoryObject Function(_CSearchManager, _CDgisObjectId)>>('CSearchManager_searchByDirectoryObjectId_CDgisObjectId');
late final _CSearchManager_searchByDirectoryObjectId_CDgisObjectId = _CSearchManager_searchByDirectoryObjectId_CDgisObjectIdPtr.asFunction<_CFuture_COptional_CDirectoryObject Function(_CSearchManager, _CDgisObjectId)>();
late final _CSearchManager_searchByIdWithLocale_CString_COptional_CLocalePtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CDirectoryObject Function(_CSearchManager, _CString, _COptional_CLocale)>>('CSearchManager_searchByIdWithLocale_CString_COptional_CLocale');
late final _CSearchManager_searchByIdWithLocale_CString_COptional_CLocale = _CSearchManager_searchByIdWithLocale_CString_COptional_CLocalePtr.asFunction<_CFuture_COptional_CDirectoryObject Function(_CSearchManager, _CString, _COptional_CLocale)>();
late final _CSearchManager_searchByDirectoryObjectIdWithLocale_CDgisObjectId_COptional_CLocalePtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CDirectoryObject Function(_CSearchManager, _CDgisObjectId, _COptional_CLocale)>>('CSearchManager_searchByDirectoryObjectIdWithLocale_CDgisObjectId_COptional_CLocale');
late final _CSearchManager_searchByDirectoryObjectIdWithLocale_CDgisObjectId_COptional_CLocale = _CSearchManager_searchByDirectoryObjectIdWithLocale_CDgisObjectId_COptional_CLocalePtr.asFunction<_CFuture_COptional_CDirectoryObject Function(_CSearchManager, _CDgisObjectId, _COptional_CLocale)>();

late final _CSearchManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSearchManager_release');
late final _CSearchManager_release = _CSearchManager_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchManager_retainPtr = _lookup<ffi.NativeFunction<_CSearchManager Function(ffi.Pointer<ffi.Void>)>>('CSearchManager_retain');
late final _CSearchManager_retain = _CSearchManager_retainPtr.asFunction<_CSearchManager Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchManager Function()>>('CSearchManagerMakeDefault');
late final _CSearchManagerMakeDefault = _CSearchManagerMakeDefaultPtr.asFunction<_CSearchManager Function()>();


late final _CResult_CSearchManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CSearchManager)>>('CResult_CSearchManager_release');
late final _CResult_CSearchManager_release = _CResult_CSearchManager_releasePtr.asFunction<void Function(_CResult_CSearchManager)>();

late final _CFuture_CSuggestResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CSuggestResult Function()>>('CFuture_CSuggestResultMakeDefault');
late final _CFuture_CSuggestResultMakeDefault = _CFuture_CSuggestResultMakeDefaultPtr.asFunction<_CFuture_CSuggestResult Function()>();
late final _CFuture_CSuggestResult_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CSuggestResult)>>('CFuture_CSuggestResult_release');
late final _CFuture_CSuggestResult_release = _CFuture_CSuggestResult_releasePtr.asFunction<void Function(_CFuture_CSuggestResult)>();
late final _CFuture_CSuggestResult_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CSuggestResult Function(_CFuture_CSuggestResult)>>('CFuture_CSuggestResult_retain');
late final _CFuture_CSuggestResult_retain = _CFuture_CSuggestResult_retainPtr.asFunction<_CFuture_CSuggestResult Function(_CFuture_CSuggestResult)>();
late final _CFuture_CSuggestResultReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CSuggestResult,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSuggestResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CSuggestResult_receive');
late final _CFuture_CSuggestResultReceive = _CFuture_CSuggestResultReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CSuggestResult,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSuggestResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CFuture_CSearchResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CSearchResult Function()>>('CFuture_CSearchResultMakeDefault');
late final _CFuture_CSearchResultMakeDefault = _CFuture_CSearchResultMakeDefaultPtr.asFunction<_CFuture_CSearchResult Function()>();
late final _CFuture_CSearchResult_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CSearchResult)>>('CFuture_CSearchResult_release');
late final _CFuture_CSearchResult_release = _CFuture_CSearchResult_releasePtr.asFunction<void Function(_CFuture_CSearchResult)>();
late final _CFuture_CSearchResult_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CSearchResult Function(_CFuture_CSearchResult)>>('CFuture_CSearchResult_retain');
late final _CFuture_CSearchResult_retain = _CFuture_CSearchResult_retainPtr.asFunction<_CFuture_CSearchResult Function(_CFuture_CSearchResult)>();
late final _CFuture_CSearchResultReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CSearchResult,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSearchResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CSearchResult_receive');
late final _CFuture_CSearchResultReceive = _CFuture_CSearchResultReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CSearchResult,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSearchResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CFuture_COptional_CDirectoryObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CDirectoryObject Function()>>('CFuture_COptional_CDirectoryObjectMakeDefault');
late final _CFuture_COptional_CDirectoryObjectMakeDefault = _CFuture_COptional_CDirectoryObjectMakeDefaultPtr.asFunction<_CFuture_COptional_CDirectoryObject Function()>();
late final _CFuture_COptional_CDirectoryObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_COptional_CDirectoryObject)>>('CFuture_COptional_CDirectoryObject_release');
late final _CFuture_COptional_CDirectoryObject_release = _CFuture_COptional_CDirectoryObject_releasePtr.asFunction<void Function(_CFuture_COptional_CDirectoryObject)>();
late final _CFuture_COptional_CDirectoryObject_retainPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CDirectoryObject Function(_CFuture_COptional_CDirectoryObject)>>('CFuture_COptional_CDirectoryObject_retain');
late final _CFuture_COptional_CDirectoryObject_retain = _CFuture_COptional_CDirectoryObject_retainPtr.asFunction<_CFuture_COptional_CDirectoryObject Function(_CFuture_COptional_CDirectoryObject)>();
late final _CFuture_COptional_CDirectoryObjectReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_COptional_CDirectoryObject,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CDirectoryObject, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_COptional_CDirectoryObject_receive');
late final _CFuture_COptional_CDirectoryObjectReceive = _CFuture_COptional_CDirectoryObjectReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_COptional_CDirectoryObject,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CDirectoryObject, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _COptional_CDirectoryObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CDirectoryObject Function()>>('COptional_CDirectoryObjectMakeDefault');
late final _COptional_CDirectoryObjectMakeDefault = _COptional_CDirectoryObjectMakeDefaultPtr.asFunction<_COptional_CDirectoryObject Function()>();

late final _COptional_CDirectoryObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CDirectoryObject)>>('COptional_CDirectoryObject_release');
late final _COptional_CDirectoryObject_release = _COptional_CDirectoryObject_releasePtr.asFunction<void Function(_COptional_CDirectoryObject)>();
late final _CFunction_G_makeLocale_With_CStringPtr = _lookup<ffi.NativeFunction<_COptional_CLocale Function(_CString)>>('CFunction_G_makeLocale_With_CString');
late final _CFunction_G_makeLocale_With_CString = _CFunction_G_makeLocale_With_CStringPtr.asFunction<_COptional_CLocale Function(_CString)>();

late final _CLocaleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocale Function()>>('CLocaleMakeDefault');
late final _CLocaleMakeDefault = _CLocaleMakeDefaultPtr.asFunction<_CLocale Function()>();


late final _COptional_CLocaleMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CLocale Function()>>('COptional_CLocaleMakeDefault');
late final _COptional_CLocaleMakeDefault = _COptional_CLocaleMakeDefaultPtr.asFunction<_COptional_CLocale Function()>();

late final _COptional_CLocale_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CLocale)>>('COptional_CLocale_release');
late final _COptional_CLocale_release = _COptional_CLocale_releasePtr.asFunction<void Function(_COptional_CLocale)>();

late final _CSearchQueryBuilder_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSearchQueryBuilder_cg_objectIdentifier');
late final _CSearchQueryBuilder_cg_objectIdentifier = _CSearchQueryBuilder_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSearchQueryBuilder_S_fromQueryText_CStringPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CString)>>('CSearchQueryBuilder_S_fromQueryText_CString');
late final _CSearchQueryBuilder_S_fromQueryText_CString = _CSearchQueryBuilder_S_fromQueryText_CStringPtr.asFunction<_CSearchQueryBuilder Function(_CString)>();
late final _CSearchQueryBuilder_S_fromRubricIds_CArray_CRubricIdPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CArray_CRubricId)>>('CSearchQueryBuilder_S_fromRubricIds_CArray_CRubricId');
late final _CSearchQueryBuilder_S_fromRubricIds_CArray_CRubricId = _CSearchQueryBuilder_S_fromRubricIds_CArray_CRubricIdPtr.asFunction<_CSearchQueryBuilder Function(_CArray_CRubricId)>();
late final _CSearchQueryBuilder_S_fromQueryTextAndRubricIds_CString_CArray_CRubricIdPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CString, _CArray_CRubricId)>>('CSearchQueryBuilder_S_fromQueryTextAndRubricIds_CString_CArray_CRubricId');
late final _CSearchQueryBuilder_S_fromQueryTextAndRubricIds_CString_CArray_CRubricId = _CSearchQueryBuilder_S_fromQueryTextAndRubricIds_CString_CArray_CRubricIdPtr.asFunction<_CSearchQueryBuilder Function(_CString, _CArray_CRubricId)>();
late final _CSearchQueryBuilder_S_fromQuery_CSearchQueryPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CSearchQuery)>>('CSearchQueryBuilder_S_fromQuery_CSearchQuery');
late final _CSearchQueryBuilder_S_fromQuery_CSearchQuery = _CSearchQueryBuilder_S_fromQuery_CSearchQueryPtr.asFunction<_CSearchQueryBuilder Function(_CSearchQuery)>();
late final _CSearchQueryBuilder_S_fromOrgId_COrgIdPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_COrgId)>>('CSearchQueryBuilder_S_fromOrgId_COrgId');
late final _CSearchQueryBuilder_S_fromOrgId_COrgId = _CSearchQueryBuilder_S_fromOrgId_COrgIdPtr.asFunction<_CSearchQueryBuilder Function(_COrgId)>();
late final _CSearchQueryBuilder_S_fromBuildingId_CBuildingIdPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CBuildingId)>>('CSearchQueryBuilder_S_fromBuildingId_CBuildingId');
late final _CSearchQueryBuilder_S_fromBuildingId_CBuildingId = _CSearchQueryBuilder_S_fromBuildingId_CBuildingIdPtr.asFunction<_CSearchQueryBuilder Function(_CBuildingId)>();
late final _CSearchQueryBuilder_S_fromGeoPoint_CGeoPointPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CGeoPoint)>>('CSearchQueryBuilder_S_fromGeoPoint_CGeoPoint');
late final _CSearchQueryBuilder_S_fromGeoPoint_CGeoPoint = _CSearchQueryBuilder_S_fromGeoPoint_CGeoPointPtr.asFunction<_CSearchQueryBuilder Function(_CGeoPoint)>();
late final _CSearchQueryBuilder_setSpatialRestriction_COptional_CArray_CGeoPointPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _COptional_CArray_CGeoPoint)>>('CSearchQueryBuilder_setSpatialRestriction_COptional_CArray_CGeoPoint');
late final _CSearchQueryBuilder_setSpatialRestriction_COptional_CArray_CGeoPoint = _CSearchQueryBuilder_setSpatialRestriction_COptional_CArray_CGeoPointPtr.asFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _COptional_CArray_CGeoPoint)>();
late final _CSearchQueryBuilder_setAreaOfInterest_COptional_CGeoRectPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _COptional_CGeoRect)>>('CSearchQueryBuilder_setAreaOfInterest_COptional_CGeoRect');
late final _CSearchQueryBuilder_setAreaOfInterest_COptional_CGeoRect = _CSearchQueryBuilder_setAreaOfInterest_COptional_CGeoRectPtr.asFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _COptional_CGeoRect)>();
late final _CSearchQueryBuilder_setAllowedResultTypes_CArray_CObjectTypePtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _CArray_CObjectType)>>('CSearchQueryBuilder_setAllowedResultTypes_CArray_CObjectType');
late final _CSearchQueryBuilder_setAllowedResultTypes_CArray_CObjectType = _CSearchQueryBuilder_setAllowedResultTypes_CArray_CObjectTypePtr.asFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _CArray_CObjectType)>();
late final _CSearchQueryBuilder_setPageSize_int32_tPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, ffi.Int32)>>('CSearchQueryBuilder_setPageSize_int32_t');
late final _CSearchQueryBuilder_setPageSize_int32_t = _CSearchQueryBuilder_setPageSize_int32_tPtr.asFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, int)>();
late final _CSearchQueryBuilder_setDirectoryFilter_CDirectoryFilterPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _CDirectoryFilter)>>('CSearchQueryBuilder_setDirectoryFilter_CDirectoryFilter');
late final _CSearchQueryBuilder_setDirectoryFilter_CDirectoryFilter = _CSearchQueryBuilder_setDirectoryFilter_CDirectoryFilterPtr.asFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _CDirectoryFilter)>();
late final _CSearchQueryBuilder_setSortingType_CSortingTypePtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _CSortingType)>>('CSearchQueryBuilder_setSortingType_CSortingType');
late final _CSearchQueryBuilder_setSortingType_CSortingType = _CSearchQueryBuilder_setSortingType_CSortingTypePtr.asFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _CSortingType)>();
late final _CSearchQueryBuilder_setGeoPoint_CGeoPointPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _CGeoPoint)>>('CSearchQueryBuilder_setGeoPoint_CGeoPoint');
late final _CSearchQueryBuilder_setGeoPoint_CGeoPoint = _CSearchQueryBuilder_setGeoPoint_CGeoPointPtr.asFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _CGeoPoint)>();
late final _CSearchQueryBuilder_setRadius_CMeterPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _CMeter)>>('CSearchQueryBuilder_setRadius_CMeter');
late final _CSearchQueryBuilder_setRadius_CMeter = _CSearchQueryBuilder_setRadius_CMeterPtr.asFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _CMeter)>();
late final _CSearchQueryBuilder_setLocale_COptional_CLocalePtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _COptional_CLocale)>>('CSearchQueryBuilder_setLocale_COptional_CLocale');
late final _CSearchQueryBuilder_setLocale_COptional_CLocale = _CSearchQueryBuilder_setLocale_COptional_CLocalePtr.asFunction<_CSearchQueryBuilder Function(_CSearchQueryBuilder, _COptional_CLocale)>();
late final _CSearchQueryBuilder_buildPtr = _lookup<ffi.NativeFunction<_CSearchQuery Function(_CSearchQueryBuilder)>>('CSearchQueryBuilder_build');
late final _CSearchQueryBuilder_build = _CSearchQueryBuilder_buildPtr.asFunction<_CSearchQuery Function(_CSearchQueryBuilder)>();

late final _CSearchQueryBuilder_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSearchQueryBuilder_release');
late final _CSearchQueryBuilder_release = _CSearchQueryBuilder_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchQueryBuilder_retainPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function(ffi.Pointer<ffi.Void>)>>('CSearchQueryBuilder_retain');
late final _CSearchQueryBuilder_retain = _CSearchQueryBuilder_retainPtr.asFunction<_CSearchQueryBuilder Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchQueryBuilderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchQueryBuilder Function()>>('CSearchQueryBuilderMakeDefault');
late final _CSearchQueryBuilderMakeDefault = _CSearchQueryBuilderMakeDefaultPtr.asFunction<_CSearchQueryBuilder Function()>();


late final _COptional_CArray_CGeoPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CArray_CGeoPoint Function()>>('COptional_CArray_CGeoPointMakeDefault');
late final _COptional_CArray_CGeoPointMakeDefault = _COptional_CArray_CGeoPointMakeDefaultPtr.asFunction<_COptional_CArray_CGeoPoint Function()>();

late final _COptional_CArray_CGeoPoint_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CArray_CGeoPoint)>>('COptional_CArray_CGeoPoint_release');
late final _COptional_CArray_CGeoPoint_release = _COptional_CArray_CGeoPoint_releasePtr.asFunction<void Function(_COptional_CArray_CGeoPoint)>();

late final _COptional_CGeoRectMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CGeoRect Function()>>('COptional_CGeoRectMakeDefault');
late final _COptional_CGeoRectMakeDefault = _COptional_CGeoRectMakeDefaultPtr.asFunction<_COptional_CGeoRect Function()>();

late final _CSuggestQueryBuilder_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSuggestQueryBuilder_cg_objectIdentifier');
late final _CSuggestQueryBuilder_cg_objectIdentifier = _CSuggestQueryBuilder_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSuggestQueryBuilder_S_fromQueryText_CStringPtr = _lookup<ffi.NativeFunction<_CSuggestQueryBuilder Function(_CString)>>('CSuggestQueryBuilder_S_fromQueryText_CString');
late final _CSuggestQueryBuilder_S_fromQueryText_CString = _CSuggestQueryBuilder_S_fromQueryText_CStringPtr.asFunction<_CSuggestQueryBuilder Function(_CString)>();
late final _CSuggestQueryBuilder_S_fromQuery_CSuggestQueryPtr = _lookup<ffi.NativeFunction<_CSuggestQueryBuilder Function(_CSuggestQuery)>>('CSuggestQueryBuilder_S_fromQuery_CSuggestQuery');
late final _CSuggestQueryBuilder_S_fromQuery_CSuggestQuery = _CSuggestQueryBuilder_S_fromQuery_CSuggestQueryPtr.asFunction<_CSuggestQueryBuilder Function(_CSuggestQuery)>();
late final _CSuggestQueryBuilder_setSpatialRestriction_COptional_CArray_CGeoPointPtr = _lookup<ffi.NativeFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, _COptional_CArray_CGeoPoint)>>('CSuggestQueryBuilder_setSpatialRestriction_COptional_CArray_CGeoPoint');
late final _CSuggestQueryBuilder_setSpatialRestriction_COptional_CArray_CGeoPoint = _CSuggestQueryBuilder_setSpatialRestriction_COptional_CArray_CGeoPointPtr.asFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, _COptional_CArray_CGeoPoint)>();
late final _CSuggestQueryBuilder_setAreaOfInterest_COptional_CGeoRectPtr = _lookup<ffi.NativeFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, _COptional_CGeoRect)>>('CSuggestQueryBuilder_setAreaOfInterest_COptional_CGeoRect');
late final _CSuggestQueryBuilder_setAreaOfInterest_COptional_CGeoRect = _CSuggestQueryBuilder_setAreaOfInterest_COptional_CGeoRectPtr.asFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, _COptional_CGeoRect)>();
late final _CSuggestQueryBuilder_setAllowedResultTypes_CArray_CSuggestedTypePtr = _lookup<ffi.NativeFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, _CArray_CSuggestedType)>>('CSuggestQueryBuilder_setAllowedResultTypes_CArray_CSuggestedType');
late final _CSuggestQueryBuilder_setAllowedResultTypes_CArray_CSuggestedType = _CSuggestQueryBuilder_setAllowedResultTypes_CArray_CSuggestedTypePtr.asFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, _CArray_CSuggestedType)>();
late final _CSuggestQueryBuilder_setSuggestorType_CSuggestorTypePtr = _lookup<ffi.NativeFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, _CSuggestorType)>>('CSuggestQueryBuilder_setSuggestorType_CSuggestorType');
late final _CSuggestQueryBuilder_setSuggestorType_CSuggestorType = _CSuggestQueryBuilder_setSuggestorType_CSuggestorTypePtr.asFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, _CSuggestorType)>();
late final _CSuggestQueryBuilder_setLimit_int32_tPtr = _lookup<ffi.NativeFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, ffi.Int32)>>('CSuggestQueryBuilder_setLimit_int32_t');
late final _CSuggestQueryBuilder_setLimit_int32_t = _CSuggestQueryBuilder_setLimit_int32_tPtr.asFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, int)>();
late final _CSuggestQueryBuilder_setLocale_COptional_CLocalePtr = _lookup<ffi.NativeFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, _COptional_CLocale)>>('CSuggestQueryBuilder_setLocale_COptional_CLocale');
late final _CSuggestQueryBuilder_setLocale_COptional_CLocale = _CSuggestQueryBuilder_setLocale_COptional_CLocalePtr.asFunction<_CSuggestQueryBuilder Function(_CSuggestQueryBuilder, _COptional_CLocale)>();
late final _CSuggestQueryBuilder_buildPtr = _lookup<ffi.NativeFunction<_CSuggestQuery Function(_CSuggestQueryBuilder)>>('CSuggestQueryBuilder_build');
late final _CSuggestQueryBuilder_build = _CSuggestQueryBuilder_buildPtr.asFunction<_CSuggestQuery Function(_CSuggestQueryBuilder)>();

late final _CSuggestQueryBuilder_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSuggestQueryBuilder_release');
late final _CSuggestQueryBuilder_release = _CSuggestQueryBuilder_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSuggestQueryBuilder_retainPtr = _lookup<ffi.NativeFunction<_CSuggestQueryBuilder Function(ffi.Pointer<ffi.Void>)>>('CSuggestQueryBuilder_retain');
late final _CSuggestQueryBuilder_retain = _CSuggestQueryBuilder_retainPtr.asFunction<_CSuggestQueryBuilder Function(ffi.Pointer<ffi.Void>)>();
late final _CSuggestQueryBuilderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSuggestQueryBuilder Function()>>('CSuggestQueryBuilderMakeDefault');
late final _CSuggestQueryBuilderMakeDefault = _CSuggestQueryBuilderMakeDefaultPtr.asFunction<_CSuggestQueryBuilder Function()>();


late final _CArray_CSuggestedTypemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CSuggestedType Function()>>('CArray_CSuggestedType_makeEmpty');
late final _CArray_CSuggestedTypemakeEmpty = _CArray_CSuggestedTypemakeEmptyPtr.asFunction<_CArray_CSuggestedType Function()>();
late final _CArray_CSuggestedTypeaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSuggestedType, _CSuggestedType)>>('CArray_CSuggestedType_addElement');
late final _CArray_CSuggestedTypeaddElement = _CArray_CSuggestedTypeaddElementPtr.asFunction<void Function(_CArray_CSuggestedType, _CSuggestedType)>();
late final _forEach_CArray_CSuggestedTypePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CSuggestedType, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSuggestedType)>>)
>>('CArray_CSuggestedType_forEachWithFunctionPointer');
late final _forEach_CArray_CSuggestedType = _forEach_CArray_CSuggestedTypePtr.asFunction<
  void Function(_CArray_CSuggestedType, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSuggestedType)
>>)>();
late final _CArray_CSuggestedType_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSuggestedType)>>('CArray_CSuggestedType_release');
late final _CArray_CSuggestedType_release = _CArray_CSuggestedType_releasePtr.asFunction<void Function(_CArray_CSuggestedType)>();

late final _CChangeTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CChangeType Function()>>('CChangeTypeMakeDefault');
late final _CChangeTypeMakeDefault = _CChangeTypeMakeDefaultPtr.asFunction<_CChangeType Function()>();
late final _CSearchQueryWithInfo_searchQueryPtr = _lookup<ffi.NativeFunction<_CSearchQuery Function(_CSearchQueryWithInfo)>>('CSearchQueryWithInfo_searchQuery');
late final _CSearchQueryWithInfo_searchQuery = _CSearchQueryWithInfo_searchQueryPtr.asFunction<_CSearchQuery Function(_CSearchQueryWithInfo)>();
late final _CSearchQueryWithInfo_titlePtr = _lookup<ffi.NativeFunction<_CString Function(_CSearchQueryWithInfo)>>('CSearchQueryWithInfo_title');
late final _CSearchQueryWithInfo_title = _CSearchQueryWithInfo_titlePtr.asFunction<_CString Function(_CSearchQueryWithInfo)>();
late final _CSearchQueryWithInfo_subtitlePtr = _lookup<ffi.NativeFunction<_CString Function(_CSearchQueryWithInfo)>>('CSearchQueryWithInfo_subtitle');
late final _CSearchQueryWithInfo_subtitle = _CSearchQueryWithInfo_subtitlePtr.asFunction<_CString Function(_CSearchQueryWithInfo)>();
late final _CSearchQueryWithInfo_rubricsPtr = _lookup<ffi.NativeFunction<_CArray_CRubricId Function(_CSearchQueryWithInfo)>>('CSearchQueryWithInfo_rubrics');
late final _CSearchQueryWithInfo_rubrics = _CSearchQueryWithInfo_rubricsPtr.asFunction<_CArray_CRubricId Function(_CSearchQueryWithInfo)>();

late final _CSearchQueryWithInfo_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSearchQueryWithInfo_cg_objectIdentifier');
late final _CSearchQueryWithInfo_cg_objectIdentifier = _CSearchQueryWithInfo_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSearchQueryWithInfo_C_createWith_CSearchQuery_CString_CStringPtr = _lookup<ffi.NativeFunction<_CSearchQueryWithInfo Function(_CSearchQuery, _CString, _CString)>>('CSearchQueryWithInfo_C_createWith_CSearchQuery_CString_CString');
late final _CSearchQueryWithInfo_C_createWith_CSearchQuery_CString_CString = _CSearchQueryWithInfo_C_createWith_CSearchQuery_CString_CStringPtr.asFunction<_CSearchQueryWithInfo Function(_CSearchQuery, _CString, _CString)>();

late final _CSearchQueryWithInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSearchQueryWithInfo_release');
late final _CSearchQueryWithInfo_release = _CSearchQueryWithInfo_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchQueryWithInfo_retainPtr = _lookup<ffi.NativeFunction<_CSearchQueryWithInfo Function(ffi.Pointer<ffi.Void>)>>('CSearchQueryWithInfo_retain');
late final _CSearchQueryWithInfo_retain = _CSearchQueryWithInfo_retainPtr.asFunction<_CSearchQueryWithInfo Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchQueryWithInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchQueryWithInfo Function()>>('CSearchQueryWithInfoMakeDefault');
late final _CSearchQueryWithInfoMakeDefault = _CSearchQueryWithInfoMakeDefaultPtr.asFunction<_CSearchQueryWithInfo Function()>();


late final _CSearchHistoryItem_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSearchHistoryItem)>>('CSearchHistoryItem_release');
late final _CSearchHistoryItem_release = _CSearchHistoryItem_releasePtr.asFunction<void Function(_CSearchHistoryItem)>();
late final _CSearchHistoryItemMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchHistoryItem Function()>>('CSearchHistoryItemMakeDefault');
late final _CSearchHistoryItemMakeDefault = _CSearchHistoryItemMakeDefaultPtr.asFunction<_CSearchHistoryItem Function()>();
late final _CSearchHistoryResult_itemsPtr = _lookup<ffi.NativeFunction<_CArray_CSearchHistoryItem Function(_CSearchHistoryResult)>>('CSearchHistoryResult_items');
late final _CSearchHistoryResult_items = _CSearchHistoryResult_itemsPtr.asFunction<_CArray_CSearchHistoryItem Function(_CSearchHistoryResult)>();

late final _CSearchHistoryResult_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSearchHistoryResult_cg_objectIdentifier');
late final _CSearchHistoryResult_cg_objectIdentifier = _CSearchHistoryResult_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CSearchHistoryResult_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSearchHistoryResult_release');
late final _CSearchHistoryResult_release = _CSearchHistoryResult_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchHistoryResult_retainPtr = _lookup<ffi.NativeFunction<_CSearchHistoryResult Function(ffi.Pointer<ffi.Void>)>>('CSearchHistoryResult_retain');
late final _CSearchHistoryResult_retain = _CSearchHistoryResult_retainPtr.asFunction<_CSearchHistoryResult Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchHistoryResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchHistoryResult Function()>>('CSearchHistoryResultMakeDefault');
late final _CSearchHistoryResultMakeDefault = _CSearchHistoryResultMakeDefaultPtr.asFunction<_CSearchHistoryResult Function()>();


late final _CArray_CSearchHistoryItemmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CSearchHistoryItem Function()>>('CArray_CSearchHistoryItem_makeEmpty');
late final _CArray_CSearchHistoryItemmakeEmpty = _CArray_CSearchHistoryItemmakeEmptyPtr.asFunction<_CArray_CSearchHistoryItem Function()>();
late final _CArray_CSearchHistoryItemaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSearchHistoryItem, _CSearchHistoryItem)>>('CArray_CSearchHistoryItem_addElement');
late final _CArray_CSearchHistoryItemaddElement = _CArray_CSearchHistoryItemaddElementPtr.asFunction<void Function(_CArray_CSearchHistoryItem, _CSearchHistoryItem)>();
late final _forEach_CArray_CSearchHistoryItemPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CSearchHistoryItem, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSearchHistoryItem)>>)
>>('CArray_CSearchHistoryItem_forEachWithFunctionPointer');
late final _forEach_CArray_CSearchHistoryItem = _forEach_CArray_CSearchHistoryItemPtr.asFunction<
  void Function(_CArray_CSearchHistoryItem, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSearchHistoryItem)
>>)>();
late final _CArray_CSearchHistoryItem_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSearchHistoryItem)>>('CArray_CSearchHistoryItem_release');
late final _CArray_CSearchHistoryItem_release = _CArray_CSearchHistoryItem_releasePtr.asFunction<void Function(_CArray_CSearchHistoryItem)>();

late final _CSearchHistoryFilterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchHistoryFilter Function()>>('CSearchHistoryFilterMakeDefault');
late final _CSearchHistoryFilterMakeDefault = _CSearchHistoryFilterMakeDefaultPtr.asFunction<_CSearchHistoryFilter Function()>();

late final _COptionSet_CSearchHistoryFilterMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptionSet_CSearchHistoryFilter Function()>>('COptionSet_CSearchHistoryFilterMakeDefault');
late final _COptionSet_CSearchHistoryFilterMakeDefault = _COptionSet_CSearchHistoryFilterMakeDefaultPtr.asFunction<_COptionSet_CSearchHistoryFilter Function()>();

late final _CSearchHistoryPageMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchHistoryPage Function()>>('CSearchHistoryPageMakeDefault');
late final _CSearchHistoryPageMakeDefault = _CSearchHistoryPageMakeDefaultPtr.asFunction<_CSearchHistoryPage Function()>();

late final _CSearchHistory_capacityPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CSearchHistory)>>('CSearchHistory_capacity');
late final _CSearchHistory_capacity = _CSearchHistory_capacityPtr.asFunction<int Function(_CSearchHistory)>();
late final _CSearchHistory_onHistoryChangedPtr = _lookup<ffi.NativeFunction<_CChannel_CChangeType Function(_CSearchHistory)>>('CSearchHistory_onHistoryChanged');
late final _CSearchHistory_onHistoryChanged = _CSearchHistory_onHistoryChangedPtr.asFunction<_CChannel_CChangeType Function(_CSearchHistory)>();

late final _CSearchHistory_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSearchHistory_cg_objectIdentifier');
late final _CSearchHistory_cg_objectIdentifier = _CSearchHistory_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSearchHistory_items_CSearchHistoryPagePtr = _lookup<ffi.NativeFunction<_CFuture_CSearchHistoryResult Function(_CSearchHistory, _CSearchHistoryPage)>>('CSearchHistory_items_CSearchHistoryPage');
late final _CSearchHistory_items_CSearchHistoryPage = _CSearchHistory_items_CSearchHistoryPagePtr.asFunction<_CFuture_CSearchHistoryResult Function(_CSearchHistory, _CSearchHistoryPage)>();
late final _CSearchHistory_addItem_CSearchHistoryItemPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSearchHistory, _CSearchHistoryItem)>>('CSearchHistory_addItem_CSearchHistoryItem');
late final _CSearchHistory_addItem_CSearchHistoryItem = _CSearchHistory_addItem_CSearchHistoryItemPtr.asFunction<void Function(_CSearchHistory, _CSearchHistoryItem)>();
late final _CSearchHistory_addItems_CArray_CSearchHistoryItemPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSearchHistory, _CArray_CSearchHistoryItem)>>('CSearchHistory_addItems_CArray_CSearchHistoryItem');
late final _CSearchHistory_addItems_CArray_CSearchHistoryItem = _CSearchHistory_addItems_CArray_CSearchHistoryItemPtr.asFunction<void Function(_CSearchHistory, _CArray_CSearchHistoryItem)>();
late final _CSearchHistory_removeItem_CSearchHistoryItemPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSearchHistory, _CSearchHistoryItem)>>('CSearchHistory_removeItem_CSearchHistoryItem');
late final _CSearchHistory_removeItem_CSearchHistoryItem = _CSearchHistory_removeItem_CSearchHistoryItemPtr.asFunction<void Function(_CSearchHistory, _CSearchHistoryItem)>();
late final _CSearchHistory_removeItems_CArray_CSearchHistoryItemPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSearchHistory, _CArray_CSearchHistoryItem)>>('CSearchHistory_removeItems_CArray_CSearchHistoryItem');
late final _CSearchHistory_removeItems_CArray_CSearchHistoryItem = _CSearchHistory_removeItems_CArray_CSearchHistoryItemPtr.asFunction<void Function(_CSearchHistory, _CArray_CSearchHistoryItem)>();
late final _CSearchHistory_clearPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSearchHistory)>>('CSearchHistory_clear');
late final _CSearchHistory_clear = _CSearchHistory_clearPtr.asFunction<void Function(_CSearchHistory)>();
late final _CSearchHistory_C_createWith_CContextPtr = _lookup<ffi.NativeFunction<_CSearchHistory Function(_CContext)>>('CSearchHistory_C_createWith_CContext');
late final _CSearchHistory_C_createWith_CContext = _CSearchHistory_C_createWith_CContextPtr.asFunction<_CSearchHistory Function(_CContext)>();

late final _CSearchHistory_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSearchHistory_release');
late final _CSearchHistory_release = _CSearchHistory_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchHistory_retainPtr = _lookup<ffi.NativeFunction<_CSearchHistory Function(ffi.Pointer<ffi.Void>)>>('CSearchHistory_retain');
late final _CSearchHistory_retain = _CSearchHistory_retainPtr.asFunction<_CSearchHistory Function(ffi.Pointer<ffi.Void>)>();
late final _CSearchHistoryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSearchHistory Function()>>('CSearchHistoryMakeDefault');
late final _CSearchHistoryMakeDefault = _CSearchHistoryMakeDefaultPtr.asFunction<_CSearchHistory Function()>();


late final _CFuture_CSearchHistoryResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CSearchHistoryResult Function()>>('CFuture_CSearchHistoryResultMakeDefault');
late final _CFuture_CSearchHistoryResultMakeDefault = _CFuture_CSearchHistoryResultMakeDefaultPtr.asFunction<_CFuture_CSearchHistoryResult Function()>();
late final _CFuture_CSearchHistoryResult_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CSearchHistoryResult)>>('CFuture_CSearchHistoryResult_release');
late final _CFuture_CSearchHistoryResult_release = _CFuture_CSearchHistoryResult_releasePtr.asFunction<void Function(_CFuture_CSearchHistoryResult)>();
late final _CFuture_CSearchHistoryResult_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CSearchHistoryResult Function(_CFuture_CSearchHistoryResult)>>('CFuture_CSearchHistoryResult_retain');
late final _CFuture_CSearchHistoryResult_retain = _CFuture_CSearchHistoryResult_retainPtr.asFunction<_CFuture_CSearchHistoryResult Function(_CFuture_CSearchHistoryResult)>();
late final _CFuture_CSearchHistoryResultReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CSearchHistoryResult,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSearchHistoryResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CSearchHistoryResult_receive');
late final _CFuture_CSearchHistoryResultReceive = _CFuture_CSearchHistoryResultReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CSearchHistoryResult,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSearchHistoryResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CChannel_CChangeTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CChannel_CChangeType Function()>>('CChannel_CChangeTypeMakeDefault');
late final _CChannel_CChangeTypeMakeDefault = _CChannel_CChangeTypeMakeDefaultPtr.asFunction<_CChannel_CChangeType Function()>();
late final _CChannel_CChangeType_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CChannel_CChangeType)>>('CChannel_CChangeType_release');
late final _CChannel_CChangeType_release = _CChannel_CChangeType_releasePtr.asFunction<void Function(_CChannel_CChangeType)>();
late final _CChannel_CChangeType_retainPtr = _lookup<ffi.NativeFunction<_CChannel_CChangeType Function(_CChannel_CChangeType)>>('CChannel_CChangeType_retain');
late final _CChannel_CChangeType_retain = _CChannel_CChangeType_retainPtr.asFunction<_CChannel_CChangeType Function(_CChannel_CChangeType)>();
late final _CChannel_CChangeTypeConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CChannel_CChangeType,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CChangeType, ffi.Int64)>>
  )
>>('CChannel_CChangeType_connect');
late final _CChannel_CChangeTypeConnect = _CChannel_CChangeTypeConnectPtr.asFunction<
  _CCancellable Function(
    _CChannel_CChangeType,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CChangeType, ffi.Int64)>>
  )
>();
late final _CPackedSearchQuery_queryTextPtr = _lookup<ffi.NativeFunction<_CString Function(_CPackedSearchQuery)>>('CPackedSearchQuery_queryText');
late final _CPackedSearchQuery_queryText = _CPackedSearchQuery_queryTextPtr.asFunction<_CString Function(_CPackedSearchQuery)>();
late final _CPackedSearchQuery_orgIdPtr = _lookup<ffi.NativeFunction<_COptional_COrgId Function(_CPackedSearchQuery)>>('CPackedSearchQuery_orgId');
late final _CPackedSearchQuery_orgId = _CPackedSearchQuery_orgIdPtr.asFunction<_COptional_COrgId Function(_CPackedSearchQuery)>();
late final _CPackedSearchQuery_rubricIdsPtr = _lookup<ffi.NativeFunction<_CArray_CRubricId Function(_CPackedSearchQuery)>>('CPackedSearchQuery_rubricIds');
late final _CPackedSearchQuery_rubricIds = _CPackedSearchQuery_rubricIdsPtr.asFunction<_CArray_CRubricId Function(_CPackedSearchQuery)>();
late final _CPackedSearchQuery_objectIdsPtr = _lookup<ffi.NativeFunction<_CArray_CDgisObjectId Function(_CPackedSearchQuery)>>('CPackedSearchQuery_objectIds');
late final _CPackedSearchQuery_objectIds = _CPackedSearchQuery_objectIdsPtr.asFunction<_CArray_CDgisObjectId Function(_CPackedSearchQuery)>();
late final _CPackedSearchQuery_buildingIdPtr = _lookup<ffi.NativeFunction<_COptional_CBuildingId Function(_CPackedSearchQuery)>>('CPackedSearchQuery_buildingId');
late final _CPackedSearchQuery_buildingId = _CPackedSearchQuery_buildingIdPtr.asFunction<_COptional_CBuildingId Function(_CPackedSearchQuery)>();
late final _CPackedSearchQuery_spatialRestrictionPtr = _lookup<ffi.NativeFunction<_COptional_CArray_CGeoPoint Function(_CPackedSearchQuery)>>('CPackedSearchQuery_spatialRestriction');
late final _CPackedSearchQuery_spatialRestriction = _CPackedSearchQuery_spatialRestrictionPtr.asFunction<_COptional_CArray_CGeoPoint Function(_CPackedSearchQuery)>();
late final _CPackedSearchQuery_areaOfInterestPtr = _lookup<ffi.NativeFunction<_COptional_CGeoRect Function(_CPackedSearchQuery)>>('CPackedSearchQuery_areaOfInterest');
late final _CPackedSearchQuery_areaOfInterest = _CPackedSearchQuery_areaOfInterestPtr.asFunction<_COptional_CGeoRect Function(_CPackedSearchQuery)>();
late final _CPackedSearchQuery_allowedResultTypesPtr = _lookup<ffi.NativeFunction<_CArray_CObjectType Function(_CPackedSearchQuery)>>('CPackedSearchQuery_allowedResultTypes');
late final _CPackedSearchQuery_allowedResultTypes = _CPackedSearchQuery_allowedResultTypesPtr.asFunction<_CArray_CObjectType Function(_CPackedSearchQuery)>();
late final _CPackedSearchQuery_pageSizePtr = _lookup<ffi.NativeFunction<ffi.Int32 Function(_CPackedSearchQuery)>>('CPackedSearchQuery_pageSize');
late final _CPackedSearchQuery_pageSize = _CPackedSearchQuery_pageSizePtr.asFunction<int Function(_CPackedSearchQuery)>();
late final _CPackedSearchQuery_directoryFilterPtr = _lookup<ffi.NativeFunction<_CDirectoryFilter Function(_CPackedSearchQuery)>>('CPackedSearchQuery_directoryFilter');
late final _CPackedSearchQuery_directoryFilter = _CPackedSearchQuery_directoryFilterPtr.asFunction<_CDirectoryFilter Function(_CPackedSearchQuery)>();
late final _CPackedSearchQuery_sortingTypePtr = _lookup<ffi.NativeFunction<_CSortingType Function(_CPackedSearchQuery)>>('CPackedSearchQuery_sortingType');
late final _CPackedSearchQuery_sortingType = _CPackedSearchQuery_sortingTypePtr.asFunction<_CSortingType Function(_CPackedSearchQuery)>();
late final _CPackedSearchQuery_geoPointPtr = _lookup<ffi.NativeFunction<_COptional_CGeoPoint Function(_CPackedSearchQuery)>>('CPackedSearchQuery_geoPoint');
late final _CPackedSearchQuery_geoPoint = _CPackedSearchQuery_geoPointPtr.asFunction<_COptional_CGeoPoint Function(_CPackedSearchQuery)>();
late final _CPackedSearchQuery_radiusPtr = _lookup<ffi.NativeFunction<_COptional_CMeter Function(_CPackedSearchQuery)>>('CPackedSearchQuery_radius');
late final _CPackedSearchQuery_radius = _CPackedSearchQuery_radiusPtr.asFunction<_COptional_CMeter Function(_CPackedSearchQuery)>();
late final _CPackedSearchQuery_localePtr = _lookup<ffi.NativeFunction<_COptional_CLocale Function(_CPackedSearchQuery)>>('CPackedSearchQuery_locale');
late final _CPackedSearchQuery_locale = _CPackedSearchQuery_localePtr.asFunction<_COptional_CLocale Function(_CPackedSearchQuery)>();

late final _CPackedSearchQuery_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPackedSearchQuery_cg_objectIdentifier');
late final _CPackedSearchQuery_cg_objectIdentifier = _CPackedSearchQuery_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPackedSearchQuery_S_fromBytes_CDataPtr = _lookup<ffi.NativeFunction<_CResult_CPackedSearchQuery Function(_CData)>>('CPackedSearchQuery_S_fromBytes_CData');
late final _CPackedSearchQuery_S_fromBytes_CData = _CPackedSearchQuery_S_fromBytes_CDataPtr.asFunction<_CResult_CPackedSearchQuery Function(_CData)>();
late final _CPackedSearchQuery_S_fromSearchQuery_CSearchQueryPtr = _lookup<ffi.NativeFunction<_CPackedSearchQuery Function(_CSearchQuery)>>('CPackedSearchQuery_S_fromSearchQuery_CSearchQuery');
late final _CPackedSearchQuery_S_fromSearchQuery_CSearchQuery = _CPackedSearchQuery_S_fromSearchQuery_CSearchQueryPtr.asFunction<_CPackedSearchQuery Function(_CSearchQuery)>();
late final _CPackedSearchQuery_toBytesPtr = _lookup<ffi.NativeFunction<_CData Function(_CPackedSearchQuery)>>('CPackedSearchQuery_toBytes');
late final _CPackedSearchQuery_toBytes = _CPackedSearchQuery_toBytesPtr.asFunction<_CData Function(_CPackedSearchQuery)>();
late final _CPackedSearchQuery_toSearchQueryPtr = _lookup<ffi.NativeFunction<_CSearchQuery Function(_CPackedSearchQuery)>>('CPackedSearchQuery_toSearchQuery');
late final _CPackedSearchQuery_toSearchQuery = _CPackedSearchQuery_toSearchQueryPtr.asFunction<_CSearchQuery Function(_CPackedSearchQuery)>();

late final _CPackedSearchQuery_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPackedSearchQuery_release');
late final _CPackedSearchQuery_release = _CPackedSearchQuery_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPackedSearchQuery_retainPtr = _lookup<ffi.NativeFunction<_CPackedSearchQuery Function(ffi.Pointer<ffi.Void>)>>('CPackedSearchQuery_retain');
late final _CPackedSearchQuery_retain = _CPackedSearchQuery_retainPtr.asFunction<_CPackedSearchQuery Function(ffi.Pointer<ffi.Void>)>();
late final _CPackedSearchQueryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPackedSearchQuery Function()>>('CPackedSearchQueryMakeDefault');
late final _CPackedSearchQueryMakeDefault = _CPackedSearchQueryMakeDefaultPtr.asFunction<_CPackedSearchQuery Function()>();


late final _CResult_CPackedSearchQuery_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CPackedSearchQuery)>>('CResult_CPackedSearchQuery_release');
late final _CResult_CPackedSearchQuery_release = _CResult_CPackedSearchQuery_releasePtr.asFunction<void Function(_CResult_CPackedSearchQuery)>();

late final _CDataCreateWithDataPtr = _lookup<ffi.NativeFunction<_CData Function(ffi.Size size, ffi.Pointer<ffi.Uint8>)>>('CData_createWithData');
late final _CDataCreateWithData = _CDataCreateWithDataPtr.asFunction<_CData Function(int, ffi.Pointer<ffi.Uint8>)>();
late final _GetSizeWith_CDataPtr = _lookup<ffi.NativeFunction<ffi.Size Function(_CData)>>('CData_getSize');
late final _GetSizeWith_CData = _GetSizeWith_CDataPtr.asFunction<int Function(_CData)>();
late final _GetDataWith_CDataPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Uint8> Function(_CData)>>('CData_getData');
late final _GetDataWith_CData = _GetDataWith_CDataPtr.asFunction<ffi.Pointer<ffi.Uint8> Function(_CData)>();
late final _CData_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CData)>>('CData_release');
late final _CData_release = _CData_releasePtr.asFunction<void Function(_CData)>();

late final _COptional_COrgIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_COrgId Function()>>('COptional_COrgIdMakeDefault');
late final _COptional_COrgIdMakeDefault = _COptional_COrgIdMakeDefaultPtr.asFunction<_COptional_COrgId Function()>();

late final _COptional_CGeoPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CGeoPoint Function()>>('COptional_CGeoPointMakeDefault');
late final _COptional_CGeoPointMakeDefault = _COptional_CGeoPointMakeDefaultPtr.asFunction<_COptional_CGeoPoint Function()>();

late final _COptional_CMeterMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CMeter Function()>>('COptional_CMeterMakeDefault');
late final _COptional_CMeterMakeDefault = _COptional_CMeterMakeDefaultPtr.asFunction<_COptional_CMeter Function()>();

late final _CPointGeometryData_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPointGeometryData)>>('CPointGeometryData_release');
late final _CPointGeometryData_release = _CPointGeometryData_releasePtr.asFunction<void Function(_CPointGeometryData)>();
late final _CPointGeometryDataMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPointGeometryData Function()>>('CPointGeometryDataMakeDefault');
late final _CPointGeometryDataMakeDefault = _CPointGeometryDataMakeDefaultPtr.asFunction<_CPointGeometryData Function()>();
late final _CPointGeometry_pointPtr = _lookup<ffi.NativeFunction<_CPointGeometryData Function(_CPointGeometry)>>('CPointGeometry_point');
late final _CPointGeometry_point = _CPointGeometry_pointPtr.asFunction<_CPointGeometryData Function(_CPointGeometry)>();

late final _CPointGeometry_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPointGeometry_cg_objectIdentifier');
late final _CPointGeometry_cg_objectIdentifier = _CPointGeometry_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPointGeometry_C_createWith_CGeoPointPtr = _lookup<ffi.NativeFunction<_CPointGeometry Function(_CGeoPoint)>>('CPointGeometry_C_createWith_CGeoPoint');
late final _CPointGeometry_C_createWith_CGeoPoint = _CPointGeometry_C_createWith_CGeoPointPtr.asFunction<_CPointGeometry Function(_CGeoPoint)>();
late final _CPointGeometry_C_createWith_CGeoPointWithElevationPtr = _lookup<ffi.NativeFunction<_CPointGeometry Function(_CGeoPointWithElevation)>>('CPointGeometry_C_createWith_CGeoPointWithElevation');
late final _CPointGeometry_C_createWith_CGeoPointWithElevation = _CPointGeometry_C_createWith_CGeoPointWithElevationPtr.asFunction<_CPointGeometry Function(_CGeoPointWithElevation)>();

late final _CPointGeometry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPointGeometry_release');
late final _CPointGeometry_release = _CPointGeometry_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPointGeometry_retainPtr = _lookup<ffi.NativeFunction<_CPointGeometry Function(ffi.Pointer<ffi.Void>)>>('CPointGeometry_retain');
late final _CPointGeometry_retain = _CPointGeometry_retainPtr.asFunction<_CPointGeometry Function(ffi.Pointer<ffi.Void>)>();
late final _CPointGeometryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPointGeometry Function()>>('CPointGeometryMakeDefault');
late final _CPointGeometryMakeDefault = _CPointGeometryMakeDefaultPtr.asFunction<_CPointGeometry Function()>();

late final _CPolygonGeometry_contoursPtr = _lookup<ffi.NativeFunction<_CArray_CArray_CGeoPoint Function(_CPolygonGeometry)>>('CPolygonGeometry_contours');
late final _CPolygonGeometry_contours = _CPolygonGeometry_contoursPtr.asFunction<_CArray_CArray_CGeoPoint Function(_CPolygonGeometry)>();

late final _CPolygonGeometry_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPolygonGeometry_cg_objectIdentifier');
late final _CPolygonGeometry_cg_objectIdentifier = _CPolygonGeometry_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPolygonGeometry_C_createWith_CArray_CArray_CGeoPointPtr = _lookup<ffi.NativeFunction<_CPolygonGeometry Function(_CArray_CArray_CGeoPoint)>>('CPolygonGeometry_C_createWith_CArray_CArray_CGeoPoint');
late final _CPolygonGeometry_C_createWith_CArray_CArray_CGeoPoint = _CPolygonGeometry_C_createWith_CArray_CArray_CGeoPointPtr.asFunction<_CPolygonGeometry Function(_CArray_CArray_CGeoPoint)>();

late final _CPolygonGeometry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPolygonGeometry_release');
late final _CPolygonGeometry_release = _CPolygonGeometry_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPolygonGeometry_retainPtr = _lookup<ffi.NativeFunction<_CPolygonGeometry Function(ffi.Pointer<ffi.Void>)>>('CPolygonGeometry_retain');
late final _CPolygonGeometry_retain = _CPolygonGeometry_retainPtr.asFunction<_CPolygonGeometry Function(ffi.Pointer<ffi.Void>)>();
late final _CPolygonGeometryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPolygonGeometry Function()>>('CPolygonGeometryMakeDefault');
late final _CPolygonGeometryMakeDefault = _CPolygonGeometryMakeDefaultPtr.asFunction<_CPolygonGeometry Function()>();

late final _CPolylineGeometry_pointsPtr = _lookup<ffi.NativeFunction<_CArray_CGeoPoint Function(_CPolylineGeometry)>>('CPolylineGeometry_points');
late final _CPolylineGeometry_points = _CPolylineGeometry_pointsPtr.asFunction<_CArray_CGeoPoint Function(_CPolylineGeometry)>();

late final _CPolylineGeometry_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPolylineGeometry_cg_objectIdentifier');
late final _CPolylineGeometry_cg_objectIdentifier = _CPolylineGeometry_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPolylineGeometry_C_createWith_CArray_CGeoPointPtr = _lookup<ffi.NativeFunction<_CPolylineGeometry Function(_CArray_CGeoPoint)>>('CPolylineGeometry_C_createWith_CArray_CGeoPoint');
late final _CPolylineGeometry_C_createWith_CArray_CGeoPoint = _CPolylineGeometry_C_createWith_CArray_CGeoPointPtr.asFunction<_CPolylineGeometry Function(_CArray_CGeoPoint)>();

late final _CPolylineGeometry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPolylineGeometry_release');
late final _CPolylineGeometry_release = _CPolylineGeometry_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPolylineGeometry_retainPtr = _lookup<ffi.NativeFunction<_CPolylineGeometry Function(ffi.Pointer<ffi.Void>)>>('CPolylineGeometry_retain');
late final _CPolylineGeometry_retain = _CPolylineGeometry_retainPtr.asFunction<_CPolylineGeometry Function(ffi.Pointer<ffi.Void>)>();
late final _CPolylineGeometryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPolylineGeometry Function()>>('CPolylineGeometryMakeDefault');
late final _CPolylineGeometryMakeDefault = _CPolylineGeometryMakeDefaultPtr.asFunction<_CPolylineGeometry Function()>();

late final _CComplexGeometry_elementsPtr = _lookup<ffi.NativeFunction<_CArray_CGeometry Function(_CComplexGeometry)>>('CComplexGeometry_elements');
late final _CComplexGeometry_elements = _CComplexGeometry_elementsPtr.asFunction<_CArray_CGeometry Function(_CComplexGeometry)>();

late final _CComplexGeometry_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CComplexGeometry_cg_objectIdentifier');
late final _CComplexGeometry_cg_objectIdentifier = _CComplexGeometry_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CComplexGeometry_C_createWith_CArray_CGeometryPtr = _lookup<ffi.NativeFunction<_CComplexGeometry Function(_CArray_CGeometry)>>('CComplexGeometry_C_createWith_CArray_CGeometry');
late final _CComplexGeometry_C_createWith_CArray_CGeometry = _CComplexGeometry_C_createWith_CArray_CGeometryPtr.asFunction<_CComplexGeometry Function(_CArray_CGeometry)>();

late final _CComplexGeometry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CComplexGeometry_release');
late final _CComplexGeometry_release = _CComplexGeometry_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CComplexGeometry_retainPtr = _lookup<ffi.NativeFunction<_CComplexGeometry Function(ffi.Pointer<ffi.Void>)>>('CComplexGeometry_retain');
late final _CComplexGeometry_retain = _CComplexGeometry_retainPtr.asFunction<_CComplexGeometry Function(ffi.Pointer<ffi.Void>)>();
late final _CComplexGeometryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CComplexGeometry Function()>>('CComplexGeometryMakeDefault');
late final _CComplexGeometryMakeDefault = _CComplexGeometryMakeDefaultPtr.asFunction<_CComplexGeometry Function()>();


late final _CArray_CGeometrymakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CGeometry Function()>>('CArray_CGeometry_makeEmpty');
late final _CArray_CGeometrymakeEmpty = _CArray_CGeometrymakeEmptyPtr.asFunction<_CArray_CGeometry Function()>();
late final _CArray_CGeometryaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CGeometry, _CGeometry)>>('CArray_CGeometry_addElement');
late final _CArray_CGeometryaddElement = _CArray_CGeometryaddElementPtr.asFunction<void Function(_CArray_CGeometry, _CGeometry)>();
late final _forEach_CArray_CGeometryPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CGeometry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeometry)>>)
>>('CArray_CGeometry_forEachWithFunctionPointer');
late final _forEach_CArray_CGeometry = _forEach_CArray_CGeometryPtr.asFunction<
  void Function(_CArray_CGeometry, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeometry)
>>)>();
late final _CArray_CGeometry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CGeometry)>>('CArray_CGeometry_release');
late final _CArray_CGeometry_release = _CArray_CGeometry_releasePtr.asFunction<void Function(_CArray_CGeometry)>();
late final _CFunction_G_downloadData_With_CContext_CStringPtr = _lookup<ffi.NativeFunction<_CFuture_CData Function(_CContext, _CString)>>('CFunction_G_downloadData_With_CContext_CString');
late final _CFunction_G_downloadData_With_CContext_CString = _CFunction_G_downloadData_With_CContext_CStringPtr.asFunction<_CFuture_CData Function(_CContext, _CString)>();

late final _CFuture_CDataMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CData Function()>>('CFuture_CDataMakeDefault');
late final _CFuture_CDataMakeDefault = _CFuture_CDataMakeDefaultPtr.asFunction<_CFuture_CData Function()>();
late final _CFuture_CData_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CData)>>('CFuture_CData_release');
late final _CFuture_CData_release = _CFuture_CData_releasePtr.asFunction<void Function(_CFuture_CData)>();
late final _CFuture_CData_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CData Function(_CFuture_CData)>>('CFuture_CData_retain');
late final _CFuture_CData_retain = _CFuture_CData_retainPtr.asFunction<_CFuture_CData Function(_CFuture_CData)>();
late final _CFuture_CDataReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CData,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CData, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CData_receive');
late final _CFuture_CDataReceive = _CFuture_CDataReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CData,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CData, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CAnchorMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAnchor Function()>>('CAnchorMakeDefault');
late final _CAnchorMakeDefault = _CAnchorMakeDefaultPtr.asFunction<_CAnchor Function()>();


late final _CArray_CAttributeValuemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CAttributeValue Function()>>('CArray_CAttributeValue_makeEmpty');
late final _CArray_CAttributeValuemakeEmpty = _CArray_CAttributeValuemakeEmptyPtr.asFunction<_CArray_CAttributeValue Function()>();
late final _CArray_CAttributeValueaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CAttributeValue, _CAttributeValue)>>('CArray_CAttributeValue_addElement');
late final _CArray_CAttributeValueaddElement = _CArray_CAttributeValueaddElementPtr.asFunction<void Function(_CArray_CAttributeValue, _CAttributeValue)>();
late final _forEach_CArray_CAttributeValuePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CAttributeValue, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CAttributeValue)>>)
>>('CArray_CAttributeValue_forEachWithFunctionPointer');
late final _forEach_CArray_CAttributeValue = _forEach_CArray_CAttributeValuePtr.asFunction<
  void Function(_CArray_CAttributeValue, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CAttributeValue)
>>)>();
late final _CArray_CAttributeValue_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CAttributeValue)>>('CArray_CAttributeValue_release');
late final _CArray_CAttributeValue_release = _CArray_CAttributeValue_releasePtr.asFunction<void Function(_CArray_CAttributeValue)>();

late final _CDictionary_CString_CAttributeValuemakeEmptyPtr = _lookup<ffi.NativeFunction<_CDictionary_CString_CAttributeValue Function()>>('CDictionary_CString_CAttributeValue_makeEmpty');
late final _CDictionary_CString_CAttributeValuemakeEmpty = _CDictionary_CString_CAttributeValuemakeEmptyPtr.asFunction<_CDictionary_CString_CAttributeValue Function()>();
late final _CDictionary_CString_CAttributeValueaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CDictionary_CString_CAttributeValue, _CString, _CAttributeValue)>>('CDictionary_CString_CAttributeValue_addElement');
late final _CDictionary_CString_CAttributeValueaddElement = _CDictionary_CString_CAttributeValueaddElementPtr.asFunction<void Function(_CDictionary_CString_CAttributeValue, _CString, _CAttributeValue)>();
late final _forEach_CDictionary_CString_CAttributeValuePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CDictionary_CString_CAttributeValue, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CString, _CAttributeValue)>>)
>>('CDictionary_CString_CAttributeValue_forEachKeyValueWithFunctionPointer');
late final _forEach_CDictionary_CString_CAttributeValue = _forEach_CDictionary_CString_CAttributeValuePtr.asFunction<
  void Function(_CDictionary_CString_CAttributeValue, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CString, _CAttributeValue)
>>)>();
late final _CDictionary_CString_CAttributeValue_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CDictionary_CString_CAttributeValue)>>('CDictionary_CString_CAttributeValue_release');
late final _CDictionary_CString_CAttributeValue_release = _CDictionary_CString_CAttributeValue_releasePtr.asFunction<void Function(_CDictionary_CString_CAttributeValue)>();

late final _CAttributeValue_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAttributeValue)>>('CAttributeValue_release');
late final _CAttributeValue_release = _CAttributeValue_releasePtr.asFunction<void Function(_CAttributeValue)>();
late final _CAttributeValueMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAttributeValue Function()>>('CAttributeValueMakeDefault');
late final _CAttributeValueMakeDefault = _CAttributeValueMakeDefaultPtr.asFunction<_CAttributeValue Function()>();

late final _CBearingSourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBearingSource Function()>>('CBearingSourceMakeDefault');
late final _CBearingSourceMakeDefault = _CBearingSourceMakeDefaultPtr.asFunction<_CBearingSource Function()>();

late final _CCameraAnimatedMoveReasonMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraAnimatedMoveReason Function()>>('CCameraAnimatedMoveReasonMakeDefault');
late final _CCameraAnimatedMoveReasonMakeDefault = _CCameraAnimatedMoveReasonMakeDefaultPtr.asFunction<_CCameraAnimatedMoveReason Function()>();

late final _CCameraAnimatedMoveResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraAnimatedMoveResult Function()>>('CCameraAnimatedMoveResultMakeDefault');
late final _CCameraAnimatedMoveResultMakeDefault = _CCameraAnimatedMoveResultMakeDefaultPtr.asFunction<_CCameraAnimatedMoveResult Function()>();

late final _CCameraAnimationTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraAnimationType Function()>>('CCameraAnimationTypeMakeDefault');
late final _CCameraAnimationTypeMakeDefault = _CCameraAnimationTypeMakeDefaultPtr.asFunction<_CCameraAnimationType Function()>();

late final _CCameraBehaviourChangeReasonMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraBehaviourChangeReason Function()>>('CCameraBehaviourChangeReasonMakeDefault');
late final _CCameraBehaviourChangeReasonMakeDefault = _CCameraBehaviourChangeReasonMakeDefaultPtr.asFunction<_CCameraBehaviourChangeReason Function()>();

late final _CCameraPositionPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraPositionPoint Function()>>('CCameraPositionPointMakeDefault');
late final _CCameraPositionPointMakeDefault = _CCameraPositionPointMakeDefaultPtr.asFunction<_CCameraPositionPoint Function()>();


late final _CCameraStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraState Function()>>('CCameraStateMakeDefault');
late final _CCameraStateMakeDefault = _CCameraStateMakeDefaultPtr.asFunction<_CCameraState Function()>();

late final _CCameraViewPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraViewPoint Function()>>('CCameraViewPointMakeDefault');
late final _CCameraViewPointMakeDefault = _CCameraViewPointMakeDefaultPtr.asFunction<_CCameraViewPoint Function()>();


late final _CColorMakeDefaultPtr = _lookup<ffi.NativeFunction<_CColor Function()>>('CColorMakeDefault');
late final _CColorMakeDefault = _CColorMakeDefaultPtr.asFunction<_CColor Function()>();


late final _CDeviceDensityMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDeviceDensity Function()>>('CDeviceDensityMakeDefault');
late final _CDeviceDensityMakeDefault = _CDeviceDensityMakeDefaultPtr.asFunction<_CDeviceDensity Function()>();


late final _CDevicePpiMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDevicePpi Function()>>('CDevicePpiMakeDefault');
late final _CDevicePpiMakeDefault = _CDevicePpiMakeDefaultPtr.asFunction<_CDevicePpi Function()>();


late final _CGraphicsPresetMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGraphicsPreset Function()>>('CGraphicsPresetMakeDefault');
late final _CGraphicsPresetMakeDefault = _CGraphicsPresetMakeDefaultPtr.asFunction<_CGraphicsPreset Function()>();

late final _CZIndexMakeDefaultPtr = _lookup<ffi.NativeFunction<_CZIndex Function()>>('CZIndexMakeDefault');
late final _CZIndexMakeDefault = _CZIndexMakeDefaultPtr.asFunction<_CZIndex Function()>();


late final _CZoomMakeDefaultPtr = _lookup<ffi.NativeFunction<_CZoom Function()>>('CZoomMakeDefault');
late final _CZoomMakeDefault = _CZoomMakeDefaultPtr.asFunction<_CZoom Function()>();


late final _CTiltMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTilt Function()>>('CTiltMakeDefault');
late final _CTiltMakeDefault = _CTiltMakeDefaultPtr.asFunction<_CTilt Function()>();


late final _CCameraPositionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraPosition Function()>>('CCameraPositionMakeDefault');
late final _CCameraPositionMakeDefault = _CCameraPositionMakeDefaultPtr.asFunction<_CCameraPosition Function()>();


late final _CCameraMoveControllerCpp_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCameraMoveControllerCpp_cg_objectIdentifier');
late final _CCameraMoveControllerCpp_cg_objectIdentifier = _CCameraMoveControllerCpp_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CCameraMoveControllerCpp_position_CTimeIntervalPtr = _lookup<ffi.NativeFunction<_CCameraPosition Function(_CCameraMoveControllerCpp, _CTimeInterval)>>('CCameraMoveControllerCpp_position_CTimeInterval');
late final _CCameraMoveControllerCpp_position_CTimeInterval = _CCameraMoveControllerCpp_position_CTimeIntervalPtr.asFunction<_CCameraPosition Function(_CCameraMoveControllerCpp, _CTimeInterval)>();
late final _CCameraMoveControllerCpp_animationTimePtr = _lookup<ffi.NativeFunction<_CTimeInterval Function(_CCameraMoveControllerCpp)>>('CCameraMoveControllerCpp_animationTime');
late final _CCameraMoveControllerCpp_animationTime = _CCameraMoveControllerCpp_animationTimePtr.asFunction<_CTimeInterval Function(_CCameraMoveControllerCpp)>();

late final _CCameraMoveControllerCpp_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCameraMoveControllerCpp_release');
late final _CCameraMoveControllerCpp_release = _CCameraMoveControllerCpp_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCameraMoveControllerCpp_retainPtr = _lookup<ffi.NativeFunction<_CCameraMoveControllerCpp Function(ffi.Pointer<ffi.Void>)>>('CCameraMoveControllerCpp_retain');
late final _CCameraMoveControllerCpp_retain = _CCameraMoveControllerCpp_retainPtr.asFunction<_CCameraMoveControllerCpp Function(ffi.Pointer<ffi.Void>)>();
late final _CCameraMoveControllerCppMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraMoveControllerCpp Function()>>('CCameraMoveControllerCppMakeDefault');
late final _CCameraMoveControllerCppMakeDefault = _CCameraMoveControllerCppMakeDefaultPtr.asFunction<_CCameraMoveControllerCpp Function()>();


late final _CCameraMoveControllerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraMoveController Function()>>('CCameraMoveControllerMakeDefault');
late final _CCameraMoveControllerMakeDefault = _CCameraMoveControllerMakeDefaultPtr.asFunction<_CCameraMoveController Function()>();
late final _CCameraMoveController_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCameraMoveController)>>('CCameraMoveController_release');
late final _CCameraMoveController_release = _CCameraMoveController_releasePtr.asFunction<void Function(_CCameraMoveController)>();

late final _CNewValuesNotifier_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CNewValuesNotifier_cg_objectIdentifier');
late final _CNewValuesNotifier_cg_objectIdentifier = _CNewValuesNotifier_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CNewValuesNotifier_sendNotificationPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CNewValuesNotifier)>>('CNewValuesNotifier_sendNotification');
late final _CNewValuesNotifier_sendNotification = _CNewValuesNotifier_sendNotificationPtr.asFunction<void Function(_CNewValuesNotifier)>();

late final _CNewValuesNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CNewValuesNotifier_release');
late final _CNewValuesNotifier_release = _CNewValuesNotifier_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CNewValuesNotifier_retainPtr = _lookup<ffi.NativeFunction<_CNewValuesNotifier Function(ffi.Pointer<ffi.Void>)>>('CNewValuesNotifier_retain');
late final _CNewValuesNotifier_retain = _CNewValuesNotifier_retainPtr.asFunction<_CNewValuesNotifier Function(ffi.Pointer<ffi.Void>)>();
late final _CNewValuesNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_CNewValuesNotifier Function()>>('CNewValuesNotifierMakeDefault');
late final _CNewValuesNotifierMakeDefault = _CNewValuesNotifierMakeDefaultPtr.asFunction<_CNewValuesNotifier Function()>();


late final _CFollowValueMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFollowValue Function()>>('CFollowValueMakeDefault');
late final _CFollowValueMakeDefault = _CFollowValueMakeDefaultPtr.asFunction<_CFollowValue Function()>();

late final _CStyleZoomMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStyleZoom Function()>>('CStyleZoomMakeDefault');
late final _CStyleZoomMakeDefault = _CStyleZoomMakeDefaultPtr.asFunction<_CStyleZoom Function()>();


late final _CCustomFollowControllerCpp_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCustomFollowControllerCpp_cg_objectIdentifier');
late final _CCustomFollowControllerCpp_cg_objectIdentifier = _CCustomFollowControllerCpp_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CCustomFollowControllerCpp_availableValuesPtr = _lookup<ffi.NativeFunction<_COptionSet_CFollowValue Function(_CCustomFollowControllerCpp)>>('CCustomFollowControllerCpp_availableValues');
late final _CCustomFollowControllerCpp_availableValues = _CCustomFollowControllerCpp_availableValuesPtr.asFunction<_COptionSet_CFollowValue Function(_CCustomFollowControllerCpp)>();
late final _CCustomFollowControllerCpp_requestValues_COptionSet_CFollowValuePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCustomFollowControllerCpp, _COptionSet_CFollowValue)>>('CCustomFollowControllerCpp_requestValues_COptionSet_CFollowValue');
late final _CCustomFollowControllerCpp_requestValues_COptionSet_CFollowValue = _CCustomFollowControllerCpp_requestValues_COptionSet_CFollowValuePtr.asFunction<void Function(_CCustomFollowControllerCpp, _COptionSet_CFollowValue)>();
late final _CCustomFollowControllerCpp_setNewValuesNotifier_COptional_CNewValuesNotifierPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCustomFollowControllerCpp, _COptional_CNewValuesNotifier)>>('CCustomFollowControllerCpp_setNewValuesNotifier_COptional_CNewValuesNotifier');
late final _CCustomFollowControllerCpp_setNewValuesNotifier_COptional_CNewValuesNotifier = _CCustomFollowControllerCpp_setNewValuesNotifier_COptional_CNewValuesNotifierPtr.asFunction<void Function(_CCustomFollowControllerCpp, _COptional_CNewValuesNotifier)>();
late final _CCustomFollowControllerCpp_coordinatesPtr = _lookup<ffi.NativeFunction<_COptional_CGeoPoint Function(_CCustomFollowControllerCpp)>>('CCustomFollowControllerCpp_coordinates');
late final _CCustomFollowControllerCpp_coordinates = _CCustomFollowControllerCpp_coordinatesPtr.asFunction<_COptional_CGeoPoint Function(_CCustomFollowControllerCpp)>();
late final _CCustomFollowControllerCpp_bearingPtr = _lookup<ffi.NativeFunction<_COptional_CBearing Function(_CCustomFollowControllerCpp)>>('CCustomFollowControllerCpp_bearing');
late final _CCustomFollowControllerCpp_bearing = _CCustomFollowControllerCpp_bearingPtr.asFunction<_COptional_CBearing Function(_CCustomFollowControllerCpp)>();
late final _CCustomFollowControllerCpp_tiltPtr = _lookup<ffi.NativeFunction<_COptional_CTilt Function(_CCustomFollowControllerCpp)>>('CCustomFollowControllerCpp_tilt');
late final _CCustomFollowControllerCpp_tilt = _CCustomFollowControllerCpp_tiltPtr.asFunction<_COptional_CTilt Function(_CCustomFollowControllerCpp)>();
late final _CCustomFollowControllerCpp_styleZoomPtr = _lookup<ffi.NativeFunction<_COptional_CStyleZoom Function(_CCustomFollowControllerCpp)>>('CCustomFollowControllerCpp_styleZoom');
late final _CCustomFollowControllerCpp_styleZoom = _CCustomFollowControllerCpp_styleZoomPtr.asFunction<_COptional_CStyleZoom Function(_CCustomFollowControllerCpp)>();

late final _CCustomFollowControllerCpp_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCustomFollowControllerCpp_release');
late final _CCustomFollowControllerCpp_release = _CCustomFollowControllerCpp_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCustomFollowControllerCpp_retainPtr = _lookup<ffi.NativeFunction<_CCustomFollowControllerCpp Function(ffi.Pointer<ffi.Void>)>>('CCustomFollowControllerCpp_retain');
late final _CCustomFollowControllerCpp_retain = _CCustomFollowControllerCpp_retainPtr.asFunction<_CCustomFollowControllerCpp Function(ffi.Pointer<ffi.Void>)>();
late final _CCustomFollowControllerCppMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCustomFollowControllerCpp Function()>>('CCustomFollowControllerCppMakeDefault');
late final _CCustomFollowControllerCppMakeDefault = _CCustomFollowControllerCppMakeDefaultPtr.asFunction<_CCustomFollowControllerCpp Function()>();


late final _COptionSet_CFollowValueMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptionSet_CFollowValue Function()>>('COptionSet_CFollowValueMakeDefault');
late final _COptionSet_CFollowValueMakeDefault = _COptionSet_CFollowValueMakeDefaultPtr.asFunction<_COptionSet_CFollowValue Function()>();

late final _COptional_CNewValuesNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CNewValuesNotifier Function()>>('COptional_CNewValuesNotifierMakeDefault');
late final _COptional_CNewValuesNotifierMakeDefault = _COptional_CNewValuesNotifierMakeDefaultPtr.asFunction<_COptional_CNewValuesNotifier Function()>();

late final _COptional_CNewValuesNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CNewValuesNotifier)>>('COptional_CNewValuesNotifier_release');
late final _COptional_CNewValuesNotifier_release = _COptional_CNewValuesNotifier_releasePtr.asFunction<void Function(_COptional_CNewValuesNotifier)>();

late final _COptional_CTiltMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CTilt Function()>>('COptional_CTiltMakeDefault');
late final _COptional_CTiltMakeDefault = _COptional_CTiltMakeDefaultPtr.asFunction<_COptional_CTilt Function()>();

late final _COptional_CStyleZoomMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CStyleZoom Function()>>('COptional_CStyleZoomMakeDefault');
late final _COptional_CStyleZoomMakeDefault = _COptional_CStyleZoomMakeDefaultPtr.asFunction<_COptional_CStyleZoom Function()>();

late final _CCustomFollowControllerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCustomFollowController Function()>>('CCustomFollowControllerMakeDefault');
late final _CCustomFollowControllerMakeDefault = _CCustomFollowControllerMakeDefaultPtr.asFunction<_CCustomFollowController Function()>();
late final _CCustomFollowController_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCustomFollowController)>>('CCustomFollowController_release');
late final _CCustomFollowController_release = _CCustomFollowController_releasePtr.asFunction<void Function(_CCustomFollowController)>();

late final _CEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CEvent_cg_objectIdentifier');
late final _CEvent_cg_objectIdentifier = _CEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CEvent_cg_getSelectorPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CEvent)>>('CEvent_cg_getSelector');
late final _CEvent_cg_getSelector = _CEvent_cg_getSelectorPtr.asFunction<int Function(_CEvent)>();

late final _CEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CEvent_release');
late final _CEvent_release = _CEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CEvent_retainPtr = _lookup<ffi.NativeFunction<_CEvent Function(ffi.Pointer<ffi.Void>)>>('CEvent_retain');
late final _CEvent_retain = _CEvent_retainPtr.asFunction<_CEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CEvent Function()>>('CEventMakeDefault');
late final _CEventMakeDefault = _CEventMakeDefaultPtr.asFunction<_CEvent Function()>();

late final _CInputEvent_timestampPtr = _lookup<ffi.NativeFunction<_CTimeInterval Function(_CInputEvent)>>('CInputEvent_timestamp');
late final _CInputEvent_timestamp = _CInputEvent_timestampPtr.asFunction<_CTimeInterval Function(_CInputEvent)>();

late final _CInputEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CInputEvent_cg_objectIdentifier');
late final _CInputEvent_cg_objectIdentifier = _CInputEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CInputEvent_cg_getSelectorPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CInputEvent)>>('CInputEvent_cg_getSelector');
late final _CInputEvent_cg_getSelector = _CInputEvent_cg_getSelectorPtr.asFunction<int Function(_CInputEvent)>();

late final _CInputEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CInputEvent_release');
late final _CInputEvent_release = _CInputEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CInputEvent_retainPtr = _lookup<ffi.NativeFunction<_CInputEvent Function(ffi.Pointer<ffi.Void>)>>('CInputEvent_retain');
late final _CInputEvent_retain = _CInputEvent_retainPtr.asFunction<_CInputEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CInputEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CInputEvent Function()>>('CInputEventMakeDefault');
late final _CInputEventMakeDefault = _CInputEventMakeDefaultPtr.asFunction<_CInputEvent Function()>();


late final _CCancelEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCancelEvent_cg_objectIdentifier');
late final _CCancelEvent_cg_objectIdentifier = _CCancelEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CCancelEvent_C_createPtr = _lookup<ffi.NativeFunction<_CCancelEvent Function()>>('CCancelEvent_C_create');
late final _CCancelEvent_C_create = _CCancelEvent_C_createPtr.asFunction<_CCancelEvent Function()>();

late final _CCancelEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCancelEvent_release');
late final _CCancelEvent_release = _CCancelEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCancelEvent_retainPtr = _lookup<ffi.NativeFunction<_CCancelEvent Function(ffi.Pointer<ffi.Void>)>>('CCancelEvent_retain');
late final _CCancelEvent_retain = _CCancelEvent_retainPtr.asFunction<_CCancelEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CCancelEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCancelEvent Function()>>('CCancelEventMakeDefault');
late final _CCancelEventMakeDefault = _CCancelEventMakeDefaultPtr.asFunction<_CCancelEvent Function()>();


late final _CDgisSourceWorkingModeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDgisSourceWorkingMode Function()>>('CDgisSourceWorkingModeMakeDefault');
late final _CDgisSourceWorkingModeMakeDefault = _CDgisSourceWorkingModeMakeDefaultPtr.asFunction<_CDgisSourceWorkingMode Function()>();

late final _CDirectMapControlBeginEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CDirectMapControlBeginEvent_cg_objectIdentifier');
late final _CDirectMapControlBeginEvent_cg_objectIdentifier = _CDirectMapControlBeginEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CDirectMapControlBeginEvent_C_createPtr = _lookup<ffi.NativeFunction<_CDirectMapControlBeginEvent Function()>>('CDirectMapControlBeginEvent_C_create');
late final _CDirectMapControlBeginEvent_C_create = _CDirectMapControlBeginEvent_C_createPtr.asFunction<_CDirectMapControlBeginEvent Function()>();

late final _CDirectMapControlBeginEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CDirectMapControlBeginEvent_release');
late final _CDirectMapControlBeginEvent_release = _CDirectMapControlBeginEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapControlBeginEvent_retainPtr = _lookup<ffi.NativeFunction<_CDirectMapControlBeginEvent Function(ffi.Pointer<ffi.Void>)>>('CDirectMapControlBeginEvent_retain');
late final _CDirectMapControlBeginEvent_retain = _CDirectMapControlBeginEvent_retainPtr.asFunction<_CDirectMapControlBeginEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapControlBeginEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDirectMapControlBeginEvent Function()>>('CDirectMapControlBeginEventMakeDefault');
late final _CDirectMapControlBeginEventMakeDefault = _CDirectMapControlBeginEventMakeDefaultPtr.asFunction<_CDirectMapControlBeginEvent Function()>();


late final _CDirectMapControlEndEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CDirectMapControlEndEvent_cg_objectIdentifier');
late final _CDirectMapControlEndEvent_cg_objectIdentifier = _CDirectMapControlEndEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CDirectMapControlEndEvent_C_createWith_CTimeIntervalPtr = _lookup<ffi.NativeFunction<_CDirectMapControlEndEvent Function(_CTimeInterval)>>('CDirectMapControlEndEvent_C_createWith_CTimeInterval');
late final _CDirectMapControlEndEvent_C_createWith_CTimeInterval = _CDirectMapControlEndEvent_C_createWith_CTimeIntervalPtr.asFunction<_CDirectMapControlEndEvent Function(_CTimeInterval)>();

late final _CDirectMapControlEndEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CDirectMapControlEndEvent_release');
late final _CDirectMapControlEndEvent_release = _CDirectMapControlEndEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapControlEndEvent_retainPtr = _lookup<ffi.NativeFunction<_CDirectMapControlEndEvent Function(ffi.Pointer<ffi.Void>)>>('CDirectMapControlEndEvent_retain');
late final _CDirectMapControlEndEvent_retain = _CDirectMapControlEndEvent_retainPtr.asFunction<_CDirectMapControlEndEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapControlEndEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDirectMapControlEndEvent Function()>>('CDirectMapControlEndEventMakeDefault');
late final _CDirectMapControlEndEventMakeDefault = _CDirectMapControlEndEventMakeDefaultPtr.asFunction<_CDirectMapControlEndEvent Function()>();


late final _CScreenPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScreenPoint Function()>>('CScreenPointMakeDefault');
late final _CScreenPointMakeDefault = _CScreenPointMakeDefaultPtr.asFunction<_CScreenPoint Function()>();

late final _CDirectMapRotationEvent_bearingDeltaPtr = _lookup<ffi.NativeFunction<_CBearing Function(_CDirectMapRotationEvent)>>('CDirectMapRotationEvent_bearingDelta');
late final _CDirectMapRotationEvent_bearingDelta = _CDirectMapRotationEvent_bearingDeltaPtr.asFunction<_CBearing Function(_CDirectMapRotationEvent)>();
late final _CDirectMapRotationEvent_rotationCenterPtr = _lookup<ffi.NativeFunction<_COptional_CScreenPoint Function(_CDirectMapRotationEvent)>>('CDirectMapRotationEvent_rotationCenter');
late final _CDirectMapRotationEvent_rotationCenter = _CDirectMapRotationEvent_rotationCenterPtr.asFunction<_COptional_CScreenPoint Function(_CDirectMapRotationEvent)>();

late final _CDirectMapRotationEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CDirectMapRotationEvent_cg_objectIdentifier');
late final _CDirectMapRotationEvent_cg_objectIdentifier = _CDirectMapRotationEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CDirectMapRotationEvent_C_createWith_CBearing_CTimeInterval_COptional_CScreenPointPtr = _lookup<ffi.NativeFunction<_CDirectMapRotationEvent Function(_CBearing, _CTimeInterval, _COptional_CScreenPoint)>>('CDirectMapRotationEvent_C_createWith_CBearing_CTimeInterval_COptional_CScreenPoint');
late final _CDirectMapRotationEvent_C_createWith_CBearing_CTimeInterval_COptional_CScreenPoint = _CDirectMapRotationEvent_C_createWith_CBearing_CTimeInterval_COptional_CScreenPointPtr.asFunction<_CDirectMapRotationEvent Function(_CBearing, _CTimeInterval, _COptional_CScreenPoint)>();

late final _CDirectMapRotationEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CDirectMapRotationEvent_release');
late final _CDirectMapRotationEvent_release = _CDirectMapRotationEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapRotationEvent_retainPtr = _lookup<ffi.NativeFunction<_CDirectMapRotationEvent Function(ffi.Pointer<ffi.Void>)>>('CDirectMapRotationEvent_retain');
late final _CDirectMapRotationEvent_retain = _CDirectMapRotationEvent_retainPtr.asFunction<_CDirectMapRotationEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapRotationEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDirectMapRotationEvent Function()>>('CDirectMapRotationEventMakeDefault');
late final _CDirectMapRotationEventMakeDefault = _CDirectMapRotationEventMakeDefaultPtr.asFunction<_CDirectMapRotationEvent Function()>();


late final _COptional_CScreenPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CScreenPoint Function()>>('COptional_CScreenPointMakeDefault');
late final _COptional_CScreenPointMakeDefault = _COptional_CScreenPointMakeDefaultPtr.asFunction<_COptional_CScreenPoint Function()>();
late final _CDirectMapScalingEvent_zoomDeltaPtr = _lookup<ffi.NativeFunction<ffi.Float Function(_CDirectMapScalingEvent)>>('CDirectMapScalingEvent_zoomDelta');
late final _CDirectMapScalingEvent_zoomDelta = _CDirectMapScalingEvent_zoomDeltaPtr.asFunction<double Function(_CDirectMapScalingEvent)>();
late final _CDirectMapScalingEvent_scalingCenterPtr = _lookup<ffi.NativeFunction<_COptional_CScreenPoint Function(_CDirectMapScalingEvent)>>('CDirectMapScalingEvent_scalingCenter');
late final _CDirectMapScalingEvent_scalingCenter = _CDirectMapScalingEvent_scalingCenterPtr.asFunction<_COptional_CScreenPoint Function(_CDirectMapScalingEvent)>();

late final _CDirectMapScalingEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CDirectMapScalingEvent_cg_objectIdentifier');
late final _CDirectMapScalingEvent_cg_objectIdentifier = _CDirectMapScalingEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CDirectMapScalingEvent_C_createWith_float_CTimeInterval_COptional_CScreenPointPtr = _lookup<ffi.NativeFunction<_CDirectMapScalingEvent Function(ffi.Float, _CTimeInterval, _COptional_CScreenPoint)>>('CDirectMapScalingEvent_C_createWith_float_CTimeInterval_COptional_CScreenPoint');
late final _CDirectMapScalingEvent_C_createWith_float_CTimeInterval_COptional_CScreenPoint = _CDirectMapScalingEvent_C_createWith_float_CTimeInterval_COptional_CScreenPointPtr.asFunction<_CDirectMapScalingEvent Function(double, _CTimeInterval, _COptional_CScreenPoint)>();

late final _CDirectMapScalingEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CDirectMapScalingEvent_release');
late final _CDirectMapScalingEvent_release = _CDirectMapScalingEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapScalingEvent_retainPtr = _lookup<ffi.NativeFunction<_CDirectMapScalingEvent Function(ffi.Pointer<ffi.Void>)>>('CDirectMapScalingEvent_retain');
late final _CDirectMapScalingEvent_retain = _CDirectMapScalingEvent_retainPtr.asFunction<_CDirectMapScalingEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapScalingEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDirectMapScalingEvent Function()>>('CDirectMapScalingEventMakeDefault');
late final _CDirectMapScalingEventMakeDefault = _CDirectMapScalingEventMakeDefaultPtr.asFunction<_CDirectMapScalingEvent Function()>();


late final _CScreenShiftMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScreenShift Function()>>('CScreenShiftMakeDefault');
late final _CScreenShiftMakeDefault = _CScreenShiftMakeDefaultPtr.asFunction<_CScreenShift Function()>();

late final _CDirectMapShiftEvent_screenShiftPtr = _lookup<ffi.NativeFunction<_CScreenShift Function(_CDirectMapShiftEvent)>>('CDirectMapShiftEvent_screenShift');
late final _CDirectMapShiftEvent_screenShift = _CDirectMapShiftEvent_screenShiftPtr.asFunction<_CScreenShift Function(_CDirectMapShiftEvent)>();
late final _CDirectMapShiftEvent_shiftedPointPtr = _lookup<ffi.NativeFunction<_CScreenPoint Function(_CDirectMapShiftEvent)>>('CDirectMapShiftEvent_shiftedPoint');
late final _CDirectMapShiftEvent_shiftedPoint = _CDirectMapShiftEvent_shiftedPointPtr.asFunction<_CScreenPoint Function(_CDirectMapShiftEvent)>();

late final _CDirectMapShiftEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CDirectMapShiftEvent_cg_objectIdentifier');
late final _CDirectMapShiftEvent_cg_objectIdentifier = _CDirectMapShiftEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CDirectMapShiftEvent_C_createWith_CScreenShift_CScreenPoint_CTimeIntervalPtr = _lookup<ffi.NativeFunction<_CDirectMapShiftEvent Function(_CScreenShift, _CScreenPoint, _CTimeInterval)>>('CDirectMapShiftEvent_C_createWith_CScreenShift_CScreenPoint_CTimeInterval');
late final _CDirectMapShiftEvent_C_createWith_CScreenShift_CScreenPoint_CTimeInterval = _CDirectMapShiftEvent_C_createWith_CScreenShift_CScreenPoint_CTimeIntervalPtr.asFunction<_CDirectMapShiftEvent Function(_CScreenShift, _CScreenPoint, _CTimeInterval)>();

late final _CDirectMapShiftEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CDirectMapShiftEvent_release');
late final _CDirectMapShiftEvent_release = _CDirectMapShiftEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapShiftEvent_retainPtr = _lookup<ffi.NativeFunction<_CDirectMapShiftEvent Function(ffi.Pointer<ffi.Void>)>>('CDirectMapShiftEvent_retain');
late final _CDirectMapShiftEvent_retain = _CDirectMapShiftEvent_retainPtr.asFunction<_CDirectMapShiftEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapShiftEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDirectMapShiftEvent Function()>>('CDirectMapShiftEventMakeDefault');
late final _CDirectMapShiftEventMakeDefault = _CDirectMapShiftEventMakeDefaultPtr.asFunction<_CDirectMapShiftEvent Function()>();

late final _CDirectMapTiltEvent_deltaPtr = _lookup<ffi.NativeFunction<ffi.Float Function(_CDirectMapTiltEvent)>>('CDirectMapTiltEvent_delta');
late final _CDirectMapTiltEvent_delta = _CDirectMapTiltEvent_deltaPtr.asFunction<double Function(_CDirectMapTiltEvent)>();

late final _CDirectMapTiltEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CDirectMapTiltEvent_cg_objectIdentifier');
late final _CDirectMapTiltEvent_cg_objectIdentifier = _CDirectMapTiltEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CDirectMapTiltEvent_C_createWith_float_CTimeIntervalPtr = _lookup<ffi.NativeFunction<_CDirectMapTiltEvent Function(ffi.Float, _CTimeInterval)>>('CDirectMapTiltEvent_C_createWith_float_CTimeInterval');
late final _CDirectMapTiltEvent_C_createWith_float_CTimeInterval = _CDirectMapTiltEvent_C_createWith_float_CTimeIntervalPtr.asFunction<_CDirectMapTiltEvent Function(double, _CTimeInterval)>();

late final _CDirectMapTiltEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CDirectMapTiltEvent_release');
late final _CDirectMapTiltEvent_release = _CDirectMapTiltEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapTiltEvent_retainPtr = _lookup<ffi.NativeFunction<_CDirectMapTiltEvent Function(ffi.Pointer<ffi.Void>)>>('CDirectMapTiltEvent_retain');
late final _CDirectMapTiltEvent_retain = _CDirectMapTiltEvent_retainPtr.asFunction<_CDirectMapTiltEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CDirectMapTiltEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDirectMapTiltEvent Function()>>('CDirectMapTiltEventMakeDefault');
late final _CDirectMapTiltEventMakeDefault = _CDirectMapTiltEventMakeDefaultPtr.asFunction<_CDirectMapTiltEvent Function()>();


late final _CMapRotationDirectionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapRotationDirection Function()>>('CMapRotationDirectionMakeDefault');
late final _CMapRotationDirectionMakeDefault = _CMapRotationDirectionMakeDefaultPtr.asFunction<_CMapRotationDirection Function()>();
late final _CMapRotationBeginEvent_directionPtr = _lookup<ffi.NativeFunction<_CMapRotationDirection Function(_CMapRotationBeginEvent)>>('CMapRotationBeginEvent_direction');
late final _CMapRotationBeginEvent_direction = _CMapRotationBeginEvent_directionPtr.asFunction<_CMapRotationDirection Function(_CMapRotationBeginEvent)>();

late final _CMapRotationBeginEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapRotationBeginEvent_cg_objectIdentifier');
late final _CMapRotationBeginEvent_cg_objectIdentifier = _CMapRotationBeginEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapRotationBeginEvent_C_createWith_CMapRotationDirectionPtr = _lookup<ffi.NativeFunction<_CMapRotationBeginEvent Function(_CMapRotationDirection)>>('CMapRotationBeginEvent_C_createWith_CMapRotationDirection');
late final _CMapRotationBeginEvent_C_createWith_CMapRotationDirection = _CMapRotationBeginEvent_C_createWith_CMapRotationDirectionPtr.asFunction<_CMapRotationBeginEvent Function(_CMapRotationDirection)>();

late final _CMapRotationBeginEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapRotationBeginEvent_release');
late final _CMapRotationBeginEvent_release = _CMapRotationBeginEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapRotationBeginEvent_retainPtr = _lookup<ffi.NativeFunction<_CMapRotationBeginEvent Function(ffi.Pointer<ffi.Void>)>>('CMapRotationBeginEvent_retain');
late final _CMapRotationBeginEvent_retain = _CMapRotationBeginEvent_retainPtr.asFunction<_CMapRotationBeginEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CMapRotationBeginEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapRotationBeginEvent Function()>>('CMapRotationBeginEventMakeDefault');
late final _CMapRotationBeginEventMakeDefault = _CMapRotationBeginEventMakeDefaultPtr.asFunction<_CMapRotationBeginEvent Function()>();


late final _CMapRotationEndEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapRotationEndEvent_cg_objectIdentifier');
late final _CMapRotationEndEvent_cg_objectIdentifier = _CMapRotationEndEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapRotationEndEvent_C_createPtr = _lookup<ffi.NativeFunction<_CMapRotationEndEvent Function()>>('CMapRotationEndEvent_C_create');
late final _CMapRotationEndEvent_C_create = _CMapRotationEndEvent_C_createPtr.asFunction<_CMapRotationEndEvent Function()>();

late final _CMapRotationEndEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapRotationEndEvent_release');
late final _CMapRotationEndEvent_release = _CMapRotationEndEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapRotationEndEvent_retainPtr = _lookup<ffi.NativeFunction<_CMapRotationEndEvent Function(ffi.Pointer<ffi.Void>)>>('CMapRotationEndEvent_retain');
late final _CMapRotationEndEvent_retain = _CMapRotationEndEvent_retainPtr.asFunction<_CMapRotationEndEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CMapRotationEndEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapRotationEndEvent Function()>>('CMapRotationEndEventMakeDefault');
late final _CMapRotationEndEventMakeDefault = _CMapRotationEndEventMakeDefaultPtr.asFunction<_CMapRotationEndEvent Function()>();


late final _CMapScalingDirectionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapScalingDirection Function()>>('CMapScalingDirectionMakeDefault');
late final _CMapScalingDirectionMakeDefault = _CMapScalingDirectionMakeDefaultPtr.asFunction<_CMapScalingDirection Function()>();
late final _CMapScalingBeginEvent_directionPtr = _lookup<ffi.NativeFunction<_CMapScalingDirection Function(_CMapScalingBeginEvent)>>('CMapScalingBeginEvent_direction');
late final _CMapScalingBeginEvent_direction = _CMapScalingBeginEvent_directionPtr.asFunction<_CMapScalingDirection Function(_CMapScalingBeginEvent)>();

late final _CMapScalingBeginEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapScalingBeginEvent_cg_objectIdentifier');
late final _CMapScalingBeginEvent_cg_objectIdentifier = _CMapScalingBeginEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapScalingBeginEvent_C_createWith_CMapScalingDirectionPtr = _lookup<ffi.NativeFunction<_CMapScalingBeginEvent Function(_CMapScalingDirection)>>('CMapScalingBeginEvent_C_createWith_CMapScalingDirection');
late final _CMapScalingBeginEvent_C_createWith_CMapScalingDirection = _CMapScalingBeginEvent_C_createWith_CMapScalingDirectionPtr.asFunction<_CMapScalingBeginEvent Function(_CMapScalingDirection)>();

late final _CMapScalingBeginEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapScalingBeginEvent_release');
late final _CMapScalingBeginEvent_release = _CMapScalingBeginEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapScalingBeginEvent_retainPtr = _lookup<ffi.NativeFunction<_CMapScalingBeginEvent Function(ffi.Pointer<ffi.Void>)>>('CMapScalingBeginEvent_retain');
late final _CMapScalingBeginEvent_retain = _CMapScalingBeginEvent_retainPtr.asFunction<_CMapScalingBeginEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CMapScalingBeginEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapScalingBeginEvent Function()>>('CMapScalingBeginEventMakeDefault');
late final _CMapScalingBeginEventMakeDefault = _CMapScalingBeginEventMakeDefaultPtr.asFunction<_CMapScalingBeginEvent Function()>();


late final _CMapScalingEndEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapScalingEndEvent_cg_objectIdentifier');
late final _CMapScalingEndEvent_cg_objectIdentifier = _CMapScalingEndEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapScalingEndEvent_C_createPtr = _lookup<ffi.NativeFunction<_CMapScalingEndEvent Function()>>('CMapScalingEndEvent_C_create');
late final _CMapScalingEndEvent_C_create = _CMapScalingEndEvent_C_createPtr.asFunction<_CMapScalingEndEvent Function()>();

late final _CMapScalingEndEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapScalingEndEvent_release');
late final _CMapScalingEndEvent_release = _CMapScalingEndEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapScalingEndEvent_retainPtr = _lookup<ffi.NativeFunction<_CMapScalingEndEvent Function(ffi.Pointer<ffi.Void>)>>('CMapScalingEndEvent_retain');
late final _CMapScalingEndEvent_retain = _CMapScalingEndEvent_retainPtr.asFunction<_CMapScalingEndEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CMapScalingEndEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapScalingEndEvent Function()>>('CMapScalingEndEventMakeDefault');
late final _CMapScalingEndEventMakeDefault = _CMapScalingEndEventMakeDefaultPtr.asFunction<_CMapScalingEndEvent Function()>();


late final _CMapShiftDirectionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapShiftDirection Function()>>('CMapShiftDirectionMakeDefault');
late final _CMapShiftDirectionMakeDefault = _CMapShiftDirectionMakeDefaultPtr.asFunction<_CMapShiftDirection Function()>();
late final _CMapShiftBeginEvent_directionPtr = _lookup<ffi.NativeFunction<_CMapShiftDirection Function(_CMapShiftBeginEvent)>>('CMapShiftBeginEvent_direction');
late final _CMapShiftBeginEvent_direction = _CMapShiftBeginEvent_directionPtr.asFunction<_CMapShiftDirection Function(_CMapShiftBeginEvent)>();

late final _CMapShiftBeginEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapShiftBeginEvent_cg_objectIdentifier');
late final _CMapShiftBeginEvent_cg_objectIdentifier = _CMapShiftBeginEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapShiftBeginEvent_C_createWith_CMapShiftDirectionPtr = _lookup<ffi.NativeFunction<_CMapShiftBeginEvent Function(_CMapShiftDirection)>>('CMapShiftBeginEvent_C_createWith_CMapShiftDirection');
late final _CMapShiftBeginEvent_C_createWith_CMapShiftDirection = _CMapShiftBeginEvent_C_createWith_CMapShiftDirectionPtr.asFunction<_CMapShiftBeginEvent Function(_CMapShiftDirection)>();

late final _CMapShiftBeginEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapShiftBeginEvent_release');
late final _CMapShiftBeginEvent_release = _CMapShiftBeginEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapShiftBeginEvent_retainPtr = _lookup<ffi.NativeFunction<_CMapShiftBeginEvent Function(ffi.Pointer<ffi.Void>)>>('CMapShiftBeginEvent_retain');
late final _CMapShiftBeginEvent_retain = _CMapShiftBeginEvent_retainPtr.asFunction<_CMapShiftBeginEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CMapShiftBeginEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapShiftBeginEvent Function()>>('CMapShiftBeginEventMakeDefault');
late final _CMapShiftBeginEventMakeDefault = _CMapShiftBeginEventMakeDefaultPtr.asFunction<_CMapShiftBeginEvent Function()>();


late final _CMapShiftEndEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapShiftEndEvent_cg_objectIdentifier');
late final _CMapShiftEndEvent_cg_objectIdentifier = _CMapShiftEndEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapShiftEndEvent_C_createPtr = _lookup<ffi.NativeFunction<_CMapShiftEndEvent Function()>>('CMapShiftEndEvent_C_create');
late final _CMapShiftEndEvent_C_create = _CMapShiftEndEvent_C_createPtr.asFunction<_CMapShiftEndEvent Function()>();

late final _CMapShiftEndEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapShiftEndEvent_release');
late final _CMapShiftEndEvent_release = _CMapShiftEndEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapShiftEndEvent_retainPtr = _lookup<ffi.NativeFunction<_CMapShiftEndEvent Function(ffi.Pointer<ffi.Void>)>>('CMapShiftEndEvent_retain');
late final _CMapShiftEndEvent_retain = _CMapShiftEndEvent_retainPtr.asFunction<_CMapShiftEndEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CMapShiftEndEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapShiftEndEvent Function()>>('CMapShiftEndEventMakeDefault');
late final _CMapShiftEndEventMakeDefault = _CMapShiftEndEventMakeDefaultPtr.asFunction<_CMapShiftEndEvent Function()>();


late final _CRotateMapToNorthEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRotateMapToNorthEvent_cg_objectIdentifier');
late final _CRotateMapToNorthEvent_cg_objectIdentifier = _CRotateMapToNorthEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRotateMapToNorthEvent_C_createPtr = _lookup<ffi.NativeFunction<_CRotateMapToNorthEvent Function()>>('CRotateMapToNorthEvent_C_create');
late final _CRotateMapToNorthEvent_C_create = _CRotateMapToNorthEvent_C_createPtr.asFunction<_CRotateMapToNorthEvent Function()>();

late final _CRotateMapToNorthEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRotateMapToNorthEvent_release');
late final _CRotateMapToNorthEvent_release = _CRotateMapToNorthEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRotateMapToNorthEvent_retainPtr = _lookup<ffi.NativeFunction<_CRotateMapToNorthEvent Function(ffi.Pointer<ffi.Void>)>>('CRotateMapToNorthEvent_retain');
late final _CRotateMapToNorthEvent_retain = _CRotateMapToNorthEvent_retainPtr.asFunction<_CRotateMapToNorthEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CRotateMapToNorthEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRotateMapToNorthEvent Function()>>('CRotateMapToNorthEventMakeDefault');
late final _CRotateMapToNorthEventMakeDefault = _CRotateMapToNorthEventMakeDefaultPtr.asFunction<_CRotateMapToNorthEvent Function()>();

late final _CScaleMapEvent_zoomDeltaPtr = _lookup<ffi.NativeFunction<ffi.Float Function(_CScaleMapEvent)>>('CScaleMapEvent_zoomDelta');
late final _CScaleMapEvent_zoomDelta = _CScaleMapEvent_zoomDeltaPtr.asFunction<double Function(_CScaleMapEvent)>();
late final _CScaleMapEvent_scalingCenterPtr = _lookup<ffi.NativeFunction<_COptional_CScreenPoint Function(_CScaleMapEvent)>>('CScaleMapEvent_scalingCenter');
late final _CScaleMapEvent_scalingCenter = _CScaleMapEvent_scalingCenterPtr.asFunction<_COptional_CScreenPoint Function(_CScaleMapEvent)>();

late final _CScaleMapEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CScaleMapEvent_cg_objectIdentifier');
late final _CScaleMapEvent_cg_objectIdentifier = _CScaleMapEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CScaleMapEvent_C_createWith_float_COptional_CScreenPointPtr = _lookup<ffi.NativeFunction<_CScaleMapEvent Function(ffi.Float, _COptional_CScreenPoint)>>('CScaleMapEvent_C_createWith_float_COptional_CScreenPoint');
late final _CScaleMapEvent_C_createWith_float_COptional_CScreenPoint = _CScaleMapEvent_C_createWith_float_COptional_CScreenPointPtr.asFunction<_CScaleMapEvent Function(double, _COptional_CScreenPoint)>();

late final _CScaleMapEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CScaleMapEvent_release');
late final _CScaleMapEvent_release = _CScaleMapEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CScaleMapEvent_retainPtr = _lookup<ffi.NativeFunction<_CScaleMapEvent Function(ffi.Pointer<ffi.Void>)>>('CScaleMapEvent_retain');
late final _CScaleMapEvent_retain = _CScaleMapEvent_retainPtr.asFunction<_CScaleMapEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CScaleMapEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScaleMapEvent Function()>>('CScaleMapEventMakeDefault');
late final _CScaleMapEventMakeDefault = _CScaleMapEventMakeDefaultPtr.asFunction<_CScaleMapEvent Function()>();


late final _CAnyMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAny Function()>>('CAnyMakeDefault');
late final _CAnyMakeDefault = _CAnyMakeDefaultPtr.asFunction<_CAny Function()>();
late final _CAny_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAny)>>('CAny_release');
late final _CAny_release = _CAny_releasePtr.asFunction<void Function(_CAny)>();

late final _CClusterOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CClusterOptions Function()>>('CClusterOptionsMakeDefault');
late final _CClusterOptionsMakeDefault = _CClusterOptionsMakeDefaultPtr.asFunction<_CClusterOptions Function()>();


late final _CFollowBearingMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFollowBearing Function()>>('CFollowBearingMakeDefault');
late final _CFollowBearingMakeDefault = _CFollowBearingMakeDefaultPtr.asFunction<_CFollowBearing Function()>();

late final _CFollowStyleZoomMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFollowStyleZoom Function()>>('CFollowStyleZoomMakeDefault');
late final _CFollowStyleZoomMakeDefault = _CFollowStyleZoomMakeDefaultPtr.asFunction<_CFollowStyleZoom Function()>();

late final _CFollowPositionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFollowPosition Function()>>('CFollowPositionMakeDefault');
late final _CFollowPositionMakeDefault = _CFollowPositionMakeDefaultPtr.asFunction<_CFollowPosition Function()>();


late final _CFollowTiltMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFollowTilt Function()>>('CFollowTiltMakeDefault');
late final _CFollowTiltMakeDefault = _CFollowTiltMakeDefaultPtr.asFunction<_CFollowTilt Function()>();
late final _CAttributes_attributeNamesPtr = _lookup<ffi.NativeFunction<_CArray_CString Function(_CAttributes)>>('CAttributes_attributeNames');
late final _CAttributes_attributeNames = _CAttributes_attributeNamesPtr.asFunction<_CArray_CString Function(_CAttributes)>();
late final _CAttributes_changedPtr = _lookup<ffi.NativeFunction<_CChannel_CArray_CString Function(_CAttributes)>>('CAttributes_changed');
late final _CAttributes_changed = _CAttributes_changedPtr.asFunction<_CChannel_CArray_CString Function(_CAttributes)>();

late final _CAttributes_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CAttributes_cg_objectIdentifier');
late final _CAttributes_cg_objectIdentifier = _CAttributes_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CAttributes_setAttributeValue_CString_CAttributeValuePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAttributes, _CString, _CAttributeValue)>>('CAttributes_setAttributeValue_CString_CAttributeValue');
late final _CAttributes_setAttributeValue_CString_CAttributeValue = _CAttributes_setAttributeValue_CString_CAttributeValuePtr.asFunction<void Function(_CAttributes, _CString, _CAttributeValue)>();
late final _CAttributes_setAttributeValues_CDictionary_CString_CAttributeValue_CArray_CStringPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAttributes, _CDictionary_CString_CAttributeValue, _CArray_CString)>>('CAttributes_setAttributeValues_CDictionary_CString_CAttributeValue_CArray_CString');
late final _CAttributes_setAttributeValues_CDictionary_CString_CAttributeValue_CArray_CString = _CAttributes_setAttributeValues_CDictionary_CString_CAttributeValue_CArray_CStringPtr.asFunction<void Function(_CAttributes, _CDictionary_CString_CAttributeValue, _CArray_CString)>();
late final _CAttributes_removeAttribute_CStringPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAttributes, _CString)>>('CAttributes_removeAttribute_CString');
late final _CAttributes_removeAttribute_CString = _CAttributes_removeAttribute_CStringPtr.asFunction<void Function(_CAttributes, _CString)>();
late final _CAttributes_getAttributeValue_CStringPtr = _lookup<ffi.NativeFunction<_CAttributeValue Function(_CAttributes, _CString)>>('CAttributes_getAttributeValue_CString');
late final _CAttributes_getAttributeValue_CString = _CAttributes_getAttributeValue_CStringPtr.asFunction<_CAttributeValue Function(_CAttributes, _CString)>();

late final _CAttributes_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CAttributes_release');
late final _CAttributes_release = _CAttributes_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CAttributes_retainPtr = _lookup<ffi.NativeFunction<_CAttributes Function(ffi.Pointer<ffi.Void>)>>('CAttributes_retain');
late final _CAttributes_retain = _CAttributes_retainPtr.asFunction<_CAttributes Function(ffi.Pointer<ffi.Void>)>();
late final _CAttributesMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAttributes Function()>>('CAttributesMakeDefault');
late final _CAttributesMakeDefault = _CAttributesMakeDefaultPtr.asFunction<_CAttributes Function()>();


late final _CChannel_CArray_CStringMakeDefaultPtr = _lookup<ffi.NativeFunction<_CChannel_CArray_CString Function()>>('CChannel_CArray_CStringMakeDefault');
late final _CChannel_CArray_CStringMakeDefault = _CChannel_CArray_CStringMakeDefaultPtr.asFunction<_CChannel_CArray_CString Function()>();
late final _CChannel_CArray_CString_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CChannel_CArray_CString)>>('CChannel_CArray_CString_release');
late final _CChannel_CArray_CString_release = _CChannel_CArray_CString_releasePtr.asFunction<void Function(_CChannel_CArray_CString)>();
late final _CChannel_CArray_CString_retainPtr = _lookup<ffi.NativeFunction<_CChannel_CArray_CString Function(_CChannel_CArray_CString)>>('CChannel_CArray_CString_retain');
late final _CChannel_CArray_CString_retain = _CChannel_CArray_CString_retainPtr.asFunction<_CChannel_CArray_CString Function(_CChannel_CArray_CString)>();
late final _CChannel_CArray_CStringConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CChannel_CArray_CString,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CString, ffi.Int64)>>
  )
>>('CChannel_CArray_CString_connect');
late final _CChannel_CArray_CStringConnect = _CChannel_CArray_CStringConnectPtr.asFunction<
  _CCancellable Function(
    _CChannel_CArray_CString,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CString, ffi.Int64)>>
  )
>();
late final _CAnimationSettings_animationIndexPtr = _lookup<ffi.NativeFunction<_COptional_int32_t Function(_CAnimationSettings)>>('CAnimationSettings_animationIndex');
late final _CAnimationSettings_animationIndex = _CAnimationSettings_animationIndexPtr.asFunction<_COptional_int32_t Function(_CAnimationSettings)>();
late final _CAnimationSettings_setAnimationIndex_COptional_int32_tPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAnimationSettings, _COptional_int32_t)>>('CAnimationSettings_setAnimationIndex_COptional_int32_t');
late final _CAnimationSettings_setAnimationIndex_COptional_int32_t = _CAnimationSettings_setAnimationIndex_COptional_int32_tPtr.asFunction<void Function(_CAnimationSettings, _COptional_int32_t)>();
late final _CAnimationSettings_animationNamePtr = _lookup<ffi.NativeFunction<_COptional_CString Function(_CAnimationSettings)>>('CAnimationSettings_animationName');
late final _CAnimationSettings_animationName = _CAnimationSettings_animationNamePtr.asFunction<_COptional_CString Function(_CAnimationSettings)>();
late final _CAnimationSettings_setAnimationName_COptional_CStringPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAnimationSettings, _COptional_CString)>>('CAnimationSettings_setAnimationName_COptional_CString');
late final _CAnimationSettings_setAnimationName_COptional_CString = _CAnimationSettings_setAnimationName_COptional_CStringPtr.asFunction<void Function(_CAnimationSettings, _COptional_CString)>();
late final _CAnimationSettings_sceneIndexPtr = _lookup<ffi.NativeFunction<_COptional_int32_t Function(_CAnimationSettings)>>('CAnimationSettings_sceneIndex');
late final _CAnimationSettings_sceneIndex = _CAnimationSettings_sceneIndexPtr.asFunction<_COptional_int32_t Function(_CAnimationSettings)>();
late final _CAnimationSettings_setSceneIndex_COptional_int32_tPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAnimationSettings, _COptional_int32_t)>>('CAnimationSettings_setSceneIndex_COptional_int32_t');
late final _CAnimationSettings_setSceneIndex_COptional_int32_t = _CAnimationSettings_setSceneIndex_COptional_int32_tPtr.asFunction<void Function(_CAnimationSettings, _COptional_int32_t)>();
late final _CAnimationSettings_sceneNamePtr = _lookup<ffi.NativeFunction<_COptional_CString Function(_CAnimationSettings)>>('CAnimationSettings_sceneName');
late final _CAnimationSettings_sceneName = _CAnimationSettings_sceneNamePtr.asFunction<_COptional_CString Function(_CAnimationSettings)>();
late final _CAnimationSettings_setSceneName_COptional_CStringPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAnimationSettings, _COptional_CString)>>('CAnimationSettings_setSceneName_COptional_CString');
late final _CAnimationSettings_setSceneName_COptional_CString = _CAnimationSettings_setSceneName_COptional_CStringPtr.asFunction<void Function(_CAnimationSettings, _COptional_CString)>();
late final _CAnimationSettings_animationRepeatCountPtr = _lookup<ffi.NativeFunction<_COptional_int32_t Function(_CAnimationSettings)>>('CAnimationSettings_animationRepeatCount');
late final _CAnimationSettings_animationRepeatCount = _CAnimationSettings_animationRepeatCountPtr.asFunction<_COptional_int32_t Function(_CAnimationSettings)>();
late final _CAnimationSettings_setAnimationRepeatCount_COptional_int32_tPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAnimationSettings, _COptional_int32_t)>>('CAnimationSettings_setAnimationRepeatCount_COptional_int32_t');
late final _CAnimationSettings_setAnimationRepeatCount_COptional_int32_t = _CAnimationSettings_setAnimationRepeatCount_COptional_int32_tPtr.asFunction<void Function(_CAnimationSettings, _COptional_int32_t)>();
late final _CAnimationSettings_animationSpeedPtr = _lookup<ffi.NativeFunction<_COptional_float Function(_CAnimationSettings)>>('CAnimationSettings_animationSpeed');
late final _CAnimationSettings_animationSpeed = _CAnimationSettings_animationSpeedPtr.asFunction<_COptional_float Function(_CAnimationSettings)>();
late final _CAnimationSettings_setAnimationSpeed_COptional_floatPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAnimationSettings, _COptional_float)>>('CAnimationSettings_setAnimationSpeed_COptional_float');
late final _CAnimationSettings_setAnimationSpeed_COptional_float = _CAnimationSettings_setAnimationSpeed_COptional_floatPtr.asFunction<void Function(_CAnimationSettings, _COptional_float)>();

late final _CAnimationSettings_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CAnimationSettings_cg_objectIdentifier');
late final _CAnimationSettings_cg_objectIdentifier = _CAnimationSettings_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CAnimationSettings_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CAnimationSettings_release');
late final _CAnimationSettings_release = _CAnimationSettings_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CAnimationSettings_retainPtr = _lookup<ffi.NativeFunction<_CAnimationSettings Function(ffi.Pointer<ffi.Void>)>>('CAnimationSettings_retain');
late final _CAnimationSettings_retain = _CAnimationSettings_retainPtr.asFunction<_CAnimationSettings Function(ffi.Pointer<ffi.Void>)>();
late final _CAnimationSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAnimationSettings Function()>>('CAnimationSettingsMakeDefault');
late final _CAnimationSettingsMakeDefault = _CAnimationSettingsMakeDefaultPtr.asFunction<_CAnimationSettings Function()>();


late final _COptional_int32_tMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_int32_t Function()>>('COptional_int32_tMakeDefault');
late final _COptional_int32_tMakeDefault = _COptional_int32_tMakeDefaultPtr.asFunction<_COptional_int32_t Function()>();

late final _COptional_floatMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_float Function()>>('COptional_floatMakeDefault');
late final _COptional_floatMakeDefault = _COptional_floatMakeDefaultPtr.asFunction<_COptional_float Function()>();
late final _CMapObject_userDataPtr = _lookup<ffi.NativeFunction<_CAny Function(_CMapObject)>>('CMapObject_userData');
late final _CMapObject_userData = _CMapObject_userDataPtr.asFunction<_CAny Function(_CMapObject)>();
late final _CMapObject_setUserData_CAnyPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapObject, _CAny)>>('CMapObject_setUserData_CAny');
late final _CMapObject_setUserData_CAny = _CMapObject_setUserData_CAnyPtr.asFunction<void Function(_CMapObject, _CAny)>();

late final _CMapObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapObject_cg_objectIdentifier');
late final _CMapObject_cg_objectIdentifier = _CMapObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapObject_cg_getSelectorPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CMapObject)>>('CMapObject_cg_getSelector');
late final _CMapObject_cg_getSelector = _CMapObject_cg_getSelectorPtr.asFunction<int Function(_CMapObject)>();

late final _CMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapObject_release');
late final _CMapObject_release = _CMapObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapObject_retainPtr = _lookup<ffi.NativeFunction<_CMapObject Function(ffi.Pointer<ffi.Void>)>>('CMapObject_retain');
late final _CMapObject_retain = _CMapObject_retainPtr.asFunction<_CMapObject Function(ffi.Pointer<ffi.Void>)>();
late final _CMapObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapObject Function()>>('CMapObjectMakeDefault');
late final _CMapObjectMakeDefault = _CMapObjectMakeDefaultPtr.asFunction<_CMapObject Function()>();

late final _CGeometryMapObject_geometryChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CGeometry Function(_CGeometryMapObject)>>('CGeometryMapObject_geometryChannel');
late final _CGeometryMapObject_geometryChannel = _CGeometryMapObject_geometryChannelPtr.asFunction<_CStatefulChannel_CGeometry Function(_CGeometryMapObject)>();
late final _CGeometryMapObject_geometryPtr = _lookup<ffi.NativeFunction<_CGeometry Function(_CGeometryMapObject)>>('CGeometryMapObject_geometry');
late final _CGeometryMapObject_geometry = _CGeometryMapObject_geometryPtr.asFunction<_CGeometry Function(_CGeometryMapObject)>();
late final _CGeometryMapObject_setGeometry_CGeometryPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObject, _CGeometry)>>('CGeometryMapObject_setGeometry_CGeometry');
late final _CGeometryMapObject_setGeometry_CGeometry = _CGeometryMapObject_setGeometry_CGeometryPtr.asFunction<void Function(_CGeometryMapObject, _CGeometry)>();
late final _CGeometryMapObject_objectAttributesPtr = _lookup<ffi.NativeFunction<_CAttributes Function(_CGeometryMapObject)>>('CGeometryMapObject_objectAttributes');
late final _CGeometryMapObject_objectAttributes = _CGeometryMapObject_objectAttributesPtr.asFunction<_CAttributes Function(_CGeometryMapObject)>();
late final _CGeometryMapObject_isVisibleChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function(_CGeometryMapObject)>>('CGeometryMapObject_isVisibleChannel');
late final _CGeometryMapObject_isVisibleChannel = _CGeometryMapObject_isVisibleChannelPtr.asFunction<_CStatefulChannel_bool Function(_CGeometryMapObject)>();
late final _CGeometryMapObject_isVisiblePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CGeometryMapObject)>>('CGeometryMapObject_isVisible');
late final _CGeometryMapObject_isVisible = _CGeometryMapObject_isVisiblePtr.asFunction<bool Function(_CGeometryMapObject)>();
late final _CGeometryMapObject_setVisible_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObject, ffi.Bool)>>('CGeometryMapObject_setVisible_bool');
late final _CGeometryMapObject_setVisible_bool = _CGeometryMapObject_setVisible_boolPtr.asFunction<void Function(_CGeometryMapObject, bool)>();
late final _CGeometryMapObject_isDraggableChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function(_CGeometryMapObject)>>('CGeometryMapObject_isDraggableChannel');
late final _CGeometryMapObject_isDraggableChannel = _CGeometryMapObject_isDraggableChannelPtr.asFunction<_CStatefulChannel_bool Function(_CGeometryMapObject)>();
late final _CGeometryMapObject_isDraggablePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CGeometryMapObject)>>('CGeometryMapObject_isDraggable');
late final _CGeometryMapObject_isDraggable = _CGeometryMapObject_isDraggablePtr.asFunction<bool Function(_CGeometryMapObject)>();
late final _CGeometryMapObject_setDraggable_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObject, ffi.Bool)>>('CGeometryMapObject_setDraggable_bool');
late final _CGeometryMapObject_setDraggable_bool = _CGeometryMapObject_setDraggable_boolPtr.asFunction<void Function(_CGeometryMapObject, bool)>();
late final _CGeometryMapObject_animationSettingsPtr = _lookup<ffi.NativeFunction<_CAnimationSettings Function(_CGeometryMapObject)>>('CGeometryMapObject_animationSettings');
late final _CGeometryMapObject_animationSettings = _CGeometryMapObject_animationSettingsPtr.asFunction<_CAnimationSettings Function(_CGeometryMapObject)>();
late final _CGeometryMapObject_boundsPtr = _lookup<ffi.NativeFunction<_CGeoRect Function(_CGeometryMapObject)>>('CGeometryMapObject_bounds');
late final _CGeometryMapObject_bounds = _CGeometryMapObject_boundsPtr.asFunction<_CGeoRect Function(_CGeometryMapObject)>();

late final _CGeometryMapObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObject_cg_objectIdentifier');
late final _CGeometryMapObject_cg_objectIdentifier = _CGeometryMapObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CGeometryMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObject_release');
late final _CGeometryMapObject_release = _CGeometryMapObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CGeometryMapObject_retainPtr = _lookup<ffi.NativeFunction<_CGeometryMapObject Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObject_retain');
late final _CGeometryMapObject_retain = _CGeometryMapObject_retainPtr.asFunction<_CGeometryMapObject Function(ffi.Pointer<ffi.Void>)>();
late final _CGeometryMapObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGeometryMapObject Function()>>('CGeometryMapObjectMakeDefault');
late final _CGeometryMapObjectMakeDefault = _CGeometryMapObjectMakeDefaultPtr.asFunction<_CGeometryMapObject Function()>();


late final _CStatefulChannel_CGeometryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CGeometry Function()>>('CStatefulChannel_CGeometryMakeDefault');
late final _CStatefulChannel_CGeometryMakeDefault = _CStatefulChannel_CGeometryMakeDefaultPtr.asFunction<_CStatefulChannel_CGeometry Function()>();
late final _CStatefulChannel_CGeometry_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CGeometry)>>('CStatefulChannel_CGeometry_release');
late final _CStatefulChannel_CGeometry_release = _CStatefulChannel_CGeometry_releasePtr.asFunction<void Function(_CStatefulChannel_CGeometry)>();
late final _CStatefulChannel_CGeometry_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CGeometry Function(_CStatefulChannel_CGeometry)>>('CStatefulChannel_CGeometry_retain');
late final _CStatefulChannel_CGeometry_retain = _CStatefulChannel_CGeometry_retainPtr.asFunction<_CStatefulChannel_CGeometry Function(_CStatefulChannel_CGeometry)>();
late final _CStatefulChannel_CGeometryGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CGeometry Function(_CStatefulChannel_CGeometry)>>('CStatefulChannel_CGeometry_getCurrentValue');
late final _CStatefulChannel_CGeometryGetCurrentValue = _CStatefulChannel_CGeometryGetCurrentValuePtr.asFunction<_CGeometry Function(_CStatefulChannel_CGeometry)>();
late final _CStatefulChannel_CGeometryConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CGeometry,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeometry, ffi.Int64)>>
  )
>>('CStatefulChannel_CGeometry_connect');
late final _CStatefulChannel_CGeometryConnect = _CStatefulChannel_CGeometryConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CGeometry,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeometry, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_boolMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function()>>('CStatefulChannel_boolMakeDefault');
late final _CStatefulChannel_boolMakeDefault = _CStatefulChannel_boolMakeDefaultPtr.asFunction<_CStatefulChannel_bool Function()>();
late final _CStatefulChannel_bool_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_bool)>>('CStatefulChannel_bool_release');
late final _CStatefulChannel_bool_release = _CStatefulChannel_bool_releasePtr.asFunction<void Function(_CStatefulChannel_bool)>();
late final _CStatefulChannel_bool_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function(_CStatefulChannel_bool)>>('CStatefulChannel_bool_retain');
late final _CStatefulChannel_bool_retain = _CStatefulChannel_bool_retainPtr.asFunction<_CStatefulChannel_bool Function(_CStatefulChannel_bool)>();
late final _CStatefulChannel_boolGetCurrentValuePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CStatefulChannel_bool)>>('CStatefulChannel_bool_getCurrentValue');
late final _CStatefulChannel_boolGetCurrentValue = _CStatefulChannel_boolGetCurrentValuePtr.asFunction<bool Function(_CStatefulChannel_bool)>();
late final _CStatefulChannel_boolConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_bool,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool, ffi.Int64)>>
  )
>>('CStatefulChannel_bool_connect');
late final _CStatefulChannel_boolConnect = _CStatefulChannel_boolConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_bool,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool, ffi.Int64)>>
  )
>();
late final _CClusterObject_positionPtr = _lookup<ffi.NativeFunction<_CGeoPointWithElevation Function(_CClusterObject)>>('CClusterObject_position');
late final _CClusterObject_position = _CClusterObject_positionPtr.asFunction<_CGeoPointWithElevation Function(_CClusterObject)>();
late final _CClusterObject_objectCountPtr = _lookup<ffi.NativeFunction<ffi.Uint32 Function(_CClusterObject)>>('CClusterObject_objectCount');
late final _CClusterObject_objectCount = _CClusterObject_objectCountPtr.asFunction<int Function(_CClusterObject)>();
late final _CClusterObject_objectsPtr = _lookup<ffi.NativeFunction<_CArray_CGeometryMapObject Function(_CClusterObject)>>('CClusterObject_objects');
late final _CClusterObject_objects = _CClusterObject_objectsPtr.asFunction<_CArray_CGeometryMapObject Function(_CClusterObject)>();
late final _CClusterObject_geometryObjectPtr = _lookup<ffi.NativeFunction<_COptional_CGeometryMapObject Function(_CClusterObject)>>('CClusterObject_geometryObject');
late final _CClusterObject_geometryObject = _CClusterObject_geometryObjectPtr.asFunction<_COptional_CGeometryMapObject Function(_CClusterObject)>();

late final _CClusterObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CClusterObject_cg_objectIdentifier');
late final _CClusterObject_cg_objectIdentifier = _CClusterObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CClusterObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CClusterObject_release');
late final _CClusterObject_release = _CClusterObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CClusterObject_retainPtr = _lookup<ffi.NativeFunction<_CClusterObject Function(ffi.Pointer<ffi.Void>)>>('CClusterObject_retain');
late final _CClusterObject_retain = _CClusterObject_retainPtr.asFunction<_CClusterObject Function(ffi.Pointer<ffi.Void>)>();
late final _CClusterObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CClusterObject Function()>>('CClusterObjectMakeDefault');
late final _CClusterObjectMakeDefault = _CClusterObjectMakeDefaultPtr.asFunction<_CClusterObject Function()>();


late final _CArray_CGeometryMapObjectmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CGeometryMapObject Function()>>('CArray_CGeometryMapObject_makeEmpty');
late final _CArray_CGeometryMapObjectmakeEmpty = _CArray_CGeometryMapObjectmakeEmptyPtr.asFunction<_CArray_CGeometryMapObject Function()>();
late final _CArray_CGeometryMapObjectaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CGeometryMapObject, _CGeometryMapObject)>>('CArray_CGeometryMapObject_addElement');
late final _CArray_CGeometryMapObjectaddElement = _CArray_CGeometryMapObjectaddElementPtr.asFunction<void Function(_CArray_CGeometryMapObject, _CGeometryMapObject)>();
late final _forEach_CArray_CGeometryMapObjectPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CGeometryMapObject, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObject)>>)
>>('CArray_CGeometryMapObject_forEachWithFunctionPointer');
late final _forEach_CArray_CGeometryMapObject = _forEach_CArray_CGeometryMapObjectPtr.asFunction<
  void Function(_CArray_CGeometryMapObject, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObject)
>>)>();
late final _CArray_CGeometryMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CGeometryMapObject)>>('CArray_CGeometryMapObject_release');
late final _CArray_CGeometryMapObject_release = _CArray_CGeometryMapObject_releasePtr.asFunction<void Function(_CArray_CGeometryMapObject)>();

late final _COptional_CGeometryMapObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CGeometryMapObject Function()>>('COptional_CGeometryMapObjectMakeDefault');
late final _COptional_CGeometryMapObjectMakeDefault = _COptional_CGeometryMapObjectMakeDefaultPtr.asFunction<_COptional_CGeometryMapObject Function()>();

late final _COptional_CGeometryMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CGeometryMapObject)>>('COptional_CGeometryMapObject_release');
late final _COptional_CGeometryMapObject_release = _COptional_CGeometryMapObject_releasePtr.asFunction<void Function(_COptional_CGeometryMapObject)>();
late final _CDgisMapObject_idPtr = _lookup<ffi.NativeFunction<_CDgisObjectId Function(_CDgisMapObject)>>('CDgisMapObject_id');
late final _CDgisMapObject_id = _CDgisMapObject_idPtr.asFunction<_CDgisObjectId Function(_CDgisMapObject)>();

late final _CDgisMapObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CDgisMapObject_cg_objectIdentifier');
late final _CDgisMapObject_cg_objectIdentifier = _CDgisMapObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CDgisMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CDgisMapObject_release');
late final _CDgisMapObject_release = _CDgisMapObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CDgisMapObject_retainPtr = _lookup<ffi.NativeFunction<_CDgisMapObject Function(ffi.Pointer<ffi.Void>)>>('CDgisMapObject_retain');
late final _CDgisMapObject_retain = _CDgisMapObject_retainPtr.asFunction<_CDgisMapObject Function(ffi.Pointer<ffi.Void>)>();
late final _CDgisMapObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDgisMapObject Function()>>('CDgisMapObjectMakeDefault');
late final _CDgisMapObjectMakeDefault = _CDgisMapObjectMakeDefaultPtr.asFunction<_CDgisMapObject Function()>();


late final _CSource_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSource_cg_objectIdentifier');
late final _CSource_cg_objectIdentifier = _CSource_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSource_cg_getSelectorPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CSource)>>('CSource_cg_getSelector');
late final _CSource_cg_getSelector = _CSource_cg_getSelectorPtr.asFunction<int Function(_CSource)>();

late final _CSource_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSource_release');
late final _CSource_release = _CSource_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSource_retainPtr = _lookup<ffi.NativeFunction<_CSource Function(ffi.Pointer<ffi.Void>)>>('CSource_retain');
late final _CSource_retain = _CSource_retainPtr.asFunction<_CSource Function(ffi.Pointer<ffi.Void>)>();
late final _CSourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSource Function()>>('CSourceMakeDefault');
late final _CSourceMakeDefault = _CSourceMakeDefaultPtr.asFunction<_CSource Function()>();

late final _CDgisSource_highlightedObjectsChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CDgisObjectId Function(_CDgisSource)>>('CDgisSource_highlightedObjectsChannel');
late final _CDgisSource_highlightedObjectsChannel = _CDgisSource_highlightedObjectsChannelPtr.asFunction<_CStatefulChannel_CArray_CDgisObjectId Function(_CDgisSource)>();
late final _CDgisSource_highlightedObjectsPtr = _lookup<ffi.NativeFunction<_CArray_CDgisObjectId Function(_CDgisSource)>>('CDgisSource_highlightedObjects');
late final _CDgisSource_highlightedObjects = _CDgisSource_highlightedObjectsPtr.asFunction<_CArray_CDgisObjectId Function(_CDgisSource)>();

late final _CDgisSource_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CDgisSource_cg_objectIdentifier');
late final _CDgisSource_cg_objectIdentifier = _CDgisSource_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CDgisSource_S_createDgisSource_CContextPtr = _lookup<ffi.NativeFunction<_CSource Function(_CContext)>>('CDgisSource_S_createDgisSource_CContext');
late final _CDgisSource_S_createDgisSource_CContext = _CDgisSource_S_createDgisSource_CContextPtr.asFunction<_CSource Function(_CContext)>();
late final _CDgisSource_setHighlighted_CArray_CDgisObjectId_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CDgisSource, _CArray_CDgisObjectId, ffi.Bool)>>('CDgisSource_setHighlighted_CArray_CDgisObjectId_bool');
late final _CDgisSource_setHighlighted_CArray_CDgisObjectId_bool = _CDgisSource_setHighlighted_CArray_CDgisObjectId_boolPtr.asFunction<void Function(_CDgisSource, _CArray_CDgisObjectId, bool)>();

late final _CDgisSource_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CDgisSource_release');
late final _CDgisSource_release = _CDgisSource_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CDgisSource_retainPtr = _lookup<ffi.NativeFunction<_CDgisSource Function(ffi.Pointer<ffi.Void>)>>('CDgisSource_retain');
late final _CDgisSource_retain = _CDgisSource_retainPtr.asFunction<_CDgisSource Function(ffi.Pointer<ffi.Void>)>();
late final _CDgisSourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDgisSource Function()>>('CDgisSourceMakeDefault');
late final _CDgisSourceMakeDefault = _CDgisSourceMakeDefaultPtr.asFunction<_CDgisSource Function()>();


late final _CStatefulChannel_CArray_CDgisObjectIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CDgisObjectId Function()>>('CStatefulChannel_CArray_CDgisObjectIdMakeDefault');
late final _CStatefulChannel_CArray_CDgisObjectIdMakeDefault = _CStatefulChannel_CArray_CDgisObjectIdMakeDefaultPtr.asFunction<_CStatefulChannel_CArray_CDgisObjectId Function()>();
late final _CStatefulChannel_CArray_CDgisObjectId_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CArray_CDgisObjectId)>>('CStatefulChannel_CArray_CDgisObjectId_release');
late final _CStatefulChannel_CArray_CDgisObjectId_release = _CStatefulChannel_CArray_CDgisObjectId_releasePtr.asFunction<void Function(_CStatefulChannel_CArray_CDgisObjectId)>();
late final _CStatefulChannel_CArray_CDgisObjectId_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CDgisObjectId Function(_CStatefulChannel_CArray_CDgisObjectId)>>('CStatefulChannel_CArray_CDgisObjectId_retain');
late final _CStatefulChannel_CArray_CDgisObjectId_retain = _CStatefulChannel_CArray_CDgisObjectId_retainPtr.asFunction<_CStatefulChannel_CArray_CDgisObjectId Function(_CStatefulChannel_CArray_CDgisObjectId)>();
late final _CStatefulChannel_CArray_CDgisObjectIdGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CArray_CDgisObjectId Function(_CStatefulChannel_CArray_CDgisObjectId)>>('CStatefulChannel_CArray_CDgisObjectId_getCurrentValue');
late final _CStatefulChannel_CArray_CDgisObjectIdGetCurrentValue = _CStatefulChannel_CArray_CDgisObjectIdGetCurrentValuePtr.asFunction<_CArray_CDgisObjectId Function(_CStatefulChannel_CArray_CDgisObjectId)>();
late final _CStatefulChannel_CArray_CDgisObjectIdConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CDgisObjectId,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CDgisObjectId, ffi.Int64)>>
  )
>>('CStatefulChannel_CArray_CDgisObjectId_connect');
late final _CStatefulChannel_CArray_CDgisObjectIdConnect = _CStatefulChannel_CArray_CDgisObjectIdConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CDgisObjectId,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CDgisObjectId, ffi.Int64)>>
  )
>();

late final _CFollowController_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CFollowController_cg_objectIdentifier');
late final _CFollowController_cg_objectIdentifier = _CFollowController_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CFollowController_cg_getSelectorPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CFollowController)>>('CFollowController_cg_getSelector');
late final _CFollowController_cg_getSelector = _CFollowController_cg_getSelectorPtr.asFunction<int Function(_CFollowController)>();

late final _CFollowController_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CFollowController_release');
late final _CFollowController_release = _CFollowController_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CFollowController_retainPtr = _lookup<ffi.NativeFunction<_CFollowController Function(ffi.Pointer<ffi.Void>)>>('CFollowController_retain');
late final _CFollowController_retain = _CFollowController_retainPtr.asFunction<_CFollowController Function(ffi.Pointer<ffi.Void>)>();
late final _CFollowControllerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFollowController Function()>>('CFollowControllerMakeDefault');
late final _CFollowControllerMakeDefault = _CFollowControllerMakeDefaultPtr.asFunction<_CFollowController Function()>();

late final _CGeometryMapObjectSource_objectsPtr = _lookup<ffi.NativeFunction<_CArray_CGeometryMapObject Function(_CGeometryMapObjectSource)>>('CGeometryMapObjectSource_objects');
late final _CGeometryMapObjectSource_objects = _CGeometryMapObjectSource_objectsPtr.asFunction<_CArray_CGeometryMapObject Function(_CGeometryMapObjectSource)>();
late final _CGeometryMapObjectSource_sourceAttributesPtr = _lookup<ffi.NativeFunction<_CAttributes Function(_CGeometryMapObjectSource)>>('CGeometryMapObjectSource_sourceAttributes');
late final _CGeometryMapObjectSource_sourceAttributes = _CGeometryMapObjectSource_sourceAttributesPtr.asFunction<_CAttributes Function(_CGeometryMapObjectSource)>();

late final _CGeometryMapObjectSource_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObjectSource_cg_objectIdentifier');
late final _CGeometryMapObjectSource_cg_objectIdentifier = _CGeometryMapObjectSource_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CGeometryMapObjectSource_clusteringObjects_CCameraPositionPtr = _lookup<ffi.NativeFunction<_CArray_CMapObject Function(_CGeometryMapObjectSource, _CCameraPosition)>>('CGeometryMapObjectSource_clusteringObjects_CCameraPosition');
late final _CGeometryMapObjectSource_clusteringObjects_CCameraPosition = _CGeometryMapObjectSource_clusteringObjects_CCameraPositionPtr.asFunction<_CArray_CMapObject Function(_CGeometryMapObjectSource, _CCameraPosition)>();
late final _CGeometryMapObjectSource_addObject_CGeometryMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObjectSource, _CGeometryMapObject)>>('CGeometryMapObjectSource_addObject_CGeometryMapObject');
late final _CGeometryMapObjectSource_addObject_CGeometryMapObject = _CGeometryMapObjectSource_addObject_CGeometryMapObjectPtr.asFunction<void Function(_CGeometryMapObjectSource, _CGeometryMapObject)>();
late final _CGeometryMapObjectSource_addObjects_CArray_CGeometryMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObjectSource, _CArray_CGeometryMapObject)>>('CGeometryMapObjectSource_addObjects_CArray_CGeometryMapObject');
late final _CGeometryMapObjectSource_addObjects_CArray_CGeometryMapObject = _CGeometryMapObjectSource_addObjects_CArray_CGeometryMapObjectPtr.asFunction<void Function(_CGeometryMapObjectSource, _CArray_CGeometryMapObject)>();
late final _CGeometryMapObjectSource_removeObject_CGeometryMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObjectSource, _CGeometryMapObject)>>('CGeometryMapObjectSource_removeObject_CGeometryMapObject');
late final _CGeometryMapObjectSource_removeObject_CGeometryMapObject = _CGeometryMapObjectSource_removeObject_CGeometryMapObjectPtr.asFunction<void Function(_CGeometryMapObjectSource, _CGeometryMapObject)>();
late final _CGeometryMapObjectSource_removeObjects_CArray_CGeometryMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObjectSource, _CArray_CGeometryMapObject)>>('CGeometryMapObjectSource_removeObjects_CArray_CGeometryMapObject');
late final _CGeometryMapObjectSource_removeObjects_CArray_CGeometryMapObject = _CGeometryMapObjectSource_removeObjects_CArray_CGeometryMapObjectPtr.asFunction<void Function(_CGeometryMapObjectSource, _CArray_CGeometryMapObject)>();
late final _CGeometryMapObjectSource_removeAndAddObjects_CArray_CGeometryMapObject_CArray_CGeometryMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObjectSource, _CArray_CGeometryMapObject, _CArray_CGeometryMapObject)>>('CGeometryMapObjectSource_removeAndAddObjects_CArray_CGeometryMapObject_CArray_CGeometryMapObject');
late final _CGeometryMapObjectSource_removeAndAddObjects_CArray_CGeometryMapObject_CArray_CGeometryMapObject = _CGeometryMapObjectSource_removeAndAddObjects_CArray_CGeometryMapObject_CArray_CGeometryMapObjectPtr.asFunction<void Function(_CGeometryMapObjectSource, _CArray_CGeometryMapObject, _CArray_CGeometryMapObject)>();
late final _CGeometryMapObjectSource_clearPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGeometryMapObjectSource)>>('CGeometryMapObjectSource_clear');
late final _CGeometryMapObjectSource_clear = _CGeometryMapObjectSource_clearPtr.asFunction<void Function(_CGeometryMapObjectSource)>();

late final _CGeometryMapObjectSource_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObjectSource_release');
late final _CGeometryMapObjectSource_release = _CGeometryMapObjectSource_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CGeometryMapObjectSource_retainPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectSource Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObjectSource_retain');
late final _CGeometryMapObjectSource_retain = _CGeometryMapObjectSource_retainPtr.asFunction<_CGeometryMapObjectSource Function(ffi.Pointer<ffi.Void>)>();
late final _CGeometryMapObjectSourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectSource Function()>>('CGeometryMapObjectSourceMakeDefault');
late final _CGeometryMapObjectSourceMakeDefault = _CGeometryMapObjectSourceMakeDefaultPtr.asFunction<_CGeometryMapObjectSource Function()>();


late final _CArray_CMapObjectmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CMapObject Function()>>('CArray_CMapObject_makeEmpty');
late final _CArray_CMapObjectmakeEmpty = _CArray_CMapObjectmakeEmptyPtr.asFunction<_CArray_CMapObject Function()>();
late final _CArray_CMapObjectaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CMapObject, _CMapObject)>>('CArray_CMapObject_addElement');
late final _CArray_CMapObjectaddElement = _CArray_CMapObjectaddElementPtr.asFunction<void Function(_CArray_CMapObject, _CMapObject)>();
late final _forEach_CArray_CMapObjectPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CMapObject, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMapObject)>>)
>>('CArray_CMapObject_forEachWithFunctionPointer');
late final _forEach_CArray_CMapObject = _forEach_CArray_CMapObjectPtr.asFunction<
  void Function(_CArray_CMapObject, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMapObject)
>>)>();
late final _CArray_CMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CMapObject)>>('CArray_CMapObject_release');
late final _CArray_CMapObject_release = _CArray_CMapObject_releasePtr.asFunction<void Function(_CArray_CMapObject)>();

late final _CImage_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CImage_cg_objectIdentifier');
late final _CImage_cg_objectIdentifier = _CImage_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CImage_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CImage_release');
late final _CImage_release = _CImage_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CImage_retainPtr = _lookup<ffi.NativeFunction<_CImage Function(ffi.Pointer<ffi.Void>)>>('CImage_retain');
late final _CImage_retain = _CImage_retainPtr.asFunction<_CImage Function(ffi.Pointer<ffi.Void>)>();
late final _CImageMakeDefaultPtr = _lookup<ffi.NativeFunction<_CImage Function()>>('CImageMakeDefault');
late final _CImageMakeDefault = _CImageMakeDefaultPtr.asFunction<_CImage Function()>();


late final _CImageFormatMakeDefaultPtr = _lookup<ffi.NativeFunction<_CImageFormat Function()>>('CImageFormatMakeDefault');
late final _CImageFormatMakeDefault = _CImageFormatMakeDefaultPtr.asFunction<_CImageFormat Function()>();

late final _CImageDataMakeDefaultPtr = _lookup<ffi.NativeFunction<_CImageData Function()>>('CImageDataMakeDefault');
late final _CImageDataMakeDefault = _CImageDataMakeDefaultPtr.asFunction<_CImageData Function()>();


late final _CImageLoaderCpp_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CImageLoaderCpp_cg_objectIdentifier');
late final _CImageLoaderCpp_cg_objectIdentifier = _CImageLoaderCpp_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CImageLoaderCpp_loadPtr = _lookup<ffi.NativeFunction<_CImageData Function(_CImageLoaderCpp)>>('CImageLoaderCpp_load');
late final _CImageLoaderCpp_load = _CImageLoaderCpp_loadPtr.asFunction<_CImageData Function(_CImageLoaderCpp)>();

late final _CImageLoaderCpp_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CImageLoaderCpp_release');
late final _CImageLoaderCpp_release = _CImageLoaderCpp_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CImageLoaderCpp_retainPtr = _lookup<ffi.NativeFunction<_CImageLoaderCpp Function(ffi.Pointer<ffi.Void>)>>('CImageLoaderCpp_retain');
late final _CImageLoaderCpp_retain = _CImageLoaderCpp_retainPtr.asFunction<_CImageLoaderCpp Function(ffi.Pointer<ffi.Void>)>();
late final _CImageLoaderCppMakeDefaultPtr = _lookup<ffi.NativeFunction<_CImageLoaderCpp Function()>>('CImageLoaderCppMakeDefault');
late final _CImageLoaderCppMakeDefault = _CImageLoaderCppMakeDefaultPtr.asFunction<_CImageLoaderCpp Function()>();


late final _CImageLoaderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CImageLoader Function()>>('CImageLoaderMakeDefault');
late final _CImageLoaderMakeDefault = _CImageLoaderMakeDefaultPtr.asFunction<_CImageLoader Function()>();
late final _CImageLoader_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CImageLoader)>>('CImageLoader_release');
late final _CImageLoader_release = _CImageLoader_releasePtr.asFunction<void Function(_CImageLoader)>();

late final _CBearingFollowController_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CBearingFollowController_cg_objectIdentifier');
late final _CBearingFollowController_cg_objectIdentifier = _CBearingFollowController_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CBearingFollowController_C_createWith_CBearingSource_CTimeInterval_CBearingPtr = _lookup<ffi.NativeFunction<_CBearingFollowController Function(_CBearingSource, _CTimeInterval, _CBearing)>>('CBearingFollowController_C_createWith_CBearingSource_CTimeInterval_CBearing');
late final _CBearingFollowController_C_createWith_CBearingSource_CTimeInterval_CBearing = _CBearingFollowController_C_createWith_CBearingSource_CTimeInterval_CBearingPtr.asFunction<_CBearingFollowController Function(_CBearingSource, _CTimeInterval, _CBearing)>();

late final _CBearingFollowController_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CBearingFollowController_release');
late final _CBearingFollowController_release = _CBearingFollowController_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CBearingFollowController_retainPtr = _lookup<ffi.NativeFunction<_CBearingFollowController Function(ffi.Pointer<ffi.Void>)>>('CBearingFollowController_retain');
late final _CBearingFollowController_retain = _CBearingFollowController_retainPtr.asFunction<_CBearingFollowController Function(ffi.Pointer<ffi.Void>)>();
late final _CBearingFollowControllerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBearingFollowController Function()>>('CBearingFollowControllerMakeDefault');
late final _CBearingFollowControllerMakeDefault = _CBearingFollowControllerMakeDefaultPtr.asFunction<_CBearingFollowController Function()>();


late final _CCoordinatesFollowController_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCoordinatesFollowController_cg_objectIdentifier');
late final _CCoordinatesFollowController_cg_objectIdentifier = _CCoordinatesFollowController_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CCoordinatesFollowController_C_createWith_CTimeInterval_CMeterPtr = _lookup<ffi.NativeFunction<_CCoordinatesFollowController Function(_CTimeInterval, _CMeter)>>('CCoordinatesFollowController_C_createWith_CTimeInterval_CMeter');
late final _CCoordinatesFollowController_C_createWith_CTimeInterval_CMeter = _CCoordinatesFollowController_C_createWith_CTimeInterval_CMeterPtr.asFunction<_CCoordinatesFollowController Function(_CTimeInterval, _CMeter)>();

late final _CCoordinatesFollowController_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCoordinatesFollowController_release');
late final _CCoordinatesFollowController_release = _CCoordinatesFollowController_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCoordinatesFollowController_retainPtr = _lookup<ffi.NativeFunction<_CCoordinatesFollowController Function(ffi.Pointer<ffi.Void>)>>('CCoordinatesFollowController_retain');
late final _CCoordinatesFollowController_retain = _CCoordinatesFollowController_retainPtr.asFunction<_CCoordinatesFollowController Function(ffi.Pointer<ffi.Void>)>();
late final _CCoordinatesFollowControllerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCoordinatesFollowController Function()>>('CCoordinatesFollowControllerMakeDefault');
late final _CCoordinatesFollowControllerMakeDefault = _CCoordinatesFollowControllerMakeDefaultPtr.asFunction<_CCoordinatesFollowController Function()>();


late final _COptional_CBearingSourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CBearingSource Function()>>('COptional_CBearingSourceMakeDefault');
late final _COptional_CBearingSourceMakeDefault = _COptional_CBearingSourceMakeDefaultPtr.asFunction<_COptional_CBearingSource Function()>();

late final _CMyLocationControllerSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMyLocationControllerSettings Function()>>('CMyLocationControllerSettingsMakeDefault');
late final _CMyLocationControllerSettingsMakeDefault = _CMyLocationControllerSettingsMakeDefaultPtr.asFunction<_CMyLocationControllerSettings Function()>();


late final _CMyLocationMapObjectMarkerTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMyLocationMapObjectMarkerType Function()>>('CMyLocationMapObjectMarkerTypeMakeDefault');
late final _CMyLocationMapObjectMarkerTypeMakeDefault = _CMyLocationMapObjectMarkerTypeMakeDefaultPtr.asFunction<_CMyLocationMapObjectMarkerType Function()>();

late final _CModelData_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CModelData_cg_objectIdentifier');
late final _CModelData_cg_objectIdentifier = _CModelData_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CModelData_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CModelData_release');
late final _CModelData_release = _CModelData_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CModelData_retainPtr = _lookup<ffi.NativeFunction<_CModelData Function(ffi.Pointer<ffi.Void>)>>('CModelData_retain');
late final _CModelData_retain = _CModelData_retainPtr.asFunction<_CModelData Function(ffi.Pointer<ffi.Void>)>();
late final _CModelDataMakeDefaultPtr = _lookup<ffi.NativeFunction<_CModelData Function()>>('CModelDataMakeDefault');
late final _CModelDataMakeDefault = _CModelDataMakeDefaultPtr.asFunction<_CModelData Function()>();

late final _CMyLocationMapObject_animationSettingsPtr = _lookup<ffi.NativeFunction<_CAnimationSettings Function(_CMyLocationMapObject)>>('CMyLocationMapObject_animationSettings');
late final _CMyLocationMapObject_animationSettings = _CMyLocationMapObject_animationSettingsPtr.asFunction<_CAnimationSettings Function(_CMyLocationMapObject)>();
late final _CMyLocationMapObject_objectAttributesPtr = _lookup<ffi.NativeFunction<_CAttributes Function(_CMyLocationMapObject)>>('CMyLocationMapObject_objectAttributes');
late final _CMyLocationMapObject_objectAttributes = _CMyLocationMapObject_objectAttributesPtr.asFunction<_CAttributes Function(_CMyLocationMapObject)>();

late final _CMyLocationMapObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMyLocationMapObject_cg_objectIdentifier');
late final _CMyLocationMapObject_cg_objectIdentifier = _CMyLocationMapObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMyLocationMapObject_setModelData_COptional_CModelDataPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMyLocationMapObject, _COptional_CModelData)>>('CMyLocationMapObject_setModelData_COptional_CModelData');
late final _CMyLocationMapObject_setModelData_COptional_CModelData = _CMyLocationMapObject_setModelData_COptional_CModelDataPtr.asFunction<void Function(_CMyLocationMapObject, _COptional_CModelData)>();

late final _CMyLocationMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMyLocationMapObject_release');
late final _CMyLocationMapObject_release = _CMyLocationMapObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMyLocationMapObject_retainPtr = _lookup<ffi.NativeFunction<_CMyLocationMapObject Function(ffi.Pointer<ffi.Void>)>>('CMyLocationMapObject_retain');
late final _CMyLocationMapObject_retain = _CMyLocationMapObject_retainPtr.asFunction<_CMyLocationMapObject Function(ffi.Pointer<ffi.Void>)>();
late final _CMyLocationMapObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMyLocationMapObject Function()>>('CMyLocationMapObjectMakeDefault');
late final _CMyLocationMapObjectMakeDefault = _CMyLocationMapObjectMakeDefaultPtr.asFunction<_CMyLocationMapObject Function()>();


late final _COptional_CModelDataMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CModelData Function()>>('COptional_CModelDataMakeDefault');
late final _COptional_CModelDataMakeDefault = _COptional_CModelDataMakeDefaultPtr.asFunction<_COptional_CModelData Function()>();

late final _COptional_CModelData_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CModelData)>>('COptional_CModelData_release');
late final _COptional_CModelData_release = _COptional_CModelData_releasePtr.asFunction<void Function(_COptional_CModelData)>();
late final _CMyLocationMapObjectSource_itemPtr = _lookup<ffi.NativeFunction<_CMyLocationMapObject Function(_CMyLocationMapObjectSource)>>('CMyLocationMapObjectSource_item');
late final _CMyLocationMapObjectSource_item = _CMyLocationMapObjectSource_itemPtr.asFunction<_CMyLocationMapObject Function(_CMyLocationMapObjectSource)>();

late final _CMyLocationMapObjectSource_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMyLocationMapObjectSource_cg_objectIdentifier');
late final _CMyLocationMapObjectSource_cg_objectIdentifier = _CMyLocationMapObjectSource_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMyLocationMapObjectSource_C_createWith_CContext_CMyLocationControllerSettings_CMyLocationMapObjectMarkerTypePtr = _lookup<ffi.NativeFunction<_CMyLocationMapObjectSource Function(_CContext, _CMyLocationControllerSettings, _CMyLocationMapObjectMarkerType)>>('CMyLocationMapObjectSource_C_createWith_CContext_CMyLocationControllerSettings_CMyLocationMapObjectMarkerType');
late final _CMyLocationMapObjectSource_C_createWith_CContext_CMyLocationControllerSettings_CMyLocationMapObjectMarkerType = _CMyLocationMapObjectSource_C_createWith_CContext_CMyLocationControllerSettings_CMyLocationMapObjectMarkerTypePtr.asFunction<_CMyLocationMapObjectSource Function(_CContext, _CMyLocationControllerSettings, _CMyLocationMapObjectMarkerType)>();

late final _CMyLocationMapObjectSource_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMyLocationMapObjectSource_release');
late final _CMyLocationMapObjectSource_release = _CMyLocationMapObjectSource_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMyLocationMapObjectSource_retainPtr = _lookup<ffi.NativeFunction<_CMyLocationMapObjectSource Function(ffi.Pointer<ffi.Void>)>>('CMyLocationMapObjectSource_retain');
late final _CMyLocationMapObjectSource_retain = _CMyLocationMapObjectSource_retainPtr.asFunction<_CMyLocationMapObjectSource Function(ffi.Pointer<ffi.Void>)>();
late final _CMyLocationMapObjectSourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMyLocationMapObjectSource Function()>>('CMyLocationMapObjectSourceMakeDefault');
late final _CMyLocationMapObjectSourceMakeDefault = _CMyLocationMapObjectSourceMakeDefaultPtr.asFunction<_CMyLocationMapObjectSource Function()>();

late final _CRoadEventMapObject_idPtr = _lookup<ffi.NativeFunction<_CDgisObjectId Function(_CRoadEventMapObject)>>('CRoadEventMapObject_id');
late final _CRoadEventMapObject_id = _CRoadEventMapObject_idPtr.asFunction<_CDgisObjectId Function(_CRoadEventMapObject)>();
late final _CRoadEventMapObject_eventPtr = _lookup<ffi.NativeFunction<_CRoadEvent Function(_CRoadEventMapObject)>>('CRoadEventMapObject_event');
late final _CRoadEventMapObject_event = _CRoadEventMapObject_eventPtr.asFunction<_CRoadEvent Function(_CRoadEventMapObject)>();
late final _CRoadEventMapObject_animationSettingsPtr = _lookup<ffi.NativeFunction<_CAnimationSettings Function(_CRoadEventMapObject)>>('CRoadEventMapObject_animationSettings');
late final _CRoadEventMapObject_animationSettings = _CRoadEventMapObject_animationSettingsPtr.asFunction<_CAnimationSettings Function(_CRoadEventMapObject)>();

late final _CRoadEventMapObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRoadEventMapObject_cg_objectIdentifier');
late final _CRoadEventMapObject_cg_objectIdentifier = _CRoadEventMapObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CRoadEventMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRoadEventMapObject_release');
late final _CRoadEventMapObject_release = _CRoadEventMapObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventMapObject_retainPtr = _lookup<ffi.NativeFunction<_CRoadEventMapObject Function(ffi.Pointer<ffi.Void>)>>('CRoadEventMapObject_retain');
late final _CRoadEventMapObject_retain = _CRoadEventMapObject_retainPtr.asFunction<_CRoadEventMapObject Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventMapObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventMapObject Function()>>('CRoadEventMapObjectMakeDefault');
late final _CRoadEventMapObjectMakeDefault = _CRoadEventMapObjectMakeDefaultPtr.asFunction<_CRoadEventMapObject Function()>();


late final _CRoadEventTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventType Function()>>('CRoadEventTypeMakeDefault');
late final _CRoadEventTypeMakeDefault = _CRoadEventTypeMakeDefaultPtr.asFunction<_CRoadEventType Function()>();
late final _CRoadEvent_typePtr = _lookup<ffi.NativeFunction<_CRoadEventType Function(_CRoadEvent)>>('CRoadEvent_type');
late final _CRoadEvent_type = _CRoadEvent_typePtr.asFunction<_CRoadEventType Function(_CRoadEvent)>();
late final _CRoadEvent_idPtr = _lookup<ffi.NativeFunction<_CString Function(_CRoadEvent)>>('CRoadEvent_id');
late final _CRoadEvent_id = _CRoadEvent_idPtr.asFunction<_CString Function(_CRoadEvent)>();
late final _CRoadEvent_namePtr = _lookup<ffi.NativeFunction<_CString Function(_CRoadEvent)>>('CRoadEvent_name');
late final _CRoadEvent_name = _CRoadEvent_namePtr.asFunction<_CString Function(_CRoadEvent)>();
late final _CRoadEvent_authorPtr = _lookup<ffi.NativeFunction<_CAuthorInfo Function(_CRoadEvent)>>('CRoadEvent_author');
late final _CRoadEvent_author = _CRoadEvent_authorPtr.asFunction<_CAuthorInfo Function(_CRoadEvent)>();
late final _CRoadEvent_timestampPtr = _lookup<ffi.NativeFunction<_COptional_CDate Function(_CRoadEvent)>>('CRoadEvent_timestamp');
late final _CRoadEvent_timestamp = _CRoadEvent_timestampPtr.asFunction<_COptional_CDate Function(_CRoadEvent)>();
late final _CRoadEvent_locationPtr = _lookup<ffi.NativeFunction<_CGeoPoint Function(_CRoadEvent)>>('CRoadEvent_location');
late final _CRoadEvent_location = _CRoadEvent_locationPtr.asFunction<_CGeoPoint Function(_CRoadEvent)>();
late final _CRoadEvent_descriptionPtr = _lookup<ffi.NativeFunction<_CString Function(_CRoadEvent)>>('CRoadEvent_description');
late final _CRoadEvent_description = _CRoadEvent_descriptionPtr.asFunction<_CString Function(_CRoadEvent)>();
late final _CRoadEvent_cameraInfoPtr = _lookup<ffi.NativeFunction<_COptional_CRoadCameraInfo Function(_CRoadEvent)>>('CRoadEvent_cameraInfo');
late final _CRoadEvent_cameraInfo = _CRoadEvent_cameraInfoPtr.asFunction<_COptional_CRoadCameraInfo Function(_CRoadEvent)>();
late final _CRoadEvent_schedulePtr = _lookup<ffi.NativeFunction<_COptional_CSchedule Function(_CRoadEvent)>>('CRoadEvent_schedule');
late final _CRoadEvent_schedule = _CRoadEvent_schedulePtr.asFunction<_COptional_CSchedule Function(_CRoadEvent)>();
late final _CRoadEvent_lanesPtr = _lookup<ffi.NativeFunction<_COptionSet_CLane Function(_CRoadEvent)>>('CRoadEvent_lanes');
late final _CRoadEvent_lanes = _CRoadEvent_lanesPtr.asFunction<_COptionSet_CLane Function(_CRoadEvent)>();
late final _CRoadEvent_availableActionsPtr = _lookup<ffi.NativeFunction<_CArray_CRoadEventAction Function(_CRoadEvent)>>('CRoadEvent_availableActions');
late final _CRoadEvent_availableActions = _CRoadEvent_availableActionsPtr.asFunction<_CArray_CRoadEventAction Function(_CRoadEvent)>();
late final _CRoadEvent_removerPtr = _lookup<ffi.NativeFunction<_COptional_CRemover Function(_CRoadEvent)>>('CRoadEvent_remover');
late final _CRoadEvent_remover = _CRoadEvent_removerPtr.asFunction<_COptional_CRemover Function(_CRoadEvent)>();

late final _CRoadEvent_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRoadEvent_cg_objectIdentifier');
late final _CRoadEvent_cg_objectIdentifier = _CRoadEvent_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRoadEvent_photosPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CRoadEventPhoto Function(_CRoadEvent)>>('CRoadEvent_photos');
late final _CRoadEvent_photos = _CRoadEvent_photosPtr.asFunction<_CFuture_CArray_CRoadEventPhoto Function(_CRoadEvent)>();

late final _CRoadEvent_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRoadEvent_release');
late final _CRoadEvent_release = _CRoadEvent_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEvent_retainPtr = _lookup<ffi.NativeFunction<_CRoadEvent Function(ffi.Pointer<ffi.Void>)>>('CRoadEvent_retain');
late final _CRoadEvent_retain = _CRoadEvent_retainPtr.asFunction<_CRoadEvent Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEvent Function()>>('CRoadEventMakeDefault');
late final _CRoadEventMakeDefault = _CRoadEventMakeDefaultPtr.asFunction<_CRoadEvent Function()>();


late final _CAuthorTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAuthorType Function()>>('CAuthorTypeMakeDefault');
late final _CAuthorTypeMakeDefault = _CAuthorTypeMakeDefaultPtr.asFunction<_CAuthorType Function()>();

late final _CAuthorInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAuthorInfo Function()>>('CAuthorInfoMakeDefault');
late final _CAuthorInfoMakeDefault = _CAuthorInfoMakeDefaultPtr.asFunction<_CAuthorInfo Function()>();


late final _CDateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDate Function()>>('CDateMakeDefault');
late final _CDateMakeDefault = _CDateMakeDefaultPtr.asFunction<_CDate Function()>();

late final _COptional_CDateMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CDate Function()>>('COptional_CDateMakeDefault');
late final _COptional_CDateMakeDefault = _COptional_CDateMakeDefaultPtr.asFunction<_COptional_CDate Function()>();

late final _CCameraPurposeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraPurpose Function()>>('CCameraPurposeMakeDefault');
late final _CCameraPurposeMakeDefault = _CCameraPurposeMakeDefaultPtr.asFunction<_CCameraPurpose Function()>();

late final _COptionSet_CCameraPurposeMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptionSet_CCameraPurpose Function()>>('COptionSet_CCameraPurposeMakeDefault');
late final _COptionSet_CCameraPurposeMakeDefault = _COptionSet_CCameraPurposeMakeDefaultPtr.asFunction<_COptionSet_CCameraPurpose Function()>();

late final _CRoadCameraInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadCameraInfo Function()>>('CRoadCameraInfoMakeDefault');
late final _CRoadCameraInfoMakeDefault = _CRoadCameraInfoMakeDefaultPtr.asFunction<_CRoadCameraInfo Function()>();


late final _COptional_CRoadCameraInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CRoadCameraInfo Function()>>('COptional_CRoadCameraInfoMakeDefault');
late final _COptional_CRoadCameraInfoMakeDefault = _COptional_CRoadCameraInfoMakeDefaultPtr.asFunction<_COptional_CRoadCameraInfo Function()>();

late final _CScheduleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSchedule Function()>>('CScheduleMakeDefault');
late final _CScheduleMakeDefault = _CScheduleMakeDefaultPtr.asFunction<_CSchedule Function()>();


late final _COptional_CScheduleMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CSchedule Function()>>('COptional_CScheduleMakeDefault');
late final _COptional_CScheduleMakeDefault = _COptional_CScheduleMakeDefaultPtr.asFunction<_COptional_CSchedule Function()>();

late final _COptional_CSchedule_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CSchedule)>>('COptional_CSchedule_release');
late final _COptional_CSchedule_release = _COptional_CSchedule_releasePtr.asFunction<void Function(_COptional_CSchedule)>();

late final _CLaneMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLane Function()>>('CLaneMakeDefault');
late final _CLaneMakeDefault = _CLaneMakeDefaultPtr.asFunction<_CLane Function()>();

late final _COptionSet_CLaneMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptionSet_CLane Function()>>('COptionSet_CLaneMakeDefault');
late final _COptionSet_CLaneMakeDefault = _COptionSet_CLaneMakeDefaultPtr.asFunction<_COptionSet_CLane Function()>();

late final _CFuture_CArray_CRoadEventPhotoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CRoadEventPhoto Function()>>('CFuture_CArray_CRoadEventPhotoMakeDefault');
late final _CFuture_CArray_CRoadEventPhotoMakeDefault = _CFuture_CArray_CRoadEventPhotoMakeDefaultPtr.asFunction<_CFuture_CArray_CRoadEventPhoto Function()>();
late final _CFuture_CArray_CRoadEventPhoto_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CArray_CRoadEventPhoto)>>('CFuture_CArray_CRoadEventPhoto_release');
late final _CFuture_CArray_CRoadEventPhoto_release = _CFuture_CArray_CRoadEventPhoto_releasePtr.asFunction<void Function(_CFuture_CArray_CRoadEventPhoto)>();
late final _CFuture_CArray_CRoadEventPhoto_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CRoadEventPhoto Function(_CFuture_CArray_CRoadEventPhoto)>>('CFuture_CArray_CRoadEventPhoto_retain');
late final _CFuture_CArray_CRoadEventPhoto_retain = _CFuture_CArray_CRoadEventPhoto_retainPtr.asFunction<_CFuture_CArray_CRoadEventPhoto Function(_CFuture_CArray_CRoadEventPhoto)>();
late final _CFuture_CArray_CRoadEventPhotoReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CArray_CRoadEventPhoto,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadEventPhoto, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CArray_CRoadEventPhoto_receive');
late final _CFuture_CArray_CRoadEventPhotoReceive = _CFuture_CArray_CRoadEventPhotoReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CArray_CRoadEventPhoto,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadEventPhoto, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CArray_CRoadEventPhotomakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CRoadEventPhoto Function()>>('CArray_CRoadEventPhoto_makeEmpty');
late final _CArray_CRoadEventPhotomakeEmpty = _CArray_CRoadEventPhotomakeEmptyPtr.asFunction<_CArray_CRoadEventPhoto Function()>();
late final _CArray_CRoadEventPhotoaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadEventPhoto, _CRoadEventPhoto)>>('CArray_CRoadEventPhoto_addElement');
late final _CArray_CRoadEventPhotoaddElement = _CArray_CRoadEventPhotoaddElementPtr.asFunction<void Function(_CArray_CRoadEventPhoto, _CRoadEventPhoto)>();
late final _forEach_CArray_CRoadEventPhotoPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CRoadEventPhoto, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadEventPhoto)>>)
>>('CArray_CRoadEventPhoto_forEachWithFunctionPointer');
late final _forEach_CArray_CRoadEventPhoto = _forEach_CArray_CRoadEventPhotoPtr.asFunction<
  void Function(_CArray_CRoadEventPhoto, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadEventPhoto)
>>)>();
late final _CArray_CRoadEventPhoto_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadEventPhoto)>>('CArray_CRoadEventPhoto_release');
late final _CArray_CRoadEventPhoto_release = _CArray_CRoadEventPhoto_releasePtr.asFunction<void Function(_CArray_CRoadEventPhoto)>();
late final _CRoadEventPhoto_photoUrlPtr = _lookup<ffi.NativeFunction<_CString Function(_CRoadEventPhoto)>>('CRoadEventPhoto_photoUrl');
late final _CRoadEventPhoto_photoUrl = _CRoadEventPhoto_photoUrlPtr.asFunction<_CString Function(_CRoadEventPhoto)>();
late final _CRoadEventPhoto_authorPtr = _lookup<ffi.NativeFunction<_CAuthorInfo Function(_CRoadEventPhoto)>>('CRoadEventPhoto_author');
late final _CRoadEventPhoto_author = _CRoadEventPhoto_authorPtr.asFunction<_CAuthorInfo Function(_CRoadEventPhoto)>();
late final _CRoadEventPhoto_timestampPtr = _lookup<ffi.NativeFunction<_CDate Function(_CRoadEventPhoto)>>('CRoadEventPhoto_timestamp');
late final _CRoadEventPhoto_timestamp = _CRoadEventPhoto_timestampPtr.asFunction<_CDate Function(_CRoadEventPhoto)>();
late final _CRoadEventPhoto_removerPtr = _lookup<ffi.NativeFunction<_COptional_CRemover Function(_CRoadEventPhoto)>>('CRoadEventPhoto_remover');
late final _CRoadEventPhoto_remover = _CRoadEventPhoto_removerPtr.asFunction<_COptional_CRemover Function(_CRoadEventPhoto)>();

late final _CRoadEventPhoto_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRoadEventPhoto_cg_objectIdentifier');
late final _CRoadEventPhoto_cg_objectIdentifier = _CRoadEventPhoto_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRoadEventPhoto_previewUrl_CScreenSizePtr = _lookup<ffi.NativeFunction<_CString Function(_CRoadEventPhoto, _CScreenSize)>>('CRoadEventPhoto_previewUrl_CScreenSize');
late final _CRoadEventPhoto_previewUrl_CScreenSize = _CRoadEventPhoto_previewUrl_CScreenSizePtr.asFunction<_CString Function(_CRoadEventPhoto, _CScreenSize)>();
late final _CRoadEventPhoto_reportPtr = _lookup<ffi.NativeFunction<_CFuture_CActionResult Function(_CRoadEventPhoto)>>('CRoadEventPhoto_report');
late final _CRoadEventPhoto_report = _CRoadEventPhoto_reportPtr.asFunction<_CFuture_CActionResult Function(_CRoadEventPhoto)>();

late final _CRoadEventPhoto_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRoadEventPhoto_release');
late final _CRoadEventPhoto_release = _CRoadEventPhoto_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventPhoto_retainPtr = _lookup<ffi.NativeFunction<_CRoadEventPhoto Function(ffi.Pointer<ffi.Void>)>>('CRoadEventPhoto_retain');
late final _CRoadEventPhoto_retain = _CRoadEventPhoto_retainPtr.asFunction<_CRoadEventPhoto Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventPhotoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventPhoto Function()>>('CRoadEventPhotoMakeDefault');
late final _CRoadEventPhotoMakeDefault = _CRoadEventPhotoMakeDefaultPtr.asFunction<_CRoadEventPhoto Function()>();


late final _CActionResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CActionResult Function()>>('CActionResultMakeDefault');
late final _CActionResultMakeDefault = _CActionResultMakeDefaultPtr.asFunction<_CActionResult Function()>();

late final _CFuture_CActionResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CActionResult Function()>>('CFuture_CActionResultMakeDefault');
late final _CFuture_CActionResultMakeDefault = _CFuture_CActionResultMakeDefaultPtr.asFunction<_CFuture_CActionResult Function()>();
late final _CFuture_CActionResult_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CActionResult)>>('CFuture_CActionResult_release');
late final _CFuture_CActionResult_release = _CFuture_CActionResult_releasePtr.asFunction<void Function(_CFuture_CActionResult)>();
late final _CFuture_CActionResult_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CActionResult Function(_CFuture_CActionResult)>>('CFuture_CActionResult_retain');
late final _CFuture_CActionResult_retain = _CFuture_CActionResult_retainPtr.asFunction<_CFuture_CActionResult Function(_CFuture_CActionResult)>();
late final _CFuture_CActionResultReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CActionResult,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CActionResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CActionResult_receive');
late final _CFuture_CActionResultReceive = _CFuture_CActionResultReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CActionResult,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CActionResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CRemover_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRemover_cg_objectIdentifier');
late final _CRemover_cg_objectIdentifier = _CRemover_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRemover_removePtr = _lookup<ffi.NativeFunction<_CFuture_CActionResult Function(_CRemover)>>('CRemover_remove');
late final _CRemover_remove = _CRemover_removePtr.asFunction<_CFuture_CActionResult Function(_CRemover)>();

late final _CRemover_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRemover_release');
late final _CRemover_release = _CRemover_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRemover_retainPtr = _lookup<ffi.NativeFunction<_CRemover Function(ffi.Pointer<ffi.Void>)>>('CRemover_retain');
late final _CRemover_retain = _CRemover_retainPtr.asFunction<_CRemover Function(ffi.Pointer<ffi.Void>)>();
late final _CRemoverMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRemover Function()>>('CRemoverMakeDefault');
late final _CRemoverMakeDefault = _CRemoverMakeDefaultPtr.asFunction<_CRemover Function()>();


late final _COptional_CRemoverMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CRemover Function()>>('COptional_CRemoverMakeDefault');
late final _COptional_CRemoverMakeDefault = _COptional_CRemoverMakeDefaultPtr.asFunction<_COptional_CRemover Function()>();

late final _COptional_CRemover_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CRemover)>>('COptional_CRemover_release');
late final _COptional_CRemover_release = _COptional_CRemover_releasePtr.asFunction<void Function(_COptional_CRemover)>();

late final _CArray_CRoadEventActionmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CRoadEventAction Function()>>('CArray_CRoadEventAction_makeEmpty');
late final _CArray_CRoadEventActionmakeEmpty = _CArray_CRoadEventActionmakeEmptyPtr.asFunction<_CArray_CRoadEventAction Function()>();
late final _CArray_CRoadEventActionaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadEventAction, _CRoadEventAction)>>('CArray_CRoadEventAction_addElement');
late final _CArray_CRoadEventActionaddElement = _CArray_CRoadEventActionaddElementPtr.asFunction<void Function(_CArray_CRoadEventAction, _CRoadEventAction)>();
late final _forEach_CArray_CRoadEventActionPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CRoadEventAction, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadEventAction)>>)
>>('CArray_CRoadEventAction_forEachWithFunctionPointer');
late final _forEach_CArray_CRoadEventAction = _forEach_CArray_CRoadEventActionPtr.asFunction<
  void Function(_CArray_CRoadEventAction, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadEventAction)
>>)>();
late final _CArray_CRoadEventAction_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRoadEventAction)>>('CArray_CRoadEventAction_release');
late final _CArray_CRoadEventAction_release = _CArray_CRoadEventAction_releasePtr.asFunction<void Function(_CArray_CRoadEventAction)>();

late final _CRoadEventActionTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventActionType Function()>>('CRoadEventActionTypeMakeDefault');
late final _CRoadEventActionTypeMakeDefault = _CRoadEventActionTypeMakeDefaultPtr.asFunction<_CRoadEventActionType Function()>();
late final _CRoadEventAction_typePtr = _lookup<ffi.NativeFunction<_CRoadEventActionType Function(_CRoadEventAction)>>('CRoadEventAction_type');
late final _CRoadEventAction_type = _CRoadEventAction_typePtr.asFunction<_CRoadEventActionType Function(_CRoadEventAction)>();
late final _CRoadEventAction_namePtr = _lookup<ffi.NativeFunction<_CString Function(_CRoadEventAction)>>('CRoadEventAction_name');
late final _CRoadEventAction_name = _CRoadEventAction_namePtr.asFunction<_CString Function(_CRoadEventAction)>();
late final _CRoadEventAction_infoChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRoadEventActionInfo Function(_CRoadEventAction)>>('CRoadEventAction_infoChannel');
late final _CRoadEventAction_infoChannel = _CRoadEventAction_infoChannelPtr.asFunction<_CStatefulChannel_CRoadEventActionInfo Function(_CRoadEventAction)>();
late final _CRoadEventAction_infoPtr = _lookup<ffi.NativeFunction<_CRoadEventActionInfo Function(_CRoadEventAction)>>('CRoadEventAction_info');
late final _CRoadEventAction_info = _CRoadEventAction_infoPtr.asFunction<_CRoadEventActionInfo Function(_CRoadEventAction)>();

late final _CRoadEventAction_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRoadEventAction_cg_objectIdentifier');
late final _CRoadEventAction_cg_objectIdentifier = _CRoadEventAction_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRoadEventAction_setPtr = _lookup<ffi.NativeFunction<_CFuture_CActionResult Function(_CRoadEventAction)>>('CRoadEventAction_set');
late final _CRoadEventAction_set = _CRoadEventAction_setPtr.asFunction<_CFuture_CActionResult Function(_CRoadEventAction)>();
late final _CRoadEventAction_resetPtr = _lookup<ffi.NativeFunction<_CFuture_CActionResult Function(_CRoadEventAction)>>('CRoadEventAction_reset');
late final _CRoadEventAction_reset = _CRoadEventAction_resetPtr.asFunction<_CFuture_CActionResult Function(_CRoadEventAction)>();

late final _CRoadEventAction_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRoadEventAction_release');
late final _CRoadEventAction_release = _CRoadEventAction_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventAction_retainPtr = _lookup<ffi.NativeFunction<_CRoadEventAction Function(ffi.Pointer<ffi.Void>)>>('CRoadEventAction_retain');
late final _CRoadEventAction_retain = _CRoadEventAction_retainPtr.asFunction<_CRoadEventAction Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventActionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventAction Function()>>('CRoadEventActionMakeDefault');
late final _CRoadEventActionMakeDefault = _CRoadEventActionMakeDefaultPtr.asFunction<_CRoadEventAction Function()>();


late final _CStatefulChannel_CRoadEventActionInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRoadEventActionInfo Function()>>('CStatefulChannel_CRoadEventActionInfoMakeDefault');
late final _CStatefulChannel_CRoadEventActionInfoMakeDefault = _CStatefulChannel_CRoadEventActionInfoMakeDefaultPtr.asFunction<_CStatefulChannel_CRoadEventActionInfo Function()>();
late final _CStatefulChannel_CRoadEventActionInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CRoadEventActionInfo)>>('CStatefulChannel_CRoadEventActionInfo_release');
late final _CStatefulChannel_CRoadEventActionInfo_release = _CStatefulChannel_CRoadEventActionInfo_releasePtr.asFunction<void Function(_CStatefulChannel_CRoadEventActionInfo)>();
late final _CStatefulChannel_CRoadEventActionInfo_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CRoadEventActionInfo Function(_CStatefulChannel_CRoadEventActionInfo)>>('CStatefulChannel_CRoadEventActionInfo_retain');
late final _CStatefulChannel_CRoadEventActionInfo_retain = _CStatefulChannel_CRoadEventActionInfo_retainPtr.asFunction<_CStatefulChannel_CRoadEventActionInfo Function(_CStatefulChannel_CRoadEventActionInfo)>();
late final _CStatefulChannel_CRoadEventActionInfoGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CRoadEventActionInfo Function(_CStatefulChannel_CRoadEventActionInfo)>>('CStatefulChannel_CRoadEventActionInfo_getCurrentValue');
late final _CStatefulChannel_CRoadEventActionInfoGetCurrentValue = _CStatefulChannel_CRoadEventActionInfoGetCurrentValuePtr.asFunction<_CRoadEventActionInfo Function(_CStatefulChannel_CRoadEventActionInfo)>();
late final _CStatefulChannel_CRoadEventActionInfoConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CRoadEventActionInfo,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadEventActionInfo, ffi.Int64)>>
  )
>>('CStatefulChannel_CRoadEventActionInfo_connect');
late final _CStatefulChannel_CRoadEventActionInfoConnect = _CStatefulChannel_CRoadEventActionInfoConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CRoadEventActionInfo,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRoadEventActionInfo, ffi.Int64)>>
  )
>();

late final _CRoadEventActionStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventActionState Function()>>('CRoadEventActionStateMakeDefault');
late final _CRoadEventActionStateMakeDefault = _CRoadEventActionStateMakeDefaultPtr.asFunction<_CRoadEventActionState Function()>();

late final _COptional_uint32_tMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_uint32_t Function()>>('COptional_uint32_tMakeDefault');
late final _COptional_uint32_tMakeDefault = _COptional_uint32_tMakeDefaultPtr.asFunction<_COptional_uint32_t Function()>();

late final _CRoadEventActionInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventActionInfo Function()>>('CRoadEventActionInfoMakeDefault');
late final _CRoadEventActionInfoMakeDefault = _CRoadEventActionInfoMakeDefaultPtr.asFunction<_CRoadEventActionInfo Function()>();

late final _CStyle_styleAttributesPtr = _lookup<ffi.NativeFunction<_CAttributes Function(_CStyle)>>('CStyle_styleAttributes');
late final _CStyle_styleAttributes = _CStyle_styleAttributesPtr.asFunction<_CAttributes Function(_CStyle)>();

late final _CStyle_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CStyle_cg_objectIdentifier');
late final _CStyle_cg_objectIdentifier = _CStyle_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CStyle_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CStyle_release');
late final _CStyle_release = _CStyle_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CStyle_retainPtr = _lookup<ffi.NativeFunction<_CStyle Function(ffi.Pointer<ffi.Void>)>>('CStyle_retain');
late final _CStyle_retain = _CStyle_retainPtr.asFunction<_CStyle Function(ffi.Pointer<ffi.Void>)>();
late final _CStyleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStyle Function()>>('CStyleMakeDefault');
late final _CStyleMakeDefault = _CStyleMakeDefaultPtr.asFunction<_CStyle Function()>();


late final _CStyleZoomFollowController_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CStyleZoomFollowController_cg_objectIdentifier');
late final _CStyleZoomFollowController_cg_objectIdentifier = _CStyleZoomFollowController_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CStyleZoomFollowController_setStyleZoom_CStyleZoomPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStyleZoomFollowController, _CStyleZoom)>>('CStyleZoomFollowController_setStyleZoom_CStyleZoom');
late final _CStyleZoomFollowController_setStyleZoom_CStyleZoom = _CStyleZoomFollowController_setStyleZoom_CStyleZoomPtr.asFunction<void Function(_CStyleZoomFollowController, _CStyleZoom)>();
late final _CStyleZoomFollowController_setStyleZoomRange_CStyleZoom_CStyleZoomPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStyleZoomFollowController, _CStyleZoom, _CStyleZoom)>>('CStyleZoomFollowController_setStyleZoomRange_CStyleZoom_CStyleZoom');
late final _CStyleZoomFollowController_setStyleZoomRange_CStyleZoom_CStyleZoom = _CStyleZoomFollowController_setStyleZoomRange_CStyleZoom_CStyleZoomPtr.asFunction<void Function(_CStyleZoomFollowController, _CStyleZoom, _CStyleZoom)>();
late final _CStyleZoomFollowController_C_createWith_CTimeIntervalPtr = _lookup<ffi.NativeFunction<_CStyleZoomFollowController Function(_CTimeInterval)>>('CStyleZoomFollowController_C_createWith_CTimeInterval');
late final _CStyleZoomFollowController_C_createWith_CTimeInterval = _CStyleZoomFollowController_C_createWith_CTimeIntervalPtr.asFunction<_CStyleZoomFollowController Function(_CTimeInterval)>();

late final _CStyleZoomFollowController_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CStyleZoomFollowController_release');
late final _CStyleZoomFollowController_release = _CStyleZoomFollowController_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CStyleZoomFollowController_retainPtr = _lookup<ffi.NativeFunction<_CStyleZoomFollowController Function(ffi.Pointer<ffi.Void>)>>('CStyleZoomFollowController_retain');
late final _CStyleZoomFollowController_retain = _CStyleZoomFollowController_retainPtr.asFunction<_CStyleZoomFollowController Function(ffi.Pointer<ffi.Void>)>();
late final _CStyleZoomFollowControllerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStyleZoomFollowController Function()>>('CStyleZoomFollowControllerMakeDefault');
late final _CStyleZoomFollowControllerMakeDefault = _CStyleZoomFollowControllerMakeDefaultPtr.asFunction<_CStyleZoomFollowController Function()>();


late final _CStyleZoomToTiltRelationCpp_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CStyleZoomToTiltRelationCpp_cg_objectIdentifier');
late final _CStyleZoomToTiltRelationCpp_cg_objectIdentifier = _CStyleZoomToTiltRelationCpp_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CStyleZoomToTiltRelationCpp_styleZoomToTilt_CStyleZoomPtr = _lookup<ffi.NativeFunction<_CTilt Function(_CStyleZoomToTiltRelationCpp, _CStyleZoom)>>('CStyleZoomToTiltRelationCpp_styleZoomToTilt_CStyleZoom');
late final _CStyleZoomToTiltRelationCpp_styleZoomToTilt_CStyleZoom = _CStyleZoomToTiltRelationCpp_styleZoomToTilt_CStyleZoomPtr.asFunction<_CTilt Function(_CStyleZoomToTiltRelationCpp, _CStyleZoom)>();

late final _CStyleZoomToTiltRelationCpp_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CStyleZoomToTiltRelationCpp_release');
late final _CStyleZoomToTiltRelationCpp_release = _CStyleZoomToTiltRelationCpp_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CStyleZoomToTiltRelationCpp_retainPtr = _lookup<ffi.NativeFunction<_CStyleZoomToTiltRelationCpp Function(ffi.Pointer<ffi.Void>)>>('CStyleZoomToTiltRelationCpp_retain');
late final _CStyleZoomToTiltRelationCpp_retain = _CStyleZoomToTiltRelationCpp_retainPtr.asFunction<_CStyleZoomToTiltRelationCpp Function(ffi.Pointer<ffi.Void>)>();
late final _CStyleZoomToTiltRelationCppMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStyleZoomToTiltRelationCpp Function()>>('CStyleZoomToTiltRelationCppMakeDefault');
late final _CStyleZoomToTiltRelationCppMakeDefault = _CStyleZoomToTiltRelationCppMakeDefaultPtr.asFunction<_CStyleZoomToTiltRelationCpp Function()>();


late final _CStyleZoomToTiltRelationMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStyleZoomToTiltRelation Function()>>('CStyleZoomToTiltRelationMakeDefault');
late final _CStyleZoomToTiltRelationMakeDefault = _CStyleZoomToTiltRelationMakeDefaultPtr.asFunction<_CStyleZoomToTiltRelation Function()>();
late final _CStyleZoomToTiltRelation_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStyleZoomToTiltRelation)>>('CStyleZoomToTiltRelation_release');
late final _CStyleZoomToTiltRelation_release = _CStyleZoomToTiltRelation_releasePtr.asFunction<void Function(_CStyleZoomToTiltRelation)>();

late final _CTiltFollowController_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CTiltFollowController_cg_objectIdentifier');
late final _CTiltFollowController_cg_objectIdentifier = _CTiltFollowController_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CTiltFollowController_C_createWith_CStyleZoomToTiltRelationPtr = _lookup<ffi.NativeFunction<_CTiltFollowController Function(_CStyleZoomToTiltRelation)>>('CTiltFollowController_C_createWith_CStyleZoomToTiltRelation');
late final _CTiltFollowController_C_createWith_CStyleZoomToTiltRelation = _CTiltFollowController_C_createWith_CStyleZoomToTiltRelationPtr.asFunction<_CTiltFollowController Function(_CStyleZoomToTiltRelation)>();

late final _CTiltFollowController_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CTiltFollowController_release');
late final _CTiltFollowController_release = _CTiltFollowController_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CTiltFollowController_retainPtr = _lookup<ffi.NativeFunction<_CTiltFollowController Function(ffi.Pointer<ffi.Void>)>>('CTiltFollowController_retain');
late final _CTiltFollowController_retain = _CTiltFollowController_retainPtr.asFunction<_CTiltFollowController Function(ffi.Pointer<ffi.Void>)>();
late final _CTiltFollowControllerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTiltFollowController Function()>>('CTiltFollowControllerMakeDefault');
late final _CTiltFollowControllerMakeDefault = _CTiltFollowControllerMakeDefaultPtr.asFunction<_CTiltFollowController Function()>();


late final _CTrafficSource_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CTrafficSource_cg_objectIdentifier');
late final _CTrafficSource_cg_objectIdentifier = _CTrafficSource_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CTrafficSource_C_createWith_CContextPtr = _lookup<ffi.NativeFunction<_CTrafficSource Function(_CContext)>>('CTrafficSource_C_createWith_CContext');
late final _CTrafficSource_C_createWith_CContext = _CTrafficSource_C_createWith_CContextPtr.asFunction<_CTrafficSource Function(_CContext)>();

late final _CTrafficSource_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CTrafficSource_release');
late final _CTrafficSource_release = _CTrafficSource_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CTrafficSource_retainPtr = _lookup<ffi.NativeFunction<_CTrafficSource Function(ffi.Pointer<ffi.Void>)>>('CTrafficSource_retain');
late final _CTrafficSource_retain = _CTrafficSource_retainPtr.asFunction<_CTrafficSource Function(ffi.Pointer<ffi.Void>)>();
late final _CTrafficSourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTrafficSource Function()>>('CTrafficSourceMakeDefault');
late final _CTrafficSourceMakeDefault = _CTrafficSourceMakeDefaultPtr.asFunction<_CTrafficSource Function()>();


late final _CRoadEventDisplayCategoryMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventDisplayCategory Function()>>('CRoadEventDisplayCategoryMakeDefault');
late final _CRoadEventDisplayCategoryMakeDefault = _CRoadEventDisplayCategoryMakeDefaultPtr.asFunction<_CRoadEventDisplayCategory Function()>();
late final _CRoadEventSource_getVisibleEventsPtr = _lookup<ffi.NativeFunction<_COptionSet_CRoadEventDisplayCategory Function(_CRoadEventSource)>>('CRoadEventSource_getVisibleEvents');
late final _CRoadEventSource_getVisibleEvents = _CRoadEventSource_getVisibleEventsPtr.asFunction<_COptionSet_CRoadEventDisplayCategory Function(_CRoadEventSource)>();
late final _CRoadEventSource_setVisibleEvents_COptionSet_CRoadEventDisplayCategoryPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRoadEventSource, _COptionSet_CRoadEventDisplayCategory)>>('CRoadEventSource_setVisibleEvents_COptionSet_CRoadEventDisplayCategory');
late final _CRoadEventSource_setVisibleEvents_COptionSet_CRoadEventDisplayCategory = _CRoadEventSource_setVisibleEvents_COptionSet_CRoadEventDisplayCategoryPtr.asFunction<void Function(_CRoadEventSource, _COptionSet_CRoadEventDisplayCategory)>();
late final _CRoadEventSource_highlightedObjectsChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CDgisObjectId Function(_CRoadEventSource)>>('CRoadEventSource_highlightedObjectsChannel');
late final _CRoadEventSource_highlightedObjectsChannel = _CRoadEventSource_highlightedObjectsChannelPtr.asFunction<_CStatefulChannel_CArray_CDgisObjectId Function(_CRoadEventSource)>();
late final _CRoadEventSource_highlightedObjectsPtr = _lookup<ffi.NativeFunction<_CArray_CDgisObjectId Function(_CRoadEventSource)>>('CRoadEventSource_highlightedObjects');
late final _CRoadEventSource_highlightedObjects = _CRoadEventSource_highlightedObjectsPtr.asFunction<_CArray_CDgisObjectId Function(_CRoadEventSource)>();

late final _CRoadEventSource_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRoadEventSource_cg_objectIdentifier');
late final _CRoadEventSource_cg_objectIdentifier = _CRoadEventSource_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRoadEventSource_setHighlighted_CArray_CDgisObjectId_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRoadEventSource, _CArray_CDgisObjectId, ffi.Bool)>>('CRoadEventSource_setHighlighted_CArray_CDgisObjectId_bool');
late final _CRoadEventSource_setHighlighted_CArray_CDgisObjectId_bool = _CRoadEventSource_setHighlighted_CArray_CDgisObjectId_boolPtr.asFunction<void Function(_CRoadEventSource, _CArray_CDgisObjectId, bool)>();
late final _CRoadEventSource_C_createWith_CContextPtr = _lookup<ffi.NativeFunction<_CRoadEventSource Function(_CContext)>>('CRoadEventSource_C_createWith_CContext');
late final _CRoadEventSource_C_createWith_CContext = _CRoadEventSource_C_createWith_CContextPtr.asFunction<_CRoadEventSource Function(_CContext)>();

late final _CRoadEventSource_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRoadEventSource_release');
late final _CRoadEventSource_release = _CRoadEventSource_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventSource_retainPtr = _lookup<ffi.NativeFunction<_CRoadEventSource Function(ffi.Pointer<ffi.Void>)>>('CRoadEventSource_retain');
late final _CRoadEventSource_retain = _CRoadEventSource_retainPtr.asFunction<_CRoadEventSource Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventSourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventSource Function()>>('CRoadEventSourceMakeDefault');
late final _CRoadEventSourceMakeDefault = _CRoadEventSourceMakeDefaultPtr.asFunction<_CRoadEventSource Function()>();


late final _COptionSet_CRoadEventDisplayCategoryMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptionSet_CRoadEventDisplayCategory Function()>>('COptionSet_CRoadEventDisplayCategoryMakeDefault');
late final _COptionSet_CRoadEventDisplayCategoryMakeDefault = _COptionSet_CRoadEventDisplayCategoryMakeDefaultPtr.asFunction<_COptionSet_CRoadEventDisplayCategory Function()>();

late final _CAlignmentMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAlignment Function()>>('CAlignmentMakeDefault');
late final _CAlignmentMakeDefault = _CAlignmentMakeDefaultPtr.asFunction<_CAlignment Function()>();

late final _CAnimationModeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAnimationMode Function()>>('CAnimationModeMakeDefault');
late final _CAnimationModeMakeDefault = _CAnimationModeMakeDefaultPtr.asFunction<_CAnimationMode Function()>();

late final _CLogicalPixelMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLogicalPixel Function()>>('CLogicalPixelMakeDefault');
late final _CLogicalPixelMakeDefault = _CLogicalPixelMakeDefaultPtr.asFunction<_CLogicalPixel Function()>();


late final _CMapDataLoadingStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapDataLoadingState Function()>>('CMapDataLoadingStateMakeDefault');
late final _CMapDataLoadingStateMakeDefault = _CMapDataLoadingStateMakeDefaultPtr.asFunction<_CMapDataLoadingState Function()>();

late final _CMapDirectionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapDirection Function()>>('CMapDirectionMakeDefault');
late final _CMapDirectionMakeDefault = _CMapDirectionMakeDefaultPtr.asFunction<_CMapDirection Function()>();


late final _CMapIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapId Function()>>('CMapIdMakeDefault');
late final _CMapIdMakeDefault = _CMapIdMakeDefaultPtr.asFunction<_CMapId Function()>();


late final _CMapVisibilityStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapVisibilityState Function()>>('CMapVisibilityStateMakeDefault');
late final _CMapVisibilityStateMakeDefault = _CMapVisibilityStateMakeDefaultPtr.asFunction<_CMapVisibilityState Function()>();

late final _COpacityMakeDefaultPtr = _lookup<ffi.NativeFunction<_COpacity Function()>>('COpacityMakeDefault');
late final _COpacityMakeDefault = _COpacityMakeDefaultPtr.asFunction<_COpacity Function()>();


late final _CPaddingMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPadding Function()>>('CPaddingMakeDefault');
late final _CPaddingMakeDefault = _CPaddingMakeDefaultPtr.asFunction<_CPadding Function()>();


late final _CProductTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CProductType Function()>>('CProductTypeMakeDefault');
late final _CProductTypeMakeDefault = _CProductTypeMakeDefaultPtr.asFunction<_CProductType Function()>();

late final _CModelScaleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CModelScale Function()>>('CModelScaleMakeDefault');
late final _CModelScaleMakeDefault = _CModelScaleMakeDefaultPtr.asFunction<_CModelScale Function()>();


late final _CRenderedObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRenderedObject Function()>>('CRenderedObjectMakeDefault');
late final _CRenderedObjectMakeDefault = _CRenderedObjectMakeDefaultPtr.asFunction<_CRenderedObject Function()>();


late final _CScreenDistanceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScreenDistance Function()>>('CScreenDistanceMakeDefault');
late final _CScreenDistanceMakeDefault = _CScreenDistanceMakeDefaultPtr.asFunction<_CScreenDistance Function()>();


late final _CStyleLayerIdMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStyleLayerId Function()>>('CStyleLayerIdMakeDefault');
late final _CStyleLayerIdMakeDefault = _CStyleLayerIdMakeDefaultPtr.asFunction<_CStyleLayerId Function()>();


late final _CTextHorizontalAlignmentMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTextHorizontalAlignment Function()>>('CTextHorizontalAlignmentMakeDefault');
late final _CTextHorizontalAlignmentMakeDefault = _CTextHorizontalAlignmentMakeDefaultPtr.asFunction<_CTextHorizontalAlignment Function()>();

late final _CTextPlacementMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTextPlacement Function()>>('CTextPlacementMakeDefault');
late final _CTextPlacementMakeDefault = _CTextPlacementMakeDefaultPtr.asFunction<_CTextPlacement Function()>();

late final _CTextStyleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTextStyle Function()>>('CTextStyleMakeDefault');
late final _CTextStyleMakeDefault = _CTextStyleMakeDefaultPtr.asFunction<_CTextStyle Function()>();


late final _COptional_CFollowPositionMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CFollowPosition Function()>>('COptional_CFollowPositionMakeDefault');
late final _COptional_CFollowPositionMakeDefault = _COptional_CFollowPositionMakeDefaultPtr.asFunction<_COptional_CFollowPosition Function()>();

late final _CCameraBehaviourMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraBehaviour Function()>>('CCameraBehaviourMakeDefault');
late final _CCameraBehaviourMakeDefault = _CCameraBehaviourMakeDefaultPtr.asFunction<_CCameraBehaviour Function()>();


late final _CCameraBehaviourChangeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraBehaviourChange Function()>>('CCameraBehaviourChangeMakeDefault');
late final _CCameraBehaviourChangeMakeDefault = _CCameraBehaviourChangeMakeDefaultPtr.asFunction<_CCameraBehaviourChange Function()>();


late final _COptional_CZoomMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CZoom Function()>>('COptional_CZoomMakeDefault');
late final _COptional_CZoomMakeDefault = _COptional_CZoomMakeDefaultPtr.asFunction<_COptional_CZoom Function()>();

late final _CCameraPositionChangeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraPositionChange Function()>>('CCameraPositionChangeMakeDefault');
late final _CCameraPositionChangeMakeDefault = _CCameraPositionChangeMakeDefaultPtr.asFunction<_CCameraPositionChange Function()>();


late final _CCameraZoomRestrictionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraZoomRestrictions Function()>>('CCameraZoomRestrictionsMakeDefault');
late final _CCameraZoomRestrictionsMakeDefault = _CCameraZoomRestrictionsMakeDefaultPtr.asFunction<_CCameraZoomRestrictions Function()>();


late final _CGeometryMapObjectBuilder_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObjectBuilder_cg_objectIdentifier');
late final _CGeometryMapObjectBuilder_cg_objectIdentifier = _CGeometryMapObjectBuilder_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CGeometryMapObjectBuilder_setObjectAttribute_CString_CAttributeValuePtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, _CString, _CAttributeValue)>>('CGeometryMapObjectBuilder_setObjectAttribute_CString_CAttributeValue');
late final _CGeometryMapObjectBuilder_setObjectAttribute_CString_CAttributeValue = _CGeometryMapObjectBuilder_setObjectAttribute_CString_CAttributeValuePtr.asFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, _CString, _CAttributeValue)>();
late final _CGeometryMapObjectBuilder_setObjectAttributes_CDictionary_CString_CAttributeValuePtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, _CDictionary_CString_CAttributeValue)>>('CGeometryMapObjectBuilder_setObjectAttributes_CDictionary_CString_CAttributeValue');
late final _CGeometryMapObjectBuilder_setObjectAttributes_CDictionary_CString_CAttributeValue = _CGeometryMapObjectBuilder_setObjectAttributes_CDictionary_CString_CAttributeValuePtr.asFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, _CDictionary_CString_CAttributeValue)>();
late final _CGeometryMapObjectBuilder_setGeometry_CGeometryPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, _CGeometry)>>('CGeometryMapObjectBuilder_setGeometry_CGeometry');
late final _CGeometryMapObjectBuilder_setGeometry_CGeometry = _CGeometryMapObjectBuilder_setGeometry_CGeometryPtr.asFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, _CGeometry)>();
late final _CGeometryMapObjectBuilder_setVisible_boolPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, ffi.Bool)>>('CGeometryMapObjectBuilder_setVisible_bool');
late final _CGeometryMapObjectBuilder_setVisible_bool = _CGeometryMapObjectBuilder_setVisible_boolPtr.asFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, bool)>();
late final _CGeometryMapObjectBuilder_setDraggable_boolPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, ffi.Bool)>>('CGeometryMapObjectBuilder_setDraggable_bool');
late final _CGeometryMapObjectBuilder_setDraggable_bool = _CGeometryMapObjectBuilder_setDraggable_boolPtr.asFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, bool)>();
late final _CGeometryMapObjectBuilder_setUserData_CAnyPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, _CAny)>>('CGeometryMapObjectBuilder_setUserData_CAny');
late final _CGeometryMapObjectBuilder_setUserData_CAny = _CGeometryMapObjectBuilder_setUserData_CAnyPtr.asFunction<_CGeometryMapObjectBuilder Function(_CGeometryMapObjectBuilder, _CAny)>();
late final _CGeometryMapObjectBuilder_createObjectPtr = _lookup<ffi.NativeFunction<_CGeometryMapObject Function(_CGeometryMapObjectBuilder)>>('CGeometryMapObjectBuilder_createObject');
late final _CGeometryMapObjectBuilder_createObject = _CGeometryMapObjectBuilder_createObjectPtr.asFunction<_CGeometryMapObject Function(_CGeometryMapObjectBuilder)>();
late final _CGeometryMapObjectBuilder_C_createPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectBuilder Function()>>('CGeometryMapObjectBuilder_C_create');
late final _CGeometryMapObjectBuilder_C_create = _CGeometryMapObjectBuilder_C_createPtr.asFunction<_CGeometryMapObjectBuilder Function()>();

late final _CGeometryMapObjectBuilder_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObjectBuilder_release');
late final _CGeometryMapObjectBuilder_release = _CGeometryMapObjectBuilder_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CGeometryMapObjectBuilder_retainPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectBuilder Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObjectBuilder_retain');
late final _CGeometryMapObjectBuilder_retain = _CGeometryMapObjectBuilder_retainPtr.asFunction<_CGeometryMapObjectBuilder Function(ffi.Pointer<ffi.Void>)>();
late final _CGeometryMapObjectBuilderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectBuilder Function()>>('CGeometryMapObjectBuilderMakeDefault');
late final _CGeometryMapObjectBuilderMakeDefault = _CGeometryMapObjectBuilderMakeDefaultPtr.asFunction<_CGeometryMapObjectBuilder Function()>();


late final _CGeometryMapObjectSourceBuilder_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObjectSourceBuilder_cg_objectIdentifier');
late final _CGeometryMapObjectSourceBuilder_cg_objectIdentifier = _CGeometryMapObjectSourceBuilder_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CGeometryMapObjectSourceBuilder_setSourceAttribute_CString_CAttributeValuePtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectSourceBuilder Function(_CGeometryMapObjectSourceBuilder, _CString, _CAttributeValue)>>('CGeometryMapObjectSourceBuilder_setSourceAttribute_CString_CAttributeValue');
late final _CGeometryMapObjectSourceBuilder_setSourceAttribute_CString_CAttributeValue = _CGeometryMapObjectSourceBuilder_setSourceAttribute_CString_CAttributeValuePtr.asFunction<_CGeometryMapObjectSourceBuilder Function(_CGeometryMapObjectSourceBuilder, _CString, _CAttributeValue)>();
late final _CGeometryMapObjectSourceBuilder_setSourceAttributes_CDictionary_CString_CAttributeValuePtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectSourceBuilder Function(_CGeometryMapObjectSourceBuilder, _CDictionary_CString_CAttributeValue)>>('CGeometryMapObjectSourceBuilder_setSourceAttributes_CDictionary_CString_CAttributeValue');
late final _CGeometryMapObjectSourceBuilder_setSourceAttributes_CDictionary_CString_CAttributeValue = _CGeometryMapObjectSourceBuilder_setSourceAttributes_CDictionary_CString_CAttributeValuePtr.asFunction<_CGeometryMapObjectSourceBuilder Function(_CGeometryMapObjectSourceBuilder, _CDictionary_CString_CAttributeValue)>();
late final _CGeometryMapObjectSourceBuilder_addObject_CGeometryMapObjectPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectSourceBuilder Function(_CGeometryMapObjectSourceBuilder, _CGeometryMapObject)>>('CGeometryMapObjectSourceBuilder_addObject_CGeometryMapObject');
late final _CGeometryMapObjectSourceBuilder_addObject_CGeometryMapObject = _CGeometryMapObjectSourceBuilder_addObject_CGeometryMapObjectPtr.asFunction<_CGeometryMapObjectSourceBuilder Function(_CGeometryMapObjectSourceBuilder, _CGeometryMapObject)>();
late final _CGeometryMapObjectSourceBuilder_addObjects_CArray_CGeometryMapObjectPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectSourceBuilder Function(_CGeometryMapObjectSourceBuilder, _CArray_CGeometryMapObject)>>('CGeometryMapObjectSourceBuilder_addObjects_CArray_CGeometryMapObject');
late final _CGeometryMapObjectSourceBuilder_addObjects_CArray_CGeometryMapObject = _CGeometryMapObjectSourceBuilder_addObjects_CArray_CGeometryMapObjectPtr.asFunction<_CGeometryMapObjectSourceBuilder Function(_CGeometryMapObjectSourceBuilder, _CArray_CGeometryMapObject)>();
late final _CGeometryMapObjectSourceBuilder_createSourcePtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectSource Function(_CGeometryMapObjectSourceBuilder)>>('CGeometryMapObjectSourceBuilder_createSource');
late final _CGeometryMapObjectSourceBuilder_createSource = _CGeometryMapObjectSourceBuilder_createSourcePtr.asFunction<_CGeometryMapObjectSource Function(_CGeometryMapObjectSourceBuilder)>();
late final _CGeometryMapObjectSourceBuilder_C_createWith_CContextPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectSourceBuilder Function(_CContext)>>('CGeometryMapObjectSourceBuilder_C_createWith_CContext');
late final _CGeometryMapObjectSourceBuilder_C_createWith_CContext = _CGeometryMapObjectSourceBuilder_C_createWith_CContextPtr.asFunction<_CGeometryMapObjectSourceBuilder Function(_CContext)>();

late final _CGeometryMapObjectSourceBuilder_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObjectSourceBuilder_release');
late final _CGeometryMapObjectSourceBuilder_release = _CGeometryMapObjectSourceBuilder_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CGeometryMapObjectSourceBuilder_retainPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectSourceBuilder Function(ffi.Pointer<ffi.Void>)>>('CGeometryMapObjectSourceBuilder_retain');
late final _CGeometryMapObjectSourceBuilder_retain = _CGeometryMapObjectSourceBuilder_retainPtr.asFunction<_CGeometryMapObjectSourceBuilder Function(ffi.Pointer<ffi.Void>)>();
late final _CGeometryMapObjectSourceBuilderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGeometryMapObjectSourceBuilder Function()>>('CGeometryMapObjectSourceBuilderMakeDefault');
late final _CGeometryMapObjectSourceBuilderMakeDefault = _CGeometryMapObjectSourceBuilderMakeDefaultPtr.asFunction<_CGeometryMapObjectSourceBuilder Function()>();

late final _CIndoorBuilding_idPtr = _lookup<ffi.NativeFunction<_CDgisObjectId Function(_CIndoorBuilding)>>('CIndoorBuilding_id');
late final _CIndoorBuilding_id = _CIndoorBuilding_idPtr.asFunction<_CDgisObjectId Function(_CIndoorBuilding)>();
late final _CIndoorBuilding_defaultLevelIndexPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CIndoorBuilding)>>('CIndoorBuilding_defaultLevelIndex');
late final _CIndoorBuilding_defaultLevelIndex = _CIndoorBuilding_defaultLevelIndexPtr.asFunction<int Function(_CIndoorBuilding)>();
late final _CIndoorBuilding_levelsPtr = _lookup<ffi.NativeFunction<_CArray_CLevelInfo Function(_CIndoorBuilding)>>('CIndoorBuilding_levels');
late final _CIndoorBuilding_levels = _CIndoorBuilding_levelsPtr.asFunction<_CArray_CLevelInfo Function(_CIndoorBuilding)>();
late final _CIndoorBuilding_activeLevelIndexChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_uint64_t Function(_CIndoorBuilding)>>('CIndoorBuilding_activeLevelIndexChannel');
late final _CIndoorBuilding_activeLevelIndexChannel = _CIndoorBuilding_activeLevelIndexChannelPtr.asFunction<_CStatefulChannel_uint64_t Function(_CIndoorBuilding)>();
late final _CIndoorBuilding_activeLevelIndexPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CIndoorBuilding)>>('CIndoorBuilding_activeLevelIndex');
late final _CIndoorBuilding_activeLevelIndex = _CIndoorBuilding_activeLevelIndexPtr.asFunction<int Function(_CIndoorBuilding)>();
late final _CIndoorBuilding_setActiveLevelIndex_uint64_tPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CIndoorBuilding, ffi.Uint64)>>('CIndoorBuilding_setActiveLevelIndex_uint64_t');
late final _CIndoorBuilding_setActiveLevelIndex_uint64_t = _CIndoorBuilding_setActiveLevelIndex_uint64_tPtr.asFunction<void Function(_CIndoorBuilding, int)>();

late final _CIndoorBuilding_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CIndoorBuilding_cg_objectIdentifier');
late final _CIndoorBuilding_cg_objectIdentifier = _CIndoorBuilding_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();


late final _CIndoorBuilding_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CIndoorBuilding_release');
late final _CIndoorBuilding_release = _CIndoorBuilding_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CIndoorBuilding_retainPtr = _lookup<ffi.NativeFunction<_CIndoorBuilding Function(ffi.Pointer<ffi.Void>)>>('CIndoorBuilding_retain');
late final _CIndoorBuilding_retain = _CIndoorBuilding_retainPtr.asFunction<_CIndoorBuilding Function(ffi.Pointer<ffi.Void>)>();
late final _CIndoorBuildingMakeDefaultPtr = _lookup<ffi.NativeFunction<_CIndoorBuilding Function()>>('CIndoorBuildingMakeDefault');
late final _CIndoorBuildingMakeDefault = _CIndoorBuildingMakeDefaultPtr.asFunction<_CIndoorBuilding Function()>();


late final _CStatefulChannel_uint64_tMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_uint64_t Function()>>('CStatefulChannel_uint64_tMakeDefault');
late final _CStatefulChannel_uint64_tMakeDefault = _CStatefulChannel_uint64_tMakeDefaultPtr.asFunction<_CStatefulChannel_uint64_t Function()>();
late final _CStatefulChannel_uint64_t_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_uint64_t)>>('CStatefulChannel_uint64_t_release');
late final _CStatefulChannel_uint64_t_release = _CStatefulChannel_uint64_t_releasePtr.asFunction<void Function(_CStatefulChannel_uint64_t)>();
late final _CStatefulChannel_uint64_t_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_uint64_t Function(_CStatefulChannel_uint64_t)>>('CStatefulChannel_uint64_t_retain');
late final _CStatefulChannel_uint64_t_retain = _CStatefulChannel_uint64_t_retainPtr.asFunction<_CStatefulChannel_uint64_t Function(_CStatefulChannel_uint64_t)>();
late final _CStatefulChannel_uint64_tGetCurrentValuePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CStatefulChannel_uint64_t)>>('CStatefulChannel_uint64_t_getCurrentValue');
late final _CStatefulChannel_uint64_tGetCurrentValue = _CStatefulChannel_uint64_tGetCurrentValuePtr.asFunction<int Function(_CStatefulChannel_uint64_t)>();
late final _CStatefulChannel_uint64_tConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_uint64_t,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint64, ffi.Int64)>>
  )
>>('CStatefulChannel_uint64_t_connect');
late final _CStatefulChannel_uint64_tConnect = _CStatefulChannel_uint64_tConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_uint64_t,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint64, ffi.Int64)>>
  )
>();

late final _CIndoorManagerStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CIndoorManagerState Function()>>('CIndoorManagerStateMakeDefault');
late final _CIndoorManagerStateMakeDefault = _CIndoorManagerStateMakeDefaultPtr.asFunction<_CIndoorManagerState Function()>();
late final _CIndoorManager_focusedBuildingChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CIndoorBuilding Function(_CIndoorManager)>>('CIndoorManager_focusedBuildingChannel');
late final _CIndoorManager_focusedBuildingChannel = _CIndoorManager_focusedBuildingChannelPtr.asFunction<_CStatefulChannel_COptional_CIndoorBuilding Function(_CIndoorManager)>();
late final _CIndoorManager_focusedBuildingPtr = _lookup<ffi.NativeFunction<_COptional_CIndoorBuilding Function(_CIndoorManager)>>('CIndoorManager_focusedBuilding');
late final _CIndoorManager_focusedBuilding = _CIndoorManager_focusedBuildingPtr.asFunction<_COptional_CIndoorBuilding Function(_CIndoorManager)>();

late final _CIndoorManager_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CIndoorManager_cg_objectIdentifier');
late final _CIndoorManager_cg_objectIdentifier = _CIndoorManager_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CIndoorManager_setIndoorState_CIndoorManagerStatePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CIndoorManager, _CIndoorManagerState)>>('CIndoorManager_setIndoorState_CIndoorManagerState');
late final _CIndoorManager_setIndoorState_CIndoorManagerState = _CIndoorManager_setIndoorState_CIndoorManagerStatePtr.asFunction<void Function(_CIndoorManager, _CIndoorManagerState)>();

late final _CIndoorManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CIndoorManager_release');
late final _CIndoorManager_release = _CIndoorManager_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CIndoorManager_retainPtr = _lookup<ffi.NativeFunction<_CIndoorManager Function(ffi.Pointer<ffi.Void>)>>('CIndoorManager_retain');
late final _CIndoorManager_retain = _CIndoorManager_retainPtr.asFunction<_CIndoorManager Function(ffi.Pointer<ffi.Void>)>();
late final _CIndoorManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CIndoorManager Function()>>('CIndoorManagerMakeDefault');
late final _CIndoorManagerMakeDefault = _CIndoorManagerMakeDefaultPtr.asFunction<_CIndoorManager Function()>();


late final _CStatefulChannel_COptional_CIndoorBuildingMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CIndoorBuilding Function()>>('CStatefulChannel_COptional_CIndoorBuildingMakeDefault');
late final _CStatefulChannel_COptional_CIndoorBuildingMakeDefault = _CStatefulChannel_COptional_CIndoorBuildingMakeDefaultPtr.asFunction<_CStatefulChannel_COptional_CIndoorBuilding Function()>();
late final _CStatefulChannel_COptional_CIndoorBuilding_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_COptional_CIndoorBuilding)>>('CStatefulChannel_COptional_CIndoorBuilding_release');
late final _CStatefulChannel_COptional_CIndoorBuilding_release = _CStatefulChannel_COptional_CIndoorBuilding_releasePtr.asFunction<void Function(_CStatefulChannel_COptional_CIndoorBuilding)>();
late final _CStatefulChannel_COptional_CIndoorBuilding_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CIndoorBuilding Function(_CStatefulChannel_COptional_CIndoorBuilding)>>('CStatefulChannel_COptional_CIndoorBuilding_retain');
late final _CStatefulChannel_COptional_CIndoorBuilding_retain = _CStatefulChannel_COptional_CIndoorBuilding_retainPtr.asFunction<_CStatefulChannel_COptional_CIndoorBuilding Function(_CStatefulChannel_COptional_CIndoorBuilding)>();
late final _CStatefulChannel_COptional_CIndoorBuildingGetCurrentValuePtr = _lookup<ffi.NativeFunction<_COptional_CIndoorBuilding Function(_CStatefulChannel_COptional_CIndoorBuilding)>>('CStatefulChannel_COptional_CIndoorBuilding_getCurrentValue');
late final _CStatefulChannel_COptional_CIndoorBuildingGetCurrentValue = _CStatefulChannel_COptional_CIndoorBuildingGetCurrentValuePtr.asFunction<_COptional_CIndoorBuilding Function(_CStatefulChannel_COptional_CIndoorBuilding)>();
late final _CStatefulChannel_COptional_CIndoorBuildingConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CIndoorBuilding,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CIndoorBuilding, ffi.Int64)>>
  )
>>('CStatefulChannel_COptional_CIndoorBuilding_connect');
late final _CStatefulChannel_COptional_CIndoorBuildingConnect = _CStatefulChannel_COptional_CIndoorBuildingConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CIndoorBuilding,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CIndoorBuilding, ffi.Int64)>>
  )
>();

late final _COptional_CIndoorBuildingMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CIndoorBuilding Function()>>('COptional_CIndoorBuildingMakeDefault');
late final _COptional_CIndoorBuildingMakeDefault = _COptional_CIndoorBuildingMakeDefaultPtr.asFunction<_COptional_CIndoorBuilding Function()>();

late final _COptional_CIndoorBuilding_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CIndoorBuilding)>>('COptional_CIndoorBuilding_release');
late final _COptional_CIndoorBuilding_release = _COptional_CIndoorBuilding_releasePtr.asFunction<void Function(_COptional_CIndoorBuilding)>();
late final _CIndoorControlModel_activeLevelIndexChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_uint64_t Function(_CIndoorControlModel)>>('CIndoorControlModel_activeLevelIndexChannel');
late final _CIndoorControlModel_activeLevelIndexChannel = _CIndoorControlModel_activeLevelIndexChannelPtr.asFunction<_CStatefulChannel_COptional_uint64_t Function(_CIndoorControlModel)>();
late final _CIndoorControlModel_activeLevelIndexPtr = _lookup<ffi.NativeFunction<_COptional_uint64_t Function(_CIndoorControlModel)>>('CIndoorControlModel_activeLevelIndex');
late final _CIndoorControlModel_activeLevelIndex = _CIndoorControlModel_activeLevelIndexPtr.asFunction<_COptional_uint64_t Function(_CIndoorControlModel)>();
late final _CIndoorControlModel_setActiveLevelIndex_COptional_uint64_tPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CIndoorControlModel, _COptional_uint64_t)>>('CIndoorControlModel_setActiveLevelIndex_COptional_uint64_t');
late final _CIndoorControlModel_setActiveLevelIndex_COptional_uint64_t = _CIndoorControlModel_setActiveLevelIndex_COptional_uint64_tPtr.asFunction<void Function(_CIndoorControlModel, _COptional_uint64_t)>();
late final _CIndoorControlModel_markedLevelsPtr = _lookup<ffi.NativeFunction<_CSet_CLevelId Function(_CIndoorControlModel)>>('CIndoorControlModel_markedLevels');
late final _CIndoorControlModel_markedLevels = _CIndoorControlModel_markedLevelsPtr.asFunction<_CSet_CLevelId Function(_CIndoorControlModel)>();
late final _CIndoorControlModel_setMarkedLevels_CSet_CLevelIdPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CIndoorControlModel, _CSet_CLevelId)>>('CIndoorControlModel_setMarkedLevels_CSet_CLevelId');
late final _CIndoorControlModel_setMarkedLevels_CSet_CLevelId = _CIndoorControlModel_setMarkedLevels_CSet_CLevelIdPtr.asFunction<void Function(_CIndoorControlModel, _CSet_CLevelId)>();
late final _CIndoorControlModel_levelNamesChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CString Function(_CIndoorControlModel)>>('CIndoorControlModel_levelNamesChannel');
late final _CIndoorControlModel_levelNamesChannel = _CIndoorControlModel_levelNamesChannelPtr.asFunction<_CStatefulChannel_CArray_CString Function(_CIndoorControlModel)>();
late final _CIndoorControlModel_levelNamesPtr = _lookup<ffi.NativeFunction<_CArray_CString Function(_CIndoorControlModel)>>('CIndoorControlModel_levelNames');
late final _CIndoorControlModel_levelNames = _CIndoorControlModel_levelNamesPtr.asFunction<_CArray_CString Function(_CIndoorControlModel)>();

late final _CIndoorControlModel_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CIndoorControlModel_cg_objectIdentifier');
late final _CIndoorControlModel_cg_objectIdentifier = _CIndoorControlModel_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CIndoorControlModel_isLevelMarked_uint64_tPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CIndoorControlModel, ffi.Uint64)>>('CIndoorControlModel_isLevelMarked_uint64_t');
late final _CIndoorControlModel_isLevelMarked_uint64_t = _CIndoorControlModel_isLevelMarked_uint64_tPtr.asFunction<bool Function(_CIndoorControlModel, int)>();
late final _CIndoorControlModel_C_createWith_CMapPtr = _lookup<ffi.NativeFunction<_CIndoorControlModel Function(_CMap)>>('CIndoorControlModel_C_createWith_CMap');
late final _CIndoorControlModel_C_createWith_CMap = _CIndoorControlModel_C_createWith_CMapPtr.asFunction<_CIndoorControlModel Function(_CMap)>();

late final _CIndoorControlModel_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CIndoorControlModel_release');
late final _CIndoorControlModel_release = _CIndoorControlModel_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CIndoorControlModel_retainPtr = _lookup<ffi.NativeFunction<_CIndoorControlModel Function(ffi.Pointer<ffi.Void>)>>('CIndoorControlModel_retain');
late final _CIndoorControlModel_retain = _CIndoorControlModel_retainPtr.asFunction<_CIndoorControlModel Function(ffi.Pointer<ffi.Void>)>();
late final _CIndoorControlModelMakeDefaultPtr = _lookup<ffi.NativeFunction<_CIndoorControlModel Function()>>('CIndoorControlModelMakeDefault');
late final _CIndoorControlModelMakeDefault = _CIndoorControlModelMakeDefaultPtr.asFunction<_CIndoorControlModel Function()>();


late final _CStatefulChannel_COptional_uint64_tMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_uint64_t Function()>>('CStatefulChannel_COptional_uint64_tMakeDefault');
late final _CStatefulChannel_COptional_uint64_tMakeDefault = _CStatefulChannel_COptional_uint64_tMakeDefaultPtr.asFunction<_CStatefulChannel_COptional_uint64_t Function()>();
late final _CStatefulChannel_COptional_uint64_t_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_COptional_uint64_t)>>('CStatefulChannel_COptional_uint64_t_release');
late final _CStatefulChannel_COptional_uint64_t_release = _CStatefulChannel_COptional_uint64_t_releasePtr.asFunction<void Function(_CStatefulChannel_COptional_uint64_t)>();
late final _CStatefulChannel_COptional_uint64_t_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_uint64_t Function(_CStatefulChannel_COptional_uint64_t)>>('CStatefulChannel_COptional_uint64_t_retain');
late final _CStatefulChannel_COptional_uint64_t_retain = _CStatefulChannel_COptional_uint64_t_retainPtr.asFunction<_CStatefulChannel_COptional_uint64_t Function(_CStatefulChannel_COptional_uint64_t)>();
late final _CStatefulChannel_COptional_uint64_tGetCurrentValuePtr = _lookup<ffi.NativeFunction<_COptional_uint64_t Function(_CStatefulChannel_COptional_uint64_t)>>('CStatefulChannel_COptional_uint64_t_getCurrentValue');
late final _CStatefulChannel_COptional_uint64_tGetCurrentValue = _CStatefulChannel_COptional_uint64_tGetCurrentValuePtr.asFunction<_COptional_uint64_t Function(_CStatefulChannel_COptional_uint64_t)>();
late final _CStatefulChannel_COptional_uint64_tConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_uint64_t,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_uint64_t, ffi.Int64)>>
  )
>>('CStatefulChannel_COptional_uint64_t_connect');
late final _CStatefulChannel_COptional_uint64_tConnect = _CStatefulChannel_COptional_uint64_tConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_uint64_t,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_uint64_t, ffi.Int64)>>
  )
>();

late final _CSet_CLevelIdmakeEmptyPtr = _lookup<ffi.NativeFunction<_CSet_CLevelId Function()>>('CSet_CLevelId_makeEmpty');
late final _CSet_CLevelIdmakeEmpty = _CSet_CLevelIdmakeEmptyPtr.asFunction<_CSet_CLevelId Function()>();
late final _CSet_CLevelIdaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSet_CLevelId, _CLevelId)>>('CSet_CLevelId_addElement');
late final _CSet_CLevelIdaddElement = _CSet_CLevelIdaddElementPtr.asFunction<void Function(_CSet_CLevelId, _CLevelId)>();
late final _forEach_CSet_CLevelIdPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CSet_CLevelId, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLevelId)>>)
>>('CSet_CLevelId_forEachWithFunctionPointer');
late final _forEach_CSet_CLevelId = _forEach_CSet_CLevelIdPtr.asFunction<
  void Function(_CSet_CLevelId, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLevelId)
>>)>();
late final _CSet_CLevelId_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSet_CLevelId)>>('CSet_CLevelId_release');
late final _CSet_CLevelId_release = _CSet_CLevelId_releasePtr.asFunction<void Function(_CSet_CLevelId)>();

late final _CStatefulChannel_CArray_CStringMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CString Function()>>('CStatefulChannel_CArray_CStringMakeDefault');
late final _CStatefulChannel_CArray_CStringMakeDefault = _CStatefulChannel_CArray_CStringMakeDefaultPtr.asFunction<_CStatefulChannel_CArray_CString Function()>();
late final _CStatefulChannel_CArray_CString_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CArray_CString)>>('CStatefulChannel_CArray_CString_release');
late final _CStatefulChannel_CArray_CString_release = _CStatefulChannel_CArray_CString_releasePtr.asFunction<void Function(_CStatefulChannel_CArray_CString)>();
late final _CStatefulChannel_CArray_CString_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CString Function(_CStatefulChannel_CArray_CString)>>('CStatefulChannel_CArray_CString_retain');
late final _CStatefulChannel_CArray_CString_retain = _CStatefulChannel_CArray_CString_retainPtr.asFunction<_CStatefulChannel_CArray_CString Function(_CStatefulChannel_CArray_CString)>();
late final _CStatefulChannel_CArray_CStringGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CArray_CString Function(_CStatefulChannel_CArray_CString)>>('CStatefulChannel_CArray_CString_getCurrentValue');
late final _CStatefulChannel_CArray_CStringGetCurrentValue = _CStatefulChannel_CArray_CStringGetCurrentValuePtr.asFunction<_CArray_CString Function(_CStatefulChannel_CArray_CString)>();
late final _CStatefulChannel_CArray_CStringConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CString,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CString, ffi.Int64)>>
  )
>>('CStatefulChannel_CArray_CString_connect');
late final _CStatefulChannel_CArray_CStringConnect = _CStatefulChannel_CArray_CStringConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CString,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CString, ffi.Int64)>>
  )
>();
late final _CMap_idPtr = _lookup<ffi.NativeFunction<_CMapId Function(_CMap)>>('CMap_id');
late final _CMap_id = _CMap_idPtr.asFunction<_CMapId Function(_CMap)>();
late final _CMap_cameraPtr = _lookup<ffi.NativeFunction<_CCamera Function(_CMap)>>('CMap_camera');
late final _CMap_camera = _CMap_cameraPtr.asFunction<_CCamera Function(_CMap)>();
late final _CMap_indoorManagerPtr = _lookup<ffi.NativeFunction<_CIndoorManager Function(_CMap)>>('CMap_indoorManager');
late final _CMap_indoorManager = _CMap_indoorManagerPtr.asFunction<_CIndoorManager Function(_CMap)>();
late final _CMap_dataLoadingStateChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CMapDataLoadingState Function(_CMap)>>('CMap_dataLoadingStateChannel');
late final _CMap_dataLoadingStateChannel = _CMap_dataLoadingStateChannelPtr.asFunction<_CStatefulChannel_CMapDataLoadingState Function(_CMap)>();
late final _CMap_dataLoadingStatePtr = _lookup<ffi.NativeFunction<_CMapDataLoadingState Function(_CMap)>>('CMap_dataLoadingState');
late final _CMap_dataLoadingState = _CMap_dataLoadingStatePtr.asFunction<_CMapDataLoadingState Function(_CMap)>();
late final _CMap_styleChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CStyle Function(_CMap)>>('CMap_styleChannel');
late final _CMap_styleChannel = _CMap_styleChannelPtr.asFunction<_CStatefulChannel_CStyle Function(_CMap)>();
late final _CMap_stylePtr = _lookup<ffi.NativeFunction<_CStyle Function(_CMap)>>('CMap_style');
late final _CMap_style = _CMap_stylePtr.asFunction<_CStyle Function(_CMap)>();
late final _CMap_setStyle_CStylePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMap, _CStyle)>>('CMap_setStyle_CStyle');
late final _CMap_setStyle_CStyle = _CMap_setStyle_CStylePtr.asFunction<void Function(_CMap, _CStyle)>();
late final _CMap_fontIconSizeMultiplierChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_float Function(_CMap)>>('CMap_fontIconSizeMultiplierChannel');
late final _CMap_fontIconSizeMultiplierChannel = _CMap_fontIconSizeMultiplierChannelPtr.asFunction<_CStatefulChannel_float Function(_CMap)>();
late final _CMap_fontIconSizeMultiplierPtr = _lookup<ffi.NativeFunction<ffi.Float Function(_CMap)>>('CMap_fontIconSizeMultiplier');
late final _CMap_fontIconSizeMultiplier = _CMap_fontIconSizeMultiplierPtr.asFunction<double Function(_CMap)>();
late final _CMap_setFontIconSizeMultiplier_floatPtr = _lookup<ffi.NativeFunction<_CResult_CEmpty Function(_CMap, ffi.Float)>>('CMap_setFontIconSizeMultiplier_float');
late final _CMap_setFontIconSizeMultiplier_float = _CMap_setFontIconSizeMultiplier_floatPtr.asFunction<_CResult_CEmpty Function(_CMap, double)>();
late final _CMap_getSourcesPtr = _lookup<ffi.NativeFunction<_CArray_CSource Function(_CMap)>>('CMap_getSources');
late final _CMap_getSources = _CMap_getSourcesPtr.asFunction<_CArray_CSource Function(_CMap)>();
late final _CMap_mapVisibilityStateChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CMapVisibilityState Function(_CMap)>>('CMap_mapVisibilityStateChannel');
late final _CMap_mapVisibilityStateChannel = _CMap_mapVisibilityStateChannelPtr.asFunction<_CStatefulChannel_CMapVisibilityState Function(_CMap)>();
late final _CMap_mapVisibilityStatePtr = _lookup<ffi.NativeFunction<_CMapVisibilityState Function(_CMap)>>('CMap_mapVisibilityState');
late final _CMap_mapVisibilityState = _CMap_mapVisibilityStatePtr.asFunction<_CMapVisibilityState Function(_CMap)>();
late final _CMap_setMapVisibilityState_CMapVisibilityStatePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMap, _CMapVisibilityState)>>('CMap_setMapVisibilityState_CMapVisibilityState');
late final _CMap_setMapVisibilityState_CMapVisibilityState = _CMap_setMapVisibilityState_CMapVisibilityStatePtr.asFunction<void Function(_CMap, _CMapVisibilityState)>();
late final _CMap_needRedrawPtr = _lookup<ffi.NativeFunction<_CChannel_bool Function(_CMap)>>('CMap_needRedraw');
late final _CMap_needRedraw = _CMap_needRedrawPtr.asFunction<_CChannel_bool Function(_CMap)>();
late final _CMap_attributesPtr = _lookup<ffi.NativeFunction<_CAttributes Function(_CMap)>>('CMap_attributes');
late final _CMap_attributes = _CMap_attributesPtr.asFunction<_CAttributes Function(_CMap)>();
late final _CMap_interactiveChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function(_CMap)>>('CMap_interactiveChannel');
late final _CMap_interactiveChannel = _CMap_interactiveChannelPtr.asFunction<_CStatefulChannel_bool Function(_CMap)>();
late final _CMap_interactivePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CMap)>>('CMap_interactive');
late final _CMap_interactive = _CMap_interactivePtr.asFunction<bool Function(_CMap)>();
late final _CMap_setInteractive_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMap, ffi.Bool)>>('CMap_setInteractive_bool');
late final _CMap_setInteractive_bool = _CMap_setInteractive_boolPtr.asFunction<void Function(_CMap, bool)>();
late final _CMap_hideCopyrightChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function(_CMap)>>('CMap_hideCopyrightChannel');
late final _CMap_hideCopyrightChannel = _CMap_hideCopyrightChannelPtr.asFunction<_CStatefulChannel_bool Function(_CMap)>();
late final _CMap_hideCopyrightPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CMap)>>('CMap_hideCopyright');
late final _CMap_hideCopyright = _CMap_hideCopyrightPtr.asFunction<bool Function(_CMap)>();
late final _CMap_productTypeChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CProductType Function(_CMap)>>('CMap_productTypeChannel');
late final _CMap_productTypeChannel = _CMap_productTypeChannelPtr.asFunction<_CStatefulChannel_CProductType Function(_CMap)>();
late final _CMap_productTypePtr = _lookup<ffi.NativeFunction<_CProductType Function(_CMap)>>('CMap_productType');
late final _CMap_productType = _CMap_productTypePtr.asFunction<_CProductType Function(_CMap)>();
late final _CMap_graphicsPresetHintChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CGraphicsPreset Function(_CMap)>>('CMap_graphicsPresetHintChannel');
late final _CMap_graphicsPresetHintChannel = _CMap_graphicsPresetHintChannelPtr.asFunction<_CStatefulChannel_COptional_CGraphicsPreset Function(_CMap)>();
late final _CMap_graphicsPresetHintPtr = _lookup<ffi.NativeFunction<_COptional_CGraphicsPreset Function(_CMap)>>('CMap_graphicsPresetHint');
late final _CMap_graphicsPresetHint = _CMap_graphicsPresetHintPtr.asFunction<_COptional_CGraphicsPreset Function(_CMap)>();
late final _CMap_graphicsPresetChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CGraphicsPreset Function(_CMap)>>('CMap_graphicsPresetChannel');
late final _CMap_graphicsPresetChannel = _CMap_graphicsPresetChannelPtr.asFunction<_CStatefulChannel_COptional_CGraphicsPreset Function(_CMap)>();
late final _CMap_graphicsPresetPtr = _lookup<ffi.NativeFunction<_COptional_CGraphicsPreset Function(_CMap)>>('CMap_graphicsPreset');
late final _CMap_graphicsPreset = _CMap_graphicsPresetPtr.asFunction<_COptional_CGraphicsPreset Function(_CMap)>();
late final _CMap_setGraphicsPreset_COptional_CGraphicsPresetPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMap, _COptional_CGraphicsPreset)>>('CMap_setGraphicsPreset_COptional_CGraphicsPreset');
late final _CMap_setGraphicsPreset_COptional_CGraphicsPreset = _CMap_setGraphicsPreset_COptional_CGraphicsPresetPtr.asFunction<void Function(_CMap, _COptional_CGraphicsPreset)>();

late final _CMap_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMap_cg_objectIdentifier');
late final _CMap_cg_objectIdentifier = _CMap_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMap_resetFontIconSizeMultiplierPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMap)>>('CMap_resetFontIconSizeMultiplier');
late final _CMap_resetFontIconSizeMultiplier = _CMap_resetFontIconSizeMultiplierPtr.asFunction<void Function(_CMap)>();
late final _CMap_addSource_CSourcePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMap, _CSource)>>('CMap_addSource_CSource');
late final _CMap_addSource_CSource = _CMap_addSource_CSourcePtr.asFunction<void Function(_CMap, _CSource)>();
late final _CMap_removeSource_CSourcePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMap, _CSource)>>('CMap_removeSource_CSource');
late final _CMap_removeSource_CSource = _CMap_removeSource_CSourcePtr.asFunction<void Function(_CMap, _CSource)>();
late final _CMap_getRenderedObjects_CScreenPoint_CScreenDistancePtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CRenderedObjectInfo Function(_CMap, _CScreenPoint, _CScreenDistance)>>('CMap_getRenderedObjects_CScreenPoint_CScreenDistance');
late final _CMap_getRenderedObjects_CScreenPoint_CScreenDistance = _CMap_getRenderedObjects_CScreenPoint_CScreenDistancePtr.asFunction<_CFuture_CArray_CRenderedObjectInfo Function(_CMap, _CScreenPoint, _CScreenDistance)>();
late final _CMap_sublayerAttributes_CStringPtr = _lookup<ffi.NativeFunction<_CAttributes Function(_CMap, _CString)>>('CMap_sublayerAttributes_CString');
late final _CMap_sublayerAttributes_CString = _CMap_sublayerAttributes_CStringPtr.asFunction<_CAttributes Function(_CMap, _CString)>();
late final _CMap_setSystemFontIconSizeMultiplier_floatPtr = _lookup<ffi.NativeFunction<_CResult_CEmpty Function(_CMap, ffi.Float)>>('CMap_setSystemFontIconSizeMultiplier_float');
late final _CMap_setSystemFontIconSizeMultiplier_float = _CMap_setSystemFontIconSizeMultiplier_floatPtr.asFunction<_CResult_CEmpty Function(_CMap, double)>();
late final _CMap_processEvent_CEventPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMap, _CEvent)>>('CMap_processEvent_CEvent');
late final _CMap_processEvent_CEvent = _CMap_processEvent_CEventPtr.asFunction<void Function(_CMap, _CEvent)>();
late final _CMap_takeSnapshot_CAlignmentPtr = _lookup<ffi.NativeFunction<_CResult_CImageData Function(_CMap, _CAlignment)>>('CMap_takeSnapshot_CAlignment');
late final _CMap_takeSnapshot_CAlignment = _CMap_takeSnapshot_CAlignmentPtr.asFunction<_CResult_CImageData Function(_CMap, _CAlignment)>();
late final _CMap_getMapObject_CScreenPoint_CScreenDistancePtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CRenderedObjectInfo Function(_CMap, _CScreenPoint, _CScreenDistance)>>('CMap_getMapObject_CScreenPoint_CScreenDistance');
late final _CMap_getMapObject_CScreenPoint_CScreenDistance = _CMap_getMapObject_CScreenPoint_CScreenDistancePtr.asFunction<_CFuture_COptional_CRenderedObjectInfo Function(_CMap, _CScreenPoint, _CScreenDistance)>();

late final _CMap_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMap_release');
late final _CMap_release = _CMap_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMap_retainPtr = _lookup<ffi.NativeFunction<_CMap Function(ffi.Pointer<ffi.Void>)>>('CMap_retain');
late final _CMap_retain = _CMap_retainPtr.asFunction<_CMap Function(ffi.Pointer<ffi.Void>)>();
late final _CMapMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMap Function()>>('CMapMakeDefault');
late final _CMapMakeDefault = _CMapMakeDefaultPtr.asFunction<_CMap Function()>();

late final _CCamera_stateChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraState Function(_CCamera)>>('CCamera_stateChannel');
late final _CCamera_stateChannel = _CCamera_stateChannelPtr.asFunction<_CStatefulChannel_CCameraState Function(_CCamera)>();
late final _CCamera_statePtr = _lookup<ffi.NativeFunction<_CCameraState Function(_CCamera)>>('CCamera_state');
late final _CCamera_state = _CCamera_statePtr.asFunction<_CCameraState Function(_CCamera)>();
late final _CCamera_behaviourChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraBehaviourChange Function(_CCamera)>>('CCamera_behaviourChannel');
late final _CCamera_behaviourChannel = _CCamera_behaviourChannelPtr.asFunction<_CStatefulChannel_CCameraBehaviourChange Function(_CCamera)>();
late final _CCamera_behaviourPtr = _lookup<ffi.NativeFunction<_CCameraBehaviourChange Function(_CCamera)>>('CCamera_behaviour');
late final _CCamera_behaviour = _CCamera_behaviourPtr.asFunction<_CCameraBehaviourChange Function(_CCamera)>();

late final _CCamera_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCamera_cg_objectIdentifier');
late final _CCamera_cg_objectIdentifier = _CCamera_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CCamera_moveToCameraPosition_CCameraPosition_CTimeInterval_CCameraAnimationTypePtr = _lookup<ffi.NativeFunction<_CFuture_CCameraAnimatedMoveResult Function(_CCamera, _CCameraPosition, _CTimeInterval, _CCameraAnimationType)>>('CCamera_moveToCameraPosition_CCameraPosition_CTimeInterval_CCameraAnimationType');
late final _CCamera_moveToCameraPosition_CCameraPosition_CTimeInterval_CCameraAnimationType = _CCamera_moveToCameraPosition_CCameraPosition_CTimeInterval_CCameraAnimationTypePtr.asFunction<_CFuture_CCameraAnimatedMoveResult Function(_CCamera, _CCameraPosition, _CTimeInterval, _CCameraAnimationType)>();
late final _CCamera_move_CGeoPoint_CZoom_COptional_CTilt_CBearing_CTimeInterval_CCameraAnimationTypePtr = _lookup<ffi.NativeFunction<_CFuture_CCameraAnimatedMoveResult Function(_CCamera, _CGeoPoint, _CZoom, _COptional_CTilt, _CBearing, _CTimeInterval, _CCameraAnimationType)>>('CCamera_move_CGeoPoint_CZoom_COptional_CTilt_CBearing_CTimeInterval_CCameraAnimationType');
late final _CCamera_move_CGeoPoint_CZoom_COptional_CTilt_CBearing_CTimeInterval_CCameraAnimationType = _CCamera_move_CGeoPoint_CZoom_COptional_CTilt_CBearing_CTimeInterval_CCameraAnimationTypePtr.asFunction<_CFuture_CCameraAnimatedMoveResult Function(_CCamera, _CGeoPoint, _CZoom, _COptional_CTilt, _CBearing, _CTimeInterval, _CCameraAnimationType)>();
late final _CCamera_processMovementAndStopPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCamera)>>('CCamera_processMovementAndStop');
late final _CCamera_processMovementAndStop = _CCamera_processMovementAndStopPtr.asFunction<void Function(_CCamera)>();
late final _CCamera_setBehaviour_CCameraBehaviourPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCamera, _CCameraBehaviour)>>('CCamera_setBehaviour_CCameraBehaviour');
late final _CCamera_setBehaviour_CCameraBehaviour = _CCamera_setBehaviour_CCameraBehaviourPtr.asFunction<void Function(_CCamera, _CCameraBehaviour)>();
late final _CCamera_addFollowController_CFollowControllerPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCamera, _CFollowController)>>('CCamera_addFollowController_CFollowController');
late final _CCamera_addFollowController_CFollowController = _CCamera_addFollowController_CFollowControllerPtr.asFunction<void Function(_CCamera, _CFollowController)>();
late final _CCamera_removeFollowController_CFollowControllerPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCamera, _CFollowController)>>('CCamera_removeFollowController_CFollowController');
late final _CCamera_removeFollowController_CFollowController = _CCamera_removeFollowController_CFollowControllerPtr.asFunction<void Function(_CCamera, _CFollowController)>();
late final _CCamera_removeCustomFollowControllerPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCamera)>>('CCamera_removeCustomFollowController');
late final _CCamera_removeCustomFollowController = _CCamera_removeCustomFollowControllerPtr.asFunction<void Function(_CCamera)>();
late final _CCamera_moveWithController_CCameraMoveControllerPtr = _lookup<ffi.NativeFunction<_CFuture_CCameraAnimatedMoveResult Function(_CCamera, _CCameraMoveController)>>('CCamera_moveWithController_CCameraMoveController');
late final _CCamera_moveWithController_CCameraMoveController = _CCamera_moveWithController_CCameraMoveControllerPtr.asFunction<_CFuture_CCameraAnimatedMoveResult Function(_CCamera, _CCameraMoveController)>();
late final _CCamera_setCustomFollowController_CCustomFollowControllerPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCamera, _CCustomFollowController)>>('CCamera_setCustomFollowController_CCustomFollowController');
late final _CCamera_setCustomFollowController_CCustomFollowController = _CCamera_setCustomFollowController_CCustomFollowControllerPtr.asFunction<void Function(_CCamera, _CCustomFollowController)>();

late final _CCamera_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCamera_release');
late final _CCamera_release = _CCamera_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCamera_retainPtr = _lookup<ffi.NativeFunction<_CCamera Function(ffi.Pointer<ffi.Void>)>>('CCamera_retain');
late final _CCamera_retain = _CCamera_retainPtr.asFunction<_CCamera Function(ffi.Pointer<ffi.Void>)>();
late final _CCameraMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCamera Function()>>('CCameraMakeDefault');
late final _CCameraMakeDefault = _CCameraMakeDefaultPtr.asFunction<_CCamera Function()>();


late final _CFuture_CCameraAnimatedMoveResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CCameraAnimatedMoveResult Function()>>('CFuture_CCameraAnimatedMoveResultMakeDefault');
late final _CFuture_CCameraAnimatedMoveResultMakeDefault = _CFuture_CCameraAnimatedMoveResultMakeDefaultPtr.asFunction<_CFuture_CCameraAnimatedMoveResult Function()>();
late final _CFuture_CCameraAnimatedMoveResult_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CCameraAnimatedMoveResult)>>('CFuture_CCameraAnimatedMoveResult_release');
late final _CFuture_CCameraAnimatedMoveResult_release = _CFuture_CCameraAnimatedMoveResult_releasePtr.asFunction<void Function(_CFuture_CCameraAnimatedMoveResult)>();
late final _CFuture_CCameraAnimatedMoveResult_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CCameraAnimatedMoveResult Function(_CFuture_CCameraAnimatedMoveResult)>>('CFuture_CCameraAnimatedMoveResult_retain');
late final _CFuture_CCameraAnimatedMoveResult_retain = _CFuture_CCameraAnimatedMoveResult_retainPtr.asFunction<_CFuture_CCameraAnimatedMoveResult Function(_CFuture_CCameraAnimatedMoveResult)>();
late final _CFuture_CCameraAnimatedMoveResultReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CCameraAnimatedMoveResult,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraAnimatedMoveResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CCameraAnimatedMoveResult_receive');
late final _CFuture_CCameraAnimatedMoveResultReceive = _CFuture_CCameraAnimatedMoveResultReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CCameraAnimatedMoveResult,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraAnimatedMoveResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CCameraStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraState Function()>>('CStatefulChannel_CCameraStateMakeDefault');
late final _CStatefulChannel_CCameraStateMakeDefault = _CStatefulChannel_CCameraStateMakeDefaultPtr.asFunction<_CStatefulChannel_CCameraState Function()>();
late final _CStatefulChannel_CCameraState_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CCameraState)>>('CStatefulChannel_CCameraState_release');
late final _CStatefulChannel_CCameraState_release = _CStatefulChannel_CCameraState_releasePtr.asFunction<void Function(_CStatefulChannel_CCameraState)>();
late final _CStatefulChannel_CCameraState_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraState Function(_CStatefulChannel_CCameraState)>>('CStatefulChannel_CCameraState_retain');
late final _CStatefulChannel_CCameraState_retain = _CStatefulChannel_CCameraState_retainPtr.asFunction<_CStatefulChannel_CCameraState Function(_CStatefulChannel_CCameraState)>();
late final _CStatefulChannel_CCameraStateGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CCameraState Function(_CStatefulChannel_CCameraState)>>('CStatefulChannel_CCameraState_getCurrentValue');
late final _CStatefulChannel_CCameraStateGetCurrentValue = _CStatefulChannel_CCameraStateGetCurrentValuePtr.asFunction<_CCameraState Function(_CStatefulChannel_CCameraState)>();
late final _CStatefulChannel_CCameraStateConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraState,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraState, ffi.Int64)>>
  )
>>('CStatefulChannel_CCameraState_connect');
late final _CStatefulChannel_CCameraStateConnect = _CStatefulChannel_CCameraStateConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraState,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraState, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CCameraBehaviourChangeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraBehaviourChange Function()>>('CStatefulChannel_CCameraBehaviourChangeMakeDefault');
late final _CStatefulChannel_CCameraBehaviourChangeMakeDefault = _CStatefulChannel_CCameraBehaviourChangeMakeDefaultPtr.asFunction<_CStatefulChannel_CCameraBehaviourChange Function()>();
late final _CStatefulChannel_CCameraBehaviourChange_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CCameraBehaviourChange)>>('CStatefulChannel_CCameraBehaviourChange_release');
late final _CStatefulChannel_CCameraBehaviourChange_release = _CStatefulChannel_CCameraBehaviourChange_releasePtr.asFunction<void Function(_CStatefulChannel_CCameraBehaviourChange)>();
late final _CStatefulChannel_CCameraBehaviourChange_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraBehaviourChange Function(_CStatefulChannel_CCameraBehaviourChange)>>('CStatefulChannel_CCameraBehaviourChange_retain');
late final _CStatefulChannel_CCameraBehaviourChange_retain = _CStatefulChannel_CCameraBehaviourChange_retainPtr.asFunction<_CStatefulChannel_CCameraBehaviourChange Function(_CStatefulChannel_CCameraBehaviourChange)>();
late final _CStatefulChannel_CCameraBehaviourChangeGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CCameraBehaviourChange Function(_CStatefulChannel_CCameraBehaviourChange)>>('CStatefulChannel_CCameraBehaviourChange_getCurrentValue');
late final _CStatefulChannel_CCameraBehaviourChangeGetCurrentValue = _CStatefulChannel_CCameraBehaviourChangeGetCurrentValuePtr.asFunction<_CCameraBehaviourChange Function(_CStatefulChannel_CCameraBehaviourChange)>();
late final _CStatefulChannel_CCameraBehaviourChangeConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraBehaviourChange,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraBehaviourChange, ffi.Int64)>>
  )
>>('CStatefulChannel_CCameraBehaviourChange_connect');
late final _CStatefulChannel_CCameraBehaviourChangeConnect = _CStatefulChannel_CCameraBehaviourChangeConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraBehaviourChange,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraBehaviourChange, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CMapDataLoadingStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CMapDataLoadingState Function()>>('CStatefulChannel_CMapDataLoadingStateMakeDefault');
late final _CStatefulChannel_CMapDataLoadingStateMakeDefault = _CStatefulChannel_CMapDataLoadingStateMakeDefaultPtr.asFunction<_CStatefulChannel_CMapDataLoadingState Function()>();
late final _CStatefulChannel_CMapDataLoadingState_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CMapDataLoadingState)>>('CStatefulChannel_CMapDataLoadingState_release');
late final _CStatefulChannel_CMapDataLoadingState_release = _CStatefulChannel_CMapDataLoadingState_releasePtr.asFunction<void Function(_CStatefulChannel_CMapDataLoadingState)>();
late final _CStatefulChannel_CMapDataLoadingState_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CMapDataLoadingState Function(_CStatefulChannel_CMapDataLoadingState)>>('CStatefulChannel_CMapDataLoadingState_retain');
late final _CStatefulChannel_CMapDataLoadingState_retain = _CStatefulChannel_CMapDataLoadingState_retainPtr.asFunction<_CStatefulChannel_CMapDataLoadingState Function(_CStatefulChannel_CMapDataLoadingState)>();
late final _CStatefulChannel_CMapDataLoadingStateGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CMapDataLoadingState Function(_CStatefulChannel_CMapDataLoadingState)>>('CStatefulChannel_CMapDataLoadingState_getCurrentValue');
late final _CStatefulChannel_CMapDataLoadingStateGetCurrentValue = _CStatefulChannel_CMapDataLoadingStateGetCurrentValuePtr.asFunction<_CMapDataLoadingState Function(_CStatefulChannel_CMapDataLoadingState)>();
late final _CStatefulChannel_CMapDataLoadingStateConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CMapDataLoadingState,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMapDataLoadingState, ffi.Int64)>>
  )
>>('CStatefulChannel_CMapDataLoadingState_connect');
late final _CStatefulChannel_CMapDataLoadingStateConnect = _CStatefulChannel_CMapDataLoadingStateConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CMapDataLoadingState,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMapDataLoadingState, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CStyleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CStyle Function()>>('CStatefulChannel_CStyleMakeDefault');
late final _CStatefulChannel_CStyleMakeDefault = _CStatefulChannel_CStyleMakeDefaultPtr.asFunction<_CStatefulChannel_CStyle Function()>();
late final _CStatefulChannel_CStyle_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CStyle)>>('CStatefulChannel_CStyle_release');
late final _CStatefulChannel_CStyle_release = _CStatefulChannel_CStyle_releasePtr.asFunction<void Function(_CStatefulChannel_CStyle)>();
late final _CStatefulChannel_CStyle_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CStyle Function(_CStatefulChannel_CStyle)>>('CStatefulChannel_CStyle_retain');
late final _CStatefulChannel_CStyle_retain = _CStatefulChannel_CStyle_retainPtr.asFunction<_CStatefulChannel_CStyle Function(_CStatefulChannel_CStyle)>();
late final _CStatefulChannel_CStyleGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CStyle Function(_CStatefulChannel_CStyle)>>('CStatefulChannel_CStyle_getCurrentValue');
late final _CStatefulChannel_CStyleGetCurrentValue = _CStatefulChannel_CStyleGetCurrentValuePtr.asFunction<_CStyle Function(_CStatefulChannel_CStyle)>();
late final _CStatefulChannel_CStyleConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CStyle,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CStyle, ffi.Int64)>>
  )
>>('CStatefulChannel_CStyle_connect');
late final _CStatefulChannel_CStyleConnect = _CStatefulChannel_CStyleConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CStyle,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CStyle, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_floatMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_float Function()>>('CStatefulChannel_floatMakeDefault');
late final _CStatefulChannel_floatMakeDefault = _CStatefulChannel_floatMakeDefaultPtr.asFunction<_CStatefulChannel_float Function()>();
late final _CStatefulChannel_float_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_float)>>('CStatefulChannel_float_release');
late final _CStatefulChannel_float_release = _CStatefulChannel_float_releasePtr.asFunction<void Function(_CStatefulChannel_float)>();
late final _CStatefulChannel_float_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_float Function(_CStatefulChannel_float)>>('CStatefulChannel_float_retain');
late final _CStatefulChannel_float_retain = _CStatefulChannel_float_retainPtr.asFunction<_CStatefulChannel_float Function(_CStatefulChannel_float)>();
late final _CStatefulChannel_floatGetCurrentValuePtr = _lookup<ffi.NativeFunction<ffi.Float Function(_CStatefulChannel_float)>>('CStatefulChannel_float_getCurrentValue');
late final _CStatefulChannel_floatGetCurrentValue = _CStatefulChannel_floatGetCurrentValuePtr.asFunction<double Function(_CStatefulChannel_float)>();
late final _CStatefulChannel_floatConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_float,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Float, ffi.Int64)>>
  )
>>('CStatefulChannel_float_connect');
late final _CStatefulChannel_floatConnect = _CStatefulChannel_floatConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_float,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Float, ffi.Int64)>>
  )
>();

late final _CResult_CEmpty_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CEmpty)>>('CResult_CEmpty_release');
late final _CResult_CEmpty_release = _CResult_CEmpty_releasePtr.asFunction<void Function(_CResult_CEmpty)>();

late final _CArray_CSourcemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CSource Function()>>('CArray_CSource_makeEmpty');
late final _CArray_CSourcemakeEmpty = _CArray_CSourcemakeEmptyPtr.asFunction<_CArray_CSource Function()>();
late final _CArray_CSourceaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSource, _CSource)>>('CArray_CSource_addElement');
late final _CArray_CSourceaddElement = _CArray_CSourceaddElementPtr.asFunction<void Function(_CArray_CSource, _CSource)>();
late final _forEach_CArray_CSourcePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CSource, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSource)>>)
>>('CArray_CSource_forEachWithFunctionPointer');
late final _forEach_CArray_CSource = _forEach_CArray_CSourcePtr.asFunction<
  void Function(_CArray_CSource, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSource)
>>)>();
late final _CArray_CSource_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSource)>>('CArray_CSource_release');
late final _CArray_CSource_release = _CArray_CSource_releasePtr.asFunction<void Function(_CArray_CSource)>();

late final _CFuture_CArray_CRenderedObjectInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CRenderedObjectInfo Function()>>('CFuture_CArray_CRenderedObjectInfoMakeDefault');
late final _CFuture_CArray_CRenderedObjectInfoMakeDefault = _CFuture_CArray_CRenderedObjectInfoMakeDefaultPtr.asFunction<_CFuture_CArray_CRenderedObjectInfo Function()>();
late final _CFuture_CArray_CRenderedObjectInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CArray_CRenderedObjectInfo)>>('CFuture_CArray_CRenderedObjectInfo_release');
late final _CFuture_CArray_CRenderedObjectInfo_release = _CFuture_CArray_CRenderedObjectInfo_releasePtr.asFunction<void Function(_CFuture_CArray_CRenderedObjectInfo)>();
late final _CFuture_CArray_CRenderedObjectInfo_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CArray_CRenderedObjectInfo Function(_CFuture_CArray_CRenderedObjectInfo)>>('CFuture_CArray_CRenderedObjectInfo_retain');
late final _CFuture_CArray_CRenderedObjectInfo_retain = _CFuture_CArray_CRenderedObjectInfo_retainPtr.asFunction<_CFuture_CArray_CRenderedObjectInfo Function(_CFuture_CArray_CRenderedObjectInfo)>();
late final _CFuture_CArray_CRenderedObjectInfoReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CArray_CRenderedObjectInfo,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CRenderedObjectInfo, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CArray_CRenderedObjectInfo_receive');
late final _CFuture_CArray_CRenderedObjectInfoReceive = _CFuture_CArray_CRenderedObjectInfoReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CArray_CRenderedObjectInfo,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CRenderedObjectInfo, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CArray_CRenderedObjectInfomakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CRenderedObjectInfo Function()>>('CArray_CRenderedObjectInfo_makeEmpty');
late final _CArray_CRenderedObjectInfomakeEmpty = _CArray_CRenderedObjectInfomakeEmptyPtr.asFunction<_CArray_CRenderedObjectInfo Function()>();
late final _CArray_CRenderedObjectInfoaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRenderedObjectInfo, _CRenderedObjectInfo)>>('CArray_CRenderedObjectInfo_addElement');
late final _CArray_CRenderedObjectInfoaddElement = _CArray_CRenderedObjectInfoaddElementPtr.asFunction<void Function(_CArray_CRenderedObjectInfo, _CRenderedObjectInfo)>();
late final _forEach_CArray_CRenderedObjectInfoPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CRenderedObjectInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRenderedObjectInfo)>>)
>>('CArray_CRenderedObjectInfo_forEachWithFunctionPointer');
late final _forEach_CArray_CRenderedObjectInfo = _forEach_CArray_CRenderedObjectInfoPtr.asFunction<
  void Function(_CArray_CRenderedObjectInfo, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CRenderedObjectInfo)
>>)>();
late final _CArray_CRenderedObjectInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CRenderedObjectInfo)>>('CArray_CRenderedObjectInfo_release');
late final _CArray_CRenderedObjectInfo_release = _CArray_CRenderedObjectInfo_releasePtr.asFunction<void Function(_CArray_CRenderedObjectInfo)>();

late final _CRenderedObjectInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRenderedObjectInfo Function()>>('CRenderedObjectInfoMakeDefault');
late final _CRenderedObjectInfoMakeDefault = _CRenderedObjectInfoMakeDefaultPtr.asFunction<_CRenderedObjectInfo Function()>();


late final _CStatefulChannel_CMapVisibilityStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CMapVisibilityState Function()>>('CStatefulChannel_CMapVisibilityStateMakeDefault');
late final _CStatefulChannel_CMapVisibilityStateMakeDefault = _CStatefulChannel_CMapVisibilityStateMakeDefaultPtr.asFunction<_CStatefulChannel_CMapVisibilityState Function()>();
late final _CStatefulChannel_CMapVisibilityState_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CMapVisibilityState)>>('CStatefulChannel_CMapVisibilityState_release');
late final _CStatefulChannel_CMapVisibilityState_release = _CStatefulChannel_CMapVisibilityState_releasePtr.asFunction<void Function(_CStatefulChannel_CMapVisibilityState)>();
late final _CStatefulChannel_CMapVisibilityState_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CMapVisibilityState Function(_CStatefulChannel_CMapVisibilityState)>>('CStatefulChannel_CMapVisibilityState_retain');
late final _CStatefulChannel_CMapVisibilityState_retain = _CStatefulChannel_CMapVisibilityState_retainPtr.asFunction<_CStatefulChannel_CMapVisibilityState Function(_CStatefulChannel_CMapVisibilityState)>();
late final _CStatefulChannel_CMapVisibilityStateGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CMapVisibilityState Function(_CStatefulChannel_CMapVisibilityState)>>('CStatefulChannel_CMapVisibilityState_getCurrentValue');
late final _CStatefulChannel_CMapVisibilityStateGetCurrentValue = _CStatefulChannel_CMapVisibilityStateGetCurrentValuePtr.asFunction<_CMapVisibilityState Function(_CStatefulChannel_CMapVisibilityState)>();
late final _CStatefulChannel_CMapVisibilityStateConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CMapVisibilityState,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMapVisibilityState, ffi.Int64)>>
  )
>>('CStatefulChannel_CMapVisibilityState_connect');
late final _CStatefulChannel_CMapVisibilityStateConnect = _CStatefulChannel_CMapVisibilityStateConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CMapVisibilityState,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMapVisibilityState, ffi.Int64)>>
  )
>();

late final _CChannel_boolMakeDefaultPtr = _lookup<ffi.NativeFunction<_CChannel_bool Function()>>('CChannel_boolMakeDefault');
late final _CChannel_boolMakeDefault = _CChannel_boolMakeDefaultPtr.asFunction<_CChannel_bool Function()>();
late final _CChannel_bool_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CChannel_bool)>>('CChannel_bool_release');
late final _CChannel_bool_release = _CChannel_bool_releasePtr.asFunction<void Function(_CChannel_bool)>();
late final _CChannel_bool_retainPtr = _lookup<ffi.NativeFunction<_CChannel_bool Function(_CChannel_bool)>>('CChannel_bool_retain');
late final _CChannel_bool_retain = _CChannel_bool_retainPtr.asFunction<_CChannel_bool Function(_CChannel_bool)>();
late final _CChannel_boolConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CChannel_bool,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool, ffi.Int64)>>
  )
>>('CChannel_bool_connect');
late final _CChannel_boolConnect = _CChannel_boolConnectPtr.asFunction<
  _CCancellable Function(
    _CChannel_bool,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CProductTypeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CProductType Function()>>('CStatefulChannel_CProductTypeMakeDefault');
late final _CStatefulChannel_CProductTypeMakeDefault = _CStatefulChannel_CProductTypeMakeDefaultPtr.asFunction<_CStatefulChannel_CProductType Function()>();
late final _CStatefulChannel_CProductType_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CProductType)>>('CStatefulChannel_CProductType_release');
late final _CStatefulChannel_CProductType_release = _CStatefulChannel_CProductType_releasePtr.asFunction<void Function(_CStatefulChannel_CProductType)>();
late final _CStatefulChannel_CProductType_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CProductType Function(_CStatefulChannel_CProductType)>>('CStatefulChannel_CProductType_retain');
late final _CStatefulChannel_CProductType_retain = _CStatefulChannel_CProductType_retainPtr.asFunction<_CStatefulChannel_CProductType Function(_CStatefulChannel_CProductType)>();
late final _CStatefulChannel_CProductTypeGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CProductType Function(_CStatefulChannel_CProductType)>>('CStatefulChannel_CProductType_getCurrentValue');
late final _CStatefulChannel_CProductTypeGetCurrentValue = _CStatefulChannel_CProductTypeGetCurrentValuePtr.asFunction<_CProductType Function(_CStatefulChannel_CProductType)>();
late final _CStatefulChannel_CProductTypeConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CProductType,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CProductType, ffi.Int64)>>
  )
>>('CStatefulChannel_CProductType_connect');
late final _CStatefulChannel_CProductTypeConnect = _CStatefulChannel_CProductTypeConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CProductType,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CProductType, ffi.Int64)>>
  )
>();

late final _CResult_CImageData_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CImageData)>>('CResult_CImageData_release');
late final _CResult_CImageData_release = _CResult_CImageData_releasePtr.asFunction<void Function(_CResult_CImageData)>();

late final _CStatefulChannel_COptional_CGraphicsPresetMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CGraphicsPreset Function()>>('CStatefulChannel_COptional_CGraphicsPresetMakeDefault');
late final _CStatefulChannel_COptional_CGraphicsPresetMakeDefault = _CStatefulChannel_COptional_CGraphicsPresetMakeDefaultPtr.asFunction<_CStatefulChannel_COptional_CGraphicsPreset Function()>();
late final _CStatefulChannel_COptional_CGraphicsPreset_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_COptional_CGraphicsPreset)>>('CStatefulChannel_COptional_CGraphicsPreset_release');
late final _CStatefulChannel_COptional_CGraphicsPreset_release = _CStatefulChannel_COptional_CGraphicsPreset_releasePtr.asFunction<void Function(_CStatefulChannel_COptional_CGraphicsPreset)>();
late final _CStatefulChannel_COptional_CGraphicsPreset_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CGraphicsPreset Function(_CStatefulChannel_COptional_CGraphicsPreset)>>('CStatefulChannel_COptional_CGraphicsPreset_retain');
late final _CStatefulChannel_COptional_CGraphicsPreset_retain = _CStatefulChannel_COptional_CGraphicsPreset_retainPtr.asFunction<_CStatefulChannel_COptional_CGraphicsPreset Function(_CStatefulChannel_COptional_CGraphicsPreset)>();
late final _CStatefulChannel_COptional_CGraphicsPresetGetCurrentValuePtr = _lookup<ffi.NativeFunction<_COptional_CGraphicsPreset Function(_CStatefulChannel_COptional_CGraphicsPreset)>>('CStatefulChannel_COptional_CGraphicsPreset_getCurrentValue');
late final _CStatefulChannel_COptional_CGraphicsPresetGetCurrentValue = _CStatefulChannel_COptional_CGraphicsPresetGetCurrentValuePtr.asFunction<_COptional_CGraphicsPreset Function(_CStatefulChannel_COptional_CGraphicsPreset)>();
late final _CStatefulChannel_COptional_CGraphicsPresetConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CGraphicsPreset,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CGraphicsPreset, ffi.Int64)>>
  )
>>('CStatefulChannel_COptional_CGraphicsPreset_connect');
late final _CStatefulChannel_COptional_CGraphicsPresetConnect = _CStatefulChannel_COptional_CGraphicsPresetConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CGraphicsPreset,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CGraphicsPreset, ffi.Int64)>>
  )
>();

late final _COptional_CGraphicsPresetMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CGraphicsPreset Function()>>('COptional_CGraphicsPresetMakeDefault');
late final _COptional_CGraphicsPresetMakeDefault = _COptional_CGraphicsPresetMakeDefaultPtr.asFunction<_COptional_CGraphicsPreset Function()>();

late final _CFuture_COptional_CRenderedObjectInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CRenderedObjectInfo Function()>>('CFuture_COptional_CRenderedObjectInfoMakeDefault');
late final _CFuture_COptional_CRenderedObjectInfoMakeDefault = _CFuture_COptional_CRenderedObjectInfoMakeDefaultPtr.asFunction<_CFuture_COptional_CRenderedObjectInfo Function()>();
late final _CFuture_COptional_CRenderedObjectInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_COptional_CRenderedObjectInfo)>>('CFuture_COptional_CRenderedObjectInfo_release');
late final _CFuture_COptional_CRenderedObjectInfo_release = _CFuture_COptional_CRenderedObjectInfo_releasePtr.asFunction<void Function(_CFuture_COptional_CRenderedObjectInfo)>();
late final _CFuture_COptional_CRenderedObjectInfo_retainPtr = _lookup<ffi.NativeFunction<_CFuture_COptional_CRenderedObjectInfo Function(_CFuture_COptional_CRenderedObjectInfo)>>('CFuture_COptional_CRenderedObjectInfo_retain');
late final _CFuture_COptional_CRenderedObjectInfo_retain = _CFuture_COptional_CRenderedObjectInfo_retainPtr.asFunction<_CFuture_COptional_CRenderedObjectInfo Function(_CFuture_COptional_CRenderedObjectInfo)>();
late final _CFuture_COptional_CRenderedObjectInfoReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_COptional_CRenderedObjectInfo,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CRenderedObjectInfo, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_COptional_CRenderedObjectInfo_receive');
late final _CFuture_COptional_CRenderedObjectInfoReceive = _CFuture_COptional_CRenderedObjectInfoReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_COptional_CRenderedObjectInfo,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CRenderedObjectInfo, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _COptional_CRenderedObjectInfoMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CRenderedObjectInfo Function()>>('COptional_CRenderedObjectInfoMakeDefault');
late final _COptional_CRenderedObjectInfoMakeDefault = _COptional_CRenderedObjectInfoMakeDefaultPtr.asFunction<_COptional_CRenderedObjectInfo Function()>();

late final _COptional_CRenderedObjectInfo_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CRenderedObjectInfo)>>('COptional_CRenderedObjectInfo_release');
late final _COptional_CRenderedObjectInfo_release = _COptional_CRenderedObjectInfo_releasePtr.asFunction<void Function(_COptional_CRenderedObjectInfo)>();

late final _CProjection_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CProjection_cg_objectIdentifier');
late final _CProjection_cg_objectIdentifier = _CProjection_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CProjection_screenToMap_CScreenPointPtr = _lookup<ffi.NativeFunction<_COptional_CGeoPoint Function(_CProjection, _CScreenPoint)>>('CProjection_screenToMap_CScreenPoint');
late final _CProjection_screenToMap_CScreenPoint = _CProjection_screenToMap_CScreenPointPtr.asFunction<_COptional_CGeoPoint Function(_CProjection, _CScreenPoint)>();
late final _CProjection_mapToScreenWithGeoPoint_CGeoPointPtr = _lookup<ffi.NativeFunction<_COptional_CScreenPoint Function(_CProjection, _CGeoPoint)>>('CProjection_mapToScreenWithGeoPoint_CGeoPoint');
late final _CProjection_mapToScreenWithGeoPoint_CGeoPoint = _CProjection_mapToScreenWithGeoPoint_CGeoPointPtr.asFunction<_COptional_CScreenPoint Function(_CProjection, _CGeoPoint)>();
late final _CProjection_mapToScreenWithGeoPointWithElevation_CGeoPointWithElevationPtr = _lookup<ffi.NativeFunction<_COptional_CScreenPoint Function(_CProjection, _CGeoPointWithElevation)>>('CProjection_mapToScreenWithGeoPointWithElevation_CGeoPointWithElevation');
late final _CProjection_mapToScreenWithGeoPointWithElevation_CGeoPointWithElevation = _CProjection_mapToScreenWithGeoPointWithElevation_CGeoPointWithElevationPtr.asFunction<_COptional_CScreenPoint Function(_CProjection, _CGeoPointWithElevation)>();
late final _CProjection_screenToMapClipped_CScreenPointPtr = _lookup<ffi.NativeFunction<_CGeoPoint Function(_CProjection, _CScreenPoint)>>('CProjection_screenToMapClipped_CScreenPoint');
late final _CProjection_screenToMapClipped_CScreenPoint = _CProjection_screenToMapClipped_CScreenPointPtr.asFunction<_CGeoPoint Function(_CProjection, _CScreenPoint)>();
late final _CProjection_distanceOnMap_CScreenPoint_CScreenPointPtr = _lookup<ffi.NativeFunction<_COptional_CMeter Function(_CProjection, _CScreenPoint, _CScreenPoint)>>('CProjection_distanceOnMap_CScreenPoint_CScreenPoint');
late final _CProjection_distanceOnMap_CScreenPoint_CScreenPoint = _CProjection_distanceOnMap_CScreenPoint_CScreenPointPtr.asFunction<_COptional_CMeter Function(_CProjection, _CScreenPoint, _CScreenPoint)>();
late final _CProjection_distanceOnScreen_CGeoPoint_CGeoPointPtr = _lookup<ffi.NativeFunction<_COptional_CLogicalPixel Function(_CProjection, _CGeoPoint, _CGeoPoint)>>('CProjection_distanceOnScreen_CGeoPoint_CGeoPoint');
late final _CProjection_distanceOnScreen_CGeoPoint_CGeoPoint = _CProjection_distanceOnScreen_CGeoPoint_CGeoPointPtr.asFunction<_COptional_CLogicalPixel Function(_CProjection, _CGeoPoint, _CGeoPoint)>();

late final _CProjection_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CProjection_release');
late final _CProjection_release = _CProjection_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CProjection_retainPtr = _lookup<ffi.NativeFunction<_CProjection Function(ffi.Pointer<ffi.Void>)>>('CProjection_retain');
late final _CProjection_retain = _CProjection_retainPtr.asFunction<_CProjection Function(ffi.Pointer<ffi.Void>)>();
late final _CProjectionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CProjection Function()>>('CProjectionMakeDefault');
late final _CProjectionMakeDefault = _CProjectionMakeDefaultPtr.asFunction<_CProjection Function()>();


late final _COptional_CLogicalPixelMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CLogicalPixel Function()>>('COptional_CLogicalPixelMakeDefault');
late final _COptional_CLogicalPixelMakeDefault = _COptional_CLogicalPixelMakeDefaultPtr.asFunction<_COptional_CLogicalPixel Function()>();
late final _CBaseCamera_projectionPtr = _lookup<ffi.NativeFunction<_CProjection Function(_CBaseCamera)>>('CBaseCamera_projection');
late final _CBaseCamera_projection = _CBaseCamera_projectionPtr.asFunction<_CProjection Function(_CBaseCamera)>();
late final _CBaseCamera_positionChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraPosition Function(_CBaseCamera)>>('CBaseCamera_positionChannel');
late final _CBaseCamera_positionChannel = _CBaseCamera_positionChannelPtr.asFunction<_CStatefulChannel_CCameraPosition Function(_CBaseCamera)>();
late final _CBaseCamera_positionPtr = _lookup<ffi.NativeFunction<_CCameraPosition Function(_CBaseCamera)>>('CBaseCamera_position');
late final _CBaseCamera_position = _CBaseCamera_positionPtr.asFunction<_CCameraPosition Function(_CBaseCamera)>();
late final _CBaseCamera_setPosition_CCameraPositionPtr = _lookup<ffi.NativeFunction<_CResult_CEmpty Function(_CBaseCamera, _CCameraPosition)>>('CBaseCamera_setPosition_CCameraPosition');
late final _CBaseCamera_setPosition_CCameraPosition = _CBaseCamera_setPosition_CCameraPositionPtr.asFunction<_CResult_CEmpty Function(_CBaseCamera, _CCameraPosition)>();
late final _CBaseCamera_zoomRestrictionsChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraZoomRestrictions Function(_CBaseCamera)>>('CBaseCamera_zoomRestrictionsChannel');
late final _CBaseCamera_zoomRestrictionsChannel = _CBaseCamera_zoomRestrictionsChannelPtr.asFunction<_CStatefulChannel_CCameraZoomRestrictions Function(_CBaseCamera)>();
late final _CBaseCamera_zoomRestrictionsPtr = _lookup<ffi.NativeFunction<_CCameraZoomRestrictions Function(_CBaseCamera)>>('CBaseCamera_zoomRestrictions');
late final _CBaseCamera_zoomRestrictions = _CBaseCamera_zoomRestrictionsPtr.asFunction<_CCameraZoomRestrictions Function(_CBaseCamera)>();
late final _CBaseCamera_setZoomRestrictions_CCameraZoomRestrictionsPtr = _lookup<ffi.NativeFunction<_CResult_CEmpty Function(_CBaseCamera, _CCameraZoomRestrictions)>>('CBaseCamera_setZoomRestrictions_CCameraZoomRestrictions');
late final _CBaseCamera_setZoomRestrictions_CCameraZoomRestrictions = _CBaseCamera_setZoomRestrictions_CCameraZoomRestrictionsPtr.asFunction<_CResult_CEmpty Function(_CBaseCamera, _CCameraZoomRestrictions)>();
late final _CBaseCamera_devicePpiChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CDevicePpi Function(_CBaseCamera)>>('CBaseCamera_devicePpiChannel');
late final _CBaseCamera_devicePpiChannel = _CBaseCamera_devicePpiChannelPtr.asFunction<_CStatefulChannel_CDevicePpi Function(_CBaseCamera)>();
late final _CBaseCamera_devicePpiPtr = _lookup<ffi.NativeFunction<_CDevicePpi Function(_CBaseCamera)>>('CBaseCamera_devicePpi');
late final _CBaseCamera_devicePpi = _CBaseCamera_devicePpiPtr.asFunction<_CDevicePpi Function(_CBaseCamera)>();
late final _CBaseCamera_deviceDensityChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CDeviceDensity Function(_CBaseCamera)>>('CBaseCamera_deviceDensityChannel');
late final _CBaseCamera_deviceDensityChannel = _CBaseCamera_deviceDensityChannelPtr.asFunction<_CStatefulChannel_CDeviceDensity Function(_CBaseCamera)>();
late final _CBaseCamera_deviceDensityPtr = _lookup<ffi.NativeFunction<_CDeviceDensity Function(_CBaseCamera)>>('CBaseCamera_deviceDensity');
late final _CBaseCamera_deviceDensity = _CBaseCamera_deviceDensityPtr.asFunction<_CDeviceDensity Function(_CBaseCamera)>();
late final _CBaseCamera_sizeChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CScreenSize Function(_CBaseCamera)>>('CBaseCamera_sizeChannel');
late final _CBaseCamera_sizeChannel = _CBaseCamera_sizeChannelPtr.asFunction<_CStatefulChannel_CScreenSize Function(_CBaseCamera)>();
late final _CBaseCamera_sizePtr = _lookup<ffi.NativeFunction<_CScreenSize Function(_CBaseCamera)>>('CBaseCamera_size');
late final _CBaseCamera_size = _CBaseCamera_sizePtr.asFunction<_CScreenSize Function(_CBaseCamera)>();
late final _CBaseCamera_setSize_CScreenSizePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CBaseCamera, _CScreenSize)>>('CBaseCamera_setSize_CScreenSize');
late final _CBaseCamera_setSize_CScreenSize = _CBaseCamera_setSize_CScreenSizePtr.asFunction<void Function(_CBaseCamera, _CScreenSize)>();
late final _CBaseCamera_paddingChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CPadding Function(_CBaseCamera)>>('CBaseCamera_paddingChannel');
late final _CBaseCamera_paddingChannel = _CBaseCamera_paddingChannelPtr.asFunction<_CStatefulChannel_CPadding Function(_CBaseCamera)>();
late final _CBaseCamera_paddingPtr = _lookup<ffi.NativeFunction<_CPadding Function(_CBaseCamera)>>('CBaseCamera_padding');
late final _CBaseCamera_padding = _CBaseCamera_paddingPtr.asFunction<_CPadding Function(_CBaseCamera)>();
late final _CBaseCamera_setPadding_CPaddingPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CBaseCamera, _CPadding)>>('CBaseCamera_setPadding_CPadding');
late final _CBaseCamera_setPadding_CPadding = _CBaseCamera_setPadding_CPaddingPtr.asFunction<void Function(_CBaseCamera, _CPadding)>();
late final _CBaseCamera_positionPointChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraPositionPoint Function(_CBaseCamera)>>('CBaseCamera_positionPointChannel');
late final _CBaseCamera_positionPointChannel = _CBaseCamera_positionPointChannelPtr.asFunction<_CStatefulChannel_CCameraPositionPoint Function(_CBaseCamera)>();
late final _CBaseCamera_positionPointPtr = _lookup<ffi.NativeFunction<_CCameraPositionPoint Function(_CBaseCamera)>>('CBaseCamera_positionPoint');
late final _CBaseCamera_positionPoint = _CBaseCamera_positionPointPtr.asFunction<_CCameraPositionPoint Function(_CBaseCamera)>();
late final _CBaseCamera_setPositionPoint_CCameraPositionPointPtr = _lookup<ffi.NativeFunction<_CResult_CEmpty Function(_CBaseCamera, _CCameraPositionPoint)>>('CBaseCamera_setPositionPoint_CCameraPositionPoint');
late final _CBaseCamera_setPositionPoint_CCameraPositionPoint = _CBaseCamera_setPositionPoint_CCameraPositionPointPtr.asFunction<_CResult_CEmpty Function(_CBaseCamera, _CCameraPositionPoint)>();
late final _CBaseCamera_viewPointPtr = _lookup<ffi.NativeFunction<_COptional_CCameraViewPoint Function(_CBaseCamera)>>('CBaseCamera_viewPoint');
late final _CBaseCamera_viewPoint = _CBaseCamera_viewPointPtr.asFunction<_COptional_CCameraViewPoint Function(_CBaseCamera)>();
late final _CBaseCamera_setViewPoint_COptional_CCameraViewPointPtr = _lookup<ffi.NativeFunction<_CResult_CEmpty Function(_CBaseCamera, _COptional_CCameraViewPoint)>>('CBaseCamera_setViewPoint_COptional_CCameraViewPoint');
late final _CBaseCamera_setViewPoint_COptional_CCameraViewPoint = _CBaseCamera_setViewPoint_COptional_CCameraViewPointPtr.asFunction<_CResult_CEmpty Function(_CBaseCamera, _COptional_CCameraViewPoint)>();
late final _CBaseCamera_visibleAreaPtr = _lookup<ffi.NativeFunction<_CGeometry Function(_CBaseCamera)>>('CBaseCamera_visibleArea');
late final _CBaseCamera_visibleArea = _CBaseCamera_visibleAreaPtr.asFunction<_CGeometry Function(_CBaseCamera)>();
late final _CBaseCamera_visibleRectChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CGeoRect Function(_CBaseCamera)>>('CBaseCamera_visibleRectChannel');
late final _CBaseCamera_visibleRectChannel = _CBaseCamera_visibleRectChannelPtr.asFunction<_CStatefulChannel_CGeoRect Function(_CBaseCamera)>();
late final _CBaseCamera_visibleRectPtr = _lookup<ffi.NativeFunction<_CGeoRect Function(_CBaseCamera)>>('CBaseCamera_visibleRect');
late final _CBaseCamera_visibleRect = _CBaseCamera_visibleRectPtr.asFunction<_CGeoRect Function(_CBaseCamera)>();
late final _CBaseCamera_maxTiltRestrictionChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CStyleZoomToTiltRelation Function(_CBaseCamera)>>('CBaseCamera_maxTiltRestrictionChannel');
late final _CBaseCamera_maxTiltRestrictionChannel = _CBaseCamera_maxTiltRestrictionChannelPtr.asFunction<_CStatefulChannel_COptional_CStyleZoomToTiltRelation Function(_CBaseCamera)>();
late final _CBaseCamera_maxTiltRestrictionPtr = _lookup<ffi.NativeFunction<_COptional_CStyleZoomToTiltRelation Function(_CBaseCamera)>>('CBaseCamera_maxTiltRestriction');
late final _CBaseCamera_maxTiltRestriction = _CBaseCamera_maxTiltRestrictionPtr.asFunction<_COptional_CStyleZoomToTiltRelation Function(_CBaseCamera)>();
late final _CBaseCamera_setMaxTiltRestriction_COptional_CStyleZoomToTiltRelationPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CBaseCamera, _COptional_CStyleZoomToTiltRelation)>>('CBaseCamera_setMaxTiltRestriction_COptional_CStyleZoomToTiltRelation');
late final _CBaseCamera_setMaxTiltRestriction_COptional_CStyleZoomToTiltRelation = _CBaseCamera_setMaxTiltRestriction_COptional_CStyleZoomToTiltRelationPtr.asFunction<void Function(_CBaseCamera, _COptional_CStyleZoomToTiltRelation)>();
late final _CBaseCamera_viewportRestrictionChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CGeoRect Function(_CBaseCamera)>>('CBaseCamera_viewportRestrictionChannel');
late final _CBaseCamera_viewportRestrictionChannel = _CBaseCamera_viewportRestrictionChannelPtr.asFunction<_CStatefulChannel_COptional_CGeoRect Function(_CBaseCamera)>();
late final _CBaseCamera_viewportRestrictionPtr = _lookup<ffi.NativeFunction<_COptional_CGeoRect Function(_CBaseCamera)>>('CBaseCamera_viewportRestriction');
late final _CBaseCamera_viewportRestriction = _CBaseCamera_viewportRestrictionPtr.asFunction<_COptional_CGeoRect Function(_CBaseCamera)>();
late final _CBaseCamera_setViewportRestriction_COptional_CGeoRectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CBaseCamera, _COptional_CGeoRect)>>('CBaseCamera_setViewportRestriction_COptional_CGeoRect');
late final _CBaseCamera_setViewportRestriction_COptional_CGeoRect = _CBaseCamera_setViewportRestriction_COptional_CGeoRectPtr.asFunction<void Function(_CBaseCamera, _COptional_CGeoRect)>();

late final _CBaseCamera_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CBaseCamera_cg_objectIdentifier');
late final _CBaseCamera_cg_objectIdentifier = _CBaseCamera_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CBaseCamera_clonePtr = _lookup<ffi.NativeFunction<_CBaseCamera Function(_CBaseCamera)>>('CBaseCamera_clone');
late final _CBaseCamera_clone = _CBaseCamera_clonePtr.asFunction<_CBaseCamera Function(_CBaseCamera)>();
late final _CBaseCamera_changePosition_CCameraPositionChangePtr = _lookup<ffi.NativeFunction<_CResult_CEmpty Function(_CBaseCamera, _CCameraPositionChange)>>('CBaseCamera_changePosition_CCameraPositionChange');
late final _CBaseCamera_changePosition_CCameraPositionChange = _CBaseCamera_changePosition_CCameraPositionChangePtr.asFunction<_CResult_CEmpty Function(_CBaseCamera, _CCameraPositionChange)>();
late final _CBaseCamera_setDevicePpi_CDevicePpi_CDeviceDensityPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CBaseCamera, _CDevicePpi, _CDeviceDensity)>>('CBaseCamera_setDevicePpi_CDevicePpi_CDeviceDensity');
late final _CBaseCamera_setDevicePpi_CDevicePpi_CDeviceDensity = _CBaseCamera_setDevicePpi_CDevicePpi_CDeviceDensityPtr.asFunction<void Function(_CBaseCamera, _CDevicePpi, _CDeviceDensity)>();
late final _CBaseCamera_cg_getSelectorPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CBaseCamera)>>('CBaseCamera_cg_getSelector');
late final _CBaseCamera_cg_getSelector = _CBaseCamera_cg_getSelectorPtr.asFunction<int Function(_CBaseCamera)>();

late final _CBaseCamera_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CBaseCamera_release');
late final _CBaseCamera_release = _CBaseCamera_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CBaseCamera_retainPtr = _lookup<ffi.NativeFunction<_CBaseCamera Function(ffi.Pointer<ffi.Void>)>>('CBaseCamera_retain');
late final _CBaseCamera_retain = _CBaseCamera_retainPtr.asFunction<_CBaseCamera Function(ffi.Pointer<ffi.Void>)>();
late final _CBaseCameraMakeDefaultPtr = _lookup<ffi.NativeFunction<_CBaseCamera Function()>>('CBaseCameraMakeDefault');
late final _CBaseCameraMakeDefault = _CBaseCameraMakeDefaultPtr.asFunction<_CBaseCamera Function()>();


late final _CStatefulChannel_CCameraPositionMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraPosition Function()>>('CStatefulChannel_CCameraPositionMakeDefault');
late final _CStatefulChannel_CCameraPositionMakeDefault = _CStatefulChannel_CCameraPositionMakeDefaultPtr.asFunction<_CStatefulChannel_CCameraPosition Function()>();
late final _CStatefulChannel_CCameraPosition_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CCameraPosition)>>('CStatefulChannel_CCameraPosition_release');
late final _CStatefulChannel_CCameraPosition_release = _CStatefulChannel_CCameraPosition_releasePtr.asFunction<void Function(_CStatefulChannel_CCameraPosition)>();
late final _CStatefulChannel_CCameraPosition_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraPosition Function(_CStatefulChannel_CCameraPosition)>>('CStatefulChannel_CCameraPosition_retain');
late final _CStatefulChannel_CCameraPosition_retain = _CStatefulChannel_CCameraPosition_retainPtr.asFunction<_CStatefulChannel_CCameraPosition Function(_CStatefulChannel_CCameraPosition)>();
late final _CStatefulChannel_CCameraPositionGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CCameraPosition Function(_CStatefulChannel_CCameraPosition)>>('CStatefulChannel_CCameraPosition_getCurrentValue');
late final _CStatefulChannel_CCameraPositionGetCurrentValue = _CStatefulChannel_CCameraPositionGetCurrentValuePtr.asFunction<_CCameraPosition Function(_CStatefulChannel_CCameraPosition)>();
late final _CStatefulChannel_CCameraPositionConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraPosition,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraPosition, ffi.Int64)>>
  )
>>('CStatefulChannel_CCameraPosition_connect');
late final _CStatefulChannel_CCameraPositionConnect = _CStatefulChannel_CCameraPositionConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraPosition,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraPosition, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CCameraZoomRestrictionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraZoomRestrictions Function()>>('CStatefulChannel_CCameraZoomRestrictionsMakeDefault');
late final _CStatefulChannel_CCameraZoomRestrictionsMakeDefault = _CStatefulChannel_CCameraZoomRestrictionsMakeDefaultPtr.asFunction<_CStatefulChannel_CCameraZoomRestrictions Function()>();
late final _CStatefulChannel_CCameraZoomRestrictions_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CCameraZoomRestrictions)>>('CStatefulChannel_CCameraZoomRestrictions_release');
late final _CStatefulChannel_CCameraZoomRestrictions_release = _CStatefulChannel_CCameraZoomRestrictions_releasePtr.asFunction<void Function(_CStatefulChannel_CCameraZoomRestrictions)>();
late final _CStatefulChannel_CCameraZoomRestrictions_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraZoomRestrictions Function(_CStatefulChannel_CCameraZoomRestrictions)>>('CStatefulChannel_CCameraZoomRestrictions_retain');
late final _CStatefulChannel_CCameraZoomRestrictions_retain = _CStatefulChannel_CCameraZoomRestrictions_retainPtr.asFunction<_CStatefulChannel_CCameraZoomRestrictions Function(_CStatefulChannel_CCameraZoomRestrictions)>();
late final _CStatefulChannel_CCameraZoomRestrictionsGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CCameraZoomRestrictions Function(_CStatefulChannel_CCameraZoomRestrictions)>>('CStatefulChannel_CCameraZoomRestrictions_getCurrentValue');
late final _CStatefulChannel_CCameraZoomRestrictionsGetCurrentValue = _CStatefulChannel_CCameraZoomRestrictionsGetCurrentValuePtr.asFunction<_CCameraZoomRestrictions Function(_CStatefulChannel_CCameraZoomRestrictions)>();
late final _CStatefulChannel_CCameraZoomRestrictionsConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraZoomRestrictions,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraZoomRestrictions, ffi.Int64)>>
  )
>>('CStatefulChannel_CCameraZoomRestrictions_connect');
late final _CStatefulChannel_CCameraZoomRestrictionsConnect = _CStatefulChannel_CCameraZoomRestrictionsConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraZoomRestrictions,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraZoomRestrictions, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CDevicePpiMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CDevicePpi Function()>>('CStatefulChannel_CDevicePpiMakeDefault');
late final _CStatefulChannel_CDevicePpiMakeDefault = _CStatefulChannel_CDevicePpiMakeDefaultPtr.asFunction<_CStatefulChannel_CDevicePpi Function()>();
late final _CStatefulChannel_CDevicePpi_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CDevicePpi)>>('CStatefulChannel_CDevicePpi_release');
late final _CStatefulChannel_CDevicePpi_release = _CStatefulChannel_CDevicePpi_releasePtr.asFunction<void Function(_CStatefulChannel_CDevicePpi)>();
late final _CStatefulChannel_CDevicePpi_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CDevicePpi Function(_CStatefulChannel_CDevicePpi)>>('CStatefulChannel_CDevicePpi_retain');
late final _CStatefulChannel_CDevicePpi_retain = _CStatefulChannel_CDevicePpi_retainPtr.asFunction<_CStatefulChannel_CDevicePpi Function(_CStatefulChannel_CDevicePpi)>();
late final _CStatefulChannel_CDevicePpiGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CDevicePpi Function(_CStatefulChannel_CDevicePpi)>>('CStatefulChannel_CDevicePpi_getCurrentValue');
late final _CStatefulChannel_CDevicePpiGetCurrentValue = _CStatefulChannel_CDevicePpiGetCurrentValuePtr.asFunction<_CDevicePpi Function(_CStatefulChannel_CDevicePpi)>();
late final _CStatefulChannel_CDevicePpiConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CDevicePpi,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDevicePpi, ffi.Int64)>>
  )
>>('CStatefulChannel_CDevicePpi_connect');
late final _CStatefulChannel_CDevicePpiConnect = _CStatefulChannel_CDevicePpiConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CDevicePpi,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDevicePpi, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CDeviceDensityMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CDeviceDensity Function()>>('CStatefulChannel_CDeviceDensityMakeDefault');
late final _CStatefulChannel_CDeviceDensityMakeDefault = _CStatefulChannel_CDeviceDensityMakeDefaultPtr.asFunction<_CStatefulChannel_CDeviceDensity Function()>();
late final _CStatefulChannel_CDeviceDensity_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CDeviceDensity)>>('CStatefulChannel_CDeviceDensity_release');
late final _CStatefulChannel_CDeviceDensity_release = _CStatefulChannel_CDeviceDensity_releasePtr.asFunction<void Function(_CStatefulChannel_CDeviceDensity)>();
late final _CStatefulChannel_CDeviceDensity_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CDeviceDensity Function(_CStatefulChannel_CDeviceDensity)>>('CStatefulChannel_CDeviceDensity_retain');
late final _CStatefulChannel_CDeviceDensity_retain = _CStatefulChannel_CDeviceDensity_retainPtr.asFunction<_CStatefulChannel_CDeviceDensity Function(_CStatefulChannel_CDeviceDensity)>();
late final _CStatefulChannel_CDeviceDensityGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CDeviceDensity Function(_CStatefulChannel_CDeviceDensity)>>('CStatefulChannel_CDeviceDensity_getCurrentValue');
late final _CStatefulChannel_CDeviceDensityGetCurrentValue = _CStatefulChannel_CDeviceDensityGetCurrentValuePtr.asFunction<_CDeviceDensity Function(_CStatefulChannel_CDeviceDensity)>();
late final _CStatefulChannel_CDeviceDensityConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CDeviceDensity,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDeviceDensity, ffi.Int64)>>
  )
>>('CStatefulChannel_CDeviceDensity_connect');
late final _CStatefulChannel_CDeviceDensityConnect = _CStatefulChannel_CDeviceDensityConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CDeviceDensity,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDeviceDensity, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CScreenSizeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CScreenSize Function()>>('CStatefulChannel_CScreenSizeMakeDefault');
late final _CStatefulChannel_CScreenSizeMakeDefault = _CStatefulChannel_CScreenSizeMakeDefaultPtr.asFunction<_CStatefulChannel_CScreenSize Function()>();
late final _CStatefulChannel_CScreenSize_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CScreenSize)>>('CStatefulChannel_CScreenSize_release');
late final _CStatefulChannel_CScreenSize_release = _CStatefulChannel_CScreenSize_releasePtr.asFunction<void Function(_CStatefulChannel_CScreenSize)>();
late final _CStatefulChannel_CScreenSize_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CScreenSize Function(_CStatefulChannel_CScreenSize)>>('CStatefulChannel_CScreenSize_retain');
late final _CStatefulChannel_CScreenSize_retain = _CStatefulChannel_CScreenSize_retainPtr.asFunction<_CStatefulChannel_CScreenSize Function(_CStatefulChannel_CScreenSize)>();
late final _CStatefulChannel_CScreenSizeGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CScreenSize Function(_CStatefulChannel_CScreenSize)>>('CStatefulChannel_CScreenSize_getCurrentValue');
late final _CStatefulChannel_CScreenSizeGetCurrentValue = _CStatefulChannel_CScreenSizeGetCurrentValuePtr.asFunction<_CScreenSize Function(_CStatefulChannel_CScreenSize)>();
late final _CStatefulChannel_CScreenSizeConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CScreenSize,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CScreenSize, ffi.Int64)>>
  )
>>('CStatefulChannel_CScreenSize_connect');
late final _CStatefulChannel_CScreenSizeConnect = _CStatefulChannel_CScreenSizeConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CScreenSize,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CScreenSize, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CPaddingMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CPadding Function()>>('CStatefulChannel_CPaddingMakeDefault');
late final _CStatefulChannel_CPaddingMakeDefault = _CStatefulChannel_CPaddingMakeDefaultPtr.asFunction<_CStatefulChannel_CPadding Function()>();
late final _CStatefulChannel_CPadding_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CPadding)>>('CStatefulChannel_CPadding_release');
late final _CStatefulChannel_CPadding_release = _CStatefulChannel_CPadding_releasePtr.asFunction<void Function(_CStatefulChannel_CPadding)>();
late final _CStatefulChannel_CPadding_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CPadding Function(_CStatefulChannel_CPadding)>>('CStatefulChannel_CPadding_retain');
late final _CStatefulChannel_CPadding_retain = _CStatefulChannel_CPadding_retainPtr.asFunction<_CStatefulChannel_CPadding Function(_CStatefulChannel_CPadding)>();
late final _CStatefulChannel_CPaddingGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CPadding Function(_CStatefulChannel_CPadding)>>('CStatefulChannel_CPadding_getCurrentValue');
late final _CStatefulChannel_CPaddingGetCurrentValue = _CStatefulChannel_CPaddingGetCurrentValuePtr.asFunction<_CPadding Function(_CStatefulChannel_CPadding)>();
late final _CStatefulChannel_CPaddingConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CPadding,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CPadding, ffi.Int64)>>
  )
>>('CStatefulChannel_CPadding_connect');
late final _CStatefulChannel_CPaddingConnect = _CStatefulChannel_CPaddingConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CPadding,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CPadding, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_CCameraPositionPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraPositionPoint Function()>>('CStatefulChannel_CCameraPositionPointMakeDefault');
late final _CStatefulChannel_CCameraPositionPointMakeDefault = _CStatefulChannel_CCameraPositionPointMakeDefaultPtr.asFunction<_CStatefulChannel_CCameraPositionPoint Function()>();
late final _CStatefulChannel_CCameraPositionPoint_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CCameraPositionPoint)>>('CStatefulChannel_CCameraPositionPoint_release');
late final _CStatefulChannel_CCameraPositionPoint_release = _CStatefulChannel_CCameraPositionPoint_releasePtr.asFunction<void Function(_CStatefulChannel_CCameraPositionPoint)>();
late final _CStatefulChannel_CCameraPositionPoint_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraPositionPoint Function(_CStatefulChannel_CCameraPositionPoint)>>('CStatefulChannel_CCameraPositionPoint_retain');
late final _CStatefulChannel_CCameraPositionPoint_retain = _CStatefulChannel_CCameraPositionPoint_retainPtr.asFunction<_CStatefulChannel_CCameraPositionPoint Function(_CStatefulChannel_CCameraPositionPoint)>();
late final _CStatefulChannel_CCameraPositionPointGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CCameraPositionPoint Function(_CStatefulChannel_CCameraPositionPoint)>>('CStatefulChannel_CCameraPositionPoint_getCurrentValue');
late final _CStatefulChannel_CCameraPositionPointGetCurrentValue = _CStatefulChannel_CCameraPositionPointGetCurrentValuePtr.asFunction<_CCameraPositionPoint Function(_CStatefulChannel_CCameraPositionPoint)>();
late final _CStatefulChannel_CCameraPositionPointConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraPositionPoint,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraPositionPoint, ffi.Int64)>>
  )
>>('CStatefulChannel_CCameraPositionPoint_connect');
late final _CStatefulChannel_CCameraPositionPointConnect = _CStatefulChannel_CCameraPositionPointConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraPositionPoint,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraPositionPoint, ffi.Int64)>>
  )
>();

late final _COptional_CCameraViewPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CCameraViewPoint Function()>>('COptional_CCameraViewPointMakeDefault');
late final _COptional_CCameraViewPointMakeDefault = _COptional_CCameraViewPointMakeDefaultPtr.asFunction<_COptional_CCameraViewPoint Function()>();

late final _CStatefulChannel_CGeoRectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CGeoRect Function()>>('CStatefulChannel_CGeoRectMakeDefault');
late final _CStatefulChannel_CGeoRectMakeDefault = _CStatefulChannel_CGeoRectMakeDefaultPtr.asFunction<_CStatefulChannel_CGeoRect Function()>();
late final _CStatefulChannel_CGeoRect_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CGeoRect)>>('CStatefulChannel_CGeoRect_release');
late final _CStatefulChannel_CGeoRect_release = _CStatefulChannel_CGeoRect_releasePtr.asFunction<void Function(_CStatefulChannel_CGeoRect)>();
late final _CStatefulChannel_CGeoRect_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CGeoRect Function(_CStatefulChannel_CGeoRect)>>('CStatefulChannel_CGeoRect_retain');
late final _CStatefulChannel_CGeoRect_retain = _CStatefulChannel_CGeoRect_retainPtr.asFunction<_CStatefulChannel_CGeoRect Function(_CStatefulChannel_CGeoRect)>();
late final _CStatefulChannel_CGeoRectGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CGeoRect Function(_CStatefulChannel_CGeoRect)>>('CStatefulChannel_CGeoRect_getCurrentValue');
late final _CStatefulChannel_CGeoRectGetCurrentValue = _CStatefulChannel_CGeoRectGetCurrentValuePtr.asFunction<_CGeoRect Function(_CStatefulChannel_CGeoRect)>();
late final _CStatefulChannel_CGeoRectConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CGeoRect,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeoRect, ffi.Int64)>>
  )
>>('CStatefulChannel_CGeoRect_connect');
late final _CStatefulChannel_CGeoRectConnect = _CStatefulChannel_CGeoRectConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CGeoRect,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CGeoRect, ffi.Int64)>>
  )
>();

late final _CStatefulChannel_COptional_CStyleZoomToTiltRelationMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CStyleZoomToTiltRelation Function()>>('CStatefulChannel_COptional_CStyleZoomToTiltRelationMakeDefault');
late final _CStatefulChannel_COptional_CStyleZoomToTiltRelationMakeDefault = _CStatefulChannel_COptional_CStyleZoomToTiltRelationMakeDefaultPtr.asFunction<_CStatefulChannel_COptional_CStyleZoomToTiltRelation Function()>();
late final _CStatefulChannel_COptional_CStyleZoomToTiltRelation_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_COptional_CStyleZoomToTiltRelation)>>('CStatefulChannel_COptional_CStyleZoomToTiltRelation_release');
late final _CStatefulChannel_COptional_CStyleZoomToTiltRelation_release = _CStatefulChannel_COptional_CStyleZoomToTiltRelation_releasePtr.asFunction<void Function(_CStatefulChannel_COptional_CStyleZoomToTiltRelation)>();
late final _CStatefulChannel_COptional_CStyleZoomToTiltRelation_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CStyleZoomToTiltRelation Function(_CStatefulChannel_COptional_CStyleZoomToTiltRelation)>>('CStatefulChannel_COptional_CStyleZoomToTiltRelation_retain');
late final _CStatefulChannel_COptional_CStyleZoomToTiltRelation_retain = _CStatefulChannel_COptional_CStyleZoomToTiltRelation_retainPtr.asFunction<_CStatefulChannel_COptional_CStyleZoomToTiltRelation Function(_CStatefulChannel_COptional_CStyleZoomToTiltRelation)>();
late final _CStatefulChannel_COptional_CStyleZoomToTiltRelationGetCurrentValuePtr = _lookup<ffi.NativeFunction<_COptional_CStyleZoomToTiltRelation Function(_CStatefulChannel_COptional_CStyleZoomToTiltRelation)>>('CStatefulChannel_COptional_CStyleZoomToTiltRelation_getCurrentValue');
late final _CStatefulChannel_COptional_CStyleZoomToTiltRelationGetCurrentValue = _CStatefulChannel_COptional_CStyleZoomToTiltRelationGetCurrentValuePtr.asFunction<_COptional_CStyleZoomToTiltRelation Function(_CStatefulChannel_COptional_CStyleZoomToTiltRelation)>();
late final _CStatefulChannel_COptional_CStyleZoomToTiltRelationConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CStyleZoomToTiltRelation,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CStyleZoomToTiltRelation, ffi.Int64)>>
  )
>>('CStatefulChannel_COptional_CStyleZoomToTiltRelation_connect');
late final _CStatefulChannel_COptional_CStyleZoomToTiltRelationConnect = _CStatefulChannel_COptional_CStyleZoomToTiltRelationConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CStyleZoomToTiltRelation,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CStyleZoomToTiltRelation, ffi.Int64)>>
  )
>();

late final _COptional_CStyleZoomToTiltRelationMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CStyleZoomToTiltRelation Function()>>('COptional_CStyleZoomToTiltRelationMakeDefault');
late final _COptional_CStyleZoomToTiltRelationMakeDefault = _COptional_CStyleZoomToTiltRelationMakeDefaultPtr.asFunction<_COptional_CStyleZoomToTiltRelation Function()>();

late final _COptional_CStyleZoomToTiltRelation_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CStyleZoomToTiltRelation)>>('COptional_CStyleZoomToTiltRelation_release');
late final _COptional_CStyleZoomToTiltRelation_release = _COptional_CStyleZoomToTiltRelation_releasePtr.asFunction<void Function(_COptional_CStyleZoomToTiltRelation)>();

late final _CStatefulChannel_COptional_CGeoRectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CGeoRect Function()>>('CStatefulChannel_COptional_CGeoRectMakeDefault');
late final _CStatefulChannel_COptional_CGeoRectMakeDefault = _CStatefulChannel_COptional_CGeoRectMakeDefaultPtr.asFunction<_CStatefulChannel_COptional_CGeoRect Function()>();
late final _CStatefulChannel_COptional_CGeoRect_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_COptional_CGeoRect)>>('CStatefulChannel_COptional_CGeoRect_release');
late final _CStatefulChannel_COptional_CGeoRect_release = _CStatefulChannel_COptional_CGeoRect_releasePtr.asFunction<void Function(_CStatefulChannel_COptional_CGeoRect)>();
late final _CStatefulChannel_COptional_CGeoRect_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CGeoRect Function(_CStatefulChannel_COptional_CGeoRect)>>('CStatefulChannel_COptional_CGeoRect_retain');
late final _CStatefulChannel_COptional_CGeoRect_retain = _CStatefulChannel_COptional_CGeoRect_retainPtr.asFunction<_CStatefulChannel_COptional_CGeoRect Function(_CStatefulChannel_COptional_CGeoRect)>();
late final _CStatefulChannel_COptional_CGeoRectGetCurrentValuePtr = _lookup<ffi.NativeFunction<_COptional_CGeoRect Function(_CStatefulChannel_COptional_CGeoRect)>>('CStatefulChannel_COptional_CGeoRect_getCurrentValue');
late final _CStatefulChannel_COptional_CGeoRectGetCurrentValue = _CStatefulChannel_COptional_CGeoRectGetCurrentValuePtr.asFunction<_COptional_CGeoRect Function(_CStatefulChannel_COptional_CGeoRect)>();
late final _CStatefulChannel_COptional_CGeoRectConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CGeoRect,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CGeoRect, ffi.Int64)>>
  )
>>('CStatefulChannel_COptional_CGeoRect_connect');
late final _CStatefulChannel_COptional_CGeoRectConnect = _CStatefulChannel_COptional_CGeoRectConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CGeoRect,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CGeoRect, ffi.Int64)>>
  )
>();
late final _CSimpleMapObject_isVisiblePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CSimpleMapObject)>>('CSimpleMapObject_isVisible');
late final _CSimpleMapObject_isVisible = _CSimpleMapObject_isVisiblePtr.asFunction<bool Function(_CSimpleMapObject)>();
late final _CSimpleMapObject_setVisible_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleMapObject, ffi.Bool)>>('CSimpleMapObject_setVisible_bool');
late final _CSimpleMapObject_setVisible_bool = _CSimpleMapObject_setVisible_boolPtr.asFunction<void Function(_CSimpleMapObject, bool)>();
late final _CSimpleMapObject_zIndexPtr = _lookup<ffi.NativeFunction<_CZIndex Function(_CSimpleMapObject)>>('CSimpleMapObject_zIndex');
late final _CSimpleMapObject_zIndex = _CSimpleMapObject_zIndexPtr.asFunction<_CZIndex Function(_CSimpleMapObject)>();
late final _CSimpleMapObject_setZIndex_CZIndexPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleMapObject, _CZIndex)>>('CSimpleMapObject_setZIndex_CZIndex');
late final _CSimpleMapObject_setZIndex_CZIndex = _CSimpleMapObject_setZIndex_CZIndexPtr.asFunction<void Function(_CSimpleMapObject, _CZIndex)>();
late final _CSimpleMapObject_levelIdPtr = _lookup<ffi.NativeFunction<_COptional_CLevelId Function(_CSimpleMapObject)>>('CSimpleMapObject_levelId');
late final _CSimpleMapObject_levelId = _CSimpleMapObject_levelIdPtr.asFunction<_COptional_CLevelId Function(_CSimpleMapObject)>();
late final _CSimpleMapObject_setLevelId_COptional_CLevelIdPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleMapObject, _COptional_CLevelId)>>('CSimpleMapObject_setLevelId_COptional_CLevelId');
late final _CSimpleMapObject_setLevelId_COptional_CLevelId = _CSimpleMapObject_setLevelId_COptional_CLevelIdPtr.asFunction<void Function(_CSimpleMapObject, _COptional_CLevelId)>();
late final _CSimpleMapObject_boundsPtr = _lookup<ffi.NativeFunction<_CGeoRect Function(_CSimpleMapObject)>>('CSimpleMapObject_bounds');
late final _CSimpleMapObject_bounds = _CSimpleMapObject_boundsPtr.asFunction<_CGeoRect Function(_CSimpleMapObject)>();

late final _CSimpleMapObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSimpleMapObject_cg_objectIdentifier');
late final _CSimpleMapObject_cg_objectIdentifier = _CSimpleMapObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSimpleMapObject_cg_getSelectorPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CSimpleMapObject)>>('CSimpleMapObject_cg_getSelector');
late final _CSimpleMapObject_cg_getSelector = _CSimpleMapObject_cg_getSelectorPtr.asFunction<int Function(_CSimpleMapObject)>();

late final _CSimpleMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSimpleMapObject_release');
late final _CSimpleMapObject_release = _CSimpleMapObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSimpleMapObject_retainPtr = _lookup<ffi.NativeFunction<_CSimpleMapObject Function(ffi.Pointer<ffi.Void>)>>('CSimpleMapObject_retain');
late final _CSimpleMapObject_retain = _CSimpleMapObject_retainPtr.asFunction<_CSimpleMapObject Function(ffi.Pointer<ffi.Void>)>();
late final _CSimpleMapObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSimpleMapObject Function()>>('CSimpleMapObjectMakeDefault');
late final _CSimpleMapObjectMakeDefault = _CSimpleMapObjectMakeDefaultPtr.asFunction<_CSimpleMapObject Function()>();

late final _CMapObjectManager_isVisiblePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CMapObjectManager)>>('CMapObjectManager_isVisible');
late final _CMapObjectManager_isVisible = _CMapObjectManager_isVisiblePtr.asFunction<bool Function(_CMapObjectManager)>();
late final _CMapObjectManager_setVisible_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapObjectManager, ffi.Bool)>>('CMapObjectManager_setVisible_bool');
late final _CMapObjectManager_setVisible_bool = _CMapObjectManager_setVisible_boolPtr.asFunction<void Function(_CMapObjectManager, bool)>();

late final _CMapObjectManager_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapObjectManager_cg_objectIdentifier');
late final _CMapObjectManager_cg_objectIdentifier = _CMapObjectManager_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapObjectManager_S_withClustering_CMap_CLogicalPixel_CZoom_CSimpleClusterRenderer_CZoom_COptional_CStringPtr = _lookup<ffi.NativeFunction<_CMapObjectManager Function(_CMap, _CLogicalPixel, _CZoom, _CSimpleClusterRenderer, _CZoom, _COptional_CString)>>('CMapObjectManager_S_withClustering_CMap_CLogicalPixel_CZoom_CSimpleClusterRenderer_CZoom_COptional_CString');
late final _CMapObjectManager_S_withClustering_CMap_CLogicalPixel_CZoom_CSimpleClusterRenderer_CZoom_COptional_CString = _CMapObjectManager_S_withClustering_CMap_CLogicalPixel_CZoom_CSimpleClusterRenderer_CZoom_COptional_CStringPtr.asFunction<_CMapObjectManager Function(_CMap, _CLogicalPixel, _CZoom, _CSimpleClusterRenderer, _CZoom, _COptional_CString)>();
late final _CMapObjectManager_S_withGeneralization_CMap_CLogicalPixel_CZoom_CZoom_COptional_CStringPtr = _lookup<ffi.NativeFunction<_CMapObjectManager Function(_CMap, _CLogicalPixel, _CZoom, _CZoom, _COptional_CString)>>('CMapObjectManager_S_withGeneralization_CMap_CLogicalPixel_CZoom_CZoom_COptional_CString');
late final _CMapObjectManager_S_withGeneralization_CMap_CLogicalPixel_CZoom_CZoom_COptional_CString = _CMapObjectManager_S_withGeneralization_CMap_CLogicalPixel_CZoom_CZoom_COptional_CStringPtr.asFunction<_CMapObjectManager Function(_CMap, _CLogicalPixel, _CZoom, _CZoom, _COptional_CString)>();
late final _CMapObjectManager_addObject_CSimpleMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapObjectManager, _CSimpleMapObject)>>('CMapObjectManager_addObject_CSimpleMapObject');
late final _CMapObjectManager_addObject_CSimpleMapObject = _CMapObjectManager_addObject_CSimpleMapObjectPtr.asFunction<void Function(_CMapObjectManager, _CSimpleMapObject)>();
late final _CMapObjectManager_removeObject_CSimpleMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapObjectManager, _CSimpleMapObject)>>('CMapObjectManager_removeObject_CSimpleMapObject');
late final _CMapObjectManager_removeObject_CSimpleMapObject = _CMapObjectManager_removeObject_CSimpleMapObjectPtr.asFunction<void Function(_CMapObjectManager, _CSimpleMapObject)>();
late final _CMapObjectManager_addObjects_CArray_CSimpleMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapObjectManager, _CArray_CSimpleMapObject)>>('CMapObjectManager_addObjects_CArray_CSimpleMapObject');
late final _CMapObjectManager_addObjects_CArray_CSimpleMapObject = _CMapObjectManager_addObjects_CArray_CSimpleMapObjectPtr.asFunction<void Function(_CMapObjectManager, _CArray_CSimpleMapObject)>();
late final _CMapObjectManager_removeObjects_CArray_CSimpleMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapObjectManager, _CArray_CSimpleMapObject)>>('CMapObjectManager_removeObjects_CArray_CSimpleMapObject');
late final _CMapObjectManager_removeObjects_CArray_CSimpleMapObject = _CMapObjectManager_removeObjects_CArray_CSimpleMapObjectPtr.asFunction<void Function(_CMapObjectManager, _CArray_CSimpleMapObject)>();
late final _CMapObjectManager_removeAndAddObjects_CArray_CSimpleMapObject_CArray_CSimpleMapObjectPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapObjectManager, _CArray_CSimpleMapObject, _CArray_CSimpleMapObject)>>('CMapObjectManager_removeAndAddObjects_CArray_CSimpleMapObject_CArray_CSimpleMapObject');
late final _CMapObjectManager_removeAndAddObjects_CArray_CSimpleMapObject_CArray_CSimpleMapObject = _CMapObjectManager_removeAndAddObjects_CArray_CSimpleMapObject_CArray_CSimpleMapObjectPtr.asFunction<void Function(_CMapObjectManager, _CArray_CSimpleMapObject, _CArray_CSimpleMapObject)>();
late final _CMapObjectManager_removeAllPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapObjectManager)>>('CMapObjectManager_removeAll');
late final _CMapObjectManager_removeAll = _CMapObjectManager_removeAllPtr.asFunction<void Function(_CMapObjectManager)>();
late final _CMapObjectManager_clusteringObjects_CCameraPositionPtr = _lookup<ffi.NativeFunction<_CArray_CMapObject Function(_CMapObjectManager, _CCameraPosition)>>('CMapObjectManager_clusteringObjects_CCameraPosition');
late final _CMapObjectManager_clusteringObjects_CCameraPosition = _CMapObjectManager_clusteringObjects_CCameraPositionPtr.asFunction<_CArray_CMapObject Function(_CMapObjectManager, _CCameraPosition)>();
late final _CMapObjectManager_C_createWith_CMap_COptional_CStringPtr = _lookup<ffi.NativeFunction<_CMapObjectManager Function(_CMap, _COptional_CString)>>('CMapObjectManager_C_createWith_CMap_COptional_CString');
late final _CMapObjectManager_C_createWith_CMap_COptional_CString = _CMapObjectManager_C_createWith_CMap_COptional_CStringPtr.asFunction<_CMapObjectManager Function(_CMap, _COptional_CString)>();

late final _CMapObjectManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapObjectManager_release');
late final _CMapObjectManager_release = _CMapObjectManager_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapObjectManager_retainPtr = _lookup<ffi.NativeFunction<_CMapObjectManager Function(ffi.Pointer<ffi.Void>)>>('CMapObjectManager_retain');
late final _CMapObjectManager_retain = _CMapObjectManager_retainPtr.asFunction<_CMapObjectManager Function(ffi.Pointer<ffi.Void>)>();
late final _CMapObjectManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapObjectManager Function()>>('CMapObjectManagerMakeDefault');
late final _CMapObjectManagerMakeDefault = _CMapObjectManagerMakeDefaultPtr.asFunction<_CMapObjectManager Function()>();


late final _CArray_CSimpleMapObjectmakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CSimpleMapObject Function()>>('CArray_CSimpleMapObject_makeEmpty');
late final _CArray_CSimpleMapObjectmakeEmpty = _CArray_CSimpleMapObjectmakeEmptyPtr.asFunction<_CArray_CSimpleMapObject Function()>();
late final _CArray_CSimpleMapObjectaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSimpleMapObject, _CSimpleMapObject)>>('CArray_CSimpleMapObject_addElement');
late final _CArray_CSimpleMapObjectaddElement = _CArray_CSimpleMapObjectaddElementPtr.asFunction<void Function(_CArray_CSimpleMapObject, _CSimpleMapObject)>();
late final _forEach_CArray_CSimpleMapObjectPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CSimpleMapObject, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSimpleMapObject)>>)
>>('CArray_CSimpleMapObject_forEachWithFunctionPointer');
late final _forEach_CArray_CSimpleMapObject = _forEach_CArray_CSimpleMapObjectPtr.asFunction<
  void Function(_CArray_CSimpleMapObject, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CSimpleMapObject)
>>)>();
late final _CArray_CSimpleMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CSimpleMapObject)>>('CArray_CSimpleMapObject_release');
late final _CArray_CSimpleMapObject_release = _CArray_CSimpleMapObject_releasePtr.asFunction<void Function(_CArray_CSimpleMapObject)>();

late final _CSimpleClusterRendererCpp_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSimpleClusterRendererCpp_cg_objectIdentifier');
late final _CSimpleClusterRendererCpp_cg_objectIdentifier = _CSimpleClusterRendererCpp_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSimpleClusterRendererCpp_renderCluster_CSimpleClusterObjectPtr = _lookup<ffi.NativeFunction<_CSimpleClusterOptions Function(_CSimpleClusterRendererCpp, _CSimpleClusterObject)>>('CSimpleClusterRendererCpp_renderCluster_CSimpleClusterObject');
late final _CSimpleClusterRendererCpp_renderCluster_CSimpleClusterObject = _CSimpleClusterRendererCpp_renderCluster_CSimpleClusterObjectPtr.asFunction<_CSimpleClusterOptions Function(_CSimpleClusterRendererCpp, _CSimpleClusterObject)>();

late final _CSimpleClusterRendererCpp_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSimpleClusterRendererCpp_release');
late final _CSimpleClusterRendererCpp_release = _CSimpleClusterRendererCpp_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSimpleClusterRendererCpp_retainPtr = _lookup<ffi.NativeFunction<_CSimpleClusterRendererCpp Function(ffi.Pointer<ffi.Void>)>>('CSimpleClusterRendererCpp_retain');
late final _CSimpleClusterRendererCpp_retain = _CSimpleClusterRendererCpp_retainPtr.asFunction<_CSimpleClusterRendererCpp Function(ffi.Pointer<ffi.Void>)>();
late final _CSimpleClusterRendererCppMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSimpleClusterRendererCpp Function()>>('CSimpleClusterRendererCppMakeDefault');
late final _CSimpleClusterRendererCppMakeDefault = _CSimpleClusterRendererCppMakeDefaultPtr.asFunction<_CSimpleClusterRendererCpp Function()>();


late final _COptional_CImageMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CImage Function()>>('COptional_CImageMakeDefault');
late final _COptional_CImageMakeDefault = _COptional_CImageMakeDefaultPtr.asFunction<_COptional_CImage Function()>();

late final _COptional_CImage_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CImage)>>('COptional_CImage_release');
late final _COptional_CImage_release = _COptional_CImage_releasePtr.asFunction<void Function(_COptional_CImage)>();

late final _COptional_CMapDirectionMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CMapDirection Function()>>('COptional_CMapDirectionMakeDefault');
late final _COptional_CMapDirectionMakeDefault = _COptional_CMapDirectionMakeDefaultPtr.asFunction<_COptional_CMapDirection Function()>();

late final _COptional_CTextStyleMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CTextStyle Function()>>('COptional_CTextStyleMakeDefault');
late final _COptional_CTextStyleMakeDefault = _COptional_CTextStyleMakeDefaultPtr.asFunction<_COptional_CTextStyle Function()>();

late final _COptional_CTextStyle_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CTextStyle)>>('COptional_CTextStyle_release');
late final _COptional_CTextStyle_release = _COptional_CTextStyle_releasePtr.asFunction<void Function(_COptional_CTextStyle)>();

late final _CSimpleClusterOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSimpleClusterOptions Function()>>('CSimpleClusterOptionsMakeDefault');
late final _CSimpleClusterOptionsMakeDefault = _CSimpleClusterOptionsMakeDefaultPtr.asFunction<_CSimpleClusterOptions Function()>();

late final _CSimpleClusterObject_positionPtr = _lookup<ffi.NativeFunction<_CGeoPointWithElevation Function(_CSimpleClusterObject)>>('CSimpleClusterObject_position');
late final _CSimpleClusterObject_position = _CSimpleClusterObject_positionPtr.asFunction<_CGeoPointWithElevation Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_objectCountPtr = _lookup<ffi.NativeFunction<ffi.Uint32 Function(_CSimpleClusterObject)>>('CSimpleClusterObject_objectCount');
late final _CSimpleClusterObject_objectCount = _CSimpleClusterObject_objectCountPtr.asFunction<int Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_objectsPtr = _lookup<ffi.NativeFunction<_CArray_CSimpleMapObject Function(_CSimpleClusterObject)>>('CSimpleClusterObject_objects');
late final _CSimpleClusterObject_objects = _CSimpleClusterObject_objectsPtr.asFunction<_CArray_CSimpleMapObject Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_anchorPtr = _lookup<ffi.NativeFunction<_CAnchor Function(_CSimpleClusterObject)>>('CSimpleClusterObject_anchor');
late final _CSimpleClusterObject_anchor = _CSimpleClusterObject_anchorPtr.asFunction<_CAnchor Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_setAnchor_CAnchorPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleClusterObject, _CAnchor)>>('CSimpleClusterObject_setAnchor_CAnchor');
late final _CSimpleClusterObject_setAnchor_CAnchor = _CSimpleClusterObject_setAnchor_CAnchorPtr.asFunction<void Function(_CSimpleClusterObject, _CAnchor)>();
late final _CSimpleClusterObject_iconOpacityPtr = _lookup<ffi.NativeFunction<_COpacity Function(_CSimpleClusterObject)>>('CSimpleClusterObject_iconOpacity');
late final _CSimpleClusterObject_iconOpacity = _CSimpleClusterObject_iconOpacityPtr.asFunction<_COpacity Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_setIconOpacity_COpacityPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleClusterObject, _COpacity)>>('CSimpleClusterObject_setIconOpacity_COpacity');
late final _CSimpleClusterObject_setIconOpacity_COpacity = _CSimpleClusterObject_setIconOpacity_COpacityPtr.asFunction<void Function(_CSimpleClusterObject, _COpacity)>();
late final _CSimpleClusterObject_textPtr = _lookup<ffi.NativeFunction<_CString Function(_CSimpleClusterObject)>>('CSimpleClusterObject_text');
late final _CSimpleClusterObject_text = _CSimpleClusterObject_textPtr.asFunction<_CString Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_setText_CStringPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleClusterObject, _CString)>>('CSimpleClusterObject_setText_CString');
late final _CSimpleClusterObject_setText_CString = _CSimpleClusterObject_setText_CStringPtr.asFunction<void Function(_CSimpleClusterObject, _CString)>();
late final _CSimpleClusterObject_textStylePtr = _lookup<ffi.NativeFunction<_CTextStyle Function(_CSimpleClusterObject)>>('CSimpleClusterObject_textStyle');
late final _CSimpleClusterObject_textStyle = _CSimpleClusterObject_textStylePtr.asFunction<_CTextStyle Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_setTextStyle_CTextStylePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleClusterObject, _CTextStyle)>>('CSimpleClusterObject_setTextStyle_CTextStyle');
late final _CSimpleClusterObject_setTextStyle_CTextStyle = _CSimpleClusterObject_setTextStyle_CTextStylePtr.asFunction<void Function(_CSimpleClusterObject, _CTextStyle)>();
late final _CSimpleClusterObject_iconWidthPtr = _lookup<ffi.NativeFunction<_CLogicalPixel Function(_CSimpleClusterObject)>>('CSimpleClusterObject_iconWidth');
late final _CSimpleClusterObject_iconWidth = _CSimpleClusterObject_iconWidthPtr.asFunction<_CLogicalPixel Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_setIconWidth_CLogicalPixelPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleClusterObject, _CLogicalPixel)>>('CSimpleClusterObject_setIconWidth_CLogicalPixel');
late final _CSimpleClusterObject_setIconWidth_CLogicalPixel = _CSimpleClusterObject_setIconWidth_CLogicalPixelPtr.asFunction<void Function(_CSimpleClusterObject, _CLogicalPixel)>();
late final _CSimpleClusterObject_iconMapDirectionPtr = _lookup<ffi.NativeFunction<_COptional_CMapDirection Function(_CSimpleClusterObject)>>('CSimpleClusterObject_iconMapDirection');
late final _CSimpleClusterObject_iconMapDirection = _CSimpleClusterObject_iconMapDirectionPtr.asFunction<_COptional_CMapDirection Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_setIconMapDirection_COptional_CMapDirectionPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleClusterObject, _COptional_CMapDirection)>>('CSimpleClusterObject_setIconMapDirection_COptional_CMapDirection');
late final _CSimpleClusterObject_setIconMapDirection_COptional_CMapDirection = _CSimpleClusterObject_setIconMapDirection_COptional_CMapDirectionPtr.asFunction<void Function(_CSimpleClusterObject, _COptional_CMapDirection)>();
late final _CSimpleClusterObject_animatedAppearancePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CSimpleClusterObject)>>('CSimpleClusterObject_animatedAppearance');
late final _CSimpleClusterObject_animatedAppearance = _CSimpleClusterObject_animatedAppearancePtr.asFunction<bool Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_setAnimatedAppearance_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleClusterObject, ffi.Bool)>>('CSimpleClusterObject_setAnimatedAppearance_bool');
late final _CSimpleClusterObject_setAnimatedAppearance_bool = _CSimpleClusterObject_setAnimatedAppearance_boolPtr.asFunction<void Function(_CSimpleClusterObject, bool)>();
late final _CSimpleClusterObject_zIndexPtr = _lookup<ffi.NativeFunction<_CZIndex Function(_CSimpleClusterObject)>>('CSimpleClusterObject_zIndex');
late final _CSimpleClusterObject_zIndex = _CSimpleClusterObject_zIndexPtr.asFunction<_CZIndex Function(_CSimpleClusterObject)>();
late final _CSimpleClusterObject_setZIndex_CZIndexPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleClusterObject, _CZIndex)>>('CSimpleClusterObject_setZIndex_CZIndex');
late final _CSimpleClusterObject_setZIndex_CZIndex = _CSimpleClusterObject_setZIndex_CZIndexPtr.asFunction<void Function(_CSimpleClusterObject, _CZIndex)>();

late final _CSimpleClusterObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CSimpleClusterObject_cg_objectIdentifier');
late final _CSimpleClusterObject_cg_objectIdentifier = _CSimpleClusterObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CSimpleClusterObject_setIcon_COptional_CImagePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleClusterObject, _COptional_CImage)>>('CSimpleClusterObject_setIcon_COptional_CImage');
late final _CSimpleClusterObject_setIcon_COptional_CImage = _CSimpleClusterObject_setIcon_COptional_CImagePtr.asFunction<void Function(_CSimpleClusterObject, _COptional_CImage)>();

late final _CSimpleClusterObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CSimpleClusterObject_release');
late final _CSimpleClusterObject_release = _CSimpleClusterObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CSimpleClusterObject_retainPtr = _lookup<ffi.NativeFunction<_CSimpleClusterObject Function(ffi.Pointer<ffi.Void>)>>('CSimpleClusterObject_retain');
late final _CSimpleClusterObject_retain = _CSimpleClusterObject_retainPtr.asFunction<_CSimpleClusterObject Function(ffi.Pointer<ffi.Void>)>();
late final _CSimpleClusterObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSimpleClusterObject Function()>>('CSimpleClusterObjectMakeDefault');
late final _CSimpleClusterObjectMakeDefault = _CSimpleClusterObjectMakeDefaultPtr.asFunction<_CSimpleClusterObject Function()>();


late final _CSimpleClusterRendererMakeDefaultPtr = _lookup<ffi.NativeFunction<_CSimpleClusterRenderer Function()>>('CSimpleClusterRendererMakeDefault');
late final _CSimpleClusterRendererMakeDefault = _CSimpleClusterRendererMakeDefaultPtr.asFunction<_CSimpleClusterRenderer Function()>();
late final _CSimpleClusterRenderer_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CSimpleClusterRenderer)>>('CSimpleClusterRenderer_release');
late final _CSimpleClusterRenderer_release = _CSimpleClusterRenderer_releasePtr.asFunction<void Function(_CSimpleClusterRenderer)>();
late final _CMarker_positionPtr = _lookup<ffi.NativeFunction<_CGeoPointWithElevation Function(_CMarker)>>('CMarker_position');
late final _CMarker_position = _CMarker_positionPtr.asFunction<_CGeoPointWithElevation Function(_CMarker)>();
late final _CMarker_setPosition_CGeoPointWithElevationPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, _CGeoPointWithElevation)>>('CMarker_setPosition_CGeoPointWithElevation');
late final _CMarker_setPosition_CGeoPointWithElevation = _CMarker_setPosition_CGeoPointWithElevationPtr.asFunction<void Function(_CMarker, _CGeoPointWithElevation)>();
late final _CMarker_iconPtr = _lookup<ffi.NativeFunction<_COptional_CImage Function(_CMarker)>>('CMarker_icon');
late final _CMarker_icon = _CMarker_iconPtr.asFunction<_COptional_CImage Function(_CMarker)>();
late final _CMarker_setIcon_COptional_CImagePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, _COptional_CImage)>>('CMarker_setIcon_COptional_CImage');
late final _CMarker_setIcon_COptional_CImage = _CMarker_setIcon_COptional_CImagePtr.asFunction<void Function(_CMarker, _COptional_CImage)>();
late final _CMarker_anchorPtr = _lookup<ffi.NativeFunction<_CAnchor Function(_CMarker)>>('CMarker_anchor');
late final _CMarker_anchor = _CMarker_anchorPtr.asFunction<_CAnchor Function(_CMarker)>();
late final _CMarker_setAnchor_CAnchorPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, _CAnchor)>>('CMarker_setAnchor_CAnchor');
late final _CMarker_setAnchor_CAnchor = _CMarker_setAnchor_CAnchorPtr.asFunction<void Function(_CMarker, _CAnchor)>();
late final _CMarker_iconOpacityPtr = _lookup<ffi.NativeFunction<_COpacity Function(_CMarker)>>('CMarker_iconOpacity');
late final _CMarker_iconOpacity = _CMarker_iconOpacityPtr.asFunction<_COpacity Function(_CMarker)>();
late final _CMarker_setIconOpacity_COpacityPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, _COpacity)>>('CMarker_setIconOpacity_COpacity');
late final _CMarker_setIconOpacity_COpacity = _CMarker_setIconOpacity_COpacityPtr.asFunction<void Function(_CMarker, _COpacity)>();
late final _CMarker_textPtr = _lookup<ffi.NativeFunction<_CString Function(_CMarker)>>('CMarker_text');
late final _CMarker_text = _CMarker_textPtr.asFunction<_CString Function(_CMarker)>();
late final _CMarker_setText_CStringPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, _CString)>>('CMarker_setText_CString');
late final _CMarker_setText_CString = _CMarker_setText_CStringPtr.asFunction<void Function(_CMarker, _CString)>();
late final _CMarker_textStylePtr = _lookup<ffi.NativeFunction<_CTextStyle Function(_CMarker)>>('CMarker_textStyle');
late final _CMarker_textStyle = _CMarker_textStylePtr.asFunction<_CTextStyle Function(_CMarker)>();
late final _CMarker_setTextStyle_CTextStylePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, _CTextStyle)>>('CMarker_setTextStyle_CTextStyle');
late final _CMarker_setTextStyle_CTextStyle = _CMarker_setTextStyle_CTextStylePtr.asFunction<void Function(_CMarker, _CTextStyle)>();
late final _CMarker_isDraggablePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CMarker)>>('CMarker_isDraggable');
late final _CMarker_isDraggable = _CMarker_isDraggablePtr.asFunction<bool Function(_CMarker)>();
late final _CMarker_setDraggable_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, ffi.Bool)>>('CMarker_setDraggable_bool');
late final _CMarker_setDraggable_bool = _CMarker_setDraggable_boolPtr.asFunction<void Function(_CMarker, bool)>();
late final _CMarker_iconWidthPtr = _lookup<ffi.NativeFunction<_CLogicalPixel Function(_CMarker)>>('CMarker_iconWidth');
late final _CMarker_iconWidth = _CMarker_iconWidthPtr.asFunction<_CLogicalPixel Function(_CMarker)>();
late final _CMarker_setIconWidth_CLogicalPixelPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, _CLogicalPixel)>>('CMarker_setIconWidth_CLogicalPixel');
late final _CMarker_setIconWidth_CLogicalPixel = _CMarker_setIconWidth_CLogicalPixelPtr.asFunction<void Function(_CMarker, _CLogicalPixel)>();
late final _CMarker_iconMapDirectionPtr = _lookup<ffi.NativeFunction<_COptional_CMapDirection Function(_CMarker)>>('CMarker_iconMapDirection');
late final _CMarker_iconMapDirection = _CMarker_iconMapDirectionPtr.asFunction<_COptional_CMapDirection Function(_CMarker)>();
late final _CMarker_setIconMapDirection_COptional_CMapDirectionPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, _COptional_CMapDirection)>>('CMarker_setIconMapDirection_COptional_CMapDirection');
late final _CMarker_setIconMapDirection_COptional_CMapDirection = _CMarker_setIconMapDirection_COptional_CMapDirectionPtr.asFunction<void Function(_CMarker, _COptional_CMapDirection)>();
late final _CMarker_animatedAppearancePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CMarker)>>('CMarker_animatedAppearance');
late final _CMarker_animatedAppearance = _CMarker_animatedAppearancePtr.asFunction<bool Function(_CMarker)>();
late final _CMarker_setAnimatedAppearance_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, ffi.Bool)>>('CMarker_setAnimatedAppearance_bool');
late final _CMarker_setAnimatedAppearance_bool = _CMarker_setAnimatedAppearance_boolPtr.asFunction<void Function(_CMarker, bool)>();
late final _CMarker_iconAnimationModePtr = _lookup<ffi.NativeFunction<_CAnimationMode Function(_CMarker)>>('CMarker_iconAnimationMode');
late final _CMarker_iconAnimationMode = _CMarker_iconAnimationModePtr.asFunction<_CAnimationMode Function(_CMarker)>();
late final _CMarker_setIconAnimationMode_CAnimationModePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMarker, _CAnimationMode)>>('CMarker_setIconAnimationMode_CAnimationMode');
late final _CMarker_setIconAnimationMode_CAnimationMode = _CMarker_setIconAnimationMode_CAnimationModePtr.asFunction<void Function(_CMarker, _CAnimationMode)>();

late final _CMarker_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMarker_cg_objectIdentifier');
late final _CMarker_cg_objectIdentifier = _CMarker_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMarker_C_createWith_CMarkerOptionsPtr = _lookup<ffi.NativeFunction<_CResult_CMarker Function(_CMarkerOptions)>>('CMarker_C_createWith_CMarkerOptions');
late final _CMarker_C_createWith_CMarkerOptions = _CMarker_C_createWith_CMarkerOptionsPtr.asFunction<_CResult_CMarker Function(_CMarkerOptions)>();

late final _CMarker_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMarker_release');
late final _CMarker_release = _CMarker_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMarker_retainPtr = _lookup<ffi.NativeFunction<_CMarker Function(ffi.Pointer<ffi.Void>)>>('CMarker_retain');
late final _CMarker_retain = _CMarker_retainPtr.asFunction<_CMarker Function(ffi.Pointer<ffi.Void>)>();
late final _CMarkerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMarker Function()>>('CMarkerMakeDefault');
late final _CMarkerMakeDefault = _CMarkerMakeDefaultPtr.asFunction<_CMarker Function()>();


late final _CMarkerOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMarkerOptions Function()>>('CMarkerOptionsMakeDefault');
late final _CMarkerOptionsMakeDefault = _CMarkerOptionsMakeDefaultPtr.asFunction<_CMarkerOptions Function()>();


late final _CResult_CMarker_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CMarker)>>('CResult_CMarker_release');
late final _CResult_CMarker_release = _CResult_CMarker_releasePtr.asFunction<void Function(_CResult_CMarker)>();

late final _CModelDataLoaderCpp_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CModelDataLoaderCpp_cg_objectIdentifier');
late final _CModelDataLoaderCpp_cg_objectIdentifier = _CModelDataLoaderCpp_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CModelDataLoaderCpp_loadPtr = _lookup<ffi.NativeFunction<_CData Function(_CModelDataLoaderCpp)>>('CModelDataLoaderCpp_load');
late final _CModelDataLoaderCpp_load = _CModelDataLoaderCpp_loadPtr.asFunction<_CData Function(_CModelDataLoaderCpp)>();

late final _CModelDataLoaderCpp_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CModelDataLoaderCpp_release');
late final _CModelDataLoaderCpp_release = _CModelDataLoaderCpp_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CModelDataLoaderCpp_retainPtr = _lookup<ffi.NativeFunction<_CModelDataLoaderCpp Function(ffi.Pointer<ffi.Void>)>>('CModelDataLoaderCpp_retain');
late final _CModelDataLoaderCpp_retain = _CModelDataLoaderCpp_retainPtr.asFunction<_CModelDataLoaderCpp Function(ffi.Pointer<ffi.Void>)>();
late final _CModelDataLoaderCppMakeDefaultPtr = _lookup<ffi.NativeFunction<_CModelDataLoaderCpp Function()>>('CModelDataLoaderCppMakeDefault');
late final _CModelDataLoaderCppMakeDefault = _CModelDataLoaderCppMakeDefaultPtr.asFunction<_CModelDataLoaderCpp Function()>();


late final _CModelDataLoaderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CModelDataLoader Function()>>('CModelDataLoaderMakeDefault');
late final _CModelDataLoaderMakeDefault = _CModelDataLoaderMakeDefaultPtr.asFunction<_CModelDataLoader Function()>();
late final _CModelDataLoader_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CModelDataLoader)>>('CModelDataLoader_release');
late final _CModelDataLoader_release = _CModelDataLoader_releasePtr.asFunction<void Function(_CModelDataLoader)>();

late final _CModelSize_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CModelSize)>>('CModelSize_release');
late final _CModelSize_release = _CModelSize_releasePtr.asFunction<void Function(_CModelSize)>();
late final _CModelSizeMakeDefaultPtr = _lookup<ffi.NativeFunction<_CModelSize Function()>>('CModelSizeMakeDefault');
late final _CModelSizeMakeDefault = _CModelSizeMakeDefaultPtr.asFunction<_CModelSize Function()>();

late final _CModelMapObjectOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CModelMapObjectOptions Function()>>('CModelMapObjectOptionsMakeDefault');
late final _CModelMapObjectOptionsMakeDefault = _CModelMapObjectOptionsMakeDefaultPtr.asFunction<_CModelMapObjectOptions Function()>();

late final _CModelMapObject_positionPtr = _lookup<ffi.NativeFunction<_CGeoPointWithElevation Function(_CModelMapObject)>>('CModelMapObject_position');
late final _CModelMapObject_position = _CModelMapObject_positionPtr.asFunction<_CGeoPointWithElevation Function(_CModelMapObject)>();
late final _CModelMapObject_setPosition_CGeoPointWithElevationPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CModelMapObject, _CGeoPointWithElevation)>>('CModelMapObject_setPosition_CGeoPointWithElevation');
late final _CModelMapObject_setPosition_CGeoPointWithElevation = _CModelMapObject_setPosition_CGeoPointWithElevationPtr.asFunction<void Function(_CModelMapObject, _CGeoPointWithElevation)>();
late final _CModelMapObject_modelDataPtr = _lookup<ffi.NativeFunction<_COptional_CModelData Function(_CModelMapObject)>>('CModelMapObject_modelData');
late final _CModelMapObject_modelData = _CModelMapObject_modelDataPtr.asFunction<_COptional_CModelData Function(_CModelMapObject)>();
late final _CModelMapObject_setModelData_COptional_CModelDataPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CModelMapObject, _COptional_CModelData)>>('CModelMapObject_setModelData_COptional_CModelData');
late final _CModelMapObject_setModelData_COptional_CModelData = _CModelMapObject_setModelData_COptional_CModelDataPtr.asFunction<void Function(_CModelMapObject, _COptional_CModelData)>();
late final _CModelMapObject_opacityPtr = _lookup<ffi.NativeFunction<_COpacity Function(_CModelMapObject)>>('CModelMapObject_opacity');
late final _CModelMapObject_opacity = _CModelMapObject_opacityPtr.asFunction<_COpacity Function(_CModelMapObject)>();
late final _CModelMapObject_setOpacity_COpacityPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CModelMapObject, _COpacity)>>('CModelMapObject_setOpacity_COpacity');
late final _CModelMapObject_setOpacity_COpacity = _CModelMapObject_setOpacity_COpacityPtr.asFunction<void Function(_CModelMapObject, _COpacity)>();
late final _CModelMapObject_sizePtr = _lookup<ffi.NativeFunction<_CModelSize Function(_CModelMapObject)>>('CModelMapObject_size');
late final _CModelMapObject_size = _CModelMapObject_sizePtr.asFunction<_CModelSize Function(_CModelMapObject)>();
late final _CModelMapObject_setSize_CModelSizePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CModelMapObject, _CModelSize)>>('CModelMapObject_setSize_CModelSize');
late final _CModelMapObject_setSize_CModelSize = _CModelMapObject_setSize_CModelSizePtr.asFunction<void Function(_CModelMapObject, _CModelSize)>();
late final _CModelMapObject_mapDirectionPtr = _lookup<ffi.NativeFunction<_COptional_CMapDirection Function(_CModelMapObject)>>('CModelMapObject_mapDirection');
late final _CModelMapObject_mapDirection = _CModelMapObject_mapDirectionPtr.asFunction<_COptional_CMapDirection Function(_CModelMapObject)>();
late final _CModelMapObject_setMapDirection_COptional_CMapDirectionPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CModelMapObject, _COptional_CMapDirection)>>('CModelMapObject_setMapDirection_COptional_CMapDirection');
late final _CModelMapObject_setMapDirection_COptional_CMapDirection = _CModelMapObject_setMapDirection_COptional_CMapDirectionPtr.asFunction<void Function(_CModelMapObject, _COptional_CMapDirection)>();
late final _CModelMapObject_animationSettingsPtr = _lookup<ffi.NativeFunction<_CAnimationSettings Function(_CModelMapObject)>>('CModelMapObject_animationSettings');
late final _CModelMapObject_animationSettings = _CModelMapObject_animationSettingsPtr.asFunction<_CAnimationSettings Function(_CModelMapObject)>();

late final _CModelMapObject_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CModelMapObject_cg_objectIdentifier');
late final _CModelMapObject_cg_objectIdentifier = _CModelMapObject_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CModelMapObject_C_createWith_CModelMapObjectOptionsPtr = _lookup<ffi.NativeFunction<_CResult_CModelMapObject Function(_CModelMapObjectOptions)>>('CModelMapObject_C_createWith_CModelMapObjectOptions');
late final _CModelMapObject_C_createWith_CModelMapObjectOptions = _CModelMapObject_C_createWith_CModelMapObjectOptionsPtr.asFunction<_CResult_CModelMapObject Function(_CModelMapObjectOptions)>();

late final _CModelMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CModelMapObject_release');
late final _CModelMapObject_release = _CModelMapObject_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CModelMapObject_retainPtr = _lookup<ffi.NativeFunction<_CModelMapObject Function(ffi.Pointer<ffi.Void>)>>('CModelMapObject_retain');
late final _CModelMapObject_retain = _CModelMapObject_retainPtr.asFunction<_CModelMapObject Function(ffi.Pointer<ffi.Void>)>();
late final _CModelMapObjectMakeDefaultPtr = _lookup<ffi.NativeFunction<_CModelMapObject Function()>>('CModelMapObjectMakeDefault');
late final _CModelMapObjectMakeDefault = _CModelMapObjectMakeDefaultPtr.asFunction<_CModelMapObject Function()>();


late final _CResult_CModelMapObject_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CModelMapObject)>>('CResult_CModelMapObject_release');
late final _CResult_CModelMapObject_release = _CResult_CModelMapObject_releasePtr.asFunction<void Function(_CResult_CModelMapObject)>();
late final _CFunction_G_createModelData_With_CContext_CModelDataLoaderPtr = _lookup<ffi.NativeFunction<_CModelData Function(_CContext, _CModelDataLoader)>>('CFunction_G_createModelData_With_CContext_CModelDataLoader');
late final _CFunction_G_createModelData_With_CContext_CModelDataLoader = _CFunction_G_createModelData_With_CContext_CModelDataLoaderPtr.asFunction<_CModelData Function(_CContext, _CModelDataLoader)>();
late final _CFunction_G_parseGeoJsonFile_With_CStringPtr = _lookup<ffi.NativeFunction<_CArray_CGeometryMapObject Function(_CString)>>('CFunction_G_parseGeoJsonFile_With_CString');
late final _CFunction_G_parseGeoJsonFile_With_CString = _CFunction_G_parseGeoJsonFile_With_CStringPtr.asFunction<_CArray_CGeometryMapObject Function(_CString)>();
late final _CFunction_G_parseGeoJson_With_CStringPtr = _lookup<ffi.NativeFunction<_CArray_CGeometryMapObject Function(_CString)>>('CFunction_G_parseGeoJson_With_CString');
late final _CFunction_G_parseGeoJson_With_CString = _CFunction_G_parseGeoJson_With_CStringPtr.asFunction<_CArray_CGeometryMapObject Function(_CString)>();
late final _CFunction_G_calcPositionForGeometry_With_CBaseCamera_CGeometry_COptional_CStyleZoomToTiltRelation_COptional_CPadding_COptional_CTilt_COptional_CBearing_COptional_CScreenSizePtr = _lookup<ffi.NativeFunction<_CCameraPosition Function(_CBaseCamera, _CGeometry, _COptional_CStyleZoomToTiltRelation, _COptional_CPadding, _COptional_CTilt, _COptional_CBearing, _COptional_CScreenSize)>>('CFunction_G_calcPositionForGeometry_With_CBaseCamera_CGeometry_COptional_CStyleZoomToTiltRelation_COptional_CPadding_COptional_CTilt_COptional_CBearing_COptional_CScreenSize');
late final _CFunction_G_calcPositionForGeometry_With_CBaseCamera_CGeometry_COptional_CStyleZoomToTiltRelation_COptional_CPadding_COptional_CTilt_COptional_CBearing_COptional_CScreenSize = _CFunction_G_calcPositionForGeometry_With_CBaseCamera_CGeometry_COptional_CStyleZoomToTiltRelation_COptional_CPadding_COptional_CTilt_COptional_CBearing_COptional_CScreenSizePtr.asFunction<_CCameraPosition Function(_CBaseCamera, _CGeometry, _COptional_CStyleZoomToTiltRelation, _COptional_CPadding, _COptional_CTilt, _COptional_CBearing, _COptional_CScreenSize)>();

late final _COptional_CPaddingMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CPadding Function()>>('COptional_CPaddingMakeDefault');
late final _COptional_CPaddingMakeDefault = _COptional_CPaddingMakeDefaultPtr.asFunction<_COptional_CPadding Function()>();

late final _COptional_CScreenSizeMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CScreenSize Function()>>('COptional_CScreenSizeMakeDefault');
late final _COptional_CScreenSizeMakeDefault = _COptional_CScreenSizeMakeDefaultPtr.asFunction<_COptional_CScreenSize Function()>();
late final _CFunction_G_calcPositionForObjects_With_CBaseCamera_CArray_CSimpleMapObject_COptional_CStyleZoomToTiltRelation_COptional_CPadding_COptional_CTilt_COptional_CBearing_COptional_CScreenSizePtr = _lookup<ffi.NativeFunction<_CCameraPosition Function(_CBaseCamera, _CArray_CSimpleMapObject, _COptional_CStyleZoomToTiltRelation, _COptional_CPadding, _COptional_CTilt, _COptional_CBearing, _COptional_CScreenSize)>>('CFunction_G_calcPositionForObjects_With_CBaseCamera_CArray_CSimpleMapObject_COptional_CStyleZoomToTiltRelation_COptional_CPadding_COptional_CTilt_COptional_CBearing_COptional_CScreenSize');
late final _CFunction_G_calcPositionForObjects_With_CBaseCamera_CArray_CSimpleMapObject_COptional_CStyleZoomToTiltRelation_COptional_CPadding_COptional_CTilt_COptional_CBearing_COptional_CScreenSize = _CFunction_G_calcPositionForObjects_With_CBaseCamera_CArray_CSimpleMapObject_COptional_CStyleZoomToTiltRelation_COptional_CPadding_COptional_CTilt_COptional_CBearing_COptional_CScreenSizePtr.asFunction<_CCameraPosition Function(_CBaseCamera, _CArray_CSimpleMapObject, _COptional_CStyleZoomToTiltRelation, _COptional_CPadding, _COptional_CTilt, _COptional_CBearing, _COptional_CScreenSize)>();
late final _CFunction_G_zoomOutToFitForGeometry_With_CBaseCamera_CGeometry_COptional_CStyleZoomToTiltRelation_COptional_CScreenSizePtr = _lookup<ffi.NativeFunction<_CCameraPosition Function(_CBaseCamera, _CGeometry, _COptional_CStyleZoomToTiltRelation, _COptional_CScreenSize)>>('CFunction_G_zoomOutToFitForGeometry_With_CBaseCamera_CGeometry_COptional_CStyleZoomToTiltRelation_COptional_CScreenSize');
late final _CFunction_G_zoomOutToFitForGeometry_With_CBaseCamera_CGeometry_COptional_CStyleZoomToTiltRelation_COptional_CScreenSize = _CFunction_G_zoomOutToFitForGeometry_With_CBaseCamera_CGeometry_COptional_CStyleZoomToTiltRelation_COptional_CScreenSizePtr.asFunction<_CCameraPosition Function(_CBaseCamera, _CGeometry, _COptional_CStyleZoomToTiltRelation, _COptional_CScreenSize)>();
late final _CFunction_G_zoomOutToFitForObjects_With_CBaseCamera_CArray_CSimpleMapObject_COptional_CStyleZoomToTiltRelation_COptional_CScreenSizePtr = _lookup<ffi.NativeFunction<_CCameraPosition Function(_CBaseCamera, _CArray_CSimpleMapObject, _COptional_CStyleZoomToTiltRelation, _COptional_CScreenSize)>>('CFunction_G_zoomOutToFitForObjects_With_CBaseCamera_CArray_CSimpleMapObject_COptional_CStyleZoomToTiltRelation_COptional_CScreenSize');
late final _CFunction_G_zoomOutToFitForObjects_With_CBaseCamera_CArray_CSimpleMapObject_COptional_CStyleZoomToTiltRelation_COptional_CScreenSize = _CFunction_G_zoomOutToFitForObjects_With_CBaseCamera_CArray_CSimpleMapObject_COptional_CStyleZoomToTiltRelation_COptional_CScreenSizePtr.asFunction<_CCameraPosition Function(_CBaseCamera, _CArray_CSimpleMapObject, _COptional_CStyleZoomToTiltRelation, _COptional_CScreenSize)>();
late final _CFunction_G_createImage_With_CContext_CImageLoaderPtr = _lookup<ffi.NativeFunction<_CImage Function(_CContext, _CImageLoader)>>('CFunction_G_createImage_With_CContext_CImageLoader');
late final _CFunction_G_createImage_With_CContext_CImageLoader = _CFunction_G_createImage_With_CContext_CImageLoaderPtr.asFunction<_CImage Function(_CContext, _CImageLoader)>();
late final _CFunction_G_createDefaultMaxTiltRestrictionPtr = _lookup<ffi.NativeFunction<_CStyleZoomToTiltRelation Function()>>('CFunction_G_createDefaultMaxTiltRestriction');
late final _CFunction_G_createDefaultMaxTiltRestriction = _CFunction_G_createDefaultMaxTiltRestrictionPtr.asFunction<_CStyleZoomToTiltRelation Function()>();
late final _CFunction_G_createDefaultStyleZoomToTiltRelationPtr = _lookup<ffi.NativeFunction<_CStyleZoomToTiltRelation Function()>>('CFunction_G_createDefaultStyleZoomToTiltRelation');
late final _CFunction_G_createDefaultStyleZoomToTiltRelation = _CFunction_G_createDefaultStyleZoomToTiltRelationPtr.asFunction<_CStyleZoomToTiltRelation Function()>();
late final _CFunction_G_createStyleZoomToTiltRelation_With_CDictionary_CStyleZoom_CTiltPtr = _lookup<ffi.NativeFunction<_CStyleZoomToTiltRelation Function(_CDictionary_CStyleZoom_CTilt)>>('CFunction_G_createStyleZoomToTiltRelation_With_CDictionary_CStyleZoom_CTilt');
late final _CFunction_G_createStyleZoomToTiltRelation_With_CDictionary_CStyleZoom_CTilt = _CFunction_G_createStyleZoomToTiltRelation_With_CDictionary_CStyleZoom_CTiltPtr.asFunction<_CStyleZoomToTiltRelation Function(_CDictionary_CStyleZoom_CTilt)>();

late final _CDictionary_CStyleZoom_CTiltmakeEmptyPtr = _lookup<ffi.NativeFunction<_CDictionary_CStyleZoom_CTilt Function()>>('CDictionary_CStyleZoom_CTilt_makeEmpty');
late final _CDictionary_CStyleZoom_CTiltmakeEmpty = _CDictionary_CStyleZoom_CTiltmakeEmptyPtr.asFunction<_CDictionary_CStyleZoom_CTilt Function()>();
late final _CDictionary_CStyleZoom_CTiltaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CDictionary_CStyleZoom_CTilt, _CStyleZoom, _CTilt)>>('CDictionary_CStyleZoom_CTilt_addElement');
late final _CDictionary_CStyleZoom_CTiltaddElement = _CDictionary_CStyleZoom_CTiltaddElementPtr.asFunction<void Function(_CDictionary_CStyleZoom_CTilt, _CStyleZoom, _CTilt)>();
late final _forEach_CDictionary_CStyleZoom_CTiltPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CDictionary_CStyleZoom_CTilt, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CStyleZoom, _CTilt)>>)
>>('CDictionary_CStyleZoom_CTilt_forEachKeyValueWithFunctionPointer');
late final _forEach_CDictionary_CStyleZoom_CTilt = _forEach_CDictionary_CStyleZoom_CTiltPtr.asFunction<
  void Function(_CDictionary_CStyleZoom_CTilt, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CStyleZoom, _CTilt)
>>)>();
late final _CDictionary_CStyleZoom_CTilt_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CDictionary_CStyleZoom_CTilt)>>('CDictionary_CStyleZoom_CTilt_release');
late final _CDictionary_CStyleZoom_CTilt_release = _CDictionary_CStyleZoom_CTilt_releasePtr.asFunction<void Function(_CDictionary_CStyleZoom_CTilt)>();
late final _CFunction_G_projectionZToStyleZ_With_CZoom_CLatitudePtr = _lookup<ffi.NativeFunction<_CStyleZoom Function(_CZoom, _CLatitude)>>('CFunction_G_projectionZToStyleZ_With_CZoom_CLatitude');
late final _CFunction_G_projectionZToStyleZ_With_CZoom_CLatitude = _CFunction_G_projectionZToStyleZ_With_CZoom_CLatitudePtr.asFunction<_CStyleZoom Function(_CZoom, _CLatitude)>();
late final _CFunction_G_styleZToProjectionZ_With_CStyleZoom_CLatitudePtr = _lookup<ffi.NativeFunction<_CZoom Function(_CStyleZoom, _CLatitude)>>('CFunction_G_styleZToProjectionZ_With_CStyleZoom_CLatitude');
late final _CFunction_G_styleZToProjectionZ_With_CStyleZoom_CLatitude = _CFunction_G_styleZToProjectionZ_With_CStyleZoom_CLatitudePtr.asFunction<_CZoom Function(_CStyleZoom, _CLatitude)>();

late final _CDashedStrokeCircleOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDashedStrokeCircleOptions Function()>>('CDashedStrokeCircleOptionsMakeDefault');
late final _CDashedStrokeCircleOptionsMakeDefault = _CDashedStrokeCircleOptionsMakeDefaultPtr.asFunction<_CDashedStrokeCircleOptions Function()>();

late final _CCircle_positionPtr = _lookup<ffi.NativeFunction<_CGeoPoint Function(_CCircle)>>('CCircle_position');
late final _CCircle_position = _CCircle_positionPtr.asFunction<_CGeoPoint Function(_CCircle)>();
late final _CCircle_setPosition_CGeoPointPtr = _lookup<ffi.NativeFunction<_CResult_CEmpty Function(_CCircle, _CGeoPoint)>>('CCircle_setPosition_CGeoPoint');
late final _CCircle_setPosition_CGeoPoint = _CCircle_setPosition_CGeoPointPtr.asFunction<_CResult_CEmpty Function(_CCircle, _CGeoPoint)>();
late final _CCircle_radiusPtr = _lookup<ffi.NativeFunction<_CMeter Function(_CCircle)>>('CCircle_radius');
late final _CCircle_radius = _CCircle_radiusPtr.asFunction<_CMeter Function(_CCircle)>();
late final _CCircle_setRadius_CMeterPtr = _lookup<ffi.NativeFunction<_CResult_CEmpty Function(_CCircle, _CMeter)>>('CCircle_setRadius_CMeter');
late final _CCircle_setRadius_CMeter = _CCircle_setRadius_CMeterPtr.asFunction<_CResult_CEmpty Function(_CCircle, _CMeter)>();
late final _CCircle_colorPtr = _lookup<ffi.NativeFunction<_CColor Function(_CCircle)>>('CCircle_color');
late final _CCircle_color = _CCircle_colorPtr.asFunction<_CColor Function(_CCircle)>();
late final _CCircle_setColor_CColorPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCircle, _CColor)>>('CCircle_setColor_CColor');
late final _CCircle_setColor_CColor = _CCircle_setColor_CColorPtr.asFunction<void Function(_CCircle, _CColor)>();
late final _CCircle_strokeWidthPtr = _lookup<ffi.NativeFunction<_CLogicalPixel Function(_CCircle)>>('CCircle_strokeWidth');
late final _CCircle_strokeWidth = _CCircle_strokeWidthPtr.asFunction<_CLogicalPixel Function(_CCircle)>();
late final _CCircle_setStrokeWidth_CLogicalPixelPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCircle, _CLogicalPixel)>>('CCircle_setStrokeWidth_CLogicalPixel');
late final _CCircle_setStrokeWidth_CLogicalPixel = _CCircle_setStrokeWidth_CLogicalPixelPtr.asFunction<void Function(_CCircle, _CLogicalPixel)>();
late final _CCircle_strokeColorPtr = _lookup<ffi.NativeFunction<_CColor Function(_CCircle)>>('CCircle_strokeColor');
late final _CCircle_strokeColor = _CCircle_strokeColorPtr.asFunction<_CColor Function(_CCircle)>();
late final _CCircle_setStrokeColor_CColorPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCircle, _CColor)>>('CCircle_setStrokeColor_CColor');
late final _CCircle_setStrokeColor_CColor = _CCircle_setStrokeColor_CColorPtr.asFunction<void Function(_CCircle, _CColor)>();
late final _CCircle_dashedStrokeOptionsPtr = _lookup<ffi.NativeFunction<_COptional_CDashedStrokeCircleOptions Function(_CCircle)>>('CCircle_dashedStrokeOptions');
late final _CCircle_dashedStrokeOptions = _CCircle_dashedStrokeOptionsPtr.asFunction<_COptional_CDashedStrokeCircleOptions Function(_CCircle)>();
late final _CCircle_setDashedStrokeOptions_COptional_CDashedStrokeCircleOptionsPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCircle, _COptional_CDashedStrokeCircleOptions)>>('CCircle_setDashedStrokeOptions_COptional_CDashedStrokeCircleOptions');
late final _CCircle_setDashedStrokeOptions_COptional_CDashedStrokeCircleOptions = _CCircle_setDashedStrokeOptions_COptional_CDashedStrokeCircleOptionsPtr.asFunction<void Function(_CCircle, _COptional_CDashedStrokeCircleOptions)>();

late final _CCircle_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCircle_cg_objectIdentifier');
late final _CCircle_cg_objectIdentifier = _CCircle_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CCircle_C_createWith_CCircleOptionsPtr = _lookup<ffi.NativeFunction<_CResult_CCircle Function(_CCircleOptions)>>('CCircle_C_createWith_CCircleOptions');
late final _CCircle_C_createWith_CCircleOptions = _CCircle_C_createWith_CCircleOptionsPtr.asFunction<_CResult_CCircle Function(_CCircleOptions)>();

late final _CCircle_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCircle_release');
late final _CCircle_release = _CCircle_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCircle_retainPtr = _lookup<ffi.NativeFunction<_CCircle Function(ffi.Pointer<ffi.Void>)>>('CCircle_retain');
late final _CCircle_retain = _CCircle_retainPtr.asFunction<_CCircle Function(ffi.Pointer<ffi.Void>)>();
late final _CCircleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCircle Function()>>('CCircleMakeDefault');
late final _CCircleMakeDefault = _CCircleMakeDefaultPtr.asFunction<_CCircle Function()>();


late final _COptional_CDashedStrokeCircleOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CDashedStrokeCircleOptions Function()>>('COptional_CDashedStrokeCircleOptionsMakeDefault');
late final _COptional_CDashedStrokeCircleOptionsMakeDefault = _COptional_CDashedStrokeCircleOptionsMakeDefaultPtr.asFunction<_COptional_CDashedStrokeCircleOptions Function()>();

late final _CCircleOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCircleOptions Function()>>('CCircleOptionsMakeDefault');
late final _CCircleOptionsMakeDefault = _CCircleOptionsMakeDefaultPtr.asFunction<_CCircleOptions Function()>();


late final _CResult_CCircle_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CCircle)>>('CResult_CCircle_release');
late final _CResult_CCircle_release = _CResult_CCircle_releasePtr.asFunction<void Function(_CResult_CCircle)>();
late final _CPolygon_contoursPtr = _lookup<ffi.NativeFunction<_CArray_CArray_CGeoPoint Function(_CPolygon)>>('CPolygon_contours');
late final _CPolygon_contours = _CPolygon_contoursPtr.asFunction<_CArray_CArray_CGeoPoint Function(_CPolygon)>();
late final _CPolygon_setContours_CArray_CArray_CGeoPointPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPolygon, _CArray_CArray_CGeoPoint)>>('CPolygon_setContours_CArray_CArray_CGeoPoint');
late final _CPolygon_setContours_CArray_CArray_CGeoPoint = _CPolygon_setContours_CArray_CArray_CGeoPointPtr.asFunction<void Function(_CPolygon, _CArray_CArray_CGeoPoint)>();
late final _CPolygon_colorPtr = _lookup<ffi.NativeFunction<_CColor Function(_CPolygon)>>('CPolygon_color');
late final _CPolygon_color = _CPolygon_colorPtr.asFunction<_CColor Function(_CPolygon)>();
late final _CPolygon_setColor_CColorPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPolygon, _CColor)>>('CPolygon_setColor_CColor');
late final _CPolygon_setColor_CColor = _CPolygon_setColor_CColorPtr.asFunction<void Function(_CPolygon, _CColor)>();
late final _CPolygon_strokeWidthPtr = _lookup<ffi.NativeFunction<_CLogicalPixel Function(_CPolygon)>>('CPolygon_strokeWidth');
late final _CPolygon_strokeWidth = _CPolygon_strokeWidthPtr.asFunction<_CLogicalPixel Function(_CPolygon)>();
late final _CPolygon_setStrokeWidth_CLogicalPixelPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPolygon, _CLogicalPixel)>>('CPolygon_setStrokeWidth_CLogicalPixel');
late final _CPolygon_setStrokeWidth_CLogicalPixel = _CPolygon_setStrokeWidth_CLogicalPixelPtr.asFunction<void Function(_CPolygon, _CLogicalPixel)>();
late final _CPolygon_strokeColorPtr = _lookup<ffi.NativeFunction<_CColor Function(_CPolygon)>>('CPolygon_strokeColor');
late final _CPolygon_strokeColor = _CPolygon_strokeColorPtr.asFunction<_CColor Function(_CPolygon)>();
late final _CPolygon_setStrokeColor_CColorPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPolygon, _CColor)>>('CPolygon_setStrokeColor_CColor');
late final _CPolygon_setStrokeColor_CColor = _CPolygon_setStrokeColor_CColorPtr.asFunction<void Function(_CPolygon, _CColor)>();

late final _CPolygon_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPolygon_cg_objectIdentifier');
late final _CPolygon_cg_objectIdentifier = _CPolygon_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPolygon_C_createWith_CPolygonOptionsPtr = _lookup<ffi.NativeFunction<_CResult_CPolygon Function(_CPolygonOptions)>>('CPolygon_C_createWith_CPolygonOptions');
late final _CPolygon_C_createWith_CPolygonOptions = _CPolygon_C_createWith_CPolygonOptionsPtr.asFunction<_CResult_CPolygon Function(_CPolygonOptions)>();

late final _CPolygon_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPolygon_release');
late final _CPolygon_release = _CPolygon_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPolygon_retainPtr = _lookup<ffi.NativeFunction<_CPolygon Function(ffi.Pointer<ffi.Void>)>>('CPolygon_retain');
late final _CPolygon_retain = _CPolygon_retainPtr.asFunction<_CPolygon Function(ffi.Pointer<ffi.Void>)>();
late final _CPolygonMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPolygon Function()>>('CPolygonMakeDefault');
late final _CPolygonMakeDefault = _CPolygonMakeDefaultPtr.asFunction<_CPolygon Function()>();


late final _CPolygonOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPolygonOptions Function()>>('CPolygonOptionsMakeDefault');
late final _CPolygonOptionsMakeDefault = _CPolygonOptionsMakeDefaultPtr.asFunction<_CPolygonOptions Function()>();


late final _CResult_CPolygon_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CPolygon)>>('CResult_CPolygon_release');
late final _CResult_CPolygon_release = _CResult_CPolygon_releasePtr.asFunction<void Function(_CResult_CPolygon)>();

late final _CDashedPolylineOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDashedPolylineOptions Function()>>('CDashedPolylineOptionsMakeDefault');
late final _CDashedPolylineOptionsMakeDefault = _CDashedPolylineOptionsMakeDefaultPtr.asFunction<_CDashedPolylineOptions Function()>();


late final _CArray_CColormakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CColor Function()>>('CArray_CColor_makeEmpty');
late final _CArray_CColormakeEmpty = _CArray_CColormakeEmptyPtr.asFunction<_CArray_CColor Function()>();
late final _CArray_CColoraddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CColor, _CColor)>>('CArray_CColor_addElement');
late final _CArray_CColoraddElement = _CArray_CColoraddElementPtr.asFunction<void Function(_CArray_CColor, _CColor)>();
late final _forEach_CArray_CColorPtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CColor, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CColor)>>)
>>('CArray_CColor_forEachWithFunctionPointer');
late final _forEach_CArray_CColor = _forEach_CArray_CColorPtr.asFunction<
  void Function(_CArray_CColor, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CColor)
>>)>();
late final _CArray_CColor_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CColor)>>('CArray_CColor_release');
late final _CArray_CColor_release = _CArray_CColor_releasePtr.asFunction<void Function(_CArray_CColor)>();

late final _CGradientPolylineOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGradientPolylineOptions Function()>>('CGradientPolylineOptionsMakeDefault');
late final _CGradientPolylineOptionsMakeDefault = _CGradientPolylineOptionsMakeDefaultPtr.asFunction<_CGradientPolylineOptions Function()>();

late final _CPolyline_pointsPtr = _lookup<ffi.NativeFunction<_CArray_CGeoPoint Function(_CPolyline)>>('CPolyline_points');
late final _CPolyline_points = _CPolyline_pointsPtr.asFunction<_CArray_CGeoPoint Function(_CPolyline)>();
late final _CPolyline_setPoints_CArray_CGeoPointPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPolyline, _CArray_CGeoPoint)>>('CPolyline_setPoints_CArray_CGeoPoint');
late final _CPolyline_setPoints_CArray_CGeoPoint = _CPolyline_setPoints_CArray_CGeoPointPtr.asFunction<void Function(_CPolyline, _CArray_CGeoPoint)>();
late final _CPolyline_widthPtr = _lookup<ffi.NativeFunction<_CLogicalPixel Function(_CPolyline)>>('CPolyline_width');
late final _CPolyline_width = _CPolyline_widthPtr.asFunction<_CLogicalPixel Function(_CPolyline)>();
late final _CPolyline_setWidth_CLogicalPixelPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPolyline, _CLogicalPixel)>>('CPolyline_setWidth_CLogicalPixel');
late final _CPolyline_setWidth_CLogicalPixel = _CPolyline_setWidth_CLogicalPixelPtr.asFunction<void Function(_CPolyline, _CLogicalPixel)>();
late final _CPolyline_colorPtr = _lookup<ffi.NativeFunction<_CColor Function(_CPolyline)>>('CPolyline_color');
late final _CPolyline_color = _CPolyline_colorPtr.asFunction<_CColor Function(_CPolyline)>();
late final _CPolyline_setColor_CColorPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPolyline, _CColor)>>('CPolyline_setColor_CColor');
late final _CPolyline_setColor_CColor = _CPolyline_setColor_CColorPtr.asFunction<void Function(_CPolyline, _CColor)>();
late final _CPolyline_erasedPartPtr = _lookup<ffi.NativeFunction<ffi.Double Function(_CPolyline)>>('CPolyline_erasedPart');
late final _CPolyline_erasedPart = _CPolyline_erasedPartPtr.asFunction<double Function(_CPolyline)>();
late final _CPolyline_setErasedPart_doublePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPolyline, ffi.Double)>>('CPolyline_setErasedPart_double');
late final _CPolyline_setErasedPart_double = _CPolyline_setErasedPart_doublePtr.asFunction<void Function(_CPolyline, double)>();
late final _CPolyline_dashedPolylineOptionsPtr = _lookup<ffi.NativeFunction<_COptional_CDashedPolylineOptions Function(_CPolyline)>>('CPolyline_dashedPolylineOptions');
late final _CPolyline_dashedPolylineOptions = _CPolyline_dashedPolylineOptionsPtr.asFunction<_COptional_CDashedPolylineOptions Function(_CPolyline)>();
late final _CPolyline_setDashedPolylineOptions_COptional_CDashedPolylineOptionsPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPolyline, _COptional_CDashedPolylineOptions)>>('CPolyline_setDashedPolylineOptions_COptional_CDashedPolylineOptions');
late final _CPolyline_setDashedPolylineOptions_COptional_CDashedPolylineOptions = _CPolyline_setDashedPolylineOptions_COptional_CDashedPolylineOptionsPtr.asFunction<void Function(_CPolyline, _COptional_CDashedPolylineOptions)>();
late final _CPolyline_gradientPolylineOptionsPtr = _lookup<ffi.NativeFunction<_COptional_CGradientPolylineOptions Function(_CPolyline)>>('CPolyline_gradientPolylineOptions');
late final _CPolyline_gradientPolylineOptions = _CPolyline_gradientPolylineOptionsPtr.asFunction<_COptional_CGradientPolylineOptions Function(_CPolyline)>();
late final _CPolyline_setGradientPolylineOptions_COptional_CGradientPolylineOptionsPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPolyline, _COptional_CGradientPolylineOptions)>>('CPolyline_setGradientPolylineOptions_COptional_CGradientPolylineOptions');
late final _CPolyline_setGradientPolylineOptions_COptional_CGradientPolylineOptions = _CPolyline_setGradientPolylineOptions_COptional_CGradientPolylineOptionsPtr.asFunction<void Function(_CPolyline, _COptional_CGradientPolylineOptions)>();

late final _CPolyline_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPolyline_cg_objectIdentifier');
late final _CPolyline_cg_objectIdentifier = _CPolyline_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPolyline_C_createWith_CPolylineOptionsPtr = _lookup<ffi.NativeFunction<_CResult_CPolyline Function(_CPolylineOptions)>>('CPolyline_C_createWith_CPolylineOptions');
late final _CPolyline_C_createWith_CPolylineOptions = _CPolyline_C_createWith_CPolylineOptionsPtr.asFunction<_CResult_CPolyline Function(_CPolylineOptions)>();

late final _CPolyline_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPolyline_release');
late final _CPolyline_release = _CPolyline_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPolyline_retainPtr = _lookup<ffi.NativeFunction<_CPolyline Function(ffi.Pointer<ffi.Void>)>>('CPolyline_retain');
late final _CPolyline_retain = _CPolyline_retainPtr.asFunction<_CPolyline Function(ffi.Pointer<ffi.Void>)>();
late final _CPolylineMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPolyline Function()>>('CPolylineMakeDefault');
late final _CPolylineMakeDefault = _CPolylineMakeDefaultPtr.asFunction<_CPolyline Function()>();


late final _COptional_CDashedPolylineOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CDashedPolylineOptions Function()>>('COptional_CDashedPolylineOptionsMakeDefault');
late final _COptional_CDashedPolylineOptionsMakeDefault = _COptional_CDashedPolylineOptionsMakeDefaultPtr.asFunction<_COptional_CDashedPolylineOptions Function()>();

late final _COptional_CGradientPolylineOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CGradientPolylineOptions Function()>>('COptional_CGradientPolylineOptionsMakeDefault');
late final _COptional_CGradientPolylineOptionsMakeDefault = _COptional_CGradientPolylineOptionsMakeDefaultPtr.asFunction<_COptional_CGradientPolylineOptions Function()>();

late final _COptional_CGradientPolylineOptions_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CGradientPolylineOptions)>>('COptional_CGradientPolylineOptions_release');
late final _COptional_CGradientPolylineOptions_release = _COptional_CGradientPolylineOptions_releasePtr.asFunction<void Function(_COptional_CGradientPolylineOptions)>();

late final _CPolylineOptionsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPolylineOptions Function()>>('CPolylineOptionsMakeDefault');
late final _CPolylineOptionsMakeDefault = _CPolylineOptionsMakeDefaultPtr.asFunction<_CPolylineOptions Function()>();


late final _CResult_CPolyline_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CPolyline)>>('CResult_CPolyline_release');
late final _CResult_CPolyline_release = _CResult_CPolyline_releasePtr.asFunction<void Function(_CResult_CPolyline)>();

late final _CCameraFollowStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCameraFollowState Function()>>('CCameraFollowStateMakeDefault');
late final _CCameraFollowStateMakeDefault = _CCameraFollowStateMakeDefaultPtr.asFunction<_CCameraFollowState Function()>();
late final _CMyLocationControlModel_isEnabledChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function(_CMyLocationControlModel)>>('CMyLocationControlModel_isEnabledChannel');
late final _CMyLocationControlModel_isEnabledChannel = _CMyLocationControlModel_isEnabledChannelPtr.asFunction<_CStatefulChannel_bool Function(_CMyLocationControlModel)>();
late final _CMyLocationControlModel_isEnabledPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CMyLocationControlModel)>>('CMyLocationControlModel_isEnabled');
late final _CMyLocationControlModel_isEnabled = _CMyLocationControlModel_isEnabledPtr.asFunction<bool Function(_CMyLocationControlModel)>();
late final _CMyLocationControlModel_followStateChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraFollowState Function(_CMyLocationControlModel)>>('CMyLocationControlModel_followStateChannel');
late final _CMyLocationControlModel_followStateChannel = _CMyLocationControlModel_followStateChannelPtr.asFunction<_CStatefulChannel_CCameraFollowState Function(_CMyLocationControlModel)>();
late final _CMyLocationControlModel_followStatePtr = _lookup<ffi.NativeFunction<_CCameraFollowState Function(_CMyLocationControlModel)>>('CMyLocationControlModel_followState');
late final _CMyLocationControlModel_followState = _CMyLocationControlModel_followStatePtr.asFunction<_CCameraFollowState Function(_CMyLocationControlModel)>();

late final _CMyLocationControlModel_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMyLocationControlModel_cg_objectIdentifier');
late final _CMyLocationControlModel_cg_objectIdentifier = _CMyLocationControlModel_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMyLocationControlModel_onClickedPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMyLocationControlModel)>>('CMyLocationControlModel_onClicked');
late final _CMyLocationControlModel_onClicked = _CMyLocationControlModel_onClickedPtr.asFunction<void Function(_CMyLocationControlModel)>();
late final _CMyLocationControlModel_C_createWith_CMapPtr = _lookup<ffi.NativeFunction<_CMyLocationControlModel Function(_CMap)>>('CMyLocationControlModel_C_createWith_CMap');
late final _CMyLocationControlModel_C_createWith_CMap = _CMyLocationControlModel_C_createWith_CMapPtr.asFunction<_CMyLocationControlModel Function(_CMap)>();

late final _CMyLocationControlModel_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMyLocationControlModel_release');
late final _CMyLocationControlModel_release = _CMyLocationControlModel_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMyLocationControlModel_retainPtr = _lookup<ffi.NativeFunction<_CMyLocationControlModel Function(ffi.Pointer<ffi.Void>)>>('CMyLocationControlModel_retain');
late final _CMyLocationControlModel_retain = _CMyLocationControlModel_retainPtr.asFunction<_CMyLocationControlModel Function(ffi.Pointer<ffi.Void>)>();
late final _CMyLocationControlModelMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMyLocationControlModel Function()>>('CMyLocationControlModelMakeDefault');
late final _CMyLocationControlModelMakeDefault = _CMyLocationControlModelMakeDefaultPtr.asFunction<_CMyLocationControlModel Function()>();


late final _CStatefulChannel_CCameraFollowStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraFollowState Function()>>('CStatefulChannel_CCameraFollowStateMakeDefault');
late final _CStatefulChannel_CCameraFollowStateMakeDefault = _CStatefulChannel_CCameraFollowStateMakeDefaultPtr.asFunction<_CStatefulChannel_CCameraFollowState Function()>();
late final _CStatefulChannel_CCameraFollowState_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CCameraFollowState)>>('CStatefulChannel_CCameraFollowState_release');
late final _CStatefulChannel_CCameraFollowState_release = _CStatefulChannel_CCameraFollowState_releasePtr.asFunction<void Function(_CStatefulChannel_CCameraFollowState)>();
late final _CStatefulChannel_CCameraFollowState_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CCameraFollowState Function(_CStatefulChannel_CCameraFollowState)>>('CStatefulChannel_CCameraFollowState_retain');
late final _CStatefulChannel_CCameraFollowState_retain = _CStatefulChannel_CCameraFollowState_retainPtr.asFunction<_CStatefulChannel_CCameraFollowState Function(_CStatefulChannel_CCameraFollowState)>();
late final _CStatefulChannel_CCameraFollowStateGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CCameraFollowState Function(_CStatefulChannel_CCameraFollowState)>>('CStatefulChannel_CCameraFollowState_getCurrentValue');
late final _CStatefulChannel_CCameraFollowStateGetCurrentValue = _CStatefulChannel_CCameraFollowStateGetCurrentValuePtr.asFunction<_CCameraFollowState Function(_CStatefulChannel_CCameraFollowState)>();
late final _CStatefulChannel_CCameraFollowStateConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraFollowState,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraFollowState, ffi.Int64)>>
  )
>>('CStatefulChannel_CCameraFollowState_connect');
late final _CStatefulChannel_CCameraFollowStateConnect = _CStatefulChannel_CCameraFollowStateConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CCameraFollowState,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CCameraFollowState, ffi.Int64)>>
  )
>();
late final _CCompassControlModel_bearingChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CBearing Function(_CCompassControlModel)>>('CCompassControlModel_bearingChannel');
late final _CCompassControlModel_bearingChannel = _CCompassControlModel_bearingChannelPtr.asFunction<_CStatefulChannel_CBearing Function(_CCompassControlModel)>();
late final _CCompassControlModel_bearingPtr = _lookup<ffi.NativeFunction<_CBearing Function(_CCompassControlModel)>>('CCompassControlModel_bearing');
late final _CCompassControlModel_bearing = _CCompassControlModel_bearingPtr.asFunction<_CBearing Function(_CCompassControlModel)>();

late final _CCompassControlModel_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CCompassControlModel_cg_objectIdentifier');
late final _CCompassControlModel_cg_objectIdentifier = _CCompassControlModel_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CCompassControlModel_onClickedPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CCompassControlModel)>>('CCompassControlModel_onClicked');
late final _CCompassControlModel_onClicked = _CCompassControlModel_onClickedPtr.asFunction<void Function(_CCompassControlModel)>();
late final _CCompassControlModel_C_createWith_CMapPtr = _lookup<ffi.NativeFunction<_CCompassControlModel Function(_CMap)>>('CCompassControlModel_C_createWith_CMap');
late final _CCompassControlModel_C_createWith_CMap = _CCompassControlModel_C_createWith_CMapPtr.asFunction<_CCompassControlModel Function(_CMap)>();

late final _CCompassControlModel_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CCompassControlModel_release');
late final _CCompassControlModel_release = _CCompassControlModel_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CCompassControlModel_retainPtr = _lookup<ffi.NativeFunction<_CCompassControlModel Function(ffi.Pointer<ffi.Void>)>>('CCompassControlModel_retain');
late final _CCompassControlModel_retain = _CCompassControlModel_retainPtr.asFunction<_CCompassControlModel Function(ffi.Pointer<ffi.Void>)>();
late final _CCompassControlModelMakeDefaultPtr = _lookup<ffi.NativeFunction<_CCompassControlModel Function()>>('CCompassControlModelMakeDefault');
late final _CCompassControlModelMakeDefault = _CCompassControlModelMakeDefaultPtr.asFunction<_CCompassControlModel Function()>();


late final _CStatefulChannel_CBearingMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CBearing Function()>>('CStatefulChannel_CBearingMakeDefault');
late final _CStatefulChannel_CBearingMakeDefault = _CStatefulChannel_CBearingMakeDefaultPtr.asFunction<_CStatefulChannel_CBearing Function()>();
late final _CStatefulChannel_CBearing_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CBearing)>>('CStatefulChannel_CBearing_release');
late final _CStatefulChannel_CBearing_release = _CStatefulChannel_CBearing_releasePtr.asFunction<void Function(_CStatefulChannel_CBearing)>();
late final _CStatefulChannel_CBearing_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CBearing Function(_CStatefulChannel_CBearing)>>('CStatefulChannel_CBearing_retain');
late final _CStatefulChannel_CBearing_retain = _CStatefulChannel_CBearing_retainPtr.asFunction<_CStatefulChannel_CBearing Function(_CStatefulChannel_CBearing)>();
late final _CStatefulChannel_CBearingGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CBearing Function(_CStatefulChannel_CBearing)>>('CStatefulChannel_CBearing_getCurrentValue');
late final _CStatefulChannel_CBearingGetCurrentValue = _CStatefulChannel_CBearingGetCurrentValuePtr.asFunction<_CBearing Function(_CStatefulChannel_CBearing)>();
late final _CStatefulChannel_CBearingConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CBearing,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CBearing, ffi.Int64)>>
  )
>>('CStatefulChannel_CBearing_connect');
late final _CStatefulChannel_CBearingConnect = _CStatefulChannel_CBearingConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CBearing,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CBearing, ffi.Int64)>>
  )
>();

late final _CZoomControlButtonMakeDefaultPtr = _lookup<ffi.NativeFunction<_CZoomControlButton Function()>>('CZoomControlButtonMakeDefault');
late final _CZoomControlButtonMakeDefault = _CZoomControlButtonMakeDefaultPtr.asFunction<_CZoomControlButton Function()>();

late final _CZoomControlModel_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CZoomControlModel_cg_objectIdentifier');
late final _CZoomControlModel_cg_objectIdentifier = _CZoomControlModel_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CZoomControlModel_isEnabled_CZoomControlButtonPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function(_CZoomControlModel, _CZoomControlButton)>>('CZoomControlModel_isEnabled_CZoomControlButton');
late final _CZoomControlModel_isEnabled_CZoomControlButton = _CZoomControlModel_isEnabled_CZoomControlButtonPtr.asFunction<_CStatefulChannel_bool Function(_CZoomControlModel, _CZoomControlButton)>();
late final _CZoomControlModel_setPressed_CZoomControlButton_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CZoomControlModel, _CZoomControlButton, ffi.Bool)>>('CZoomControlModel_setPressed_CZoomControlButton_bool');
late final _CZoomControlModel_setPressed_CZoomControlButton_bool = _CZoomControlModel_setPressed_CZoomControlButton_boolPtr.asFunction<void Function(_CZoomControlModel, _CZoomControlButton, bool)>();
late final _CZoomControlModel_C_createWith_CMapPtr = _lookup<ffi.NativeFunction<_CZoomControlModel Function(_CMap)>>('CZoomControlModel_C_createWith_CMap');
late final _CZoomControlModel_C_createWith_CMap = _CZoomControlModel_C_createWith_CMapPtr.asFunction<_CZoomControlModel Function(_CMap)>();

late final _CZoomControlModel_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CZoomControlModel_release');
late final _CZoomControlModel_release = _CZoomControlModel_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CZoomControlModel_retainPtr = _lookup<ffi.NativeFunction<_CZoomControlModel Function(ffi.Pointer<ffi.Void>)>>('CZoomControlModel_retain');
late final _CZoomControlModel_retain = _CZoomControlModel_retainPtr.asFunction<_CZoomControlModel Function(ffi.Pointer<ffi.Void>)>();
late final _CZoomControlModelMakeDefaultPtr = _lookup<ffi.NativeFunction<_CZoomControlModel Function()>>('CZoomControlModelMakeDefault');
late final _CZoomControlModelMakeDefault = _CZoomControlModelMakeDefaultPtr.asFunction<_CZoomControlModel Function()>();


late final _CDefaultRasterUrlTemplateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDefaultRasterUrlTemplate Function()>>('CDefaultRasterUrlTemplateMakeDefault');
late final _CDefaultRasterUrlTemplateMakeDefault = _CDefaultRasterUrlTemplateMakeDefaultPtr.asFunction<_CDefaultRasterUrlTemplate Function()>();


late final _CWmsRasterUrlTemplateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CWmsRasterUrlTemplate Function()>>('CWmsRasterUrlTemplateMakeDefault');
late final _CWmsRasterUrlTemplateMakeDefault = _CWmsRasterUrlTemplateMakeDefaultPtr.asFunction<_CWmsRasterUrlTemplate Function()>();


late final _CRasterUrlTemplate_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRasterUrlTemplate)>>('CRasterUrlTemplate_release');
late final _CRasterUrlTemplate_release = _CRasterUrlTemplate_releasePtr.asFunction<void Function(_CRasterUrlTemplate)>();
late final _CRasterUrlTemplateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRasterUrlTemplate Function()>>('CRasterUrlTemplateMakeDefault');
late final _CRasterUrlTemplateMakeDefault = _CRasterUrlTemplateMakeDefaultPtr.asFunction<_CRasterUrlTemplate Function()>();

late final _CRasterTileSource_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRasterTileSource_cg_objectIdentifier');
late final _CRasterTileSource_cg_objectIdentifier = _CRasterTileSource_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRasterTileSource_setOpacity_COpacityPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CRasterTileSource, _COpacity)>>('CRasterTileSource_setOpacity_COpacity');
late final _CRasterTileSource_setOpacity_COpacity = _CRasterTileSource_setOpacity_COpacityPtr.asFunction<void Function(_CRasterTileSource, _COpacity)>();
late final _CRasterTileSource_C_createWith_CContext_CString_CRasterUrlTemplatePtr = _lookup<ffi.NativeFunction<_CRasterTileSource Function(_CContext, _CString, _CRasterUrlTemplate)>>('CRasterTileSource_C_createWith_CContext_CString_CRasterUrlTemplate');
late final _CRasterTileSource_C_createWith_CContext_CString_CRasterUrlTemplate = _CRasterTileSource_C_createWith_CContext_CString_CRasterUrlTemplatePtr.asFunction<_CRasterTileSource Function(_CContext, _CString, _CRasterUrlTemplate)>();

late final _CRasterTileSource_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRasterTileSource_release');
late final _CRasterTileSource_release = _CRasterTileSource_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRasterTileSource_retainPtr = _lookup<ffi.NativeFunction<_CRasterTileSource Function(ffi.Pointer<ffi.Void>)>>('CRasterTileSource_retain');
late final _CRasterTileSource_retain = _CRasterTileSource_retainPtr.asFunction<_CRasterTileSource Function(ffi.Pointer<ffi.Void>)>();
late final _CRasterTileSourceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRasterTileSource Function()>>('CRasterTileSourceMakeDefault');
late final _CRasterTileSourceMakeDefault = _CRasterTileSourceMakeDefaultPtr.asFunction<_CRasterTileSource Function()>();

late final _CParkingControlModel_isEnabledChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_bool Function(_CParkingControlModel)>>('CParkingControlModel_isEnabledChannel');
late final _CParkingControlModel_isEnabledChannel = _CParkingControlModel_isEnabledChannelPtr.asFunction<_CStatefulChannel_bool Function(_CParkingControlModel)>();
late final _CParkingControlModel_isEnabledPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CParkingControlModel)>>('CParkingControlModel_isEnabled');
late final _CParkingControlModel_isEnabled = _CParkingControlModel_isEnabledPtr.asFunction<bool Function(_CParkingControlModel)>();

late final _CParkingControlModel_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CParkingControlModel_cg_objectIdentifier');
late final _CParkingControlModel_cg_objectIdentifier = _CParkingControlModel_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CParkingControlModel_toggleParkingsVisibilityPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CParkingControlModel)>>('CParkingControlModel_toggleParkingsVisibility');
late final _CParkingControlModel_toggleParkingsVisibility = _CParkingControlModel_toggleParkingsVisibilityPtr.asFunction<void Function(_CParkingControlModel)>();
late final _CParkingControlModel_C_createWith_CMapPtr = _lookup<ffi.NativeFunction<_CParkingControlModel Function(_CMap)>>('CParkingControlModel_C_createWith_CMap');
late final _CParkingControlModel_C_createWith_CMap = _CParkingControlModel_C_createWith_CMapPtr.asFunction<_CParkingControlModel Function(_CMap)>();

late final _CParkingControlModel_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CParkingControlModel_release');
late final _CParkingControlModel_release = _CParkingControlModel_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CParkingControlModel_retainPtr = _lookup<ffi.NativeFunction<_CParkingControlModel Function(ffi.Pointer<ffi.Void>)>>('CParkingControlModel_retain');
late final _CParkingControlModel_retain = _CParkingControlModel_retainPtr.asFunction<_CParkingControlModel Function(ffi.Pointer<ffi.Void>)>();
late final _CParkingControlModelMakeDefaultPtr = _lookup<ffi.NativeFunction<_CParkingControlModel Function()>>('CParkingControlModelMakeDefault');
late final _CParkingControlModelMakeDefault = _CParkingControlModelMakeDefaultPtr.asFunction<_CParkingControlModel Function()>();

late final _CPackedMapState_showTrafficPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CPackedMapState)>>('CPackedMapState_showTraffic');
late final _CPackedMapState_showTraffic = _CPackedMapState_showTrafficPtr.asFunction<bool Function(_CPackedMapState)>();
late final _CPackedMapState_setShowTraffic_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPackedMapState, ffi.Bool)>>('CPackedMapState_setShowTraffic_bool');
late final _CPackedMapState_setShowTraffic_bool = _CPackedMapState_setShowTraffic_boolPtr.asFunction<void Function(_CPackedMapState, bool)>();
late final _CPackedMapState_cameraPositionPtr = _lookup<ffi.NativeFunction<_CCameraPosition Function(_CPackedMapState)>>('CPackedMapState_cameraPosition');
late final _CPackedMapState_cameraPosition = _CPackedMapState_cameraPositionPtr.asFunction<_CCameraPosition Function(_CPackedMapState)>();
late final _CPackedMapState_setCameraPosition_CCameraPositionPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPackedMapState, _CCameraPosition)>>('CPackedMapState_setCameraPosition_CCameraPosition');
late final _CPackedMapState_setCameraPosition_CCameraPosition = _CPackedMapState_setCameraPosition_CCameraPositionPtr.asFunction<void Function(_CPackedMapState, _CCameraPosition)>();
late final _CPackedMapState_cameraBehaviourPtr = _lookup<ffi.NativeFunction<_CCameraBehaviour Function(_CPackedMapState)>>('CPackedMapState_cameraBehaviour');
late final _CPackedMapState_cameraBehaviour = _CPackedMapState_cameraBehaviourPtr.asFunction<_CCameraBehaviour Function(_CPackedMapState)>();
late final _CPackedMapState_setCameraBehaviour_CCameraBehaviourPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPackedMapState, _CCameraBehaviour)>>('CPackedMapState_setCameraBehaviour_CCameraBehaviour');
late final _CPackedMapState_setCameraBehaviour_CCameraBehaviour = _CPackedMapState_setCameraBehaviour_CCameraBehaviourPtr.asFunction<void Function(_CPackedMapState, _CCameraBehaviour)>();

late final _CPackedMapState_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPackedMapState_cg_objectIdentifier');
late final _CPackedMapState_cg_objectIdentifier = _CPackedMapState_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPackedMapState_S_of_CCameraPosition_bool_CCameraBehaviourPtr = _lookup<ffi.NativeFunction<_CPackedMapState Function(_CCameraPosition, ffi.Bool, _CCameraBehaviour)>>('CPackedMapState_S_of_CCameraPosition_bool_CCameraBehaviour');
late final _CPackedMapState_S_of_CCameraPosition_bool_CCameraBehaviour = _CPackedMapState_S_of_CCameraPosition_bool_CCameraBehaviourPtr.asFunction<_CPackedMapState Function(_CCameraPosition, bool, _CCameraBehaviour)>();
late final _CPackedMapState_S_fromBytes_CDataPtr = _lookup<ffi.NativeFunction<_CResult_CPackedMapState Function(_CData)>>('CPackedMapState_S_fromBytes_CData');
late final _CPackedMapState_S_fromBytes_CData = _CPackedMapState_S_fromBytes_CDataPtr.asFunction<_CResult_CPackedMapState Function(_CData)>();
late final _CPackedMapState_S_fromMap_CMapPtr = _lookup<ffi.NativeFunction<_CPackedMapState Function(_CMap)>>('CPackedMapState_S_fromMap_CMap');
late final _CPackedMapState_S_fromMap_CMap = _CPackedMapState_S_fromMap_CMapPtr.asFunction<_CPackedMapState Function(_CMap)>();
late final _CPackedMapState_toBytesPtr = _lookup<ffi.NativeFunction<_CData Function(_CPackedMapState)>>('CPackedMapState_toBytes');
late final _CPackedMapState_toBytes = _CPackedMapState_toBytesPtr.asFunction<_CData Function(_CPackedMapState)>();

late final _CPackedMapState_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPackedMapState_release');
late final _CPackedMapState_release = _CPackedMapState_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPackedMapState_retainPtr = _lookup<ffi.NativeFunction<_CPackedMapState Function(ffi.Pointer<ffi.Void>)>>('CPackedMapState_retain');
late final _CPackedMapState_retain = _CPackedMapState_retainPtr.asFunction<_CPackedMapState Function(ffi.Pointer<ffi.Void>)>();
late final _CPackedMapStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPackedMapState Function()>>('CPackedMapStateMakeDefault');
late final _CPackedMapStateMakeDefault = _CPackedMapStateMakeDefaultPtr.asFunction<_CPackedMapState Function()>();


late final _CResult_CPackedMapState_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CResult_CPackedMapState)>>('CResult_CPackedMapState_release');
late final _CResult_CPackedMapState_release = _CResult_CPackedMapState_releasePtr.asFunction<void Function(_CResult_CPackedMapState)>();

late final _CFpsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFps Function()>>('CFpsMakeDefault');
late final _CFpsMakeDefault = _CFpsMakeDefaultPtr.asFunction<_CFps Function()>();

late final _CMapSurfaceProvider_idPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CMapSurfaceProvider)>>('CMapSurfaceProvider_id');
late final _CMapSurfaceProvider_id = _CMapSurfaceProvider_idPtr.asFunction<int Function(_CMapSurfaceProvider)>();

late final _CMapSurfaceProvider_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapSurfaceProvider_cg_objectIdentifier');
late final _CMapSurfaceProvider_cg_objectIdentifier = _CMapSurfaceProvider_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapSurfaceProvider_S_create_CMapPtr = _lookup<ffi.NativeFunction<_CMapSurfaceProvider Function(_CMap)>>('CMapSurfaceProvider_S_create_CMap');
late final _CMapSurfaceProvider_S_create_CMap = _CMapSurfaceProvider_S_create_CMapPtr.asFunction<_CMapSurfaceProvider Function(_CMap)>();
late final _CMapSurfaceProvider_setOffscreenSurface_CScreenSizePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapSurfaceProvider, _CScreenSize)>>('CMapSurfaceProvider_setOffscreenSurface_CScreenSize');
late final _CMapSurfaceProvider_setOffscreenSurface_CScreenSize = _CMapSurfaceProvider_setOffscreenSurface_CScreenSizePtr.asFunction<void Function(_CMapSurfaceProvider, _CScreenSize)>();
late final _CMapSurfaceProvider_destroySurfacePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapSurfaceProvider)>>('CMapSurfaceProvider_destroySurface');
late final _CMapSurfaceProvider_destroySurface = _CMapSurfaceProvider_destroySurfacePtr.asFunction<void Function(_CMapSurfaceProvider)>();
late final _CMapSurfaceProvider_destroySurfaceAsyncPtr = _lookup<ffi.NativeFunction<_CFuture_bool Function(_CMapSurfaceProvider)>>('CMapSurfaceProvider_destroySurfaceAsync');
late final _CMapSurfaceProvider_destroySurfaceAsync = _CMapSurfaceProvider_destroySurfaceAsyncPtr.asFunction<_CFuture_bool Function(_CMapSurfaceProvider)>();
late final _CMapSurfaceProvider_resizeSurface_CScreenSizePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapSurfaceProvider, _CScreenSize)>>('CMapSurfaceProvider_resizeSurface_CScreenSize');
late final _CMapSurfaceProvider_resizeSurface_CScreenSize = _CMapSurfaceProvider_resizeSurface_CScreenSizePtr.asFunction<void Function(_CMapSurfaceProvider, _CScreenSize)>();
late final _CMapSurfaceProvider_setActive_boolPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapSurfaceProvider, ffi.Bool)>>('CMapSurfaceProvider_setActive_bool');
late final _CMapSurfaceProvider_setActive_bool = _CMapSurfaceProvider_setActive_boolPtr.asFunction<void Function(_CMapSurfaceProvider, bool)>();

late final _CMapSurfaceProvider_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapSurfaceProvider_release');
late final _CMapSurfaceProvider_release = _CMapSurfaceProvider_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapSurfaceProvider_retainPtr = _lookup<ffi.NativeFunction<_CMapSurfaceProvider Function(ffi.Pointer<ffi.Void>)>>('CMapSurfaceProvider_retain');
late final _CMapSurfaceProvider_retain = _CMapSurfaceProvider_retainPtr.asFunction<_CMapSurfaceProvider Function(ffi.Pointer<ffi.Void>)>();
late final _CMapSurfaceProviderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapSurfaceProvider Function()>>('CMapSurfaceProviderMakeDefault');
late final _CMapSurfaceProviderMakeDefault = _CMapSurfaceProviderMakeDefaultPtr.asFunction<_CMapSurfaceProvider Function()>();


late final _CFuture_boolMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_bool Function()>>('CFuture_boolMakeDefault');
late final _CFuture_boolMakeDefault = _CFuture_boolMakeDefaultPtr.asFunction<_CFuture_bool Function()>();
late final _CFuture_bool_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_bool)>>('CFuture_bool_release');
late final _CFuture_bool_release = _CFuture_bool_releasePtr.asFunction<void Function(_CFuture_bool)>();
late final _CFuture_bool_retainPtr = _lookup<ffi.NativeFunction<_CFuture_bool Function(_CFuture_bool)>>('CFuture_bool_retain');
late final _CFuture_bool_retain = _CFuture_bool_retainPtr.asFunction<_CFuture_bool Function(_CFuture_bool)>();
late final _CFuture_boolReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_bool,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_bool_receive');
late final _CFuture_boolReceive = _CFuture_boolReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_bool,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();
late final _CMapRenderer_maxFpsPtr = _lookup<ffi.NativeFunction<_COptional_CFps Function(_CMapRenderer)>>('CMapRenderer_maxFps');
late final _CMapRenderer_maxFps = _CMapRenderer_maxFpsPtr.asFunction<_COptional_CFps Function(_CMapRenderer)>();
late final _CMapRenderer_powerSavingMaxFpsPtr = _lookup<ffi.NativeFunction<_COptional_CFps Function(_CMapRenderer)>>('CMapRenderer_powerSavingMaxFps');
late final _CMapRenderer_powerSavingMaxFps = _CMapRenderer_powerSavingMaxFpsPtr.asFunction<_COptional_CFps Function(_CMapRenderer)>();
late final _CMapRenderer_fpsChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CFps Function(_CMapRenderer)>>('CMapRenderer_fpsChannel');
late final _CMapRenderer_fpsChannel = _CMapRenderer_fpsChannelPtr.asFunction<_CStatefulChannel_CFps Function(_CMapRenderer)>();
late final _CMapRenderer_fpsPtr = _lookup<ffi.NativeFunction<_CFps Function(_CMapRenderer)>>('CMapRenderer_fps');
late final _CMapRenderer_fps = _CMapRenderer_fpsPtr.asFunction<_CFps Function(_CMapRenderer)>();

late final _CMapRenderer_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapRenderer_cg_objectIdentifier');
late final _CMapRenderer_cg_objectIdentifier = _CMapRenderer_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapRenderer_S_create_CMapPtr = _lookup<ffi.NativeFunction<_CMapRenderer Function(_CMap)>>('CMapRenderer_S_create_CMap');
late final _CMapRenderer_S_create_CMap = _CMapRenderer_S_create_CMapPtr.asFunction<_CMapRenderer Function(_CMap)>();
late final _CMapRenderer_setMaxFps_COptional_CFps_COptional_CFpsPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapRenderer, _COptional_CFps, _COptional_CFps)>>('CMapRenderer_setMaxFps_COptional_CFps_COptional_CFps');
late final _CMapRenderer_setMaxFps_COptional_CFps_COptional_CFps = _CMapRenderer_setMaxFps_COptional_CFps_COptional_CFpsPtr.asFunction<void Function(_CMapRenderer, _COptional_CFps, _COptional_CFps)>();
late final _CMapRenderer_waitForLoadingPtr = _lookup<ffi.NativeFunction<_CFuture_bool Function(_CMapRenderer)>>('CMapRenderer_waitForLoading');
late final _CMapRenderer_waitForLoading = _CMapRenderer_waitForLoadingPtr.asFunction<_CFuture_bool Function(_CMapRenderer)>();
late final _CMapRenderer_waitForRenderingPtr = _lookup<ffi.NativeFunction<_CFuture_bool Function(_CMapRenderer)>>('CMapRenderer_waitForRendering');
late final _CMapRenderer_waitForRendering = _CMapRenderer_waitForRenderingPtr.asFunction<_CFuture_bool Function(_CMapRenderer)>();
late final _CMapRenderer_takeSnapshot_CAlignmentPtr = _lookup<ffi.NativeFunction<_CFuture_CImageData Function(_CMapRenderer, _CAlignment)>>('CMapRenderer_takeSnapshot_CAlignment');
late final _CMapRenderer_takeSnapshot_CAlignment = _CMapRenderer_takeSnapshot_CAlignmentPtr.asFunction<_CFuture_CImageData Function(_CMapRenderer, _CAlignment)>();

late final _CMapRenderer_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapRenderer_release');
late final _CMapRenderer_release = _CMapRenderer_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapRenderer_retainPtr = _lookup<ffi.NativeFunction<_CMapRenderer Function(ffi.Pointer<ffi.Void>)>>('CMapRenderer_retain');
late final _CMapRenderer_retain = _CMapRenderer_retainPtr.asFunction<_CMapRenderer Function(ffi.Pointer<ffi.Void>)>();
late final _CMapRendererMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapRenderer Function()>>('CMapRendererMakeDefault');
late final _CMapRendererMakeDefault = _CMapRendererMakeDefaultPtr.asFunction<_CMapRenderer Function()>();


late final _COptional_CFpsMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CFps Function()>>('COptional_CFpsMakeDefault');
late final _COptional_CFpsMakeDefault = _COptional_CFpsMakeDefaultPtr.asFunction<_COptional_CFps Function()>();

late final _CStatefulChannel_CFpsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CFps Function()>>('CStatefulChannel_CFpsMakeDefault');
late final _CStatefulChannel_CFpsMakeDefault = _CStatefulChannel_CFpsMakeDefaultPtr.asFunction<_CStatefulChannel_CFps Function()>();
late final _CStatefulChannel_CFps_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CFps)>>('CStatefulChannel_CFps_release');
late final _CStatefulChannel_CFps_release = _CStatefulChannel_CFps_releasePtr.asFunction<void Function(_CStatefulChannel_CFps)>();
late final _CStatefulChannel_CFps_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CFps Function(_CStatefulChannel_CFps)>>('CStatefulChannel_CFps_retain');
late final _CStatefulChannel_CFps_retain = _CStatefulChannel_CFps_retainPtr.asFunction<_CStatefulChannel_CFps Function(_CStatefulChannel_CFps)>();
late final _CStatefulChannel_CFpsGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CFps Function(_CStatefulChannel_CFps)>>('CStatefulChannel_CFps_getCurrentValue');
late final _CStatefulChannel_CFpsGetCurrentValue = _CStatefulChannel_CFpsGetCurrentValuePtr.asFunction<_CFps Function(_CStatefulChannel_CFps)>();
late final _CStatefulChannel_CFpsConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CFps,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CFps, ffi.Int64)>>
  )
>>('CStatefulChannel_CFps_connect');
late final _CStatefulChannel_CFpsConnect = _CStatefulChannel_CFpsConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CFps,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CFps, ffi.Int64)>>
  )
>();

late final _CFuture_CImageDataMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CImageData Function()>>('CFuture_CImageDataMakeDefault');
late final _CFuture_CImageDataMakeDefault = _CFuture_CImageDataMakeDefaultPtr.asFunction<_CFuture_CImageData Function()>();
late final _CFuture_CImageData_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CImageData)>>('CFuture_CImageData_release');
late final _CFuture_CImageData_release = _CFuture_CImageData_releasePtr.asFunction<void Function(_CFuture_CImageData)>();
late final _CFuture_CImageData_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CImageData Function(_CFuture_CImageData)>>('CFuture_CImageData_retain');
late final _CFuture_CImageData_retain = _CFuture_CImageData_retainPtr.asFunction<_CFuture_CImageData Function(_CFuture_CImageData)>();
late final _CFuture_CImageDataReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CImageData,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CImageData, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CImageData_receive');
late final _CFuture_CImageDataReceive = _CFuture_CImageDataReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CImageData,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CImageData, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CMapBuilder_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapBuilder_cg_objectIdentifier');
late final _CMapBuilder_cg_objectIdentifier = _CMapBuilder_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapBuilder_setSize_CScreenSizePtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CScreenSize)>>('CMapBuilder_setSize_CScreenSize');
late final _CMapBuilder_setSize_CScreenSize = _CMapBuilder_setSize_CScreenSizePtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CScreenSize)>();
late final _CMapBuilder_setDevicePpi_CDevicePpi_CDeviceDensityPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CDevicePpi, _CDeviceDensity)>>('CMapBuilder_setDevicePpi_CDevicePpi_CDeviceDensity');
late final _CMapBuilder_setDevicePpi_CDevicePpi_CDeviceDensity = _CMapBuilder_setDevicePpi_CDevicePpi_CDeviceDensityPtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CDevicePpi, _CDeviceDensity)>();
late final _CMapBuilder_setFontIconSizeMultiplier_floatPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, ffi.Float)>>('CMapBuilder_setFontIconSizeMultiplier_float');
late final _CMapBuilder_setFontIconSizeMultiplier_float = _CMapBuilder_setFontIconSizeMultiplier_floatPtr.asFunction<_CMapBuilder Function(_CMapBuilder, double)>();
late final _CMapBuilder_setSystemFontIconSizeMultiplier_floatPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, ffi.Float)>>('CMapBuilder_setSystemFontIconSizeMultiplier_float');
late final _CMapBuilder_setSystemFontIconSizeMultiplier_float = _CMapBuilder_setSystemFontIconSizeMultiplier_floatPtr.asFunction<_CMapBuilder Function(_CMapBuilder, double)>();
late final _CMapBuilder_setStyle_CStylePtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CStyle)>>('CMapBuilder_setStyle_CStyle');
late final _CMapBuilder_setStyle_CStyle = _CMapBuilder_setStyle_CStylePtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CStyle)>();
late final _CMapBuilder_setStyleFromFile_CContext_CFilePtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CContext, _CFile)>>('CMapBuilder_setStyleFromFile_CContext_CFile');
late final _CMapBuilder_setStyleFromFile_CContext_CFile = _CMapBuilder_setStyleFromFile_CContext_CFilePtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CContext, _CFile)>();
late final _CMapBuilder_setPosition_CCameraPositionPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CCameraPosition)>>('CMapBuilder_setPosition_CCameraPosition');
late final _CMapBuilder_setPosition_CCameraPosition = _CMapBuilder_setPosition_CCameraPositionPtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CCameraPosition)>();
late final _CMapBuilder_setZoomRestrictions_CCameraZoomRestrictionsPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CCameraZoomRestrictions)>>('CMapBuilder_setZoomRestrictions_CCameraZoomRestrictions');
late final _CMapBuilder_setZoomRestrictions_CCameraZoomRestrictions = _CMapBuilder_setZoomRestrictions_CCameraZoomRestrictionsPtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CCameraZoomRestrictions)>();
late final _CMapBuilder_setPositionPoint_CCameraPositionPointPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CCameraPositionPoint)>>('CMapBuilder_setPositionPoint_CCameraPositionPoint');
late final _CMapBuilder_setPositionPoint_CCameraPositionPoint = _CMapBuilder_setPositionPoint_CCameraPositionPointPtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CCameraPositionPoint)>();
late final _CMapBuilder_setBehaviour_CCameraBehaviourPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CCameraBehaviour)>>('CMapBuilder_setBehaviour_CCameraBehaviour');
late final _CMapBuilder_setBehaviour_CCameraBehaviour = _CMapBuilder_setBehaviour_CCameraBehaviourPtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CCameraBehaviour)>();
late final _CMapBuilder_setFollowController_CFollowControllerPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CFollowController)>>('CMapBuilder_setFollowController_CFollowController');
late final _CMapBuilder_setFollowController_CFollowController = _CMapBuilder_setFollowController_CFollowControllerPtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CFollowController)>();
late final _CMapBuilder_setAttribute_CString_CAttributeValuePtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CString, _CAttributeValue)>>('CMapBuilder_setAttribute_CString_CAttributeValue');
late final _CMapBuilder_setAttribute_CString_CAttributeValue = _CMapBuilder_setAttribute_CString_CAttributeValuePtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CString, _CAttributeValue)>();
late final _CMapBuilder_setAttributes_CDictionary_CString_CAttributeValuePtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CDictionary_CString_CAttributeValue)>>('CMapBuilder_setAttributes_CDictionary_CString_CAttributeValue');
late final _CMapBuilder_setAttributes_CDictionary_CString_CAttributeValue = _CMapBuilder_setAttributes_CDictionary_CString_CAttributeValuePtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CDictionary_CString_CAttributeValue)>();
late final _CMapBuilder_setBackgroundColor_CColorPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CColor)>>('CMapBuilder_setBackgroundColor_CColor');
late final _CMapBuilder_setBackgroundColor_CColor = _CMapBuilder_setBackgroundColor_CColorPtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CColor)>();
late final _CMapBuilder_setVisibilityState_CMapVisibilityStatePtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CMapVisibilityState)>>('CMapBuilder_setVisibilityState_CMapVisibilityState');
late final _CMapBuilder_setVisibilityState_CMapVisibilityState = _CMapBuilder_setVisibilityState_CMapVisibilityStatePtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CMapVisibilityState)>();
late final _CMapBuilder_setGraphicsPreset_CGraphicsPresetPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CGraphicsPreset)>>('CMapBuilder_setGraphicsPreset_CGraphicsPreset');
late final _CMapBuilder_setGraphicsPreset_CGraphicsPreset = _CMapBuilder_setGraphicsPreset_CGraphicsPresetPtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CGraphicsPreset)>();
late final _CMapBuilder_addSource_CSourcePtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(_CMapBuilder, _CSource)>>('CMapBuilder_addSource_CSource');
late final _CMapBuilder_addSource_CSource = _CMapBuilder_addSource_CSourcePtr.asFunction<_CMapBuilder Function(_CMapBuilder, _CSource)>();
late final _CMapBuilder_createMap_CContextPtr = _lookup<ffi.NativeFunction<_CFuture_CMap Function(_CMapBuilder, _CContext)>>('CMapBuilder_createMap_CContext');
late final _CMapBuilder_createMap_CContext = _CMapBuilder_createMap_CContextPtr.asFunction<_CFuture_CMap Function(_CMapBuilder, _CContext)>();
late final _CMapBuilder_C_createPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function()>>('CMapBuilder_C_create');
late final _CMapBuilder_C_create = _CMapBuilder_C_createPtr.asFunction<_CMapBuilder Function()>();

late final _CMapBuilder_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapBuilder_release');
late final _CMapBuilder_release = _CMapBuilder_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapBuilder_retainPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function(ffi.Pointer<ffi.Void>)>>('CMapBuilder_retain');
late final _CMapBuilder_retain = _CMapBuilder_retainPtr.asFunction<_CMapBuilder Function(ffi.Pointer<ffi.Void>)>();
late final _CMapBuilderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapBuilder Function()>>('CMapBuilderMakeDefault');
late final _CMapBuilderMakeDefault = _CMapBuilderMakeDefaultPtr.asFunction<_CMapBuilder Function()>();


late final _CFuture_CMapMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CMap Function()>>('CFuture_CMapMakeDefault');
late final _CFuture_CMapMakeDefault = _CFuture_CMapMakeDefaultPtr.asFunction<_CFuture_CMap Function()>();
late final _CFuture_CMap_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CMap)>>('CFuture_CMap_release');
late final _CFuture_CMap_release = _CFuture_CMap_releasePtr.asFunction<void Function(_CFuture_CMap)>();
late final _CFuture_CMap_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CMap Function(_CFuture_CMap)>>('CFuture_CMap_retain');
late final _CFuture_CMap_retain = _CFuture_CMap_retainPtr.asFunction<_CFuture_CMap Function(_CFuture_CMap)>();
late final _CFuture_CMapReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CMap,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMap, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CMap_receive');
late final _CFuture_CMapReceive = _CFuture_CMapReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CMap,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CMap, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CStyleBuilder_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CStyleBuilder_cg_objectIdentifier');
late final _CStyleBuilder_cg_objectIdentifier = _CStyleBuilder_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CStyleBuilder_setStyleAttribute_CString_CAttributeValuePtr = _lookup<ffi.NativeFunction<_CStyleBuilder Function(_CStyleBuilder, _CString, _CAttributeValue)>>('CStyleBuilder_setStyleAttribute_CString_CAttributeValue');
late final _CStyleBuilder_setStyleAttribute_CString_CAttributeValue = _CStyleBuilder_setStyleAttribute_CString_CAttributeValuePtr.asFunction<_CStyleBuilder Function(_CStyleBuilder, _CString, _CAttributeValue)>();
late final _CStyleBuilder_getDefaultStylePtr = _lookup<ffi.NativeFunction<_CFuture_CStyle Function(_CStyleBuilder)>>('CStyleBuilder_getDefaultStyle');
late final _CStyleBuilder_getDefaultStyle = _CStyleBuilder_getDefaultStylePtr.asFunction<_CFuture_CStyle Function(_CStyleBuilder)>();
late final _CStyleBuilder_loadStyle_CFilePtr = _lookup<ffi.NativeFunction<_CFuture_CStyle Function(_CStyleBuilder, _CFile)>>('CStyleBuilder_loadStyle_CFile');
late final _CStyleBuilder_loadStyle_CFile = _CStyleBuilder_loadStyle_CFilePtr.asFunction<_CFuture_CStyle Function(_CStyleBuilder, _CFile)>();
late final _CStyleBuilder_C_createWith_CContextPtr = _lookup<ffi.NativeFunction<_CStyleBuilder Function(_CContext)>>('CStyleBuilder_C_createWith_CContext');
late final _CStyleBuilder_C_createWith_CContext = _CStyleBuilder_C_createWith_CContextPtr.asFunction<_CStyleBuilder Function(_CContext)>();

late final _CStyleBuilder_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CStyleBuilder_release');
late final _CStyleBuilder_release = _CStyleBuilder_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CStyleBuilder_retainPtr = _lookup<ffi.NativeFunction<_CStyleBuilder Function(ffi.Pointer<ffi.Void>)>>('CStyleBuilder_retain');
late final _CStyleBuilder_retain = _CStyleBuilder_retainPtr.asFunction<_CStyleBuilder Function(ffi.Pointer<ffi.Void>)>();
late final _CStyleBuilderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStyleBuilder Function()>>('CStyleBuilderMakeDefault');
late final _CStyleBuilderMakeDefault = _CStyleBuilderMakeDefaultPtr.asFunction<_CStyleBuilder Function()>();


late final _CFuture_CStyleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CStyle Function()>>('CFuture_CStyleMakeDefault');
late final _CFuture_CStyleMakeDefault = _CFuture_CStyleMakeDefaultPtr.asFunction<_CFuture_CStyle Function()>();
late final _CFuture_CStyle_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CStyle)>>('CFuture_CStyle_release');
late final _CFuture_CStyle_release = _CFuture_CStyle_releasePtr.asFunction<void Function(_CFuture_CStyle)>();
late final _CFuture_CStyle_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CStyle Function(_CFuture_CStyle)>>('CFuture_CStyle_retain');
late final _CFuture_CStyle_retain = _CFuture_CStyle_retainPtr.asFunction<_CFuture_CStyle Function(_CFuture_CStyle)>();
late final _CFuture_CStyleReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CStyle,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CStyle, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CStyle_receive');
late final _CFuture_CStyleReceive = _CFuture_CStyleReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CStyle,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CStyle, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CRotationCenterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRotationCenter Function()>>('CRotationCenterMakeDefault');
late final _CRotationCenterMakeDefault = _CRotationCenterMakeDefaultPtr.asFunction<_CRotationCenter Function()>();

late final _CScalingCenterMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScalingCenter Function()>>('CScalingCenterMakeDefault');
late final _CScalingCenterMakeDefault = _CScalingCenterMakeDefaultPtr.asFunction<_CScalingCenter Function()>();

late final _CEventsProcessingSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CEventsProcessingSettings Function()>>('CEventsProcessingSettingsMakeDefault');
late final _CEventsProcessingSettingsMakeDefault = _CEventsProcessingSettingsMakeDefaultPtr.asFunction<_CEventsProcessingSettings Function()>();


late final _CDragBeginDataMakeDefaultPtr = _lookup<ffi.NativeFunction<_CDragBeginData Function()>>('CDragBeginDataMakeDefault');
late final _CDragBeginDataMakeDefault = _CDragBeginDataMakeDefaultPtr.asFunction<_CDragBeginData Function()>();


late final _CGestureMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGesture Function()>>('CGestureMakeDefault');
late final _CGestureMakeDefault = _CGestureMakeDefaultPtr.asFunction<_CGesture Function()>();

late final _CScalingSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CScalingSettings Function()>>('CScalingSettingsMakeDefault');
late final _CScalingSettingsMakeDefault = _CScalingSettingsMakeDefaultPtr.asFunction<_CScalingSettings Function()>();


late final _CRotationSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRotationSettings Function()>>('CRotationSettingsMakeDefault');
late final _CRotationSettingsMakeDefault = _CRotationSettingsMakeDefaultPtr.asFunction<_CRotationSettings Function()>();


late final _CMultiTouchShiftSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMultiTouchShiftSettings Function()>>('CMultiTouchShiftSettingsMakeDefault');
late final _CMultiTouchShiftSettingsMakeDefault = _CMultiTouchShiftSettingsMakeDefaultPtr.asFunction<_CMultiTouchShiftSettings Function()>();


late final _CTiltSettingsMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTiltSettings Function()>>('CTiltSettingsMakeDefault');
late final _CTiltSettingsMakeDefault = _CTiltSettingsMakeDefaultPtr.asFunction<_CTiltSettings Function()>();

late final _CGestureManager_enabledGesturesPtr = _lookup<ffi.NativeFunction<_COptionSet_CGesture Function(_CGestureManager)>>('CGestureManager_enabledGestures');
late final _CGestureManager_enabledGestures = _CGestureManager_enabledGesturesPtr.asFunction<_COptionSet_CGesture Function(_CGestureManager)>();
late final _CGestureManager_setEnabledGestures_COptionSet_CGesturePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGestureManager, _COptionSet_CGesture)>>('CGestureManager_setEnabledGestures_COptionSet_CGesture');
late final _CGestureManager_setEnabledGestures_COptionSet_CGesture = _CGestureManager_setEnabledGestures_COptionSet_CGesturePtr.asFunction<void Function(_CGestureManager, _COptionSet_CGesture)>();
late final _CGestureManager_scalingSettingsPtr = _lookup<ffi.NativeFunction<_CScalingSettings Function(_CGestureManager)>>('CGestureManager_scalingSettings');
late final _CGestureManager_scalingSettings = _CGestureManager_scalingSettingsPtr.asFunction<_CScalingSettings Function(_CGestureManager)>();
late final _CGestureManager_setScalingSettings_CScalingSettingsPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGestureManager, _CScalingSettings)>>('CGestureManager_setScalingSettings_CScalingSettings');
late final _CGestureManager_setScalingSettings_CScalingSettings = _CGestureManager_setScalingSettings_CScalingSettingsPtr.asFunction<void Function(_CGestureManager, _CScalingSettings)>();
late final _CGestureManager_rotationSettingsPtr = _lookup<ffi.NativeFunction<_CRotationSettings Function(_CGestureManager)>>('CGestureManager_rotationSettings');
late final _CGestureManager_rotationSettings = _CGestureManager_rotationSettingsPtr.asFunction<_CRotationSettings Function(_CGestureManager)>();
late final _CGestureManager_setRotationSettings_CRotationSettingsPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGestureManager, _CRotationSettings)>>('CGestureManager_setRotationSettings_CRotationSettings');
late final _CGestureManager_setRotationSettings_CRotationSettings = _CGestureManager_setRotationSettings_CRotationSettingsPtr.asFunction<void Function(_CGestureManager, _CRotationSettings)>();
late final _CGestureManager_multitouchShiftSettingsPtr = _lookup<ffi.NativeFunction<_CMultiTouchShiftSettings Function(_CGestureManager)>>('CGestureManager_multitouchShiftSettings');
late final _CGestureManager_multitouchShiftSettings = _CGestureManager_multitouchShiftSettingsPtr.asFunction<_CMultiTouchShiftSettings Function(_CGestureManager)>();
late final _CGestureManager_setMultitouchShiftSettings_CMultiTouchShiftSettingsPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGestureManager, _CMultiTouchShiftSettings)>>('CGestureManager_setMultitouchShiftSettings_CMultiTouchShiftSettings');
late final _CGestureManager_setMultitouchShiftSettings_CMultiTouchShiftSettings = _CGestureManager_setMultitouchShiftSettings_CMultiTouchShiftSettingsPtr.asFunction<void Function(_CGestureManager, _CMultiTouchShiftSettings)>();
late final _CGestureManager_tiltSettingsPtr = _lookup<ffi.NativeFunction<_CTiltSettings Function(_CGestureManager)>>('CGestureManager_tiltSettings');
late final _CGestureManager_tiltSettings = _CGestureManager_tiltSettingsPtr.asFunction<_CTiltSettings Function(_CGestureManager)>();
late final _CGestureManager_setTiltSettings_CTiltSettingsPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGestureManager, _CTiltSettings)>>('CGestureManager_setTiltSettings_CTiltSettings');
late final _CGestureManager_setTiltSettings_CTiltSettings = _CGestureManager_setTiltSettings_CTiltSettingsPtr.asFunction<void Function(_CGestureManager, _CTiltSettings)>();

late final _CGestureManager_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CGestureManager_cg_objectIdentifier');
late final _CGestureManager_cg_objectIdentifier = _CGestureManager_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CGestureManager_enableGesture_CGesturePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGestureManager, _CGesture)>>('CGestureManager_enableGesture_CGesture');
late final _CGestureManager_enableGesture_CGesture = _CGestureManager_enableGesture_CGesturePtr.asFunction<void Function(_CGestureManager, _CGesture)>();
late final _CGestureManager_disableGesture_CGesturePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGestureManager, _CGesture)>>('CGestureManager_disableGesture_CGesture');
late final _CGestureManager_disableGesture_CGesture = _CGestureManager_disableGesture_CGesturePtr.asFunction<void Function(_CGestureManager, _CGesture)>();
late final _CGestureManager_gestureEnabled_CGesturePtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CGestureManager, _CGesture)>>('CGestureManager_gestureEnabled_CGesture');
late final _CGestureManager_gestureEnabled_CGesture = _CGestureManager_gestureEnabled_CGesturePtr.asFunction<bool Function(_CGestureManager, _CGesture)>();
late final _CGestureManager_setSettingsAboutMapPositionPoint_CEventsProcessingSettingsPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGestureManager, _CEventsProcessingSettings)>>('CGestureManager_setSettingsAboutMapPositionPoint_CEventsProcessingSettings');
late final _CGestureManager_setSettingsAboutMapPositionPoint_CEventsProcessingSettings = _CGestureManager_setSettingsAboutMapPositionPoint_CEventsProcessingSettingsPtr.asFunction<void Function(_CGestureManager, _CEventsProcessingSettings)>();
late final _CGestureManager_setTargetGeoPoint_COptional_CGeoPointPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGestureManager, _COptional_CGeoPoint)>>('CGestureManager_setTargetGeoPoint_COptional_CGeoPoint');
late final _CGestureManager_setTargetGeoPoint_COptional_CGeoPoint = _CGestureManager_setTargetGeoPoint_COptional_CGeoPointPtr.asFunction<void Function(_CGestureManager, _COptional_CGeoPoint)>();
late final _CGestureManager_setMutuallyExclusiveGestures_CArray_COptionSet_CGesturePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CGestureManager, _CArray_COptionSet_CGesture)>>('CGestureManager_setMutuallyExclusiveGestures_CArray_COptionSet_CGesture');
late final _CGestureManager_setMutuallyExclusiveGestures_CArray_COptionSet_CGesture = _CGestureManager_setMutuallyExclusiveGestures_CArray_COptionSet_CGesturePtr.asFunction<void Function(_CGestureManager, _CArray_COptionSet_CGesture)>();

late final _CGestureManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CGestureManager_release');
late final _CGestureManager_release = _CGestureManager_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CGestureManager_retainPtr = _lookup<ffi.NativeFunction<_CGestureManager Function(ffi.Pointer<ffi.Void>)>>('CGestureManager_retain');
late final _CGestureManager_retain = _CGestureManager_retainPtr.asFunction<_CGestureManager Function(ffi.Pointer<ffi.Void>)>();
late final _CGestureManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CGestureManager Function()>>('CGestureManagerMakeDefault');
late final _CGestureManagerMakeDefault = _CGestureManagerMakeDefaultPtr.asFunction<_CGestureManager Function()>();


late final _COptionSet_CGestureMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptionSet_CGesture Function()>>('COptionSet_CGestureMakeDefault');
late final _COptionSet_CGestureMakeDefault = _COptionSet_CGestureMakeDefaultPtr.asFunction<_COptionSet_CGesture Function()>();

late final _CArray_COptionSet_CGesturemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_COptionSet_CGesture Function()>>('CArray_COptionSet_CGesture_makeEmpty');
late final _CArray_COptionSet_CGesturemakeEmpty = _CArray_COptionSet_CGesturemakeEmptyPtr.asFunction<_CArray_COptionSet_CGesture Function()>();
late final _CArray_COptionSet_CGestureaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_COptionSet_CGesture, _COptionSet_CGesture)>>('CArray_COptionSet_CGesture_addElement');
late final _CArray_COptionSet_CGestureaddElement = _CArray_COptionSet_CGestureaddElementPtr.asFunction<void Function(_CArray_COptionSet_CGesture, _COptionSet_CGesture)>();
late final _forEach_CArray_COptionSet_CGesturePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_COptionSet_CGesture, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptionSet_CGesture)>>)
>>('CArray_COptionSet_CGesture_forEachWithFunctionPointer');
late final _forEach_CArray_COptionSet_CGesture = _forEach_CArray_COptionSet_CGesturePtr.asFunction<
  void Function(_CArray_COptionSet_CGesture, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptionSet_CGesture)
>>)>();
late final _CArray_COptionSet_CGesture_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_COptionSet_CGesture)>>('CArray_COptionSet_CGesture_release');
late final _CArray_COptionSet_CGesture_release = _CArray_COptionSet_CGesture_releasePtr.asFunction<void Function(_CArray_COptionSet_CGesture)>();

late final _CTouchPointStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTouchPointState Function()>>('CTouchPointStateMakeDefault');
late final _CTouchPointStateMakeDefault = _CTouchPointStateMakeDefaultPtr.asFunction<_CTouchPointState Function()>();
late final _CMapGestureRecognizer_dragBeginPtr = _lookup<ffi.NativeFunction<_CChannel_CDragBeginData Function(_CMapGestureRecognizer)>>('CMapGestureRecognizer_dragBegin');
late final _CMapGestureRecognizer_dragBegin = _CMapGestureRecognizer_dragBeginPtr.asFunction<_CChannel_CDragBeginData Function(_CMapGestureRecognizer)>();
late final _CMapGestureRecognizer_dragEndPtr = _lookup<ffi.NativeFunction<_CChannel_bool Function(_CMapGestureRecognizer)>>('CMapGestureRecognizer_dragEnd');
late final _CMapGestureRecognizer_dragEnd = _CMapGestureRecognizer_dragEndPtr.asFunction<_CChannel_bool Function(_CMapGestureRecognizer)>();
late final _CMapGestureRecognizer_dragMovePtr = _lookup<ffi.NativeFunction<_CChannel_CScreenPoint Function(_CMapGestureRecognizer)>>('CMapGestureRecognizer_dragMove');
late final _CMapGestureRecognizer_dragMove = _CMapGestureRecognizer_dragMovePtr.asFunction<_CChannel_CScreenPoint Function(_CMapGestureRecognizer)>();
late final _CMapGestureRecognizer_tapPtr = _lookup<ffi.NativeFunction<_CChannel_CScreenPoint Function(_CMapGestureRecognizer)>>('CMapGestureRecognizer_tap');
late final _CMapGestureRecognizer_tap = _CMapGestureRecognizer_tapPtr.asFunction<_CChannel_CScreenPoint Function(_CMapGestureRecognizer)>();
late final _CMapGestureRecognizer_longTouchPtr = _lookup<ffi.NativeFunction<_CChannel_CScreenPoint Function(_CMapGestureRecognizer)>>('CMapGestureRecognizer_longTouch');
late final _CMapGestureRecognizer_longTouch = _CMapGestureRecognizer_longTouchPtr.asFunction<_CChannel_CScreenPoint Function(_CMapGestureRecognizer)>();
late final _CMapGestureRecognizer_gestureManagerPtr = _lookup<ffi.NativeFunction<_COptional_CGestureManager Function(_CMapGestureRecognizer)>>('CMapGestureRecognizer_gestureManager');
late final _CMapGestureRecognizer_gestureManager = _CMapGestureRecognizer_gestureManagerPtr.asFunction<_COptional_CGestureManager Function(_CMapGestureRecognizer)>();

late final _CMapGestureRecognizer_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CMapGestureRecognizer_cg_objectIdentifier');
late final _CMapGestureRecognizer_cg_objectIdentifier = _CMapGestureRecognizer_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CMapGestureRecognizer_S_create_CMapPtr = _lookup<ffi.NativeFunction<_CMapGestureRecognizer Function(_CMap)>>('CMapGestureRecognizer_S_create_CMap');
late final _CMapGestureRecognizer_S_create_CMap = _CMapGestureRecognizer_S_create_CMapPtr.asFunction<_CMapGestureRecognizer Function(_CMap)>();
late final _CMapGestureRecognizer_addTouchPoint_CScreenPoint_CTouchPointState_uint64_tPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapGestureRecognizer, _CScreenPoint, _CTouchPointState, ffi.Uint64)>>('CMapGestureRecognizer_addTouchPoint_CScreenPoint_CTouchPointState_uint64_t');
late final _CMapGestureRecognizer_addTouchPoint_CScreenPoint_CTouchPointState_uint64_t = _CMapGestureRecognizer_addTouchPoint_CScreenPoint_CTouchPointState_uint64_tPtr.asFunction<void Function(_CMapGestureRecognizer, _CScreenPoint, _CTouchPointState, int)>();
late final _CMapGestureRecognizer_processTouchEvent_CTimeIntervalPtr = _lookup<ffi.NativeFunction<ffi.Bool Function(_CMapGestureRecognizer, _CTimeInterval)>>('CMapGestureRecognizer_processTouchEvent_CTimeInterval');
late final _CMapGestureRecognizer_processTouchEvent_CTimeInterval = _CMapGestureRecognizer_processTouchEvent_CTimeIntervalPtr.asFunction<bool Function(_CMapGestureRecognizer, _CTimeInterval)>();
late final _CMapGestureRecognizer_cancelPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapGestureRecognizer)>>('CMapGestureRecognizer_cancel');
late final _CMapGestureRecognizer_cancel = _CMapGestureRecognizer_cancelPtr.asFunction<void Function(_CMapGestureRecognizer)>();
late final _CMapGestureRecognizer_onDevicePpiChanged_CDevicePpiPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CMapGestureRecognizer, _CDevicePpi)>>('CMapGestureRecognizer_onDevicePpiChanged_CDevicePpi');
late final _CMapGestureRecognizer_onDevicePpiChanged_CDevicePpi = _CMapGestureRecognizer_onDevicePpiChanged_CDevicePpiPtr.asFunction<void Function(_CMapGestureRecognizer, _CDevicePpi)>();

late final _CMapGestureRecognizer_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CMapGestureRecognizer_release');
late final _CMapGestureRecognizer_release = _CMapGestureRecognizer_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CMapGestureRecognizer_retainPtr = _lookup<ffi.NativeFunction<_CMapGestureRecognizer Function(ffi.Pointer<ffi.Void>)>>('CMapGestureRecognizer_retain');
late final _CMapGestureRecognizer_retain = _CMapGestureRecognizer_retainPtr.asFunction<_CMapGestureRecognizer Function(ffi.Pointer<ffi.Void>)>();
late final _CMapGestureRecognizerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CMapGestureRecognizer Function()>>('CMapGestureRecognizerMakeDefault');
late final _CMapGestureRecognizerMakeDefault = _CMapGestureRecognizerMakeDefaultPtr.asFunction<_CMapGestureRecognizer Function()>();


late final _CChannel_CDragBeginDataMakeDefaultPtr = _lookup<ffi.NativeFunction<_CChannel_CDragBeginData Function()>>('CChannel_CDragBeginDataMakeDefault');
late final _CChannel_CDragBeginDataMakeDefault = _CChannel_CDragBeginDataMakeDefaultPtr.asFunction<_CChannel_CDragBeginData Function()>();
late final _CChannel_CDragBeginData_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CChannel_CDragBeginData)>>('CChannel_CDragBeginData_release');
late final _CChannel_CDragBeginData_release = _CChannel_CDragBeginData_releasePtr.asFunction<void Function(_CChannel_CDragBeginData)>();
late final _CChannel_CDragBeginData_retainPtr = _lookup<ffi.NativeFunction<_CChannel_CDragBeginData Function(_CChannel_CDragBeginData)>>('CChannel_CDragBeginData_retain');
late final _CChannel_CDragBeginData_retain = _CChannel_CDragBeginData_retainPtr.asFunction<_CChannel_CDragBeginData Function(_CChannel_CDragBeginData)>();
late final _CChannel_CDragBeginDataConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CChannel_CDragBeginData,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDragBeginData, ffi.Int64)>>
  )
>>('CChannel_CDragBeginData_connect');
late final _CChannel_CDragBeginDataConnect = _CChannel_CDragBeginDataConnectPtr.asFunction<
  _CCancellable Function(
    _CChannel_CDragBeginData,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CDragBeginData, ffi.Int64)>>
  )
>();

late final _CChannel_CScreenPointMakeDefaultPtr = _lookup<ffi.NativeFunction<_CChannel_CScreenPoint Function()>>('CChannel_CScreenPointMakeDefault');
late final _CChannel_CScreenPointMakeDefault = _CChannel_CScreenPointMakeDefaultPtr.asFunction<_CChannel_CScreenPoint Function()>();
late final _CChannel_CScreenPoint_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CChannel_CScreenPoint)>>('CChannel_CScreenPoint_release');
late final _CChannel_CScreenPoint_release = _CChannel_CScreenPoint_releasePtr.asFunction<void Function(_CChannel_CScreenPoint)>();
late final _CChannel_CScreenPoint_retainPtr = _lookup<ffi.NativeFunction<_CChannel_CScreenPoint Function(_CChannel_CScreenPoint)>>('CChannel_CScreenPoint_retain');
late final _CChannel_CScreenPoint_retain = _CChannel_CScreenPoint_retainPtr.asFunction<_CChannel_CScreenPoint Function(_CChannel_CScreenPoint)>();
late final _CChannel_CScreenPointConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CChannel_CScreenPoint,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CScreenPoint, ffi.Int64)>>
  )
>>('CChannel_CScreenPoint_connect');
late final _CChannel_CScreenPointConnect = _CChannel_CScreenPointConnectPtr.asFunction<
  _CCancellable Function(
    _CChannel_CScreenPoint,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CScreenPoint, ffi.Int64)>>
  )
>();

late final _COptional_CGestureManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CGestureManager Function()>>('COptional_CGestureManagerMakeDefault');
late final _COptional_CGestureManagerMakeDefault = _COptional_CGestureManagerMakeDefaultPtr.asFunction<_COptional_CGestureManager Function()>();

late final _COptional_CGestureManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CGestureManager)>>('COptional_CGestureManager_release');
late final _COptional_CGestureManager_release = _COptional_CGestureManager_releasePtr.asFunction<void Function(_COptional_CGestureManager)>();

late final _CApplicationStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CApplicationState Function()>>('CApplicationStateMakeDefault');
late final _CApplicationStateMakeDefault = _CApplicationStateMakeDefaultPtr.asFunction<_CApplicationState Function()>();
late final _CHttpCacheManager_getCurrentSizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CHttpCacheManager)>>('CHttpCacheManager_getCurrentSize');
late final _CHttpCacheManager_getCurrentSize = _CHttpCacheManager_getCurrentSizePtr.asFunction<int Function(_CHttpCacheManager)>();
late final _CHttpCacheManager_getMaxSizePtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(_CHttpCacheManager)>>('CHttpCacheManager_getMaxSize');
late final _CHttpCacheManager_getMaxSize = _CHttpCacheManager_getMaxSizePtr.asFunction<int Function(_CHttpCacheManager)>();
late final _CHttpCacheManager_setMaxSize_uint64_tPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CHttpCacheManager, ffi.Uint64)>>('CHttpCacheManager_setMaxSize_uint64_t');
late final _CHttpCacheManager_setMaxSize_uint64_t = _CHttpCacheManager_setMaxSize_uint64_tPtr.asFunction<void Function(_CHttpCacheManager, int)>();

late final _CHttpCacheManager_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CHttpCacheManager_cg_objectIdentifier');
late final _CHttpCacheManager_cg_objectIdentifier = _CHttpCacheManager_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CHttpCacheManager_clearPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CHttpCacheManager)>>('CHttpCacheManager_clear');
late final _CHttpCacheManager_clear = _CHttpCacheManager_clearPtr.asFunction<void Function(_CHttpCacheManager)>();

late final _CHttpCacheManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CHttpCacheManager_release');
late final _CHttpCacheManager_release = _CHttpCacheManager_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CHttpCacheManager_retainPtr = _lookup<ffi.NativeFunction<_CHttpCacheManager Function(ffi.Pointer<ffi.Void>)>>('CHttpCacheManager_retain');
late final _CHttpCacheManager_retain = _CHttpCacheManager_retainPtr.asFunction<_CHttpCacheManager Function(ffi.Pointer<ffi.Void>)>();
late final _CHttpCacheManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CHttpCacheManager Function()>>('CHttpCacheManagerMakeDefault');
late final _CHttpCacheManagerMakeDefault = _CHttpCacheManagerMakeDefaultPtr.asFunction<_CHttpCacheManager Function()>();


late final _CLocaleChangeNotifier_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CLocaleChangeNotifier_cg_objectIdentifier');
late final _CLocaleChangeNotifier_cg_objectIdentifier = _CLocaleChangeNotifier_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CLocaleChangeNotifier_changed_CArray_CLocalePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CLocaleChangeNotifier, _CArray_CLocale)>>('CLocaleChangeNotifier_changed_CArray_CLocale');
late final _CLocaleChangeNotifier_changed_CArray_CLocale = _CLocaleChangeNotifier_changed_CArray_CLocalePtr.asFunction<void Function(_CLocaleChangeNotifier, _CArray_CLocale)>();

late final _CLocaleChangeNotifier_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CLocaleChangeNotifier_release');
late final _CLocaleChangeNotifier_release = _CLocaleChangeNotifier_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CLocaleChangeNotifier_retainPtr = _lookup<ffi.NativeFunction<_CLocaleChangeNotifier Function(ffi.Pointer<ffi.Void>)>>('CLocaleChangeNotifier_retain');
late final _CLocaleChangeNotifier_retain = _CLocaleChangeNotifier_retainPtr.asFunction<_CLocaleChangeNotifier Function(ffi.Pointer<ffi.Void>)>();
late final _CLocaleChangeNotifierMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocaleChangeNotifier Function()>>('CLocaleChangeNotifierMakeDefault');
late final _CLocaleChangeNotifierMakeDefault = _CLocaleChangeNotifierMakeDefaultPtr.asFunction<_CLocaleChangeNotifier Function()>();


late final _CArray_CLocalemakeEmptyPtr = _lookup<ffi.NativeFunction<_CArray_CLocale Function()>>('CArray_CLocale_makeEmpty');
late final _CArray_CLocalemakeEmpty = _CArray_CLocalemakeEmptyPtr.asFunction<_CArray_CLocale Function()>();
late final _CArray_CLocaleaddElementPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CLocale, _CLocale)>>('CArray_CLocale_addElement');
late final _CArray_CLocaleaddElement = _CArray_CLocaleaddElementPtr.asFunction<void Function(_CArray_CLocale, _CLocale)>();
late final _forEach_CArray_CLocalePtr = _lookup<ffi.NativeFunction<
  ffi.Void Function(_CArray_CLocale, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLocale)>>)
>>('CArray_CLocale_forEachWithFunctionPointer');
late final _forEach_CArray_CLocale = _forEach_CArray_CLocalePtr.asFunction<
  void Function(_CArray_CLocale, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CLocale)
>>)>();
late final _CArray_CLocale_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CArray_CLocale)>>('CArray_CLocale_release');
late final _CArray_CLocale_release = _CArray_CLocale_releasePtr.asFunction<void Function(_CArray_CLocale)>();
late final _CLocaleManager_localesChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CLocale Function(_CLocaleManager)>>('CLocaleManager_localesChannel');
late final _CLocaleManager_localesChannel = _CLocaleManager_localesChannelPtr.asFunction<_CStatefulChannel_CArray_CLocale Function(_CLocaleManager)>();
late final _CLocaleManager_localesPtr = _lookup<ffi.NativeFunction<_CArray_CLocale Function(_CLocaleManager)>>('CLocaleManager_locales');
late final _CLocaleManager_locales = _CLocaleManager_localesPtr.asFunction<_CArray_CLocale Function(_CLocaleManager)>();
late final _CLocaleManager_systemLocalesChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CLocale Function(_CLocaleManager)>>('CLocaleManager_systemLocalesChannel');
late final _CLocaleManager_systemLocalesChannel = _CLocaleManager_systemLocalesChannelPtr.asFunction<_CStatefulChannel_CArray_CLocale Function(_CLocaleManager)>();
late final _CLocaleManager_systemLocalesPtr = _lookup<ffi.NativeFunction<_CArray_CLocale Function(_CLocaleManager)>>('CLocaleManager_systemLocales');
late final _CLocaleManager_systemLocales = _CLocaleManager_systemLocalesPtr.asFunction<_CArray_CLocale Function(_CLocaleManager)>();

late final _CLocaleManager_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CLocaleManager_cg_objectIdentifier');
late final _CLocaleManager_cg_objectIdentifier = _CLocaleManager_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CLocaleManager_overrideLocales_CArray_CLocalePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CLocaleManager, _CArray_CLocale)>>('CLocaleManager_overrideLocales_CArray_CLocale');
late final _CLocaleManager_overrideLocales_CArray_CLocale = _CLocaleManager_overrideLocales_CArray_CLocalePtr.asFunction<void Function(_CLocaleManager, _CArray_CLocale)>();

late final _CLocaleManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CLocaleManager_release');
late final _CLocaleManager_release = _CLocaleManager_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CLocaleManager_retainPtr = _lookup<ffi.NativeFunction<_CLocaleManager Function(ffi.Pointer<ffi.Void>)>>('CLocaleManager_retain');
late final _CLocaleManager_retain = _CLocaleManager_retainPtr.asFunction<_CLocaleManager Function(ffi.Pointer<ffi.Void>)>();
late final _CLocaleManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocaleManager Function()>>('CLocaleManagerMakeDefault');
late final _CLocaleManagerMakeDefault = _CLocaleManagerMakeDefaultPtr.asFunction<_CLocaleManager Function()>();


late final _CStatefulChannel_CArray_CLocaleMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CLocale Function()>>('CStatefulChannel_CArray_CLocaleMakeDefault');
late final _CStatefulChannel_CArray_CLocaleMakeDefault = _CStatefulChannel_CArray_CLocaleMakeDefaultPtr.asFunction<_CStatefulChannel_CArray_CLocale Function()>();
late final _CStatefulChannel_CArray_CLocale_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CArray_CLocale)>>('CStatefulChannel_CArray_CLocale_release');
late final _CStatefulChannel_CArray_CLocale_release = _CStatefulChannel_CArray_CLocale_releasePtr.asFunction<void Function(_CStatefulChannel_CArray_CLocale)>();
late final _CStatefulChannel_CArray_CLocale_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CArray_CLocale Function(_CStatefulChannel_CArray_CLocale)>>('CStatefulChannel_CArray_CLocale_retain');
late final _CStatefulChannel_CArray_CLocale_retain = _CStatefulChannel_CArray_CLocale_retainPtr.asFunction<_CStatefulChannel_CArray_CLocale Function(_CStatefulChannel_CArray_CLocale)>();
late final _CStatefulChannel_CArray_CLocaleGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CArray_CLocale Function(_CStatefulChannel_CArray_CLocale)>>('CStatefulChannel_CArray_CLocale_getCurrentValue');
late final _CStatefulChannel_CArray_CLocaleGetCurrentValue = _CStatefulChannel_CArray_CLocaleGetCurrentValuePtr.asFunction<_CArray_CLocale Function(_CStatefulChannel_CArray_CLocale)>();
late final _CStatefulChannel_CArray_CLocaleConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CLocale,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CLocale, ffi.Int64)>>
  )
>>('CStatefulChannel_CArray_CLocale_connect');
late final _CStatefulChannel_CArray_CLocaleConnect = _CStatefulChannel_CArray_CLocaleConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CArray_CLocale,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CArray_CLocale, ffi.Int64)>>
  )
>();

late final _CPlatformLocaleManagerCpp_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CPlatformLocaleManagerCpp_cg_objectIdentifier');
late final _CPlatformLocaleManagerCpp_cg_objectIdentifier = _CPlatformLocaleManagerCpp_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CPlatformLocaleManagerCpp_localesPtr = _lookup<ffi.NativeFunction<_CArray_CLocale Function(_CPlatformLocaleManagerCpp)>>('CPlatformLocaleManagerCpp_locales');
late final _CPlatformLocaleManagerCpp_locales = _CPlatformLocaleManagerCpp_localesPtr.asFunction<_CArray_CLocale Function(_CPlatformLocaleManagerCpp)>();
late final _CPlatformLocaleManagerCpp_setLocalesChangeNotifier_CLocaleChangeNotifierPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPlatformLocaleManagerCpp, _CLocaleChangeNotifier)>>('CPlatformLocaleManagerCpp_setLocalesChangeNotifier_CLocaleChangeNotifier');
late final _CPlatformLocaleManagerCpp_setLocalesChangeNotifier_CLocaleChangeNotifier = _CPlatformLocaleManagerCpp_setLocalesChangeNotifier_CLocaleChangeNotifierPtr.asFunction<void Function(_CPlatformLocaleManagerCpp, _CLocaleChangeNotifier)>();
late final _CPlatformLocaleManagerCpp_systemLocalesPtr = _lookup<ffi.NativeFunction<_CArray_CLocale Function(_CPlatformLocaleManagerCpp)>>('CPlatformLocaleManagerCpp_systemLocales');
late final _CPlatformLocaleManagerCpp_systemLocales = _CPlatformLocaleManagerCpp_systemLocalesPtr.asFunction<_CArray_CLocale Function(_CPlatformLocaleManagerCpp)>();
late final _CPlatformLocaleManagerCpp_setSystemLocalesChangeNotifier_CLocaleChangeNotifierPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPlatformLocaleManagerCpp, _CLocaleChangeNotifier)>>('CPlatformLocaleManagerCpp_setSystemLocalesChangeNotifier_CLocaleChangeNotifier');
late final _CPlatformLocaleManagerCpp_setSystemLocalesChangeNotifier_CLocaleChangeNotifier = _CPlatformLocaleManagerCpp_setSystemLocalesChangeNotifier_CLocaleChangeNotifierPtr.asFunction<void Function(_CPlatformLocaleManagerCpp, _CLocaleChangeNotifier)>();
late final _CPlatformLocaleManagerCpp_overrideLocales_CArray_CLocalePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPlatformLocaleManagerCpp, _CArray_CLocale)>>('CPlatformLocaleManagerCpp_overrideLocales_CArray_CLocale');
late final _CPlatformLocaleManagerCpp_overrideLocales_CArray_CLocale = _CPlatformLocaleManagerCpp_overrideLocales_CArray_CLocalePtr.asFunction<void Function(_CPlatformLocaleManagerCpp, _CArray_CLocale)>();

late final _CPlatformLocaleManagerCpp_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CPlatformLocaleManagerCpp_release');
late final _CPlatformLocaleManagerCpp_release = _CPlatformLocaleManagerCpp_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CPlatformLocaleManagerCpp_retainPtr = _lookup<ffi.NativeFunction<_CPlatformLocaleManagerCpp Function(ffi.Pointer<ffi.Void>)>>('CPlatformLocaleManagerCpp_retain');
late final _CPlatformLocaleManagerCpp_retain = _CPlatformLocaleManagerCpp_retainPtr.asFunction<_CPlatformLocaleManagerCpp Function(ffi.Pointer<ffi.Void>)>();
late final _CPlatformLocaleManagerCppMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPlatformLocaleManagerCpp Function()>>('CPlatformLocaleManagerCppMakeDefault');
late final _CPlatformLocaleManagerCppMakeDefault = _CPlatformLocaleManagerCppMakeDefaultPtr.asFunction<_CPlatformLocaleManagerCpp Function()>();


late final _CPlatformLocaleManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CPlatformLocaleManager Function()>>('CPlatformLocaleManagerMakeDefault');
late final _CPlatformLocaleManagerMakeDefault = _CPlatformLocaleManagerMakeDefaultPtr.asFunction<_CPlatformLocaleManager Function()>();
late final _CPlatformLocaleManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CPlatformLocaleManager)>>('CPlatformLocaleManager_release');
late final _CPlatformLocaleManager_release = _CPlatformLocaleManager_releasePtr.asFunction<void Function(_CPlatformLocaleManager)>();
late final _CFunction_G_getHttpCacheManager_With_CContextPtr = _lookup<ffi.NativeFunction<_COptional_CHttpCacheManager Function(_CContext)>>('CFunction_G_getHttpCacheManager_With_CContext');
late final _CFunction_G_getHttpCacheManager_With_CContext = _CFunction_G_getHttpCacheManager_With_CContextPtr.asFunction<_COptional_CHttpCacheManager Function(_CContext)>();

late final _COptional_CHttpCacheManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_COptional_CHttpCacheManager Function()>>('COptional_CHttpCacheManagerMakeDefault');
late final _COptional_CHttpCacheManagerMakeDefault = _COptional_CHttpCacheManagerMakeDefaultPtr.asFunction<_COptional_CHttpCacheManager Function()>();

late final _COptional_CHttpCacheManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_COptional_CHttpCacheManager)>>('COptional_CHttpCacheManager_release');
late final _COptional_CHttpCacheManager_release = _COptional_CHttpCacheManager_releasePtr.asFunction<void Function(_COptional_CHttpCacheManager)>();
late final _CFunction_G_getLocaleManager_With_CContextPtr = _lookup<ffi.NativeFunction<_CLocaleManager Function(_CContext)>>('CFunction_G_getLocaleManager_With_CContext');
late final _CFunction_G_getLocaleManager_With_CContext = _CFunction_G_getLocaleManager_With_CContextPtr.asFunction<_CLocaleManager Function(_CContext)>();
late final _CFunction_G_toLocaleManager_With_CPlatformLocaleManagerPtr = _lookup<ffi.NativeFunction<_CLocaleManager Function(_CPlatformLocaleManager)>>('CFunction_G_toLocaleManager_With_CPlatformLocaleManager');
late final _CFunction_G_toLocaleManager_With_CPlatformLocaleManager = _CFunction_G_toLocaleManager_With_CPlatformLocaleManagerPtr.asFunction<_CLocaleManager Function(_CPlatformLocaleManager)>();
late final _CFunction_G_toLocalePosix_With_CLocalePtr = _lookup<ffi.NativeFunction<_CString Function(_CLocale)>>('CFunction_G_toLocalePosix_With_CLocale');
late final _CFunction_G_toLocalePosix_With_CLocale = _CFunction_G_toLocalePosix_With_CLocalePtr.asFunction<_CString Function(_CLocale)>();

late final _CLocationService_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CLocationService_cg_objectIdentifier');
late final _CLocationService_cg_objectIdentifier = _CLocationService_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CLocationService_lastLocationPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CLocation Function(_CLocationService)>>('CLocationService_lastLocation');
late final _CLocationService_lastLocation = _CLocationService_lastLocationPtr.asFunction<_CStatefulChannel_COptional_CLocation Function(_CLocationService)>();
late final _CLocationService_onPermissionGrantedPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CLocationService)>>('CLocationService_onPermissionGranted');
late final _CLocationService_onPermissionGranted = _CLocationService_onPermissionGrantedPtr.asFunction<void Function(_CLocationService)>();
late final _CLocationService_C_createWith_CContextPtr = _lookup<ffi.NativeFunction<_CLocationService Function(_CContext)>>('CLocationService_C_createWith_CContext');
late final _CLocationService_C_createWith_CContext = _CLocationService_C_createWith_CContextPtr.asFunction<_CLocationService Function(_CContext)>();

late final _CLocationService_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CLocationService_release');
late final _CLocationService_release = _CLocationService_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CLocationService_retainPtr = _lookup<ffi.NativeFunction<_CLocationService Function(ffi.Pointer<ffi.Void>)>>('CLocationService_retain');
late final _CLocationService_retain = _CLocationService_retainPtr.asFunction<_CLocationService Function(ffi.Pointer<ffi.Void>)>();
late final _CLocationServiceMakeDefaultPtr = _lookup<ffi.NativeFunction<_CLocationService Function()>>('CLocationServiceMakeDefault');
late final _CLocationServiceMakeDefault = _CLocationServiceMakeDefaultPtr.asFunction<_CLocationService Function()>();


late final _CStatefulChannel_COptional_CLocationMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CLocation Function()>>('CStatefulChannel_COptional_CLocationMakeDefault');
late final _CStatefulChannel_COptional_CLocationMakeDefault = _CStatefulChannel_COptional_CLocationMakeDefaultPtr.asFunction<_CStatefulChannel_COptional_CLocation Function()>();
late final _CStatefulChannel_COptional_CLocation_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_COptional_CLocation)>>('CStatefulChannel_COptional_CLocation_release');
late final _CStatefulChannel_COptional_CLocation_release = _CStatefulChannel_COptional_CLocation_releasePtr.asFunction<void Function(_CStatefulChannel_COptional_CLocation)>();
late final _CStatefulChannel_COptional_CLocation_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_COptional_CLocation Function(_CStatefulChannel_COptional_CLocation)>>('CStatefulChannel_COptional_CLocation_retain');
late final _CStatefulChannel_COptional_CLocation_retain = _CStatefulChannel_COptional_CLocation_retainPtr.asFunction<_CStatefulChannel_COptional_CLocation Function(_CStatefulChannel_COptional_CLocation)>();
late final _CStatefulChannel_COptional_CLocationGetCurrentValuePtr = _lookup<ffi.NativeFunction<_COptional_CLocation Function(_CStatefulChannel_COptional_CLocation)>>('CStatefulChannel_COptional_CLocation_getCurrentValue');
late final _CStatefulChannel_COptional_CLocationGetCurrentValue = _CStatefulChannel_COptional_CLocationGetCurrentValuePtr.asFunction<_COptional_CLocation Function(_CStatefulChannel_COptional_CLocation)>();
late final _CStatefulChannel_COptional_CLocationConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CLocation,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CLocation, ffi.Int64)>>
  )
>>('CStatefulChannel_COptional_CLocation_connect');
late final _CStatefulChannel_COptional_CLocationConnect = _CStatefulChannel_COptional_CLocationConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_COptional_CLocation,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_COptional_CLocation, ffi.Int64)>>
  )
>();

late final _CAddEventErrorMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAddEventError Function()>>('CAddEventErrorMakeDefault');
late final _CAddEventErrorMakeDefault = _CAddEventErrorMakeDefaultPtr.asFunction<_CAddEventError Function()>();

late final _CAddEventResult_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CAddEventResult)>>('CAddEventResult_release');
late final _CAddEventResult_release = _CAddEventResult_releasePtr.asFunction<void Function(_CAddEventResult)>();
late final _CAddEventResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CAddEventResult Function()>>('CAddEventResultMakeDefault');
late final _CAddEventResultMakeDefault = _CAddEventResultMakeDefaultPtr.asFunction<_CAddEventResult Function()>();

late final _CRoadEventManager_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CRoadEventManager_cg_objectIdentifier');
late final _CRoadEventManager_cg_objectIdentifier = _CRoadEventManager_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CRoadEventManager_createAccident_CGeoPoint_COptionSet_CLane_CStringPtr = _lookup<ffi.NativeFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _COptionSet_CLane, _CString)>>('CRoadEventManager_createAccident_CGeoPoint_COptionSet_CLane_CString');
late final _CRoadEventManager_createAccident_CGeoPoint_COptionSet_CLane_CString = _CRoadEventManager_createAccident_CGeoPoint_COptionSet_CLane_CStringPtr.asFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _COptionSet_CLane, _CString)>();
late final _CRoadEventManager_createCamera_CGeoPoint_CStringPtr = _lookup<ffi.NativeFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _CString)>>('CRoadEventManager_createCamera_CGeoPoint_CString');
late final _CRoadEventManager_createCamera_CGeoPoint_CString = _CRoadEventManager_createCamera_CGeoPoint_CStringPtr.asFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _CString)>();
late final _CRoadEventManager_createRoadRestriction_CGeoPoint_CStringPtr = _lookup<ffi.NativeFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _CString)>>('CRoadEventManager_createRoadRestriction_CGeoPoint_CString');
late final _CRoadEventManager_createRoadRestriction_CGeoPoint_CString = _CRoadEventManager_createRoadRestriction_CGeoPoint_CStringPtr.asFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _CString)>();
late final _CRoadEventManager_createComment_CGeoPoint_CStringPtr = _lookup<ffi.NativeFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _CString)>>('CRoadEventManager_createComment_CGeoPoint_CString');
late final _CRoadEventManager_createComment_CGeoPoint_CString = _CRoadEventManager_createComment_CGeoPoint_CStringPtr.asFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _CString)>();
late final _CRoadEventManager_createOther_CGeoPoint_COptionSet_CLane_CStringPtr = _lookup<ffi.NativeFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _COptionSet_CLane, _CString)>>('CRoadEventManager_createOther_CGeoPoint_COptionSet_CLane_CString');
late final _CRoadEventManager_createOther_CGeoPoint_COptionSet_CLane_CString = _CRoadEventManager_createOther_CGeoPoint_COptionSet_CLane_CStringPtr.asFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _COptionSet_CLane, _CString)>();
late final _CRoadEventManager_createRoadWorks_CGeoPoint_COptionSet_CLane_CStringPtr = _lookup<ffi.NativeFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _COptionSet_CLane, _CString)>>('CRoadEventManager_createRoadWorks_CGeoPoint_COptionSet_CLane_CString');
late final _CRoadEventManager_createRoadWorks_CGeoPoint_COptionSet_CLane_CString = _CRoadEventManager_createRoadWorks_CGeoPoint_COptionSet_CLane_CStringPtr.asFunction<_CFuture_CAddEventResult Function(_CRoadEventManager, _CGeoPoint, _COptionSet_CLane, _CString)>();
late final _CRoadEventManager_C_createWith_CContextPtr = _lookup<ffi.NativeFunction<_CRoadEventManager Function(_CContext)>>('CRoadEventManager_C_createWith_CContext');
late final _CRoadEventManager_C_createWith_CContext = _CRoadEventManager_C_createWith_CContextPtr.asFunction<_CRoadEventManager Function(_CContext)>();

late final _CRoadEventManager_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CRoadEventManager_release');
late final _CRoadEventManager_release = _CRoadEventManager_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventManager_retainPtr = _lookup<ffi.NativeFunction<_CRoadEventManager Function(ffi.Pointer<ffi.Void>)>>('CRoadEventManager_retain');
late final _CRoadEventManager_retain = _CRoadEventManager_retainPtr.asFunction<_CRoadEventManager Function(ffi.Pointer<ffi.Void>)>();
late final _CRoadEventManagerMakeDefaultPtr = _lookup<ffi.NativeFunction<_CRoadEventManager Function()>>('CRoadEventManagerMakeDefault');
late final _CRoadEventManagerMakeDefault = _CRoadEventManagerMakeDefaultPtr.asFunction<_CRoadEventManager Function()>();


late final _CFuture_CAddEventResultMakeDefaultPtr = _lookup<ffi.NativeFunction<_CFuture_CAddEventResult Function()>>('CFuture_CAddEventResultMakeDefault');
late final _CFuture_CAddEventResultMakeDefault = _CFuture_CAddEventResultMakeDefaultPtr.asFunction<_CFuture_CAddEventResult Function()>();
late final _CFuture_CAddEventResult_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CFuture_CAddEventResult)>>('CFuture_CAddEventResult_release');
late final _CFuture_CAddEventResult_release = _CFuture_CAddEventResult_releasePtr.asFunction<void Function(_CFuture_CAddEventResult)>();
late final _CFuture_CAddEventResult_retainPtr = _lookup<ffi.NativeFunction<_CFuture_CAddEventResult Function(_CFuture_CAddEventResult)>>('CFuture_CAddEventResult_retain');
late final _CFuture_CAddEventResult_retain = _CFuture_CAddEventResult_retainPtr.asFunction<_CFuture_CAddEventResult Function(_CFuture_CAddEventResult)>();
late final _CFuture_CAddEventResultReceivePtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CFuture_CAddEventResult,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CAddEventResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>>('CFuture_CAddEventResult_receive');
late final _CFuture_CAddEventResultReceive = _CFuture_CAddEventResultReceivePtr.asFunction<
  _CCancellable Function(
    _CFuture_CAddEventResult,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CAddEventResult, ffi.Int64)>>,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CError, ffi.Int64)>>
  )
>();

late final _CTrafficScoreStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTrafficScoreState Function()>>('CTrafficScoreStateMakeDefault');
late final _CTrafficScoreStateMakeDefault = _CTrafficScoreStateMakeDefaultPtr.asFunction<_CTrafficScoreState Function()>();

late final _CTrafficScoreMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTrafficScore Function()>>('CTrafficScoreMakeDefault');
late final _CTrafficScoreMakeDefault = _CTrafficScoreMakeDefaultPtr.asFunction<_CTrafficScore Function()>();

late final _CTrafficScoreProvider_scoreChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CTrafficScore Function(_CTrafficScoreProvider)>>('CTrafficScoreProvider_scoreChannel');
late final _CTrafficScoreProvider_scoreChannel = _CTrafficScoreProvider_scoreChannelPtr.asFunction<_CStatefulChannel_CTrafficScore Function(_CTrafficScoreProvider)>();
late final _CTrafficScoreProvider_scorePtr = _lookup<ffi.NativeFunction<_CTrafficScore Function(_CTrafficScoreProvider)>>('CTrafficScoreProvider_score');
late final _CTrafficScoreProvider_score = _CTrafficScoreProvider_scorePtr.asFunction<_CTrafficScore Function(_CTrafficScoreProvider)>();

late final _CTrafficScoreProvider_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CTrafficScoreProvider_cg_objectIdentifier');
late final _CTrafficScoreProvider_cg_objectIdentifier = _CTrafficScoreProvider_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CTrafficScoreProvider_C_createWith_CMapPtr = _lookup<ffi.NativeFunction<_CTrafficScoreProvider Function(_CMap)>>('CTrafficScoreProvider_C_createWith_CMap');
late final _CTrafficScoreProvider_C_createWith_CMap = _CTrafficScoreProvider_C_createWith_CMapPtr.asFunction<_CTrafficScoreProvider Function(_CMap)>();
late final _CTrafficScoreProvider_C_createWith_CContext_CGeoPointPtr = _lookup<ffi.NativeFunction<_CTrafficScoreProvider Function(_CContext, _CGeoPoint)>>('CTrafficScoreProvider_C_createWith_CContext_CGeoPoint');
late final _CTrafficScoreProvider_C_createWith_CContext_CGeoPoint = _CTrafficScoreProvider_C_createWith_CContext_CGeoPointPtr.asFunction<_CTrafficScoreProvider Function(_CContext, _CGeoPoint)>();

late final _CTrafficScoreProvider_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CTrafficScoreProvider_release');
late final _CTrafficScoreProvider_release = _CTrafficScoreProvider_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CTrafficScoreProvider_retainPtr = _lookup<ffi.NativeFunction<_CTrafficScoreProvider Function(ffi.Pointer<ffi.Void>)>>('CTrafficScoreProvider_retain');
late final _CTrafficScoreProvider_retain = _CTrafficScoreProvider_retainPtr.asFunction<_CTrafficScoreProvider Function(ffi.Pointer<ffi.Void>)>();
late final _CTrafficScoreProviderMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTrafficScoreProvider Function()>>('CTrafficScoreProviderMakeDefault');
late final _CTrafficScoreProviderMakeDefault = _CTrafficScoreProviderMakeDefaultPtr.asFunction<_CTrafficScoreProvider Function()>();


late final _CStatefulChannel_CTrafficScoreMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CTrafficScore Function()>>('CStatefulChannel_CTrafficScoreMakeDefault');
late final _CStatefulChannel_CTrafficScoreMakeDefault = _CStatefulChannel_CTrafficScoreMakeDefaultPtr.asFunction<_CStatefulChannel_CTrafficScore Function()>();
late final _CStatefulChannel_CTrafficScore_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CTrafficScore)>>('CStatefulChannel_CTrafficScore_release');
late final _CStatefulChannel_CTrafficScore_release = _CStatefulChannel_CTrafficScore_releasePtr.asFunction<void Function(_CStatefulChannel_CTrafficScore)>();
late final _CStatefulChannel_CTrafficScore_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CTrafficScore Function(_CStatefulChannel_CTrafficScore)>>('CStatefulChannel_CTrafficScore_retain');
late final _CStatefulChannel_CTrafficScore_retain = _CStatefulChannel_CTrafficScore_retainPtr.asFunction<_CStatefulChannel_CTrafficScore Function(_CStatefulChannel_CTrafficScore)>();
late final _CStatefulChannel_CTrafficScoreGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CTrafficScore Function(_CStatefulChannel_CTrafficScore)>>('CStatefulChannel_CTrafficScore_getCurrentValue');
late final _CStatefulChannel_CTrafficScoreGetCurrentValue = _CStatefulChannel_CTrafficScoreGetCurrentValuePtr.asFunction<_CTrafficScore Function(_CStatefulChannel_CTrafficScore)>();
late final _CStatefulChannel_CTrafficScoreConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CTrafficScore,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTrafficScore, ffi.Int64)>>
  )
>>('CStatefulChannel_CTrafficScore_connect');
late final _CStatefulChannel_CTrafficScoreConnect = _CStatefulChannel_CTrafficScoreConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CTrafficScore,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTrafficScore, ffi.Int64)>>
  )
>();

late final _CTrafficControlStatusMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTrafficControlStatus Function()>>('CTrafficControlStatusMakeDefault');
late final _CTrafficControlStatusMakeDefault = _CTrafficControlStatusMakeDefaultPtr.asFunction<_CTrafficControlStatus Function()>();

late final _CTrafficControlStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTrafficControlState Function()>>('CTrafficControlStateMakeDefault');
late final _CTrafficControlStateMakeDefault = _CTrafficControlStateMakeDefaultPtr.asFunction<_CTrafficControlState Function()>();

late final _CTrafficControlModel_stateChannelPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CTrafficControlState Function(_CTrafficControlModel)>>('CTrafficControlModel_stateChannel');
late final _CTrafficControlModel_stateChannel = _CTrafficControlModel_stateChannelPtr.asFunction<_CStatefulChannel_CTrafficControlState Function(_CTrafficControlModel)>();
late final _CTrafficControlModel_statePtr = _lookup<ffi.NativeFunction<_CTrafficControlState Function(_CTrafficControlModel)>>('CTrafficControlModel_state');
late final _CTrafficControlModel_state = _CTrafficControlModel_statePtr.asFunction<_CTrafficControlState Function(_CTrafficControlModel)>();

late final _CTrafficControlModel_cg_objectIdentifierPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('CTrafficControlModel_cg_objectIdentifier');
late final _CTrafficControlModel_cg_objectIdentifier = _CTrafficControlModel_cg_objectIdentifierPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

late final _CTrafficControlModel_onClickedPtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CTrafficControlModel)>>('CTrafficControlModel_onClicked');
late final _CTrafficControlModel_onClicked = _CTrafficControlModel_onClickedPtr.asFunction<void Function(_CTrafficControlModel)>();
late final _CTrafficControlModel_C_createWith_CMapPtr = _lookup<ffi.NativeFunction<_CTrafficControlModel Function(_CMap)>>('CTrafficControlModel_C_createWith_CMap');
late final _CTrafficControlModel_C_createWith_CMap = _CTrafficControlModel_C_createWith_CMapPtr.asFunction<_CTrafficControlModel Function(_CMap)>();

late final _CTrafficControlModel_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('CTrafficControlModel_release');
late final _CTrafficControlModel_release = _CTrafficControlModel_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
late final _CTrafficControlModel_retainPtr = _lookup<ffi.NativeFunction<_CTrafficControlModel Function(ffi.Pointer<ffi.Void>)>>('CTrafficControlModel_retain');
late final _CTrafficControlModel_retain = _CTrafficControlModel_retainPtr.asFunction<_CTrafficControlModel Function(ffi.Pointer<ffi.Void>)>();
late final _CTrafficControlModelMakeDefaultPtr = _lookup<ffi.NativeFunction<_CTrafficControlModel Function()>>('CTrafficControlModelMakeDefault');
late final _CTrafficControlModelMakeDefault = _CTrafficControlModelMakeDefaultPtr.asFunction<_CTrafficControlModel Function()>();


late final _CStatefulChannel_CTrafficControlStateMakeDefaultPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CTrafficControlState Function()>>('CStatefulChannel_CTrafficControlStateMakeDefault');
late final _CStatefulChannel_CTrafficControlStateMakeDefault = _CStatefulChannel_CTrafficControlStateMakeDefaultPtr.asFunction<_CStatefulChannel_CTrafficControlState Function()>();
late final _CStatefulChannel_CTrafficControlState_releasePtr = _lookup<ffi.NativeFunction<ffi.Void Function(_CStatefulChannel_CTrafficControlState)>>('CStatefulChannel_CTrafficControlState_release');
late final _CStatefulChannel_CTrafficControlState_release = _CStatefulChannel_CTrafficControlState_releasePtr.asFunction<void Function(_CStatefulChannel_CTrafficControlState)>();
late final _CStatefulChannel_CTrafficControlState_retainPtr = _lookup<ffi.NativeFunction<_CStatefulChannel_CTrafficControlState Function(_CStatefulChannel_CTrafficControlState)>>('CStatefulChannel_CTrafficControlState_retain');
late final _CStatefulChannel_CTrafficControlState_retain = _CStatefulChannel_CTrafficControlState_retainPtr.asFunction<_CStatefulChannel_CTrafficControlState Function(_CStatefulChannel_CTrafficControlState)>();
late final _CStatefulChannel_CTrafficControlStateGetCurrentValuePtr = _lookup<ffi.NativeFunction<_CTrafficControlState Function(_CStatefulChannel_CTrafficControlState)>>('CStatefulChannel_CTrafficControlState_getCurrentValue');
late final _CStatefulChannel_CTrafficControlStateGetCurrentValue = _CStatefulChannel_CTrafficControlStateGetCurrentValuePtr.asFunction<_CTrafficControlState Function(_CStatefulChannel_CTrafficControlState)>();
late final _CStatefulChannel_CTrafficControlStateConnectPtr = _lookup<ffi.NativeFunction<
  _CCancellable Function(
    _CStatefulChannel_CTrafficControlState,
    ffi.Int64,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTrafficControlState, ffi.Int64)>>
  )
>>('CStatefulChannel_CTrafficControlState_connect');
late final _CStatefulChannel_CTrafficControlStateConnect = _CStatefulChannel_CTrafficControlStateConnectPtr.asFunction<
  _CCancellable Function(
    _CStatefulChannel_CTrafficControlState,
    int,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(_CTrafficControlState, ffi.Int64)>>
  )
>();

//ApplicationState, BaseCameraInternalMethods, ImageLoader, LocaleChangeNotifier, MapBuilder, MapGestureRecognizer, MapInternalMethods, MapRenderer, MapSurfaceProvider, ModelDataLoader, PlatformLocaleManager, ProductType, calculateBearing, calculateDistance, createImage, createModelData, downloadData, makeSystemContext, move, toLocaleManager